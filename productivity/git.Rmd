```{r, include=FALSE}
if(knitr::is_html_output()){
  knitr::opts_chunk$set(out.width = "500px",
                        out.extra='style="display: block; margin-left: auto; margin-right: auto; background-color: #000; padding:3px;"')
} else{
  knitr::opts_chunk$set(out.width = "50%")
}
```

# Git y GitHub {#git}

```{r, echo=FALSE}
img_path <- "productivity/img/"
screenshots <- list.files(file.path(img_path, "windows-screenshots"))
screenshots <- file.path(img_path, "windows-screenshots", screenshots)
mac_screenshots <- list.files(file.path(img_path, "mac-screenshots"))
mac_screenshots <- file.path(img_path,"mac-screenshots", mac_screenshots)
```

Aquí proveemos algunos detalles sobre Git y GitHub. Sin embargo, solo estamos rascando la superficie. Para obtener más información sobre este tema, recomendamos los siguientes recursos:

* Codeacademy: [https://www.codecademy.com/learn/learn-git](https://www.codecademy.com/learn/learn-git)
* Guías de GitHub: [https://guides.github.com/activities/hello-world/](https://guides.github.com/activities/hello-world/)
* Try Git tutorial: [https://try.github.io/levels/1/challenges/1](https://try.github.io/levels/1/challenges/1)
* Happy Git y GitHub para el useR: [http://happygitwithr.com](http://happygitwithr.com/)


## ¿Por qué usar Git y GitHub?

Hay tres razones principales para usar Git y GitHub.

1. Compartir: [fix "Even if we do not take advantage of the advanced and powerful version control functionality"] incluso si no aprovechamos la funcionalidad avanzada y poderosa de control de versiones, aún podemos usar Git y GitHub para compartir nuestro código. Ya hemos mostrado cómo podemos hacer esto con RStudio.

2. Colaboración: una vez que configuren un repositorio central, pueden hacer que varias personas realicen cambios en el código y mantengan las versiones sincronizadas. GitHub ofrece un servicio gratuito para repositorios centralizados. GitHub también tiene una herramienta, llamada _pull request_, que cualquier persona puede usar para sugerir cambios a su código. Pueden aceptar o rechazar fácilmente la recomendación.

3. Control de versiones: las capacidades de control de versiones de Git nos permite darle seguimiento a los cambios que realizamos en nuestro código. También podemos volver a las versiones anteriores de los archivos. Git también nos permite crear _branches_ en los que podemos probar ideas, luego decidir si fusionamos (_merge_ en inglés) la nueva rama con la original.

Aquí nos enfocamos en los aspectos de uso compartido de Git y GitHub y remitimos al lector a los enlaces anteriores para obtener más información sobre esta herramienta útil.

## Cuentas GitHub

Después de instalar git^[https://rafalab.github.io/dsbook/accessing-the-terminal-and-installing-git.html], el primer paso es obtener una cuenta de GitHub. Las cuentas básicas de GitHub son gratuitas. Para hacer esto, vayan a [GitHub](github.com) donde verán un cuadro en el que pueden registrarse.

<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[71])
```
-->

Quieren escoger un nombre con cuidado. Debe ser breve, fácil de recordar y deletrear,  relacionado de alguna manera con su nombre y, claro, profesional. Este último es importante ya que podría estar enviando un enlace a su cuenta de GitHub a posibles empleadores. En el siguiente ejemplo, sacrifico la facilidad de deletreo para incorporar mi nombre. Sus iniciales y apellidos suelen ser una buena opción. Si tienen un nombre muy común, es posible que tengan que tomar eso en cuenta. Una solución sencilla sería agregar números o deletrear parte de su nombre.

La cuenta que uso para mi investigación, _rafalab_, es la misma que uso para mi página web^[http://rafalab.org] y Twitter^[http://twitter.com/rafalab], que lo hace fácil de recordar para los que siguen mi trabajo.

<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[72])
```
-->

Una vez que tengan una cuenta de GitHub, estarán listos para conectar Git y RStudio a esta cuenta.

Un primer paso es dejar que Git sepa quiénes somos. Esto facilitará la conexión con GitHub. Comenzamos abriendo una ventana de terminal en RStudio (recuerden que pueden obtener una a través de _Tools_ en la barra de menú). Ahora usamos el comando `git config` para decirle a Git quiénes somos. Escribiremos los siguientes dos comandos en nuestra ventana de terminal:

```{bash, eval=FALSE, echo=TRUE}
git config --global user.name "Your Name"
git config --global user.mail "your@email.com"
```

Deben usar la cuenta de correo electrónico que utilizaron para abrir su cuenta de GitHub. La sesión de RStudio debería verse así:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[85])
```

Empiecen yendo a _Global Options_, seleccionando _Git/SVN_,
<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[73])
```
-->
y luego ingresando una ruta para el ejecutable de Git que acabamos de instalar.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[74])
```

En la instalación predeterminada de Windows, la ruta será _C:/ Program File/ Git/ bin/ git.exe_, pero deben encontrarla explorando su sistema, ya que esto puede cambiar de un sistema a otro. Ahora, para evitar ingresar nuestra contraseña de GitHub cada vez que intentemos acceder a nuestro repositorio, crearemos lo que se llama _SSH RSA Key_. RStudio puede hacer esto por nosotros automáticamente si hacemos clic en el botón _Create RSA Key_:

<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[75])
```
-->

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[75:76])
```

Pueden seguir las instrucciones predeterminadas como se muestra a continuación:

```{r, echo=FALSE, out.width = "45%"}
knitr::include_graphics(screenshots[77:78])
```

Git, RStudio y GitHub ahora deberían poder conectarse y estamos listos para crear un primer repositorio de código de GitHub.

## Repositorios de GitHub {#github-repos}

Ahora pueden crear un repositorio de GitHub (repositorio). La idea general es tener al menos dos copias de su código: una copia en sus computadoras y otra en GitHub. Si añaden colaboradores a este proyecto, cada uno tendrá una copia en su computadora. La copia de GitHub generalmente se considera la copia _master_ con la que se sincroniza cada colaborador. Git les ayudará a mantener sincronizadas todas las copias diferentes.

Como se mencionó anteriormente, una de las ventajas de mantener el código en un repositorio de GitHub es que pueden compartirlo fácilmente con posibles empleadores interesados en ver ejemplos de su trabajo. Debido a que muchas compañías de ciencia de datos usan sistemas de control de versiones, como Git, para colaborar en proyectos, también pueden estar impresionadas de que ya conocen al menos los conceptos básicos.

El primer paso para crear un repositorio para su código es inicializar en GitHub. Debido a que ya crearon una cuenta, tendrán una página en GitHub con la URL `http://github.com/username`.

Para crear un repositorio, primero inicien sesión en su cuenta haciendo clic en el botón _Sign In_ en [https://github.com](http://github.com). Es posible que ya hayan iniciado una sesión, en cuyo caso el botón _Sign In_ no aparecerá.
<!--

```{r, echo=FALSE}
knitr::include_graphics(screenshots[79])
```
-->
Si inician sesión, deben ingresar su nombre de usuario y contraseña. Le recomendamos que configuren su navegador para recordar esto y evitar escribirlo cada vez.
<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[80])
```
-->

Una vez en sus cuentas, pueden hacer clic en _Repositories_ y luego hacer clic en _New_ para crear un nuevo repositorio:


```{r, out.width="45%", echo=FALSE}
knitr::include_graphics(screenshots[81:82])
```


Entonces querrán elegir un buen nombre descriptivo para el proyecto. En el futuro, es posible que tengan docenas de repositorios, así que tomen esto en cuenta al elegir un nombre. Aquí usaremos `homework-0`. Le recomendamos que hagan público el repositorio. Si desean mantenerlo en privado, tendrán que pagar un cargo mensual.


```{r, echo=FALSE}
knitr::include_graphics(screenshots[83])
```

Ahora tienen su primer repositorio en GitHub. El siguiente paso será _clonarlo_ (_clone it_ en inglés) en su computadora y comenzar a editar y sincronizar usando Git.

Para hacer esto, es conveniente copiar el enlace proporcionado por GitHub específicamente para conectarse a este repositorio, usando Git como se muestra a continuación. Más tarde necesitaremos copiar y pegar esto, así que asegúrense de recordar este paso.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[84])
```



## Descripción general de Git {#git-overview}


[fix check trans below] Las principales acciones en Git son:

1. **pull** o jalar/tirar cambios desde el repositorio remoto, en este caso el repositorio de GitHub
2. **add** o añadir archivos o, como decimos en la jerga de Git, _stage_ los archivos
3. **commit** o asignar cambios al repositorio local
4. **push** o empujar cambios al repositorio _remote_, en nuestro caso el repositorio GitHub

Para permitir efectivamente el control de versiones y la colaboración en Git, los archivos se mueven a través de cuatro áreas diferentes:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-layout.png"))
```

Pero, ¿cómo comienza todo? Hay dos formas: podemos clonar un repositorio existente o inicializar uno. Exploraremos la clonación primero.

### Clonar

[fix do we trans upstream repo?] Vamos a _clonar_ un _Upstream Repository_ existente. Pueden verlo en GitHub aquí: [https://github.com/rairizarry/murders](https://github.com/rairizarry/murders). Al visitar esta página, pueden ver varios archivos y directorios. Este es el _Upstream Repository_. Al hacer clic en el botón verde de clonar, podemos copiar la URL del repositorio `https://github.com/rairizarry/murders.git`.

Pero, ¿qué significa _clone_? En lugar de descargar todos estos archivos a su computadora, vamos a copiar toda la estructura de Git,que significa que agregaremos los archivos y directorios a cada una de las tres etapas locales: _Working Directory_, _Staging Area_ y _Local Repository_. [fix is this correct?] Cuando clonan, estos tres son exactamente iguales en el comienzo.

Pueden ver rápidamente un ejemplo de esto haciendo lo siguiente. Abran una terminal y escriban:


```{r, echo=FALSE}
wd <- getwd() ##so we set back later. We are about to start switching dirs
if(file.exists("git-example")) unlink("git-example", recursive=TRUE, force = TRUE)
```


```{bash}
pwd
mkdir git-example
cd git-example
git clone https://github.com/rairizarry/murders.git
cd murders
```


```{r, include=FALSE}
knitr::opts_knit$set(root.dir = "git-example/murders")
```


Ahora han clonado un repositorio de GitHub y tienen un directorio de trabajo de Git, con todos los archivos, en su sistema.

```{bash}
ls
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-clone.png"))
```


El _Working Directory_ es el mismo que el directorio de trabajo de Unix. Cuando editan archivos usando un editor como RStudio, cambian los archivos en esta área y solo en esta área. Git puede decirles cómo se relacionan estos archivos con las versiones de los archivos en otras áreas con el comando `git status`:


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path, "git/git-status.png"))
```

Si verifican el estatus ahora, verán que nada ha cambiado y recibirán el siguiente mensaje:

```{bash}
git status
```

Ahora vamos a hacer cambios en estos archivos. Eventualmente, queremos que estas nuevas versiones de los archivos sean rastreadas y sincronizadas con el _upstream repository_. Pero no queremos darle seguimiento a cada cambio pequeño: no queremos sincronizar hasta que estemos seguros de que estas versiones son lo suficientemente finales como para compartirlas. Por esta razón, el sistema de control de versiones no guarda las ediciones en el _staging area_.

Para demostrar, agregamos un archivo al _staging area_ con el comando `git add`. A continuación creamos un archivo usando el comando de Unix `echo` solo como ejemplo (normalmente usarían RStudio):

```{bash}
echo "test" >> new-file.txt
```

También estamos agregando un archivo temporal que no queremos [fix "track"] rastrear:

```{bash}
echo "temporary" >> tmp.txt
```

Ahora podemos organizar el archivo que finalmente queremos agregar a nuestro repositorio:

```{bash}
git add new-file.txt
```

Observen lo que dice el estatus ahora:

```{bash}
git status
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-add.png"))
```

Como `new-file.txt` está _staged_, la versión actual del archivo se agregará al repositorio local la próxima vez que decidimos _commit_ y que hacemos de la siguiente manera:

```{bash}
git commit -m "adding a new file"
```

Ahora hemos cambiado el repositorio local, que pueden confirmar usando:

```{bash, eval=FALSE}
git status
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"/git/git-commit.png"))
```

Sin embargo, si volvemos a editar ese archivo, solo cambia en el directorio de trabajo. Para agregar al repositorio local, necesitamos organizarlo y confirmar los cambios que se agregan al repositorio local:

```{bash}
echo "adding a line" >> new-file.txt
git add new-file.txt
git commit -m "adding a new line to new-file"
```

Tengan en cuenta que este paso a menudo es innecesario en nuestros usos de Git. Podemos omitir la parte de preparación si agregamos el nombre del archivo al comando _commit_ de esta manera:

```{bash}
echo "adding a second line" >> new-file.txt
git commit -m "minor change to new-file" new-file.txt
```

Podemos darle seguimiento a todos los cambios que hemos realizado con:

```{bash}
git log new-file.txt
```

Para mantener todo sincronizado, el paso final es impulsar los cambios al _upstream repository_. Esto se hace con el comando `git push` así:

```{bash, eval=FALSE}
git push
```

```{r, include=FALSE}
knitr::opts_knit$set(root.dir = wd)
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-push.png"))
```

Sin embargo, en este ejemplo en particular, no podrán hacerlo porque no tiene permiso para editar el _upstream repository_. Si este fuera su repositorio, podrían.

Si este es un proyecto colaborativo, el _upstream repository_ puede cambiar y volverse diferente a nuestra versión. Para actualizar nuestro repositorio local para que sea como el _upstream repository_, usamos el comando `fetch`:

```{bash, eval=FALSE}
git fetch
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-fetch.png"))
```


Y luego, para hacer estas copias en las áreas del _staging_ y _working directory_, utilizamos el comando:

```{bash, eval=FALSE}
git merge
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-merge.png"))
```

No obstante, a menudo solo queremos cambiar ambos con un solo comando. Para esto, utilizamos:

```{bash, eval=FALSE}
git pull
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-pull.png"))
```


Aprenderemos en la Sección \@ref(rstudio-git) cómo RStudio tiene botones para hacer todo esto. Los detalles proporcionados aquí deberían ayudarlos a entender lo que sucede en el fondo.


## Inicializando un directorio Git {#init}

Ahora exploremos la segunda manera en que podemos comenzar: inicializando un directorio en nuestra propia computadora en lugar de clonar.

Supongamos que ya tenemos un directorio local poblado y queremos convertir este directorio en un repositorio colaborativo de GitHub. La forma más eficiente de lograr esto es _inicializando_ el directorio local.

Para demostrar cómo hacer esto, inicializaremos el directorio de asesinatos con armas de fuego que creamos en la Sección \@ref(prep-project). Tengan en cuenta que ya creamos un directorio con varios subdirectorios en nuestra computadora, pero aún no tenemos un repositorio local de Git o un _Upstream Repository_ de GitHub.

Comenzamos creando un nuevo repositorio en nuestra página de GitHub. Hacemos clic en el botón _New_:


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[112:113])
```

Lo llamamos `murders` aquí para que coincida con el nombre del directorio en nuestro sistema local. Pero si están haciendo esto para otro proyecto, elijan un nombre apropiado.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[114])
```

Luego obtenemos una serie de instrucciones sobre cómo comenzar, pero en su lugar podemos usar lo que hemos aprendido. Lo principal que necesitamos de esta página es copiar la URL del repositorio, en este caso: `https://github.com/rairizarry/murders.git`.
<!--

```{r, echo=FALSE}
knitr::include_graphics(screenshots[115])
```
-->

En este momento, podemos [fix "start a termina"] comenzar una terminal y `cd` en nuestro directorio de proyectos locales. En nuestro ejemplo, sería:

```{bash, eval=FALSE}
cd ~/projects/murders
```

Entonces, _inicializamos_ el directorio. Esto convierte el directorio en un directorio Git y Git comienza a rastrear:

```{bash, eval=FALSE}
git init
```

Todos los archivos ahora están **solo** en nuestro directorio de trabajo; no hay archivos en nuestro repositorio local o en GitHub.

El siguiente paso es conectar el repositorio local con el repositorio de GitHub. En un ejemplo anterior, hicimos que RStudio hiciera esto por nosotros. Ahora tenemos que hacerlo nosotros mismos. Podemos agregar cualquiera de los archivos y hacer _commit_:

```{bash, eval=FALSE}
git add README.txt
git commit -m "First commit. Adding README.txt file just to get started"
```

Ahora tenemos un archivo en nuestro repositorio local y podemos conectarlo al _upstream repository_, que tiene url: `https://github.com/rairizarry/murders.git`.

Para hacer esto, usamos el comando `git remote add`.

```{bash, eval=FALSE}
git remote add origin `https://github.com/rairizarry/murders.git`
```

Ahora podemos usar `git push` ya que hay una conexión a un _upstream repository_:

```{bash, eval=FALSE}
git push
```

En la Sección \@ref(organizing) continuamos trabajando con este ejemplo, mientras demostramos cómo podemos usar RStudio para trabajar con Git y mantener un proyecto sincronizado en GitHub.


```{r, echo=FALSE}
if(file.exists("git-example")) unlink("git-example", recursive=TRUE, force = TRUE)
```


## Usando Git y GitHub en RStudio {#rstudio-git}

Si bien la línea de comandos Git es una herramienta [fix ok "powerful"?] poderosa y flexible, puede ser algo desalentador cuando estamos comenzando. RStudio proporciona una interfaz gráfico que facilita el uso de Git en el contexto de un proyecto de análisis de datos. Describimos cómo usar [fix "feature"] este atributo de RStudio para hacer esto aquí.

Ahora estamos listos para comenzar un proyecto de RStudio que usa control de versiones y almacena el código en un repositorio de GitHub. Para hacer esto, comenzamos un proyecto pero, en lugar de _New Directory_, seleccionaremos _Version Control_ y luego seleccionaremos _Git_ como nuestro sistema de control de versiones:

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[86:87])
```

El URL del repositorio es el enlace que usaron para clonar. En la Sección \@ref(github-repos), nosotros usamos `https://github.com/username/homework-0.git` como ejemplo. En el nombre del directorio del proyecto, deben poner el nombre de la carpeta que se generó, que en nuestro ejemplo será el nombre del repositorio `homework-0`. Esto creará una carpeta llamada `homework-0` en su sistema local. Una vez que hagan esto, se crea el proyecto y está al tanto de la conexión a un repositorio de GitHub. Verán en la esquina superior derecha el nombre y el tipo de proyecto, así como una nueva pestaña en el panel superior derecho titulada _Git_.


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[88:89])
```


Si selecciona esta pestaña, le mostrará los archivos de su proyecto con algunos iconos que le brindan información sobre estos archivos y su relación con el repositorio. En el ejemplo a continuación, ya agregamos un archivo a la carpeta, llamado _code.R_, que puede ver en el [fix "editing pane"] panel de edición.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[90])
```

Ahora debemos prestar atención al panel Git. Es importante saber que **sus archivos locales y el repositorio de GitHub no se sincronizarán automáticamente**. Como se describe en la Sección \@ref(git-overview), deben sincronizar usando git push cuando estén listos. A continuación, les mostramos que pueden hacerlo a través de RStudio en lugar del terminal.

Antes de comenzar a trabajar en un proyecto colaborativo, generalmente lo primero que hacemos es _pull__ los cambios desde el repositorio remoto, en nuestro caso el de GitHub. Sin embargo, para el ejemplo que se muestra aquí, dado que estamos comenzando con un repositorio vacío y somos los únicos que hacemos cambios, no tenemos que comenzar con _pull_.

En RStudio, el status del archivo en relación con los repositorios remotos y locales se representa en los símbolos de status con colores. Un cuadrado amarillo significa que Git no sabe nada sobre este archivo. Para sincronizar con el repositorio de GitHub, necesitamos _add_ el archivo, luego _commit_ el cambio a nuestro repositorio de Git local y entonces _push_ el cambio al repositorio de GitHub. En este momento, el archivo está en nuestra computadora. Para añadir el archivo usando RStudio, hacemos clic en la caja _Stage_. Verán que el ícono de status ahora cambia a una A verde.


```{r, echo=FALSE}
knitr::include_graphics(screenshots[91])
```

Nota: solo estamos añadiendo el archivo _code.R_. No necesariamente tenemos que añadir todos los archivos de nuestro repositorio local al repositorio de GitHub, solo los que queremos darle seguimiento o los que queremos compartir. Si nuestro trabajo está produciendo archivos de cierto tipo a los que no queremos darle seguimiento, podemos agregar el sufijo que define estos archivos al archivo .gitignore. Aquí se incluyen más detalles sobre el uso de .gitignore: [https://git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore). Estos archivos dejarán de aparecer en su panel RStudio Git. Para el ejemplo que se muestra aquí, solo agregaremos _code.R_. Pero, en general, para un proyecto de RStudio, recomendamos agregar los archivos .gitignore y .Rproj.

Ahora estamos listos para enviar el archivo a nuestro repositorio local. En RStudio, podemos usar el botón _Commit_. Esto abrirá una nueva ventana de diálogo. Con Git, cada vez que hacemos _commit_ a un cambio, debemos ingresar un comentario que describa los cambios.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[92])
```

En este caso, simplemente describiremos que estamos agregando un nuevo script. En este cuadro de diálogo, RStudio también le ofrece un resumen de lo que está cambiando al repositorio de GitHub. En este caso, debido a que es un archivo nuevo, todo el archivo se resalta en verde, que resalta los cambios.

Una vez que presionen el botón _commit_, deberíam ver un mensaje de Git con un resumen de los cambios que se confirmaron. Ahora estamos listos para empujar estos cambios al repositorio de GitHub. Podemos hacer esto haciendo clic en el botón _Push_ en la esquina superior derecha:

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[93:94])
```

Ahora vemos un mensaje de Git que nos dice que el _push_ ha sido exitoso.
En la ventana emergente ya no vemos el archivo `code.R`. Esto se debe a que no se han realizado nuevos cambios desde la última vez que hicimos _push_. Podemos salir de esta ventana emergente ahora y continuar trabajando en nuestro código.


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[95:96])
```

Si ahora visitamos nuestro repositorio en la web, veremos que coincide con nuestra copia local.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[97])
```

¡Felicitaciones, han compartido código con éxito en un repositorio de GitHub!

```{r, include=FALSE}
knitr::opts_chunk$set(out.width = NULL, out.extra = NULL)
```

