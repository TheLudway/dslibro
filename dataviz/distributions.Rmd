# Cómo visualizar distribuciones de datos {#distributions}

Posiblemente hayan notado que los datos numéricos a menudo se resumen con el valor _promedio_. Por ejemplo, la calidad de una escuela secundaria a veces se resume con un número: la puntuación promedio en una prueba estandarizada. Ocasionalmente, se informa un segundo número: la _desviación estándar_. Por ejemplo, pueden leer un informe que indique que las puntuaciones fueron 680 más o menos 50 (la desviación estándar). El informe ha resumido un vector completo de puntajes con solo dos números. ¿Es esto apropiado? ¿Hay alguna información importante que no estamos considerando al ver este resumen en lugar de la lista completa?

Nuestro primer componente básico de visualización de datos es aprender a resumir listas de factores o vectores numéricos. Generalmente, la mejor manera de compartir o explorar este resumen es a través de la visualización de datos. El resumen estadístico más básico de una lista de objetos o números es su distribución. Una vez que un vector se haya resumido como una distribución, existen varias técnicas de visualización de datos para transmitir esta información de manera efectiva.

En este capítulo, primero discutiremos las propiedades de una variedad de distribuciones y cómo visualizar las distribuciones usando un ejemplo motivante de alturas de estudiantes. Luego, en la Sección \@ref(other-geometries), discutiremos las geometrías de __ggplot2__ para estas visualizaciones.


## Tipos de variables

Trabajaremos con dos tipos de variables: categóricas y numéricas. Cada uno puede dividirse en otros dos grupos: las variables categóricas pueden ser ordinales o no, mientras que las numéricas pueden ser discretas o continuas.

Cuando cada entrada en un vector proviene de uno de un pequeño número de grupos, nos referimos a los datos como _datos categóricos_. Dos ejemplos sencillos son el sexo (masculino o femenino) y las regiones (noreste, sur, norte central, oeste). Algunos datos categóricos se pueden ordenar aunque no sean números, por ejemplo cuán picante es una comida (leve, medio, muy). En los libros de texto de estadísticas, los datos categóricos ordenados se denominan datos _ordinales_.

Ejemplos de datos numéricos son el tamaño de la población, las tasas de asesinatos y las alturas. Algunos datos numéricos se pueden tratar como ordenados categóricos. Podemos dividir aún más los datos numéricos en continuos y discretos. Las variables continuas son aquellas que pueden tomar cualquier valor, como las alturas, si se miden con suficiente precisión. Por ejemplo, un par de gemelos pueden medir 68.12 y 68.11 pulgadas, respectivamente. Los recuentos, como el tamaño de la población, son discretos porque tienen que ser números redondos.

Tengan en cuenta que los datos numéricos discretos pueden considerarse ordinales. Aunque esto es técnicamente cierto, generalmente reservamos el término datos ordinales para variables que pertenecen a un pequeño número de grupos diferentes, y cada grupo tiene muchos miembros. En contraste, cuando tenemos muchos grupos con pocos casos en cada grupo, generalmente nos referimos a ellos como variables numéricas discretas. Entonces, por ejemplo, el número de paquetes de cigarrillos que una persona fuma al día, redondeado al paquete más cercano, se consideraría ordinal, mientras que el número real de cigarrillos se consideraría una variable numérica. Pero, de hecho, hay ejemplos que pueden considerarse tanto numéricos como ordinales cuando se trata de visualizar datos.

## Estudio de caso: describiendo alturas de estudiantes

Aquí presentamos un nuevo problema motivante. Es artificial, pero nos ayudará ilustrar los conceptos necesarios para comprender las distribuciones.

Imaginen que tenemos que describir las alturas de nuestros compañeros de clase a ET, un extraterrestre que nunca ha visto humanos. Como primer paso, necesitamos recopilar datos. Para hacer esto, les pedimos a los estudiantes que indiquen sus alturas en pulgadas. Les pedimos que nos provean información sobre su sexo biológico porque sabemos que hay dos distribuciones diferentes por sexo. Recopilamos los datos y los guardamos en el set de datos `heights`:

```{r load-heights, warning=FALSE, message=FALSE}
library(tidyverse)
library(dslabs)
data(heights)
```

Una forma de transmitir las alturas a ET es simplemente enviarle esta lista de `r nrow(heights)` alturas.  Sin embargo, hay formas mucho más efectivas de transmitir la información, y entender el concepto de distribución ayudará. Para simplificar la explicación, primero nos enfocamos en las alturas masculinas. Examinamos los datos de altura femenina en la Sección \@ref(student-height-cont).

## La función de distribución

Resulta que, en algunos casos, el promedio y la desviación estándar son prácticamente todo lo que necesitamos para comprender los datos. Aprenderemos técnicas de visualización de datos que nos ayudarán a determinar cuándo este resumen de dos números es apropiado. Estas mismas técnicas servirán como una alternativa para cuando dos números no son suficientes.

El resumen estadístico más básico de una lista de objetos o números es su distribución. La forma más sencilla de pensar en una distribución es como una descripción compacta de una lista con muchas entradas. Este concepto no debería ser nuevo para los lectores de este libro. Por ejemplo, con datos categóricos, la distribución simplemente describe la proporción de cada categoría única. El sexo representado en el set de datos de alturas es:

```{r echo = FALSE}
prop.table(table(heights$sex))
```

Esta _tabla de frecuencia_ de dos categorías es la forma más simple de una distribución. Realmente no necesitamos visualizarla ya que un número describe todo lo que necesitamos saber: `r round(mean(heights$sex=="Female")*100)`% son mujeres y el resto son hombres. Cuando hay más categorías, un diagrama de barras sencillo describe la distribución. Aquí hay un ejemplo con las regiones estatales de EE. UU.:

```{r state-region-distribution, echo=FALSE}
murders %>% group_by(region) %>%
summarize(n = n()) %>%
mutate(Proportion = n/sum(n),
region = reorder(region, Proportion)) %>%
ggplot(aes(x=region, y=Proportion, fill=region)) +
geom_bar(stat = "identity", show.legend = FALSE) +
xlab("")
```

Este gráfico simplemente nos muestra cuatro números, uno para cada categoría. Usualmente usamos diagramas de barras cuando tenemos pocos números. Aunque este gráfico en particular no proporciona mucha más información que una tabla de frecuencias en sí, es un primer ejemplo de cómo convertimos un vector en un gráfico que resume de manera sucinta toda la información en el vector. Cuando los datos son numéricos, la tarea de mostrar distribuciones es más retante.

## Funciones de distribución acumulada {#cdf-intro}

Los datos numéricos que no son categóricos también tienen distribuciones. En general, cuando los datos no son categóricos, indicar la frecuencia de cada entrada no es un resumen efectivo, ya que la mayoría de las entradas son únicas. En nuestro estudio de caso, por ejemplo, mientras varios estudiantes reportaron una altura de 68 pulgadas, un estudiante indicó una altura de `68.503937007874` pulgadas y otro una altura `68.8976377952756` pulgadas. Suponemos que convirtieron sus alturas de 174 y 175 centímetros, respectivamente.

Los libros de texto de estadísticas nos enseñan que una forma más útil de definir una distribución de datos numéricos es definir una función que indique la proporción de los datos a continuación $a$ para todos los valores posibles de $a$. Esta función se llama la función de distribución acumulada o CDF por sus siglas en inglés. En estadística, se usa la siguiente notación:

$$ F(a) = \mbox{Pr}(x \leq a) $$

Aquí hay un gráfico de $F$ para los datos de altura masculina:

```{r ecdf, echo=FALSE}
ds_theme_set()
heights %>% filter(sex=="Male") %>% ggplot(aes(height)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Similar a lo que hace la tabla de frecuencias para datos categóricos, el CDF define la distribución de datos numéricos. En el gráfico, podemos ver que `r round(ecdf(heights$height[heights$sex == "Male"]) (66) * 100) `% de los valores son menos de 65, ya que $F(66)=$ `r ecdf(heights$height[heights$sex == "Male"])(66) `, o que `r round(ecdf (heights$height[heights$sex == "Male"])(72) * 100) `% de los valores son menos de 72, ya que $F(72)=$ `r ecdf(heights$height[heights$sex == "Male"]) (72) `,
y así. De hecho, podemos informar la proporción de valores entre dos alturas, digamos $a$ y $b$, al computar $F(b) - F(a)$. Esto significa que si enviamos este diagrama a ET, tendrá toda la información necesaria para reconstruir la lista completa. Parafraseando la expresión "una imagen vale más que mil palabras", en este caso una imagen es tan informativa como `r sum(heights$sex=="Male")` números.

Una nota final: debido a que los CDF pueden definirse matemáticamente, la palabra _empírica_ se agrega para distinguir cuando se usan los datos. Por lo tanto, utilizamos el término CDF empírico o eCDF por sus siglas en inglés.


## Histogramas

Aunque el concepto de CDF se discute ampliamente en los libros de texto de estadística, el gráfico no es muy popular en la práctica. La razón principal es que no transmite fácilmente características de interés como: ¿En qué valor se centra la distribución? ¿La distribución es simétrica? ¿Qué rangos contienen el 95% de los valores? Los histogramas son preferidos porque facilitan enormemente la respuesta a tales preguntas. Los histogramas sacrifican solo un poco de información para producir gráficos que son mucho más fáciles de interpretar.

La forma más sencilla de hacer un histograma es dividir el _span_ de nuestros datos en _compartimientos_ (_bins_ en inglés) no superpuestos del mismo tamaño. Luego, para cada compartimiento, contamos el número de valores que se encuentran en ese intervalo. El histograma grafica estos recuentos como barras con la base de la barra definida por los intervalos. A continuación tenemos el histograma para los datos de altura que dividen el rango de valores en intervalos de una pulgada: $[49.5, 50.5], [51.5,52.5],(53.5,54.5],...,(82.5,83.5]$

```{r height-histogram, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, color = "black")
```

Como pueden ver en la figura anterior, un histograma es similar a un diagrama de barras, pero difiere en que el eje-x es numérico, no categórico.

Si le enviamos este diagrama a ET, inmediatamente aprenderá algunos detalles importantes sobre nuestros datos. Primero, el rango de datos es de 50 a 84 con la mayoría (más del 95%) entre 63 y 75 pulgadas. Además, las alturas son casi simétricas alrededor de 69 pulgadas. Por último, al sumar conteos, ET podría obtener una muy buena aproximación de la proporción de los datos en cualquier intervalo. Por lo tanto, el histograma anterior no solo es fácil de interpretar, sino que también ofrece casi toda la información contenida en la lista cruda de `r sum(heights$sex=="Male")` alturas con aproximadamente 30 conteos, uno por cada compartimiento.

¿Qué información perdemos? Tengan en cuenta que todos los valores en cada intervalo se tratan de la misma manera cuando se calculan las alturas del compartimiento. Entonces, por ejemplo, el histograma no distingue entre 64, 64.1 y 64.2 pulgadas. Dado que estas diferencias son casi imperceptibles a la vista, las implicaciones prácticas son insignificantes y pudimos resumir los datos en solo 23 números.

Discutimos cómo codificar histogramas en la Sección \@ref(other-geometries).

## Densidad suave

Los gráficos de densidad suave son estéticamente más atractivos que los histogramas. A continuación vemos un gráfico de densidad suave para nuestros datos de altura:

```{r example-of-smoothed-density, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha = .2, fill= "#00BFC4", color = 0) +
geom_line(stat='density')
```

En este gráfico, ya no tenemos bordes afilados en los límites de intervalo y  se han eliminado muchos de los picos locales. Además, la escala del eje-y cambió de conteos a _densidad_.

Para entender las densidades suaves, tenemos que entender las _estimaciones_, un tema que no abordamos hasta más tarde. Sin embargo, ofrecemos una explicación heurística para ayudarles a entender los conceptos básicos y así poder utilizar esta herramienta útil de visualización de datos.

El nuevo concepto principal que deben entender es que suponemos que nuestra lista de valores observados es un subconjunto de una lista mucho más grande de valores no observados. En el caso de las alturas, pueden imaginar que nuestra lista de `r sum(heights$sex=="Male")` estudiantes varones proviene de una lista hipotética que contiene todas las alturas de todos los estudiantes varones en todo el mundo, medidos todos con mucha precisión. Digamos que hay 1,000,000 de estas medidas. Esta lista de valores tiene una distribución, como cualquier lista de valores, y esta distribución considerable es realmente lo que queremos transmitir a ET, ya que es mucho más general. Desafortunadamente, no podemos ver esa lista grandísima.

Sin embargo, podemos hacer una suposición que quizás nos ayude a aproximarla. Si tuviéramos 1,000,000 valores, medidos con mucha precisión, podríamos hacer un histograma con compartimientos muy, muy pequeños. La suposición es que si mostramos esto, la altura de los compartimientos consecutivos será similar. Esto es lo que queremos decir con suave: no tenemos grandes saltos en las alturas de los compartimientos consecutivos. A continuación tenemos un histograma hipotético con compartimientos de tamaño 1:


```{r simulated-data-histogram-1, echo=FALSE}
set.seed(1988)
x <- data.frame(height = c(rnorm(1000000,69,3), rnorm(1000000,65,3)))
x %>% ggplot(aes(height)) + geom_histogram(binwidth = 1, color = "black")
```

Entre más pequeños hacemos los compartimientos, más suave se vuelve el histograma. Aquí están los histogramas con ancho de compartimiento de 1, 0.5 y 0.1:

```{r simulated-data-histogram-2, fig.width=9, fig.height=3, out.width = "100%",echo=FALSE, message=FALSE}
p1 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 1, color = "black") + ggtitle("binwidth=1")
p2 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 0.5, color="black") + ggtitle("binwidth=0.5")
p3 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 0.1) + ggtitle("binwidth=0.1")
library(gridExtra)
grid.arrange(p1, p2, p3, nrow = 1)
```

La densidad suave es básicamente la curva que atraviesa la parte superior de las barras del histograma cuando los compartimientos son muy, muy pequeños. Para que la curva no dependa del tamaño hipotético de la lista hipotética, calculamos la curva usando frecuencias en lugar de conteos:

```{r, simulated-density-1, echo=FALSE}
x %>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 0.1, color = I("black")) +
geom_line(stat='density')
```

Ahora, de vuelta a la realidad. No tenemos millones de medidas. En cambio, tenemos `r sum(heights$sex=="Male")` y no podemos hacer un histograma con compartimientos muy pequeños.

Por lo tanto, hacemos un histograma, utilizando tamaños de compartimiento apropiados para nuestros datos y frecuencias de cómputo en lugar de conteos. Además, dibujamos una curva suave que pasa por la parte superior de las barras del histograma. Los siguientes gráficos muestran los pasos que conducen a una densidad suave:

```{r smooth-density-2, echo=FALSE, out.width = "100%"}
hist1 <- heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, color="black")
hist2 <- hist1 +
geom_line(stat='density')
hist3 <- hist1 +
geom_point(data = ggplot_build(hist2)$data[[1]], aes(x,y), col = "blue")
hist4 <- ggplot() + geom_point(data = ggplot_build(hist2)$data[[1]], aes(x,y), col = "blue") +
xlab("height") + ylab("density")
hist5 <- hist4 + geom_line(data = ggplot_build(hist2)$data[[2]], aes(x,y))
hist6 <- heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha = 0.2, fill="#00BFC4", col = 0) +
geom_line(stat='density') +
scale_y_continuous(limits = layer_scales(hist2)$y$range$range)

grid.arrange(hist1, hist3, hist4, hist5, hist2, hist6, nrow=2)
```

Sin embargo, recuerden que _suave_ (_smooth_ en inglés) es un término relativo. De hecho, podemos controlar la _suavidad_ de la curva cambiando el número de puntos en los compartimientos. Esta opción se conoce como _bandwidth_, _span_, _window size_ o, en español, _ventana de suavizado_ o _parámetro de suavizado_, y se puede ajustar en la función que calcula la curva de densidad suave. Aquí hay dos ejemplos que usan diferentes niveles de suavidad en el mismo histograma:


```{r densities-different-smoothness, echo = FALSE, out.width = "100%", fig.width = 6, fig.height = 3}
p1 <- heights %>%
filter(sex=="Male")%>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, alpha = 0.5) +
geom_line(stat='density', adjust = 0.5)

p2 <- heights %>%
filter(sex=="Male") %>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, alpha = 0.5) +
geom_line(stat='density', adjust = 2)

grid.arrange(p1,p2, ncol=2)
```
Necesitamos tomar esta decisión con cuidado ya que las visualizaciones que resultan pueden cambiar nuestra interpretación de los datos. Debemos seleccionar un grado de suavidad que podamos defender como representativo de los datos subyacentes. En el caso de la altura, realmente tenemos razones para creer que la proporción de personas con alturas similares debería ser la misma. Por ejemplo, la proporción que es 72 pulgadas debería ser más similar a la proporción que es 71 que a la proporción que es 78 o 65. Esto implica que la curva debe ser bastante suave; es decir, la curva debería parecerse más al ejemplo de la derecha que al de la izquierda.

Si bien el histograma es un resumen sin supuestos, la densidad suavizada se basa en algunos supuestos.

### Cómo interpretar el eje-y

Tengan en cuenta que interpretar el eje-y de un gráfico de densidad suave no es obvio. Se escala para que el área bajo la curva de densidad se sume a 1. Si imaginan que formamos un compartimiento con una base de 1 unidad de longitud, el valor del eje-y nos indica la proporción de valores en ese compartimiento. Sin embargo, esto solo es cierto para compartimientos de tamaño 1. Para intervalos de otro tamaño, la mejor manera de determinar la proporción de datos en ese intervalo es calculando la proporción del área total contenida en ese intervalo. Por ejemplo, aquí vemos la proporción de valores entre 65 y 68:

```{r area-under-curve, echo=FALSE}
d <- with(heights, density(height[sex=="Male"]))
tmp <- data.frame(height=d$x, density=d$y)
tmp %>% ggplot(aes(height,density)) + geom_line() +
geom_area(aes(x=height,y=density), data = filter(tmp, between(height, 65, 68)), alpha=0.2, fill="#00BFC4")
```

La proporción de esta área es aproximadamente
`r round (mean(dplyr::between (heights$height[heights$sex == "Male"], 65, 68)), 2)`,
lo que significa que aproximadamente `r noquote(paste0(round(mean(dplyr::between(heights$height[heights$sex=="Male"], 65, 68)), 2)*100, '%'))` de las alturas masculinas están entre 65 y 68 pulgadas.

Al comprender esto, estamos listos para usar la densidad suave como resumen. Para este set de datos, nos sentimos bastante cómodos suponiendo suavidad y, por ende, compartiendo esta figura estéticamente agradable con ET, que puede usarla para comprender nuestros datos de alturas masculinas:

```{r example-of-smoothed-density-2, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha=.2, fill= "#00BFC4", color = 0) +
geom_line(stat='density')
```


### Densidades permiten estratificación

Como nota final, señalamos que una ventaja de las densidades suaves sobre los histogramas para fines de visualización es que las densidades facilitan la comparación de dos distribuciones. Esto se debe en gran parte a que los bordes irregulares del histograma agregan desorden. Aquí hay un ejemplo que compara las alturas masculinas y las femeninas:

```{r two-densities-one-plot, echo=FALSE}
heights %>%
ggplot(aes(height, fill=sex)) +
geom_density(alpha = 0.2, color = 0) +
geom_line(stat='density')
```

Con el argumento correcto, `ggplot` automáticamente sombrea la región de intersección con un color diferente. Mostraremos ejemplos de código de __ggplot2__ para densidades en la Sección \@ref(gapminder) así como en la Sección \@ref(other-geometries).


## Ejercicios


1\. En el set de datos `murders`, la región es una variable categórica y la siguiente es su distribución:

```{r barplot-exercise, echo=FALSE}
library(dslabs)
ds_theme_set()
data(murders)
murders %>% group_by(region) %>%
summarize(n = n()) %>%
mutate(Proportion = n/sum(n),
region = reorder(region, Proportion)) %>%
ggplot(aes(x=region, y=Proportion, fill=region)) +
geom_bar(stat = "identity", show.legend = FALSE) +
xlab("")
```

Redondeando al 5% más cercano, ¿qué proporción de los estados se encuentran en la región "North Central"?


2\. ¿Cuál de los siguientes es cierto?

a. El gráfico anterior es un histograma.
b. El gráfico anterior muestra solo cuatro números con un diagrama de barras.
c. Las categorías no son números, por lo que no tiene sentido graficar la distribución.
d. Los colores, no la altura de las barras, describen la distribución.

3\. El siguiente gráfico muestra el eCDF para las alturas masculinas:


```{r ecdf-exercise, echo=FALSE}
heights %>% filter(sex == "Male") %>% ggplot(aes(height)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Según el gráfico, ¿qué porcentaje de hombres son más bajos que 75 pulgadas?

a. 100%
b. 95%
c. 80%
d. 72 pulgadas


4\. A la pulgada más cercana, ¿qué altura `m` tiene la propiedad de que la mitad de los estudiantes varones son más altos que `m` y la mitad son más bajos?

a. 61 pulgadas
b. 64 pulgadas
c. 69 pulgadas
d. 74 pulgadas

5\. Aquí hay un eCDF de las tasas de asesinatos en todos los estados:

```{r ecdf-exercise-2, echo=FALSE}
murders %>% mutate(murder_rate = total/population * 10^5) %>%
ggplot(aes(murder_rate)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Sabiendo que hay 51 estados (contando DC) y basado en este gráfico, ¿cuántos estados tienen tasas de homicidio superiores a 10 por cada 100,000 personas?

a. 1
b. 5
c. 10
d. 50


6\. Según el eCDF anterior, ¿cuál de las siguientes afirmaciones es cierta?


a. Alrededor de la mitad de los estados tienen tasas de homicidios superiores a 7 por 100,000 y la otra mitad por debajo.
b. La mayoría de los estados tienen tasas de homicidio de menos de 2 por 100,000.
c. Todos los estados tienen tasas de asesinatos superiores a 2 por 100,000.
d. Con la excepción de 4 estados, las tasas de asesinatos son inferiores a 5 por cada 100,000.


7\. A continuación mostramos el histograma de alturas masculinas de nuestro set de datos `heights`:

```{r height-histogram-exercise, echo=FALSE}
heights %>%
filter(sex == "Male") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, color = "black")
```

Según este gráfico, ¿cuántos hombres hay entre 63.5 y 65.5?

a. 10
b. 24
c. 34
d. 100

8\. ¿Aproximadamente qué **porcentaje** son más bajos que 60 pulgadas?

a. 1%
b. 10%
c. 25%
d. 50%

9\. Según el gráfico de densidad abajo, ¿aproximadamente qué proporción de estados de EE. UU. tiene poblaciones con más de 10 millones de personas?

```{r density-exercise, echo=FALSE}
murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey") +
scale_x_log10() +
xlab("Population in millions")
```

a. 0.02
b. 0.15
c. 0.50
d. 0.55

10\. Abajo hay tres gráficos de densidad. ¿Es posible que sean del mismo set de datos?

```{r density-exercise-2, echo=FALSE, warning=FALSE, message=FALSE}
library(gridExtra)
p1 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = 5) + xlab("Population in millions") + ggtitle("1")
p2 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = .05) + scale_x_log10() + xlab("Population in millions") + ggtitle("2")
p3 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = 1) + scale_x_log10() + xlab("Population in millions") + ggtitle("3")
grid.arrange(p1,p2,p3,ncol=2)
```

¿Cuál de las siguientes afirmaciones es cierta?

a. Es imposible que sean del mismo set de datos.
b. Son del mismo set de datos, pero los gráficos son diferentes debido a errores de código.
c. Son del mismo set de datos, pero el primer y el segundo gráfico suavizan de menos y el tercero sobresuaviza.
d. Son del mismo set de datos, pero el primero no está en la escala logarítmica, el segundo suaviza de menos y el tercero sobresuaviza.

## La distribución normal {#normal-distribution}

Los histogramas y los gráficos de densidad proveen excelentes resúmenes de una distribución. ¿Pero podemos resumir aún más? A menudo vemos el promedio y la desviación estándar utilizada como resumen estadístico: ¡un resumen de dos números! Para comprender cuáles son estos resúmenes y por qué se usan tanto, necesitamos comprender la distribución normal.

La distribución normal, también conocida como curva de campana y distribución Gausiana, es uno de los conceptos matemáticos más famosos de la historia. Una razón para esto es que se producen distribuciones aproximadamente normales en muchas situaciones, incluyendo las ganancias de juego, las alturas, los pesos, la presión arterial, las puntuaciones en las pruebas estandarizadas y los errores de medición experimentales. Hay explicaciones para esto y las describiremos más adelante. Aquí nos enfocamos en cómo la distribución normal nos ayuda a resumir los datos.

En vez de usar datos, la distribución normal se define con una fórmula matemática. Para cualquier intervalo $(a,b)$, la proporción de valores en ese intervalo se puede calcular utilizando esta fórmula:

$$\mbox{Pr}(a < x < b) = \int_a^b \frac{1}{\sqrt{2\pi}s} e^{-\frac{1}{2}\left( \frac{x-m}{s} \right)^2} \, dx$$


No necesitan memorizar o comprender los detalles de la fórmula. Pero recuerden que está completamente definida por solo dos parámetros: $m$ y $s$. El resto de los símbolos en la fórmula representan los extremos del intervalo que determinamos, $a$ y $b$ y las conocidas constantes matemáticas $\pi$ y $e$. Estos dos parámetros $m$ y $s$, se conocen respectivamente como el _promedio_ (o _la media_) y _la desviación estándar_, o SD por sus siglas en inglés, de la distribución.

La distribución es simétrica, centrada en el promedio y la mayoría de los valores (alrededor del 95%) están dentro de 2 SD del promedio. Así es como se ve la distribución normal cuando el promedio es 0 y la SD es 1:

```{r normal-distribution-density, echo=FALSE}
mu <- 0; s <- 1
norm_dist <- data.frame(x=seq(-4,4,len=50)*s+mu) %>% mutate(density=dnorm(x,mu,s))
norm_dist %>% ggplot(aes(x,density)) + geom_line()
```

El hecho de que la distribución está definida por solo dos parámetros implica que si la distribución de un set de datos se puede aproximar con una distribución normal, toda la información necesaria para describir la distribución se puede codificar en solo dos números: el promedio y la desviación estándar. Ahora vamos a definir estos valores para una lista arbitraria de números.

Para una lista de números contenidos en un vector `x`, el promedio se define como:

```{r, eval=TRUE}
m <- sum(x)/ length(x)
```

y la SD se define como:
```{r}
s <- sqrt(sum((x-mu)^2)/ length(x))
```
que puede interpretarse como la distancia promedio entre los valores y su promedio.

Calculemos los valores para la altura de los varones que almacenaremos en el objeto $x$:

```{r}
index <- heights$sex == "Male"
x <- heights$height[index]
```

Se pueden usar las funciones predefinidas `mean` y `sd` (tengan en cuenta que por razones que se explican en la Sección \@ref(data-driven-model), `sd` divide por `length(x)-1` en vez de `length(x)`) :
```{r}
m <- mean(x)
s <- sd(x)
c(average = m, sd = s)
```

A continuación tenemos un gráfico de la densidad suave y la distribución normal con media = `r round(m,1)` y SD = `r round(s,1)` trazado como una línea negra con la densidad suave de nuestras alturas de estudiantes en azul:

```{r data-and-normal-densities, echo=FALSE}
norm_dist <- data.frame(x = seq(-4, 4, len=50)*s + m) %>%
mutate(density = dnorm(x, m, s))

heights %>% filter(sex == "Male") %>% ggplot(aes(height)) +
geom_density(fill="#0099FF") +
geom_line(aes(x, density), data = norm_dist, lwd=1.5)
```

La distribución normal parece ser una buena aproximación aquí. Ahora veremos cuán bien funciona esta aproximación para predecir la proporción de valores dentro de los intervalos.

## Unidades estándar

Para los datos que se distribuyen aproximadamente normalmente, es conveniente pensar en términos de _unidades estándar_. La unidad estándar de un valor nos dice cuántas desviaciones estándar se alejan del promedio. Específicamente, para un valor `x` de un vector `X`, definimos el valor de `x` en unidades estándar como `z = (x - m)/s` con `m` y `s` el promedio y la desviación estándar de `X`, respectivamente. ¿Por qué es conveniente hacer esto?

Primero repasen la fórmula para la distribución normal y observen que lo que se está exponiendo es $-z^2/2$ con $z$ equivalente a $x$ en unidades estándar. El hecho de que el máximo de $e^{-z^2/2}$ es cuando $z=0$ explica por qué la distribución ocurre en el promedio. También explica la simetría ya que $- z^2/2$ es simétrico alrededor de 0. Además, noten que si convertimos los datos distribuidos normalmente a unidades estándar, podemos saber rápidamente si, por ejemplo, una persona es aproximadamente promedio ( $z=0$), entre los más altos ( $z \approx 2$), entre los más pequeños ( $z \approx -2$), o una ocurrencia extremadamente rara ( $z > 3$ o $z < -3$). Recuerden que no importa cuáles sean las unidades originales, estas reglas aplican a cualquier dato que es aproximadamente normal.

En R, podemos obtener unidades estándar usando la función `scale`:
```{r}
z <- scale(x)
```

Ahora para ver cuántos hombres hay dentro de 2 SD del promedio, simplemente escribimos:

```{r}
mean(abs(z) < 2)
```

¡La proporción es aproximadamente el 95%, que es lo que predice la distribución normal! Para tener hasta más confirmación de que la aproximación es precisa, podemos usar gráficos Q-Q (_quantile-quantile_ plots en inglés).


## Gráficos Q-Q

Una forma sistemática de evaluar cuán bien se ajusta la distribución normal a los datos es verificar si las proporciones observadas y predecidas coinciden. En general, este es el acercamiento del gráfico q-q.

Primero, definimos los cuantiles teóricos para la distribución normal. En los libros de estadísticas usamos el símbolo $\Phi(x)$ para definir la función que nos da la probabilidad de que una distribución normal estándar sea menos que $x$. Así por ejemplo, $\Phi(-1.96) = 0.025$ y $\Phi(1.96) = 0.975$. En R, podemos evaluar $\Phi$ utilizando la función `pnorm`:

```{r}
pnorm(-1.96)
```


La función inversa $\Phi^{-1}(x)$ nos da los _cuantiles teóricos_ para la distribución normal. Así por ejemplo, $\Phi^{-1}(0.975) = 1.96$. En R, podemos evaluar el inverso de $\Phi$ utilizando la `qnorm` función.

```{r}
qnorm(0.975)
```

Tengan en cuenta que estos cálculos son para la distribución normal estándar por defecto (media = 0, desviación estándar = 1), pero también podemos definirlos para cualquier distribución normal. Podemos hacer esto usando los argumentos `mean` y `sd` en las funciones `pnorm` y `qnorm`. Por ejemplo, podemos usar `qnorm` para determinar cuantiles de una distribución con promedio y desviación estándar específicos:

```{r}
qnorm(0.975, mean = 5, sd = 2)
```

Para la distribución normal, todos los cálculos relacionados con los cuantiles se realizan sin datos, de ahí el nombre de _cuantiles teóricos_. Pero los cuantiles se pueden definir para cualquier distribución, incluso una empírica. Entonces, si tenemos datos en un vector $x$, podemos definir el cuantil asociado con cualquier proporción $p$ como el $q$ para el cual la proporción de valores [fix] por debajo/menos de $q$ es $p$. Usando el código R, podemos definir `q` como el valor para el cual `mean(x <= q) = p`. [fix] Observen que no todo $p$ tiene un $q$ para el cual la proporción es exactamente $p$. Hay varias maneras de definir el mejor $q$ como se discute en la página de ayuda para la función `quantile`.

Como ejemplo rápido, para los datos de alturas masculinas, tenemos que:
```{r}
mean(x <= 69.5)
```
Entonces, alrededor del 50% son más bajos o iguales a 69 pulgadas. Esto implica que si $p=0.50$, entonces $q=69.5$.

La idea de un gráfico Q-Q es que si sus datos están bien aproximados por la distribución normal, los cuantiles de sus datos deberían ser similares a los cuantiles de una distribución normal. Para construir un gráfico Q-Q, hacemos lo siguiente:

1. Definimos un vector de $m$ dimensiones $p_1, p_2, \dots, p_m$.
2. [fix] Definimos un vector de cuantiles $q_1, \dots, q_m$ para sus datos para las proporciones $p_1, \dots, p_m$. Nos referimos a estos como los _cuantiles muestrales_ (_sample quantiles_ en inglés).
3. Definimos un vector de cuantiles teóricos para las proporciones. $p_1, \dots, p_m$ para una distribución normal con el mismo promedio y desviación estándar que los datos.
4. Graficamos los cuantiles muestrales versus los cuantiles teóricos.


Construyamos un diagrama Q-Q usando el código R. Comiencen definiendo el vector de proporciones.
```{r}
p <- seq(0.05, 0.95, 0.05)
```

Para obtener los cuantiles de los datos, podemos usar la función `quantile` así:
```{r}
sample_quantiles <- quantile(x, p)
```

Para obtener los cuantiles teóricos de distribución normal con promedio y SD correspondiente, utilizamos la función `qnorm`:
```{r}
theoretical_quantiles <- qnorm(p, mean = mean(x), sd = sd(x))
```

Para ver si coinciden o no, los graficamos uno contra el otro y dibujamos la línea de identidad:

```{r qqplot-original}
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

Noten que este código [fix] se hace mucho más limpio/es mucho más sencillo si usamos unidades estándar:
```{r qqplot-standardized, eval=FALSE}
sample_quantiles <- quantile(z, p)
theoretical_quantiles <- qnorm(p)
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

El código anterior se incluye para ayudar a describir los gráficos Q-Q. Sin embargo, en la práctica es más fácil usar el código **ggplot2** descrito en la Sección \@ref(other-geometries):

```{r, eval=FALSE}
heights %>% filter(sex == "Male") %>%
ggplot(aes(sample = scale(height))) +
geom_qq() +
geom_abline()
```

Mientras que para la ilustración anterior usamos 20 cuantiles, el valor por defecto de la función `geom_qq` es utilizar la misma cantidad de cuantiles como datos.

## Percentiles

Antes de continuar, definamos algunos términos que se usan comúnmente en el análisis exploratorio de datos.

_Percentiles_ son casos especiales de _cuantiles_ que se usan comúnmente. Los percentiles son los cuantiles que se obtienen al configurar el $p$ a $0.01, 0.02, ..., 0.99$. Denominamos, por ejemplo, el caso de $p=0.25$ el cuartilo inferior, ya que nos da un número para el cual el 25% de los datos están por debajo. El percentil más famoso es el 50, también conocido como la _mediana_.

Para la distribución normal, la _mediana_ y el promedio son los mismos, pero generalmente este no es el caso.

Otro caso especial que recibe un nombre son los _cuartiles_, que se obtienen al configurar $p=0.25,0.50$ y $0.75$.


## Diagramas de caja

Para presentar los diagramas de caja (_boxplots_ en inglés) volveremos a los datos de asesinatos de EE. UU..
Supongamos que queremos resumir la distribución de la tasa de asesinatos. Usando la técnica de visualización de datos que hemos aprendido, podemos ver que la aproximación normal no aplica aquí:

```{r hist-qqplot-non-normal-data, out.width = "100%", fig.width = 6, fig.height = 3, echo=FALSE}
data(murders)
murders <- murders %>% mutate(rate = total/population*100000)
library(gridExtra)
p1 <- murders %>% ggplot(aes(x=rate)) + geom_histogram(binwidth = 1) + ggtitle("Histogram")
p2 <- murders %>% ggplot(aes(sample=rate)) +
geom_qq(dparams=summarize(murders, mean=mean(rate), sd=sd(rate))) +
geom_abline() + ggtitle("QQ-plot")
grid.arrange(p1, p2, ncol = 2)
```

En este caso, el histograma anterior o un gráfico de densidad suave serviría como un resumen relativamente sucinto.

Ahora supongamos que los que están acostumbrados a recibir solo dos números como resúmenes nos piden un resumen numérico más compacto.

Aquí Tukey ofreció algunos consejos. Primero, recomendó proveer un resumen de cinco números compuestos por el rango junto con los cuartiles (los percentiles 25, 50 y 75). Además,Tukey sugirió ignorar los _valores atípicos_ cuando calculen el rango y, en su lugar, que los grafiquen como puntos independientes. Ofreceremos una explicación detallada de los valores atípicos más adelante. Finalmente, recomendó que graficáramos estos números como una "caja" con "bigotes" así:


```{r first-boxplot, echo=FALSE}
murders %>% ggplot(aes("",rate)) + geom_boxplot() +
coord_cartesian(xlim = c(0, 2)) + xlab("")
```

con el cuadro definido por los percentiles 25% y 75% y los bigotes mostrando el rango. La distancia entre estos dos se llama el rango _intercuartil_. Los dos puntos son valores atípicos según la definición de Tukey. La mediana se muestra con una línea horizontal. 

A partir de este simple gráfico, hoy conocido como un _diagrama de caja_, sabemos que la mediana es de aproximadamente 2.5, que la distribución no es simétrica y que el rango es de 0 a 5 para la gran mayoría de los estados con dos excepciones.

Discutimos cómo crear diagramas de caja en la Sección \@ref(other-geometries).

## Estratificación {#stratification}

En el análisis de datos, a menudo dividimos las observaciones en grupos según los valores de una o más variables asociadas con esas observaciones. Por ejemplo, en la siguiente sección dividimos los valores de altura en grupos según una variable de sexo: hembras y varones. Llamamos a este procedimiento _estratificación_ y nos referimos a los grupos resultantes como _estratos_.

La estratificación es común en la visualización de datos porque a menudo estamos interesados en cómo la distribución de variables difiere entre los diferentes subgrupos. Veremos varios ejemplos a lo largo de esta parte del libro. Revisaremos el concepto de estratificación cuando aprendamos regresión en el Capítulo \@ref(regression) y en la parte de _machine learning_ del libro.

## Estudio de caso: descripción de alturas de estudiantes (continuación) {#student-height-cont}

Usando el histograma, los gráficos de densidad y los gráficos Q-Q, nos hemos convencido de que los datos de altura masculina se aproximan bien con una distribución normal. En este caso, le damos a ET un resumen muy sucinto: las alturas masculinas siguen una distribución normal con un promedio de `r round(m, 1)` pulgadas y una SD de `r round(s,1)` pulgadas. Con esta información, ET tendrá una buena idea de qué esperar cuando conozca a nuestros estudiantes varones. Sin embargo, para proporcionar una imagen completa, también debemos proporcionar un resumen de las alturas femeninas.

Aprendimos que los diagramas de caja son útiles cuando queremos comparar rápidamente dos o más distribuciones. Aquí vemos las alturas para varones y hembras:

```{r female-male-boxplots, echo=FALSE}
heights %>% ggplot(aes(x=sex, y=height, fill=sex)) +
geom_boxplot()
```

El diagrama inmediatamente demuestra que los varones son, en promedio, más altos que las hembras. Las desviaciones estándar parecen ser similares. Pero, ¿la aproximación normal también funciona para los datos de altura femenina recopilados por la encuesta? Esperamos que sigan una distribución normal, al igual que los varones. Sin embargo, los gráficos exploratorios revelan que la aproximación no es tan útil:


```{r histogram-qqplot-female-heights, echo=FALSE, out.width="100%", fig.width = 6, fig.height = 3}
p1 <- heights %>% filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density(fill="#F8766D")
p2 <- heights %>% filter(sex == "Female") %>%
ggplot(aes(sample=scale(height))) +
geom_qq() + geom_abline() + ylab("Standard Units")
grid.arrange(p1, p2, ncol=2)
```

Vemos algo que no observamos para los varones: el gráfico de densidad tiene una segunda protuberancia. Además, el gráfico Q-Q muestra que los puntos más altos tienden a ser más altos de lo esperado por la distribución normal. Finalmente, también vemos cinco puntos en el gráfico Q-Q que sugieren alturas más bajas de lo esperado para una distribución normal. Al nuevamente informar a ET, es posible que necesitemos proporcionar un histograma en lugar de solo el promedio y la desviación estándar para las alturas femeninas.

Sin embargo, leemos de nuevo la cita de Tukey y nos damos cuenta de que hemos notado lo que no esperábamos ver. Si observamos otras distribuciones de altura femenina, encontramos que están bien aproximadas con una distribución normal. Entonces, ¿por qué nuestras alumnas son diferentes? ¿Es nuestra clase un requisito para el equipo femenino de baloncesto? ¿Hay una proporción pequeña de mujeres que dicen ser más altas de lo que son? Otra explicación, quizás más probable, es que en el formulario en que los estudiantes ingresaron sus alturas, `FEMALE` era el sexo predeterminado y algunos varones ingresaron a sus alturas, pero olvidaron cambiar la variable de sexo. En cualquier caso, la visualización de datos ha ayudado a descubrir una posible falla en nuestros datos.

Con respecto a los cinco valores más pequeños, noten que estos valores son:
```{r}
heights %>% filter(sex == "Female") %>%
top_n(5, desc(height)) %>%
pull(height)
```

Debido a que estas son alturas autoreportadas, una posibilidad es que las estudiantes quisieron ingresar `5'1"`, `5'2"`, `5'3"` o `5'5"`.


## Ejercicios

1\. Defina variables que contengan las alturas de varones y hembras de esta manera:

```{r, eval=FALSE}
library(dslabs)
data(heights)
male <- heights$height[heights$sex == "Male"]
female <- heights$height[heights$sex == "Female"]
```

¿Cuántas medidas tenemos para cada una?


2\. Supongamos que no podemos hacer un gráfico y queremos comparar las distribuciones una al lado de otra. No podemos simplemente enumerar todos los números. En cambio, veremos los percentiles. Cree una tabla de cinco filas que muestre `female_percentiles` y `male_percentiles` con los percentiles 10, 30, 50, ..., 90 para cada sexo. Luego cree un _data frame_ con estos dos como columnas.


3\. Estudie los siguientes diagramas de caja que muestran los tamaños de población por país:

```{r boxplot-exercise, echo=FALSE, message=FALSE}
library(tidyverse)
library(dslabs)
ds_theme_set()
data(gapminder)
tab <- gapminder %>% filter(year == 2010) %>% group_by(continent) %>% select(continent, population)
tab %>% ggplot(aes(x=continent, y=population/10^6)) +
geom_boxplot() +
scale_y_continuous(trans = "log10", breaks = c(1,10,100,1000)) + ylab("Population in millions")
```

¿Qué continente tiene el país con el mayor tamaño de población?

4\. ¿Qué continente tiene la mediana de tamaño poblacional más grande?


5\. ¿Cuál es la mediana del tamaño poblacional de África al millón más cercano?


6\. ¿Qué proporción de países en Europa tienen poblaciones  menos de 14 millones?

a. 0.99
b. 0.75
c. 0.50
d. 0.25

7\. Si utilizamos una transformación logarítmica, ¿qué continente de los de arriba tiene el mayor rango intercuartil?

8\. Cargue el set de datos de altura y cree un vector `x` con solo las alturas masculinas:

```{r, eval=FALSE}
library(dslabs)
data(heights)
x <- heights$height[heights$sex=="Male"]
```

¿Qué proporción de los datos está entre 69 y 72 pulgadas (más alto que 69, pero más corto o igual a 72)? Sugerencia: use un operador lógico y `mean`.

9\. Supongamos que todo lo que sabe sobre los datos es el promedio y la desviación estándar. Use la aproximación normal para estimar la proporción que acaba de calcular. Sugerencia: comience calculando el promedio y la desviación estándar. Luego use la  función `pnorm` para predecir las proporciones.

10\. Observe que la aproximación calculada en la pregunta nueve está muy cerca del cálculo exacto en la primera pregunta. Ahora realice la misma tarea para valores más atípicos. Compare el cálculo exacto y la aproximación normal para el intervalo (79,81]. ¿Cuántas veces mayor es la proporción real que la aproximación?

11\. Aproxime la distribución de hombres adultos en el mundo como distribución normal con un promedio de 69 pulgadas y una desviación estándar de 3 pulgadas. Usando esta aproximación, calcule la proporción de hombres adultos que miden 7 pies de alto o más, conocidos como _seven footers_. Sugerencia: use la función `pnorm`.

12\. Hay alrededor de mil millones de hombres entre las edades de 18 y 40 en el mundo. Use su respuesta a la pregunta anterior para estimar cuántos de estos hombres (de 18 a 40 años) miden siete pies de altura o más en el mundo.

13\. Hay alrededor de 10 jugadores de la Asociación Nacional de Baloncesto (NBA) que miden 7 pies de altura o más. Usando la respuesta a las dos preguntas anteriores, ¿qué proporción de los _seven footers_, de 18 a 40 años, del mundo están en la NBA?

14\. Repita los cálculos realizados en la pregunta anterior para la altura de Lebron James: 6 pies y 8 pulgadas. Hay alrededor de 150 jugadores que son al menos tan altos.

15\. Al responder a las preguntas anteriores, descubrimos que no es raro que un jugador de siete pies se convierta en jugador de la NBA. Entonces, ¿que sería una crítica justa de nuestros cálculos?

a. La práctica y el talento son los que hacen a un gran jugador de baloncesto, no la altura.
b. La aproximación normal no es apropiada para alturas.
c. Como se observa en la pregunta 10, la aproximación normal tiende a subestimar los valores atípicos. Es posible que haya más _seven footers_ de lo que predijimos.
d. Como se observa en la pregunta 10, la aproximación normal tiende a sobreestimar los valores atípicos. Es posible que haya menos _seven footers_ de lo que predijimos.

## Geometrías ggplot2 {#other-geometries}

En el capitulo \@ref(ggplot2), presentamos el paquete __ggplot2__ para la visualización de datos. Aquí demostramos cómo generar gráficos relacionados con distribuciones, específicamente los gráficos que se muestran anteriormente en este capítulo.

### Diagramas de barras

Para generar un diagrama de barras (_barplots_ en inglés) podemos usar la geometría `geom_bar`. Por defecto, R cuenta los casos en cada categoría y dibuja una barra. Aquí está el diagrama de barras para las regiones de Estados Unidos.

```{r barplot-geom}
murders %>% ggplot(aes(region)) + geom_bar()
```

A menudo ya tenemos una tabla con una distribución que queremos presentar como diagrama de barras. Aquí tenemos un ejemplo de tal tabla:

```{r}
data(murders)
tab <- murders %>%
count(region) %>%
mutate(proportion = n/sum(n))
tab
```

Ya no queremos que `geom_bar` cuente, sino simplemente grafique una barra a la altura proporcionada por la variable `proportion`. Para esto necesitamos proveer `x` (las categorías) y `y` (los valores) y usar la opción `stat="identity"`.

```{r region-freq-barplot}
tab %>% ggplot(aes(region, proportion)) + geom_bar(stat = "identity")
```

### Histogramas

Para generar histogramas utilizamos `geom_histogram`. Al revisar la página de ayuda para esta función, vemos que el único argumento requerido es `x`, la variable para la cual construiremos un histograma. No usamos la `x` porque sabemos que es el primer argumento.
El código se ve así:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram()
```

Si ejecutamos el código anterior, nos da un mensaje:

> `stat_bin()` utilizando `bins = 30`. Elija un mejor valor con
`binwidth`.

Anteriormente utilizamos un tamaño de compartimiento de 1 pulgada, por lo que el código se ve así:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1)
```

Finalmente, si por razones estéticas queremos agregar color, usamos los argumentos descritos en la página de ayuda. También añadimos etiquetas y un título:

```{r height-histogram-geom}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, fill = "blue", col = "black") +
xlab("Male heights in inches") +
ggtitle("Histogram")
```

### Gráficos de densidad

Para crear una densidad suave, usamos `geom_density`. Para hacer un gráfico de densidad suave con los datos que anteriormente visualizamos como un histograma, podemos usar este código:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density()
```

Para rellenar con color, podemos usar el argumento `fill`.

```{r ggplot-density}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density(fill="blue")
```

Para cambiar la suavidad de la densidad, utilizamos el argumento `adjust` para multiplicar el valor por defecto por ese `adjust`. Por ejemplo, si queremos que el parámetro de suavizado sea el doble de grande, usamos:

```{r eval = FALSE}
heights %>%
filter(sex == "Female") +
geom_density(fill="blue", adjust = 2)
```

### Diagramas de caja

La geometría para crear diagramas de caja es `geom_boxplot`. Como ya hemos discutido, los diagramas de caja son útiles para comparar distribuciones. Por ejemplo, a continuación se muestran las alturas mostradas anteriormente para las mujeres, pero aquí en comparación con los hombres. Para esta geometría, necesitamos los argumentos `x` como las categorías y los argumentos `y` como los valores:

```{r female-male-boxplots-geom, echo=FALSE}
heights %>% ggplot(aes(sex, height)) +
geom_boxplot()
```

### Gráficos Q-Q

Para gráficos Q-Q usamos la geometría `geom_qq`. De la página de ayuda, aprendemos que necesitamos especificar el `sample` (aprenderemos sobre _samples_ en un capítulo posterior). Aquí está el gráfico Q-Q para alturas de varones:

```{r ggplot-qq}
heights %>% filter(sex=="Male") %>%
ggplot(aes(sample = height)) +
geom_qq()
```

Por defecto, la variable muestral se compara con una distribución normal con un promedio de 0 y una desviación estándar de 1. Para cambiar esto, utilizamos el argumento `dparams` según la página de ayuda. Para agregar una línea de identidad simplemente asignen otra capa. Para líneas rectas, usamos la función `geom_abline`. La línea por defecto es la línea de identidad (pendiente = 1, intercepto = 0).

```{r ggplot-qq-dparams, eval=FALSE}
params <- heights %>% filter(sex=="Male") %>%
summarize(mean = mean(height), sd = sd(height))

heights %>% filter(sex=="Male") %>%
ggplot(aes(sample = height)) +
geom_qq(dparams = params) +
geom_abline()
```

Otra opción aquí es escalar los datos primero y luego hacer un gráfico Q-Q contra el estándar normal.

```{r ggplot-qq-standard-units, eval=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(sample = scale(height))) +
geom_qq() +
geom_abline()
```

### Imágenes

No hemos necesitado utilizar imágenes para los conceptos descritos en este capítulo, pero los usaremos en la Sección \@ref(vaccines), así que presentamos las dos geometrías utilizadas para crear imágenes: __geom_tile__ y __geom_raster__. Se comportan de manera similar; para ver cómo difieren, consulten la página de ayuda. Para crear una imagen en __ggplot2__, necesitamos un _data frame_ con las coordenadas x e y, así como los valores asociados con cada uno de estos. Aquí tenemos un _data frame_:

```{r}
x <- expand.grid(x = 1:12, y = 1:10) %>%
mutate(z = 1:120)
```

Tengan en cuenta que esta es la versión _tidy_ de una matriz, `matrix(1:120, 12, 10)`. Para graficar la imagen, usamos el siguiente código:

```{r, eval=FALSE}
x %>% ggplot(aes(x, y, fill = z)) +
geom_raster()
```

Con estas imágenes, a menudo querrán cambiar la escala de color. Esto se puede hacer a través de la capa `scale_fill_gradientn`.

```{r ggplot2-image-new-colors}
x %>% ggplot(aes(x, y, fill = z)) +
geom_raster() +
scale_fill_gradientn(colors = terrain.colors(10))
```



### Gráficos rápidos

En la sección \@ref(qplot) presentamos `qplot` como una función útil cuando necesitamos hacer un diagrama de dispersión rápido. También podemos usar `qplot` para hacer histogramas, diagramas de densidad, diagramas de caja, gráficos Q-Q y más. Aunque no provee el nivel de control de `ggplot`, `qplot` es definitivamente útil, ya que nos permite hacer un gráfico con un pequeño fragmento de código.

Supongamos que tenemos las alturas femeninas en un objeto `x`:

```{r}
x <- heights %>%
filter(sex=="Male") %>%
pull(height)
```

Para hacer un histograma rápido podemos usar:

```{r qplot-example-1, warning=FALSE, message=FALSE, eval=FALSE}
qplot(x)
```

La función adivina que queremos hacer un histograma porque solo proveemos una variable. En la sección \@ref(qplot) vimos que si le proporcionamos dos variables a `qplot` , automáticamente crea un diagrama de dispersión.

Para hacer un gráfico Q-Q rápido, tienen que usar el argumento `sample`. Recuerden que podemos agregar capas tal como lo hacemos con `ggplot`.

```{r qplot-example-2, eval=FALSE}
qplot(sample = scale(x)) + geom_abline()
```


Si proveemos un factor y un vector numérico, obtenemos un gráfico como el que vemos abajo. Tengan en cuenta que en el código estamos utilizando el argumento `data`. Como el _data frame_ no es el primer argumento en `qplot`, tenemos que usar el operador de punto.

```{r qplot-example-3, eval=FALSE}
heights %>% qplot(sex, height, data = .)
```

También podemos seleccionar una geometría específica mediante el uso del argumento `geom`. Entonces, para convertir el diagrama anterior en un diagrama de caja, usamos el siguiente código:

```{r qplot-example-4, eval=FALSE}
heights %>% qplot(sex, height, data = ., geom = "boxplot")
```

También podemos usar el  argumento `geom` para generar un gráfico de densidad en lugar de un histograma:

```{r qplot-example-5, eval=FALSE}
qplot(x, geom = "density")
```

Aunque no tanto como con `ggplot`, tenemos cierta flexibilidad para mejorar los resultados de `qplot`. Mirando el archivo de ayuda, vemos varias formas en que podemos mejorar el aspecto del histograma anterior. Por ejemplo:

```{r qplot-example-6}
qplot(x, bins=15, color = I("black"), xlab = "Population")
```

**Nota técnica**: La razón por la que usamos `I("black")` es porque queremos que `qplot` trate `"black"` como un carácter en lugar de convertirlo en un factor. Este es el comportamiento por defecto dentro de `aes`, que se llama internamente aquí. En general, la función `I` se usa en R para decir "manténgalo como está".




## Ejercicios


1\. Ahora vamos a usar la función `geom_histogram` para hacer un histograma de las alturas en el set de datos `height`. Al leer la documentación para esta función, vemos que requiere solo una asignación, los valores que se utilizarán para el histograma. Haz un histograma de todas los gráficos.

¿Cuál es la variable que contiene las alturas?

a. `sex`
b. `heights`
c. `height`
d. `heights$height`

2\. Ahora cree un objeto ggplot usando el _pipe_ para asignar los datos de altura a un objeto ggplot. Asigne `height` a los valores de x a través de la función `aes`.

3\. Ahora estamos listos para agregar una capa para hacer el histograma. Utilice el objeto creado en el ejercicio anterior y la función `geom_histogram` para hacer el histograma.

4\. Tenga en cuenta que cuando ejecutamos el código en el ejercicio anterior recibimos la advertencia:
`stat_bin()` utilizando `bins = 30`. Elija un mejor valor con `binwidth`.`

Utilice el argumento `binwidth` para cambiar el histograma creado en el ejercicio anterior para usar compartimientos de tamaño de 1 pulgada.

5\. En lugar de un histograma, vamos a hacer un gráfico de densidad suave. En este caso, no crearemos un objeto, sino haremos y mostraremos el gráfico con una línea de código. Cambie la geometría en el código utilizado anteriormente para hacer una densidad suave en lugar de un histograma.

6\. Ahora vamos a hacer un gráfico de densidad para varones y hembras por separado. Podemos hacer esto usando el argumento `group`. Asignamos grupos a través del mapeo estético, ya que cada punto necesita un grupo antes de hacer los cálculos necesarios para estimar una densidad.

7\. También podemos asignar grupos a través del argumento `color`. Esto tiene el beneficio adicional de que utiliza el color para distinguir los grupos. Cambie el código anterior para usar color.

8\. Además podemos asignar grupos a través del argumento `fill`. Esto tiene el beneficio adicional de que usa colores para distinguir los grupos así:


```{r, eval=FALSE}
heights %>%
ggplot(aes(height, fill = sex)) +
geom_density()
```

Sin embargo, aquí la segunda densidad se traza sobre la otra. Podemos hacer que las curvas sean más visibles mediante el uso de _alpha blending_ para agregar transparencia. Establezca el parámetro alfa a 0.2 en la función `geom_density` para hacer este cambio.








