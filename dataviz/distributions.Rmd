# Visualizar distribuciones de datos {#distributions}

Es posible que haya notado que los datos numéricos a menudo se resumen con el valor _average_. Por ejemplo, la calidad de una escuela secundaria a veces se resume con un número: el puntaje promedio en una prueba estandarizada. Ocasionalmente, se informa un segundo número: la _desviación estándar_. Por ejemplo, puede leer un informe que indique que las puntuaciones fueron 680 más o menos 50 (la desviación estándar). El informe ha resumido un vector completo de puntajes con solo dos números. ¿Es esto apropiado? ¿Hay alguna información importante que nos falta al mirar este resumen en lugar de la lista completa?

Nuestro primer componente básico de visualización de datos es aprender a resumir listas de factores o vectores numéricos. La mayoría de las veces, la mejor manera de compartir o explorar este resumen es a través de la visualización de datos. El resumen estadístico más básico de una lista de objetos o números es su distribución. Una vez que un vector se ha resumido como una distribución, existen varias técnicas de visualización de datos para transmitir esta información de manera efectiva.

En este capítulo, primero discutimos las propiedades de una variedad de distribuciones y cómo visualizar las distribuciones usando un ejemplo motivador de las alturas de los estudiantes. Luego discutimos las geometrías __ggplot2__ para estas visualizaciones en la Sección \@ref(other-geometries).


## Tipos de variables

Trabajaremos con dos tipos de variables: categóricas y numéricas. Cada uno puede dividirse en otros dos grupos: los categóricos pueden ser ordinales o no, mientras que las variables numéricas pueden ser discretas o continuas.

Cuando cada entrada en un vector proviene de uno de un pequeño número de grupos, nos referimos a los datos como _categorical data_. Dos ejemplos simples son el sexo (masculino o femenino) y las regiones (noreste, sur, norte central, oeste). Algunos datos categóricos se pueden ordenar incluso si no son números en sí, como picante (leve, medio, picante). En los libros de texto de estadísticas, los datos categóricos ordenados se denominan datos _ordinales_.

Ejemplos de datos numéricos son el tamaño de la población, las tasas de asesinatos y las alturas. Algunos datos numéricos pueden tratarse como ordenados categóricos. Podemos dividir aún más los datos numéricos en continuos y discretos. Las variables continuas son aquellas que pueden tomar cualquier valor, como las alturas, si se miden con suficiente precisión. Por ejemplo, un par de gemelos puede tener 68.12 y 68.11 pulgadas, respectivamente. Los recuentos, como el tamaño de la población, son discretos porque tienen que ser números redondos.

Tenga en cuenta que los datos numéricos discretos pueden considerarse ordinales. Aunque esto es técnicamente cierto, generalmente reservamos el término datos ordinales para variables que pertenecen a un pequeño número de grupos diferentes, y cada grupo tiene muchos miembros. En contraste, cuando tenemos muchos grupos con pocos casos en cada grupo, generalmente nos referimos a ellos como variables numéricas discretas. Entonces, por ejemplo, el número de paquetes de cigarrillos que una persona fuma al día, redondeado al paquete más cercano, se consideraría ordinal, mientras que el número real de cigarrillos se consideraría una variable numérica. Pero, de hecho, hay ejemplos que pueden considerarse tanto numéricos como ordinales cuando se trata de visualizar datos.

## Estudio de caso: descripción de las alturas de los estudiantes

Aquí presentamos un nuevo problema motivador. Es artificial, pero nos ayudará a ilustrar los conceptos necesarios para comprender las distribuciones.

Finja que tenemos que describir las alturas de nuestros compañeros de clase a ET, un extraterrestre que nunca ha visto humanos. Como primer paso, necesitamos recopilar datos. Para hacer esto, les pedimos a los estudiantes que informen sus alturas en pulgadas. Les pedimos que proporcionen información sobre el sexo porque sabemos que hay dos distribuciones diferentes por sexo. Recopilamos los datos y los guardamos en el `heights` marco de datos:

```{r load-heights, warning=FALSE, message=FALSE}
library(tidyverse)
library(dslabs)
data(heights)
```

Una forma de transmitir las alturas a ET es simplemente enviarle esta lista de `r nrow(heights)` alturas Pero hay formas mucho más efectivas de transmitir esta información, y comprender el concepto de distribución ayudará. Para simplificar la explicación, primero nos enfocamos en las alturas masculinas. Examinamos los datos de altura femenina en la Sección \@ref(student-height-cont).

## Función de distribución

Resulta que, en algunos casos, el promedio y la desviación estándar son prácticamente todo lo que necesitamos para comprender los datos. Aprenderemos técnicas de visualización de datos que nos ayudarán a determinar cuándo este resumen de dos números es apropiado. Estas mismas técnicas servirán como una alternativa para cuando dos números no son suficientes.

El resumen estadístico más básico de una lista de objetos o números es su distribución. La forma más sencilla de pensar en una distribución es como una descripción compacta de una lista con muchas entradas. Este concepto no debería ser nuevo para los lectores de este libro. Por ejemplo, con datos categóricos, la distribución simplemente describe la proporción de cada categoría única. El sexo representado en el conjunto de datos de alturas es:

```{r echo = FALSE}
prop.table(table(heights$sex))
```

Esta tabla de frecuencia de dos categorías es la forma más simple de una distribución. Realmente no necesitamos visualizarlo ya que un número describe todo lo que necesitamos saber: `r round(mean(heights$sex=="Female")*100)`% son mujeres y el resto son hombres. Cuando hay más categorías, un diagrama de barras simple describe la distribución. Aquí hay un ejemplo con las regiones estatales de EE. UU .:

```{r state-region-distribution, echo=FALSE}
murders %>% group_by(region) %>%
summarize(n = n()) %>%
mutate(Proportion = n/sum(n),
region = reorder(region, Proportion)) %>%
ggplot(aes(x=region, y=Proportion, fill=region)) +
geom_bar(stat = "identity", show.legend = FALSE) +
xlab("")
```

Este gráfico en particular simplemente nos muestra cuatro números, uno para cada categoría. Usualmente usamos gráficos de barras para mostrar algunos números. Aunque este gráfico en particular no proporciona mucha más información que una tabla de frecuencias en sí, es un primer ejemplo de cómo convertimos un vector en un gráfico que resume de manera sucinta toda la información en el vector. Cuando los datos son numéricos, la tarea de mostrar distribuciones es más desafiante.

## Funciones de distribución acumulativa {#cdf-intro}

Los datos numéricos que no son categóricos también tienen distribuciones. En general, cuando los datos no son categóricos, informar la frecuencia de cada entrada no es un resumen efectivo, ya que la mayoría de las entradas son únicas. En nuestro estudio de caso, mientras varios estudiantes reportaron una altura de 68 pulgadas, solo un estudiante reportó una altura de `68.503937007874` pulgadas y solo un estudiante informó una altura `68.8976377952756` pulgadas. Suponemos que se convirtieron de 174 y 175 centímetros, respectivamente.

Los libros de texto de estadísticas nos enseñan que una forma más útil de definir una distribución de datos numéricos es definir una función que informe la proporción de los datos a continuación $a$ para todos los valores posibles de $a$. Esta función se llama función de distribución acumulativa (CDF). En estadística, se usa la siguiente notación:

$$ F(a) = \mbox{Pr}(x \leq a) $$

Aquí hay una trama de $F$ para los datos de estatura masculina:

```{r ecdf, echo=FALSE}
ds_theme_set()
heights %>% filter(sex=="Male") %>% ggplot(aes(height)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Similar a lo que hace la tabla de frecuencias para datos categóricos, el CDF
define la distribución de datos numéricos. De la trama, podemos ver que `r round(ecdf(heights$height[heights$sex == "Male"]) (66) * 100) `% de los valores están por debajo de 65, ya que $F(66)=$ `r ecdf(heights$height[heights$sex == "Male"])(66) `, or that ` r round(ecdf (heights$height[heights$sex == "Male"])(72) * 100) `% de los valores están por debajo de 72, ya que $F(72)=$ `r ecdf(heights$height[heights$sex == "Male"]) (72) `,
y así. De hecho, podemos informar la proporción de valores entre dos alturas, digamos $a$ y $b$, por computación $F(b) - F(a)$. Esto significa que si enviamos este diagrama a ET, él tendrá toda la información necesaria para reconstruir la lista completa. Parafraseando la expresión "una imagen vale más que mil palabras", en este caso, una imagen es tan informativa como `r sum(heights$sex=="Male")` números.

Una nota final: debido a que los CDF pueden definirse matemáticamente, la palabra _empirical_ se agrega para hacer la distinción cuando se usan los datos. Por lo tanto, utilizamos el término empírico CDF (eCDF).


## Histogramas

Aunque el concepto CDF se discute ampliamente en los libros de texto de estadística, la trama en realidad no es muy popular en la práctica. La razón principal es que no transmite fácilmente características de interés como: ¿en qué valor se centra la distribución? ¿La distribución es simétrica? ¿Qué rangos contienen el 95% de los valores? Los histogramas son muy preferidos porque facilitan enormemente la respuesta a tales preguntas. Los histogramas sacrifican solo un poco de información para producir gráficos que son mucho más fáciles de interpretar.

La forma más sencilla de hacer un histograma es dividir el alcance de nuestros datos en contenedores no superpuestos del mismo tamaño. Luego, para cada bin, contamos el número de valores que se encuentran en ese intervalo. El histograma traza estos recuentos como barras con la base de la barra definida por los intervalos. Aquí está el histograma para los datos de altura que dividen el rango de valores en intervalos de una pulgada: $[49.5, 50.5], [51.5,52.5],(53.5,54.5],...,(82.5,83.5]$

```{r height-histogram, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, color = "black")
```

Como puede ver en la figura anterior, un histograma es similar a un diagrama de barras, pero difiere en que el eje x es numérico, no categórico.

Si enviamos este diagrama a ET, él aprenderá de inmediato algunas propiedades importantes sobre nuestros datos. Primero, el rango de datos es de 50 a 84 con la mayoría (más del 95%) entre 63 y 75 pulgadas. En segundo lugar, las alturas son casi simétricas alrededor de 69 pulgadas. Además, al sumar conteos, ET podría obtener una muy buena aproximación de la proporción de los datos en cualquier intervalo. Por lo tanto, el histograma anterior no solo es fácil de interpretar, sino que también proporciona casi toda la información contenida en la lista cruda de `r sum(heights$sex=="Male")` alturas con aproximadamente 30 conteos de basura.

¿Qué información perdemos? Tenga en cuenta que todos los valores en cada intervalo se tratan de la misma manera cuando se calculan las alturas del contenedor. Entonces, por ejemplo, el histograma no distingue entre 64, 64.1 y 64.2 pulgadas. Dado que estas diferencias son casi imperceptibles a la vista, las implicaciones prácticas son insignificantes y pudimos resumir los datos a solo 23 números.

Discutimos cómo codificar histogramas en la Sección \@ref(other-geometries).

## Densidad suavizada

Las gráficas de densidad suave son estéticamente más atractivas que los histogramas. Así es como se ve un gráfico de densidad uniforme para nuestros datos de altura:

```{r example-of-smoothed-density, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha = .2, fill= "#00BFC4", color = 0) +
geom_line(stat='density')
```

En este gráfico, ya no tenemos bordes afilados en los límites de intervalo y muchos de los picos locales se han eliminado. Además, la escala del eje y cambió de conteos a _densidad_.

Para comprender las densidades suaves, tenemos que entender las estimaciones, un tema que no cubrimos hasta más tarde. Sin embargo, proporcionamos una explicación heurística para ayudarlo a comprender los conceptos básicos para que pueda utilizar esta útil herramienta de visualización de datos.

El nuevo concepto principal que debe comprender es que suponemos que nuestra lista de valores observados es un subconjunto de una lista mucho más grande de valores no observados. En el caso de las alturas, puedes imaginar que nuestra lista de `r sum(heights$sex=="Male")` los estudiantes varones provienen de una lista hipotética que contiene todas las alturas de todos los estudiantes varones en todo el mundo, medidos con mucha precisión. Digamos que hay 1,000,000 de estas medidas. Esta lista de valores tiene una distribución, como cualquier lista de valores, y esta distribución más grande es realmente lo que queremos informar a ET, ya que es mucho más general. Desafortunadamente, no podemos verlo.

Sin embargo, hacemos una suposición que nos ayuda quizás a aproximarnos. Si tuviéramos 1,000,000 de valores, medidos con mucha precisión, podríamos hacer un histograma con contenedores muy, muy pequeños. La suposición es que si mostramos esto, la altura de los contenedores consecutivos será similar. Esto es lo que queremos decir con suave: no tenemos grandes saltos en las alturas de los contenedores consecutivos. A continuación tenemos un histograma hipotético con contenedores de tamaño 1:


```{r simulated-data-histogram-1, echo=FALSE}
set.seed(1988)
x <- data.frame(height = c(rnorm(1000000,69,3), rnorm(1000000,65,3)))
x %>% ggplot(aes(height)) + geom_histogram(binwidth = 1, color = "black")
```

Cuanto más pequeños hacemos los contenedores, más suave se vuelve el histograma. Aquí están los histogramas con ancho de bin de 1, 0.5 y 0.1:

```{r simulated-data-histogram-2, fig.width=9, fig.height=3, out.width = "100%",echo=FALSE, message=FALSE}
p1 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 1, color = "black") + ggtitle("binwidth=1")
p2 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 0.5, color="black") + ggtitle("binwidth=0.5")
p3 <- x %>% ggplot(aes(height)) + geom_histogram(binwidth = 0.1) + ggtitle("binwidth=0.1")
library(gridExtra)
grid.arrange(p1, p2, p3, nrow = 1)
```

La densidad suave es básicamente la curva que atraviesa la parte superior de las barras de histograma cuando los contenedores son muy, muy pequeños. Para que la curva no dependa del tamaño hipotético de la lista hipotética, calculamos la curva en frecuencias en lugar de conteos:

```{r, simulated-density-1, echo=FALSE}
x %>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 0.1, color = I("black")) +
geom_line(stat='density')
```

Ahora, de vuelta a la realidad. No tenemos millones de medidas. En cambio, tenemos `r sum(heights$sex=="Male")` y no podemos hacer un histograma con contenedores muy pequeños.

Por lo tanto, hacemos un histograma, utilizando tamaños de bin apropiados para nuestros datos y frecuencias de cómputo en lugar de conteos, y dibujamos una curva suave que pasa por la parte superior de las barras de histograma. Los siguientes gráficos muestran los pasos que conducen a una densidad uniforme:

```{r smooth-density-2, echo=FALSE, out.width = "100%"}
hist1 <- heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, color="black")
hist2 <- hist1 +
geom_line(stat='density')
hist3 <- hist1 +
geom_point(data = ggplot_build(hist2)$data[[1]], aes(x,y), col = "blue")
hist4 <- ggplot() + geom_point(data = ggplot_build(hist2)$data[[1]], aes(x,y), col = "blue") +
xlab("height") + ylab("density")
hist5 <- hist4 + geom_line(data = ggplot_build(hist2)$data[[2]], aes(x,y))
hist6 <- heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha = 0.2, fill="#00BFC4", col = 0) +
geom_line(stat='density') +
scale_y_continuous(limits = layer_scales(hist2)$y$range$range)

grid.arrange(hist1, hist3, hist4, hist5, hist2, hist6, nrow=2)
```

Sin embargo, recuerde que _smooth_ es un término relativo. De hecho, podemos controlar la suavidad de la curva que define la densidad uniforme a través de una opción en la función que calcula la curva de densidad uniforme. Aquí hay dos ejemplos que usan diferentes grados de suavidad en el mismo histograma:


```{r densities-different-smoothness, echo = FALSE, out.width = "100%", fig.width = 6, fig.height = 3}
p1 <- heights %>%
filter(sex=="Male")%>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, alpha = 0.5) +
geom_line(stat='density', adjust = 0.5)

p2 <- heights %>%
filter(sex=="Male") %>% ggplot(aes(height)) +
geom_histogram(aes(y=..density..), binwidth = 1, alpha = 0.5) +
geom_line(stat='density', adjust = 2)

grid.arrange(p1,p2, ncol=2)
```
Necesitamos tomar esta decisión con cuidado ya que las visualizaciones resultantes pueden cambiar nuestra interpretación de los datos. Debemos seleccionar un grado de suavidad que podamos defender como representativo de los datos subyacentes. En el caso de la altura, realmente tenemos razones para creer que la proporción de personas con alturas similares debería ser la misma. Por ejemplo, la proporción que es 72 pulgadas debería ser más similar a la proporción que es 71 que a la proporción que es 78 o 65. Esto implica que la curva debe ser bastante suave; es decir, la curva debería parecerse más al ejemplo de la derecha que a la izquierda.

Si bien el histograma es un resumen sin supuestos, la densidad suavizada se basa en algunos supuestos.

### Interpretando el eje y

Tenga en cuenta que interpretar el eje y de un gráfico de densidad uniforme no es sencillo. Se escala para que el área bajo la curva de densidad se sume a 1. Si imagina que formamos un contenedor con una base de 1 unidad de longitud, el valor del eje y nos indica la proporción de valores en ese contenedor. Sin embargo, esto solo es cierto para contenedores de tamaño 1. Para otros intervalos de tamaño, la mejor manera de determinar la proporción de datos en ese intervalo es calculando la proporción del área total contenida en ese intervalo. Por ejemplo, aquí están la proporción de valores entre 65 y 68:

```{r area-under-curve, echo=FALSE}
d <- with(heights, density(height[sex=="Male"]))
tmp <- data.frame(height=d$x, density=d$y)
tmp %>% ggplot(aes(height,density)) + geom_line() +
geom_area(aes(x=height,y=density), data = filter(tmp, between(height, 65, 68)), alpha=0.2, fill="#00BFC4")
```

La proporción de esta área es aproximadamente
`r round (mean (dplyr :: between (heights $height[heights$ sexo == "Masculino"], 65, 68)), 2) `,
lo que significa que aproximadamente esa proporción es entre 65 y 68 pulgadas.

Al comprender esto, estamos listos para usar la densidad uniforme como resumen. Para este conjunto de datos, nos sentiríamos bastante cómodos con el supuesto de suavidad y, por lo tanto, al compartir esta figura estéticamente agradable con ET, que podría usar para comprender nuestros datos de alturas masculinas:

```{r example-of-smoothed-density-2, echo=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(height)) +
geom_density(alpha=.2, fill= "#00BFC4", color = 0) +
geom_line(stat='density')
```


### Las densidades permiten la estratificación

Como nota final, señalamos que una ventaja de las densidades suaves sobre los histogramas para fines de visualización es que las densidades facilitan la comparación de dos distribuciones. Esto se debe en gran parte a que los bordes irregulares del histograma agregan desorden. Aquí hay un ejemplo que compara las alturas masculinas y femeninas:

```{r two-densities-one-plot, echo=FALSE}
heights %>%
ggplot(aes(height, fill=sex)) +
geom_density(alpha = 0.2, color = 0) +
geom_line(stat='density')
```

Con el argumento correcto, `ggplot` sombrea automáticamente la región de intersección con un color diferente. Mostraremos ejemplos de código __ggplot2__ para densidades en la Sección \@ref(gapminder) así como Sección \@ref(other-geometries).


## Ejercicios


1\. En el `murders` conjunto de datos, la región es una variable categórica y la siguiente es su distribución:

```{r barplot-exercise, echo=FALSE}
library(dslabs)
ds_theme_set()
data(murders)
murders %>% group_by(region) %>%
summarize(n = n()) %>%
mutate(Proportion = n/sum(n),
region = reorder(region, Proportion)) %>%
ggplot(aes(x=region, y=Proportion, fill=region)) +
geom_bar(stat = "identity", show.legend = FALSE) +
xlab("")
```

Al 5% más cercano, ¿qué proporción de los estados se encuentran en la región Centro Norte?



2\. Cual de los siguientes es verdadero:

a. El gráfico de arriba es un histograma.
si. El gráfico anterior muestra solo cuatro números con un diagrama de barras.
c. Las categorías no son números, por lo que no tiene sentido graficar la distribución.
re. Los colores, no la altura de las barras, describen la distribución.

3\. La siguiente gráfica muestra el eCDF para las alturas masculinas:


```{r ecdf-exercise, echo=FALSE}
heights %>% filter(sex == "Male") %>% ggplot(aes(height)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Según el gráfico, ¿qué porcentaje de hombres son más cortos que 75 pulgadas?

a. 100%
si. 95%
c. 80%
re. 72 pulgadas


4\. A la pulgada más cercana, qué altura `m` tiene la propiedad de que la mitad de los estudiantes varones son más altos que `m` y 1/2 son más cortos?

a. 61 pulgadas
si. 64 pulgadas
c. 69 pulgadas
re. 74 pulgadas

5\. Aquí hay un eCDF de las tasas de asesinatos en todos los estados:

```{r ecdf-exercise-2, echo=FALSE}
murders %>% mutate(murder_rate = total/population * 10^5) %>%
ggplot(aes(murder_rate)) +
stat_ecdf() +
ylab("F(a)") + xlab("a")
```

Sabiendo que hay 51 estados (contando DC) y en base a esta trama, ¿cuántos estados tienen tasas de homicidio superiores a 10 por cada 100,000 personas?

a. 1
si. 5 5
c. 10
re. 50


6\. Según el eCDF anterior, cuál de las siguientes afirmaciones es verdadera:

a. Alrededor de la mitad de los estados tienen tasas de homicidios superiores a 7 por 100.000 y la otra mitad a continuación.
si. La mayoría de los estados tienen tasas de homicidio por debajo de 2 por 100,000.
c. Todos los estados tienen tasas de asesinatos superiores a 2 por 100,000.
re. Con la excepción de 4 estados, las tasas de asesinatos son inferiores a 5 por cada 100,000.


7\. A continuación se muestra un histograma de alturas masculinas en nuestro `heights` conjunto de datos:

```{r height-histogram-exercise, echo=FALSE}
heights %>%
filter(sex == "Male") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, color = "black")
```

Según esta gráfica, ¿cuántos hombres hay entre 63.5 y 65.5?

a. 10
si. 24
c. 34
re. 100

8\. ¿Aproximadamente qué **porcentaje** son más cortos que 60 pulgadas?

a. 1%
si. 10%
c. 25%
re. 50%

9\. Según la gráfica de densidad a continuación, ¿aproximadamente qué proporción de estados de EE. UU. Tienen poblaciones mayores de 10 millones?

```{r density-exercise, echo=FALSE}
murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey") +
scale_x_log10() +
xlab("Population in millions")
```

a. 0,02
si. 0,15
c. 0,50
re. 0,55

10\. Debajo hay tres diagramas de densidad. ¿Es posible que sean del mismo conjunto de datos?

```{r density-exercise-2, echo=FALSE, warning=FALSE, message=FALSE}
library(gridExtra)
p1 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = 5) + xlab("Population in millions") + ggtitle("1")
p2 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = .05) + scale_x_log10() + xlab("Population in millions") + ggtitle("2")
p3 <- murders %>% ggplot(aes(x=population/10^6)) +
geom_density(fill = "grey", bw = 1) + scale_x_log10() + xlab("Population in millions") + ggtitle("3")
grid.arrange(p1,p2,p3,ncol=2)
```

Cuál de las siguientes afirmaciones es verdadera:

a. Es imposible que sean del mismo conjunto de datos.
si. Son del mismo conjunto de datos, pero los gráficos son diferentes debido a errores de código.
c. Son el mismo conjunto de datos, pero el primer y el segundo diagrama son poco profundos y los terceros son demasiado suaves.
re. Son el mismo conjunto de datos, pero el primero no está en la escala logarítmica, el segundo undermooths y el tercero oversmooths.

## La distribución normal {#normal-distribution}

Los histogramas y las gráficas de densidad proporcionan excelentes resúmenes de una distribución. ¿Pero podemos resumir aún más? A menudo vemos la desviación promedio y estándar utilizada como resumen estadístico: ¡un resumen de dos números! Para comprender cuáles son estos resúmenes y por qué se usan tanto, necesitamos comprender la distribución normal.

La distribución normal, también conocida como curva de campana y distribución gaussiana, es uno de los conceptos matemáticos más famosos de la historia. Una razón para esto es que se producen distribuciones aproximadamente normales en muchas situaciones, incluidas las ganancias de juego, las alturas, los pesos, la presión arterial, los puntajes de las pruebas estandarizadas y los errores de medición experimentales. Hay explicaciones para esto, pero las describimos más adelante. Aquí nos centramos en cómo la distribución normal nos ayuda a resumir los datos.

En lugar de usar datos, la distribución normal se define con una fórmula matemática. Para cualquier intervalo $(a,b)$, la proporción de valores en ese intervalo se puede calcular utilizando esta fórmula:

$$\mbox{Pr}(a < x < b) = \int_a^b \frac{1}{\sqrt{2\pi}s} e^{-\frac{1}{2}\left( \frac{x-m}{s} \right)^2} \, dx$$


No necesita memorizar o comprender los detalles de la fórmula. Pero tenga en cuenta que está completamente definido por solo dos parámetros: $m$ y $s$. El resto de los símbolos en la fórmula representan los extremos de intervalo que determinamos, $a$ y $b$ y constantes matemáticas conocidas $\pi$ y $e$. Estos dos parámetros $m$ y $s$, se conocen como _average_ (también llamado _mean_) y _standard deviation_ (SD) de la distribución, respectivamente.

La distribución es simétrica, centrada en el promedio, y la mayoría de los valores (alrededor del 95%) están dentro de 2 SD del promedio. Así es como se ve la distribución normal cuando el promedio es 0 y el SD es 1:

```{r normal-distribution-density, echo=FALSE}
mu <- 0; s <- 1
norm_dist <- data.frame(x=seq(-4,4,len=50)*s+mu) %>% mutate(density=dnorm(x,mu,s))
norm_dist %>% ggplot(aes(x,density)) + geom_line()
```

El hecho de que la distribución esté definida por solo dos parámetros implica que si un conjunto de datos se aproxima por una distribución normal, toda la información necesaria para describir la distribución se puede codificar en solo dos números: el promedio y la desviación estándar. Ahora definimos estos valores para una lista arbitraria de números.

Para una lista de números contenidos en un vector `x`, el promedio se define como:

```{r, eval=TRUE}
m <- sum(x)/ length(x)
```

y la SD se define como:
```{r}
s <- sqrt(sum((x-mu)^2)/ length(x))
```
que puede interpretarse como la distancia promedio entre valores y su promedio.

Calculemos los valores para la altura de los machos que almacenaremos en el objeto $x$:

```{r}
index <- heights$sex == "Male"
x <- heights$height[index]
```

Las funciones preconstruidas `mean` y `sd` (tenga en cuenta que por razones explicadas en la Sección \@ref(data-driven-model), `sd` divide por `length(x)-1` más bien que `length(x)`) se puede usar aquí:
```{r}
m <- mean(x)
s <- sd(x)
c(average = m, sd = s)
```

Aquí hay una gráfica de la densidad suave y la distribución normal con media = `r round(m,1)` y SD = `r round(s,1)` trazado como una línea negra con la densidad suave de nuestra altura de estudiante en azul:

```{r data-and-normal-densities, echo=FALSE}
norm_dist <- data.frame(x = seq(-4, 4, len=50)*s + m) %>%
mutate(density = dnorm(x, m, s))

heights %>% filter(sex == "Male") %>% ggplot(aes(height)) +
geom_density(fill="#0099FF") +
geom_line(aes(x, density), data = norm_dist, lwd=1.5)
```

La distribución normal parece ser una buena aproximación aquí. Ahora veremos qué tan bien funciona esta aproximación para predecir la proporción de valores dentro de los intervalos.

## Unidades estándar

Para los datos que se distribuyen aproximadamente normalmente, es conveniente pensar en términos de _unidades estándar_. La unidad estándar de un valor nos dice cuántas desviaciones estándar se alejan del promedio. Específicamente, por un valor `x` de un vector `X`, definimos el valor de `x` en unidades estándar como `z = (x - m)/s` con `m` y `s` la desviación promedio y estándar de `X`, respectivamente. ¿Por qué es esto conveniente?

Primero revise la fórmula para la distribución normal y observe que lo que se está exponiendo es $-z^2/2$ con $z$ equivalente a $x$ en unidades estándar Porque el máximo de $e^{-z^2/2}$ es cuando $z=0$, esto explica por qué el máximo de la distribución ocurre en el promedio. También explica la simetría desde $- z^2/2$ es simétrico alrededor de 0. En segundo lugar, tenga en cuenta que si convertimos los datos distribuidos normalmente a unidades estándar, podemos saber rápidamente si, por ejemplo, una persona es aproximadamente promedio ( $z=0$), uno de los más largos ( $z \approx 2$), uno de los más pequeños ( $z \approx -2$), o una ocurrencia extremadamente rara ( $z > 3$ o $z < -3$) Recuerde que no importa cuáles sean las unidades originales, estas reglas se aplican a cualquier dato que sea aproximadamente normal.

En R, podemos obtener unidades estándar usando la función `scale`:
```{r}
z <- scale(x)
```

Ahora para ver cuántos hombres hay dentro de 2 SD del promedio, simplemente escribimos:

```{r}
mean(abs(z) < 2)
```

¡La proporción es de aproximadamente el 95%, que es lo que predice la distribución normal! Para confirmar aún más que, de hecho, la aproximación es buena, podemos usar gráficas cuantil-cuantil.


## Gráficos cuantil-cuantil

Una forma sistemática de evaluar qué tan bien se ajusta la distribución normal a los datos es verificar si las proporciones observadas y predichas coinciden. En general, este es el enfoque del gráfico cuantil-cuantil (gráfico QQ).

Primero definamos los cuantiles teóricos para la distribución normal. En los libros de estadísticas usamos el símbolo $\Phi(x)$ para definir la función que nos da la probabilidad de que una distribución normal estándar sea menor que $x$. Así por ejemplo, $\Phi(-1.96) = 0.025$ y $\Phi(1.96) = 0.975$. En R, podemos evaluar $\Phi$ utilizando la `pnorm` función:

```{r}
pnorm(-1.96)
```


La función inversa $\Phi^{-1}(x)$ nos da los _cuantiles teóricos_ para la distribución normal. Así por ejemplo, $\Phi^{-1}(0.975) = 1.96$. En R, podemos evaluar el inverso de $\Phi$ utilizando la `qnorm` función.

```{r}
qnorm(0.975)
```

Tenga en cuenta que estos cálculos son para la distribución normal estándar por defecto (media = 0, desviación estándar = 1), pero también podemos definirlos para cualquier distribución normal. Podemos hacer esto usando el `mean` y `sd` argumentos en el `pnorm` y `qnorm` función. Por ejemplo, podemos usar `qnorm` para determinar cuantiles de una distribución con un promedio específico y desviación estándar

```{r}
qnorm(0.975, mean = 5, sd = 2)
```

Para la distribución normal, todos los cálculos relacionados con los cuantiles se realizan sin datos, de ahí el nombre de cuantiles teóricos. Pero los cuantiles se pueden definir para cualquier distribución, incluida una empírica. Entonces, si tenemos datos en un vector $x$, podemos definir el cuantil asociado con cualquier proporción $p$ como el $q$ para el cual la proporción de valores por debajo $q$ es $p$. Usando el código R, podemos definir `q` como el valor para el cual `mean(x <= q) = p`. Tenga en cuenta que no todos $p$ tener un $q$ para lo cual la proporción es exactamente $p$. Hay varias formas de definir lo mejor $q$ como se discutió en la ayuda para el NA función.

Para dar un ejemplo rápido, para los datos de alturas masculinas, tenemos que:
```{r}
mean(x <= 69.5)
```
Entonces, alrededor del 50% son más cortos o iguales a 69 pulgadas. Esto implica que si $p=0.50$ luego $q=69.5$.

La idea de un gráfico QQ es que si sus datos están bien aproximados por la distribución normal, los cuantiles de sus datos deberían ser similares a los cuantiles de una distribución normal. Para construir un diagrama QQ, hacemos lo siguiente:

1. Definir un vector de $m$ dimensiones $p_1, p_2, \dots, p_m$.
2. Definir un vector de cuantiles $q_1, \dots, q_m$ para sus datos para las proporciones $p_1, \dots, p_m$. Nos referimos a estos como los _cuantiles de muestra_.
3. Definir un vector de cuantiles teóricos para las proporciones. $p_1, \dots, p_m$ para una distribución normal con el mismo promedio y desviación estándar que los datos.
4. Graficar los cuantiles de la muestra versus los cuantiles teóricos.


Construyamos un diagrama QQ usando el código R. Comience definiendo el vector de proporciones.
```{r}
p <- seq(0.05, 0.95, 0.05)
```

Para obtener los cuantiles de los datos, podemos usar el `quantile` funciona así:
```{r}
sample_quantiles <- quantile(x, p)
```

Para obtener los cuantiles teóricos de distribución normal con el promedio correspondiente y SD, utilizamos el `qnorm` función:
```{r}
theoretical_quantiles <- qnorm(p, mean = mean(x), sd = sd(x))
```

Para ver si coinciden o no, los trazamos uno contra el otro y dibujamos la línea de identidad:

```{r qqplot-original}
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

Tenga en cuenta que este código se vuelve mucho más limpio si usamos unidades estándar:
```{r qqplot-standardized, eval=FALSE}
sample_quantiles <- quantile(z, p)
theoretical_quantiles <- qnorm(p)
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

El código anterior se incluye para ayudar a describir los gráficos QQ. Sin embargo, en la práctica es más fácil usar el código **ggplot2** descrito en la Sección \@ref(other-geometries):

```{r, eval=FALSE}
heights %>% filter(sex == "Male") %>%
ggplot(aes(sample = scale(height))) +
geom_qq() +
geom_abline()
```

Mientras que para la ilustración anterior usamos 20 cuantiles, el valor predeterminado de `geom_qq` la función es utilizar tantos cuantiles como puntos de datos.

## Percentiles

Antes de continuar, definamos algunos términos que se usan comúnmente en el análisis exploratorio de datos.

_Percentiles_son casos especiales de_quantiles_ que se usan comúnmente. Los percentiles son los cuantiles que obtienes al configurar el $p$ a $0.01, 0.02, ..., 0.99$. Llamamos, por ejemplo, el caso de $p=0.25$ el percentil 25, que nos da un número para el cual el 25% de los datos está debajo. El percentil más famoso es el 50, también conocido como el _medio_.

Para la distribución normal, _median_ y average son los mismos, pero generalmente este no es el caso.

Otro caso especial que recibe un nombre son los _cuartiles_, que se obtienen al configurar $p=0.25,0.50$ y $0.75$.


## Gráficos de caja

Para presentar los diagramas de caja volveremos a los datos de asesinatos de los EE.
Supongamos que queremos resumir la distribución de la tasa de asesinatos. Usando la técnica de visualización de datos que hemos aprendido, podemos ver rápidamente que la aproximación normal no se aplica aquí:

```{r hist-qqplot-non-normal-data, out.width = "100%", fig.width = 6, fig.height = 3, echo=FALSE}
data(murders)
murders <- murders %>% mutate(rate = total/population*100000)
library(gridExtra)
p1 <- murders %>% ggplot(aes(x=rate)) + geom_histogram(binwidth = 1) + ggtitle("Histogram")
p2 <- murders %>% ggplot(aes(sample=rate)) +
geom_qq(dparams=summarize(murders, mean=mean(rate), sd=sd(rate))) +
geom_abline() + ggtitle("QQ-plot")
grid.arrange(p1, p2, ncol = 2)
```

En este caso, el histograma anterior o un gráfico de densidad uniforme serviría como un resumen relativamente sucinto.

Ahora supongamos que los que están acostumbrados a recibir solo dos números como resúmenes nos solicitan un resumen numérico más compacto.

Aquí Tukey ofreció algunos consejos. Proporcione un resumen de cinco números compuesto por el rango junto con los cuartiles (los percentiles 25, 50 y 75). Tukey sugirió además que ignoremos _outliers_ cuando calcule el rango y, en su lugar, grafiquemos estos como puntos independientes. Proporcionamos una explicación detallada de los valores atípicos más adelante. Finalmente, sugirió que trazáramos estos números como una "caja" con "bigotes" como este:


```{r first-boxplot, echo=FALSE}
murders %>% ggplot(aes("",rate)) + geom_boxplot() +
coord_cartesian(xlim = c(0, 2)) + xlab("")
```

con el cuadro definido por el percentil 25% y 75% y los bigotes que muestran el rango. La distancia entre estos dos se llama rango _intercuartil_. Los dos puntos son valores atípicos según la definición de Tukey. La mediana se muestra con una línea horizontal. Hoy, los llamamos _boxplots_.

A partir de este simple diagrama, sabemos que la mediana es de aproximadamente 2.5, que la distribución no es simétrica y que el rango es de 0 a 5 para la gran mayoría de los estados con dos excepciones.

Discutimos cómo hacer diagramas de caja en la Sección \@ref(other-geometries).

## Estratificación {#stratification}

En el análisis de datos, a menudo dividimos las observaciones en grupos según los valores de una o más variables asociadas con esas observaciones. Por ejemplo, en la siguiente sección dividimos los valores de altura en grupos según una variable de sexo: mujeres y hombres. Llamamos a este procedimiento _estratificación_y nos referimos a los grupos resultantes como_estrata_.

La estratificación es común en la visualización de datos porque a menudo estamos interesados en cómo la distribución de variables difiere entre los diferentes subgrupos. Veremos varios ejemplos a lo largo de esta parte del libro. Revisaremos el concepto de estratificación cuando aprendamos regresión en el Capítulo \@ref(regression) y en la parte de aprendizaje automático del libro.

## Estudio de caso: descripción de las alturas de los estudiantes (continuación) {#student-height-cont}

Usando el histograma, los gráficos de densidad y los gráficos QQ, nos hemos convencido de que los datos de altura masculina se aproximan bien con una distribución normal. En este caso, informamos a ET un resumen muy sucinto: las alturas masculinas siguen una distribución normal con un promedio de `r round(m, 1)` pulgadas y una SD de `r round(s,1)` pulgadas. Con esta información, ET tendrá una buena idea de qué esperar cuando conozca a nuestros estudiantes varones.
Sin embargo, para proporcionar una imagen completa, también debemos proporcionar un resumen de las alturas femeninas.

Aprendimos que los diagramas de caja son útiles cuando queremos comparar rápidamente dos o más distribuciones. Aquí están las alturas para hombres y mujeres:

```{r female-male-boxplots, echo=FALSE}
heights %>% ggplot(aes(x=sex, y=height, fill=sex)) +
geom_boxplot()
```

La trama revela de inmediato que los machos son, en promedio, más altos que las hembras. Las desviaciones estándar parecen ser similares. Pero, ¿la aproximación normal también funciona para los datos de estatura femenina recopilados por la encuesta? Esperamos que sigan una distribución normal, al igual que los machos. Sin embargo, los gráficos exploratorios revelan que la aproximación no es tan útil:


```{r histogram-qqplot-female-heights, echo=FALSE, out.width="100%", fig.width = 6, fig.height = 3}
p1 <- heights %>% filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density(fill="#F8766D")
p2 <- heights %>% filter(sex == "Female") %>%
ggplot(aes(sample=scale(height))) +
geom_qq() + geom_abline() + ylab("Standard Units")
grid.arrange(p1, p2, ncol=2)
```

Vemos algo que no vimos para los machos: la gráfica de densidad tiene una segunda "protuberancia". Además, el gráfico QQ muestra que los puntos más altos tienden a ser más altos de lo esperado por la distribución normal. Finalmente, también vemos cinco puntos en el gráfico QQ que sugieren alturas más cortas de lo esperado para una distribución normal. Al informar de nuevo a ET, es posible que necesitemos proporcionar un histograma en lugar de solo la desviación promedio y estándar para las alturas femeninas.

Sin embargo, regrese y lea la cita de Tukey. Hemos notado lo que no esperábamos ver. Si observamos otras distribuciones de estatura femenina, encontramos que están bien aproximadas con una distribución normal. Entonces, ¿por qué nuestras alumnas son diferentes? ¿Es nuestra clase un requisito para el equipo femenino de baloncesto? ¿Son pequeñas proporciones de mujeres que dicen ser más altas de lo que son? Otra explicación, quizás más probable, es que en la forma en que los estudiantes solían ingresar a sus alturas, `FEMALE` era el sexo predeterminado y algunos machos ingresaron a sus alturas, pero olvidaron cambiar la variable de sexo. En cualquier caso, la visualización de datos ha ayudado a descubrir una falla potencial en nuestros datos.

Con respecto a los cinco valores más pequeños, tenga en cuenta que estos valores son:
```{r}
heights %>% filter(sex == "Female") %>%
top_n(5, desc(height)) %>%
pull(height)
```

Debido a que estas son alturas reportadas, una posibilidad es que el estudiante esté destinado a ingresar `5'1"`, `5'2"`, `5'3"` o `5'5"`.


## Ejercicios

1\. Defina variables que contengan las alturas de hombres y mujeres de esta manera:

```{r, eval=FALSE}
library(dslabs)
data(heights)
male <- heights$height[heights$sex == "Male"]
female <- heights$height[heights$sex == "Female"]
```

¿Cuántas medidas tenemos para cada uno?


2\. Supongamos que no podemos hacer un diagrama y queremos comparar las distribuciones una al lado de la otra. No podemos simplemente enumerar todos los números. En cambio, veremos los percentiles. Cree una tabla de cinco filas que muestre `female_percentiles` y `male_percentiles` con los percentiles 10, 30, 50, ..., 90 para cada sexo. Luego cree un marco de datos con estos dos como columnas.


3\. Estudie los siguientes diagramas de caja que muestran los tamaños de población por país:

```{r boxplot-exercise, echo=FALSE, message=FALSE}
library(tidyverse)
library(dslabs)
ds_theme_set()
data(gapminder)
tab <- gapminder %>% filter(year == 2010) %>% group_by(continent) %>% select(continent, population)
tab %>% ggplot(aes(x=continent, y=population/10^6)) +
geom_boxplot() +
scale_y_continuous(trans = "log10", breaks = c(1,10,100,1000)) + ylab("Population in millions")
```

¿Qué continente tiene el país con el mayor tamaño de población?

4\. ¿Qué continente tiene el mayor tamaño de población promedio?


5\. ¿Cuál es el tamaño medio de la población de África al millón más cercano?


6\. ¿Qué proporción de países en Europa tienen poblaciones inferiores a 14 millones?

a. 0,99
si. 0,75
c. 0,50
re. 0.25

7\. Si utilizamos una transformación logarítmica, ¿qué continente que se muestra arriba tiene el mayor rango intercuartil?

8\. Cargue el conjunto de datos de altura y cree un vector `x` con solo las alturas masculinas:

```{r, eval=FALSE}
library(dslabs)
data(heights)
x <- heights$height[heights$sex=="Male"]
```

¿Qué proporción de los datos está entre 69 y 72 pulgadas (más alto que 69, pero más corto o igual a 72)? Sugerencia: use un operador lógico y `mean`.

9\. Supongamos que todo lo que sabe sobre los datos es el promedio y la desviación estándar. Use la aproximación normal para estimar la proporción que acaba de calcular. Sugerencia: comience calculando la desviación promedio y estándar. Luego usa el `pnorm` función para predecir las proporciones.

10\. Observe que la aproximación calculada en la pregunta nueve está muy cerca del cálculo exacto en la primera pregunta. Ahora realice la misma tarea para valores más extremos. Compare el cálculo exacto y la aproximación normal para el intervalo (79,81]. ¿Cuántas veces mayor es la proporción real que la aproximación?

11\. La distribución aproximada de hombres adultos en el mundo se distribuye normalmente con un promedio de 69 pulgadas y una desviación estándar de 3 pulgadas. Usando esta aproximación, calcule la proporción de hombres adultos que miden 7 pies de alto o más, conocidos como "siete pies de página". Sugerencia: use el `pnorm` función.

12\. Hay alrededor de mil millones de hombres entre las edades de 18 y 40 en el mundo. Usa tu respuesta a la pregunta anterior para estimar cuántos de estos hombres (de 18 a 40 años) miden siete pies de altura o más en el mundo.

13\. Hay alrededor de 10 jugadores de la Asociación Nacional de Baloncesto (NBA) que miden 7 pies de altura o más. Usando la respuesta a las dos preguntas anteriores, ¿qué proporción de los siete pies de página del mundo de 18 a 40 años están en la NBA?

14\. Repita los cálculos realizados en la pregunta anterior para la altura de Lebron James: 6 pies y 8 pulgadas. Hay alrededor de 150 jugadores que son al menos tan altos.

15\. Al responder las preguntas anteriores, descubrimos que no es raro que un jugador de siete pies se convierta en jugador de la NBA. Lo que sería una crítica justa de nuestros cálculos:

a. La práctica y el talento son los que hacen a un gran jugador de baloncesto, no la altura.
si. La aproximación normal no es apropiada para alturas.
c. Como se ve en la pregunta 10, la aproximación normal tiende a subestimar los valores extremos. Es posible que haya más siete pies de página de lo que predijimos.
re. Como se ve en la pregunta 10, la aproximación normal tiende a sobreestimar los valores extremos. Es posible que haya menos siete pies de página de lo que predijimos.

## geometrías ggplot2 {#other-geometries}

En el capitulo \@ref(ggplot2), presentamos el paquete __ggplot2__ para la visualización de datos. Aquí demostramos cómo generar gráficos relacionados con las distribuciones, específicamente los gráficos que se muestran anteriormente en este capítulo.

### Barplots

Para generar un diagrama de barras podemos usar el `geom_bar` geometría. El valor predeterminado es contar el número de cada categoría y dibujar una barra. Aquí está la trama para las regiones de los Estados Unidos.

```{r barplot-geom}
murders %>% ggplot(aes(region)) + geom_bar()
```

A menudo ya tenemos una tabla con una distribución que queremos presentar como diagrama de barras. Aquí hay un ejemplo de tal tabla:

```{r}
data(murders)
tab <- murders %>%
count(region) %>%
mutate(proportion = n/sum(n))
tab
```

Ya no queremos `geom_bar` para contar, sino simplemente trazar una barra a la altura proporcionada por el `proportion` variable. Para esto necesitamos proporcionar `x` (las categorías) y `y` (los valores) y use el `stat="identity"` opción.

```{r region-freq-barplot}
tab %>% ggplot(aes(region, proportion)) + geom_bar(stat = "identity")
```

### Histogramas

Para generar histogramas utilizamos `geom_histogram`. Al mirar el archivo de ayuda para esta función, aprendemos que el único argumento requerido es `x`, la variable para la cual construiremos un histograma. Dejamos caer el `x` porque sabemos que es el primer argumento.
El código se ve así:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram()
```

Si ejecutamos el código anterior, nos da un mensaje:

> `stat_bin()` utilizando `bins = 30`. Elija un mejor valor con
`binwidth`.

Anteriormente utilizamos un tamaño de contenedor de 1 pulgada, por lo que el código se ve así:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1)
```

Finalmente, si por razones estéticas queremos agregar color, usamos los argumentos descritos en el archivo de ayuda. También agregamos etiquetas y un título:

```{r height-histogram-geom}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_histogram(binwidth = 1, fill = "blue", col = "black") +
xlab("Male heights in inches") +
ggtitle("Histogram")
```

### Gráficos de densidad

Para crear una densidad suave, usamos el `geom_density`. Para hacer un diagrama de densidad uniforme con los datos mostrados previamente como un histograma, podemos usar este código:

```{r, eval=FALSE}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density()
```

Para rellenar con color, podemos usar el `fill` argumento.

```{r ggplot-density}
heights %>%
filter(sex == "Female") %>%
ggplot(aes(height)) +
geom_density(fill="blue")
```

Para cambiar la suavidad de la densidad, utilizamos el `adjust` argumento para multiplicar el valor predeterminado por ese `adjust`. Por ejemplo, si queremos que el ancho de banda sea el doble de grande, usamos:

```{r eval = FALSE}
heights %>%
filter(sex == "Female") +
geom_density(fill="blue", adjust = 2)
```

### Boxplots

La geometría para boxplot es `geom_boxplot`. Como se discutió, los diagramas de caja son útiles para comparar distribuciones. Por ejemplo, a continuación se muestran las alturas mostradas anteriormente para las mujeres, pero en comparación con los hombres. Para esta geometría, necesitamos argumentos `x` como las categorías, y `y` como los valores

```{r female-male-boxplots-geom, echo=FALSE}
heights %>% ggplot(aes(sex, height)) +
geom_boxplot()
```

### QQ-plot

Para qq-plot usamos el `geom_qq` geometría. Del archivo de ayuda, aprendemos que necesitamos especificar el `sample` (aprenderemos sobre muestras en un capítulo posterior). Aquí está el qqplot para hombres de altura.

```{r ggplot-qq}
heights %>% filter(sex=="Male") %>%
ggplot(aes(sample = height)) +
geom_qq()
```

Por defecto, la variable de muestra se compara con una distribución normal con un promedio de 0 y una desviación estándar 1. Para cambiar esto, utilizamos el `dparams` argumentos basados en el archivo de ayuda. Agregar una línea de identidad es tan simple como asignar otra capa. Para líneas rectas, usamos el `geom_abline` función. La línea predeterminada es la línea de identidad (pendiente = 1, intercepción = 0).

```{r ggplot-qq-dparams, eval=FALSE}
params <- heights %>% filter(sex=="Male") %>%
summarize(mean = mean(height), sd = sd(height))

heights %>% filter(sex=="Male") %>%
ggplot(aes(sample = height)) +
geom_qq(dparams = params) +
geom_abline()
```

Otra opción aquí es escalar los datos primero y luego hacer un qqplot contra el estándar normal.

```{r ggplot-qq-standard-units, eval=FALSE}
heights %>%
filter(sex=="Male") %>%
ggplot(aes(sample = scale(height))) +
geom_qq() +
geom_abline()
```

### Imágenes

No se necesitaban imágenes para los conceptos descritos en este capítulo, pero usaremos imágenes en la Sección \@ref(vaccines), así que presentamos las dos geometrías utilizadas para crear imágenes: __geom_tile__y__geom_raster__. Se comportan de manera similar; Para ver cómo difieren, consulte el archivo de ayuda. Para crear una imagen en __ggplot2__ necesitamos un marco de datos con las coordenadas xey, así como los valores asociados con cada uno de estos. Aquí hay un marco de datos.

```{r}
x <- expand.grid(x = 1:12, y = 1:10) %>%
mutate(z = 1:120)
```

Tenga en cuenta que esta es la versión ordenada de una matriz, `matrix(1:120, 12, 10)`. Para trazar la imagen usamos el siguiente código:

```{r, eval=FALSE}
x %>% ggplot(aes(x, y, fill = z)) +
geom_raster()
```

Con estas imágenes, a menudo querrá cambiar la escala de color. Esto se puede hacer a través de `scale_fill_gradientn` capa.

```{r ggplot2-image-new-colors}
x %>% ggplot(aes(x, y, fill = z)) +
geom_raster() +
scale_fill_gradientn(colors = terrain.colors(10))
```



### Trazados rápidos

En la sección \@ref(qplot) presentamos `qplot` como una función útil cuando necesitamos hacer un diagrama de dispersión rápido. También podemos usar `qplot` para hacer histogramas, diagramas de densidad, diagrama de caja, diagramas qq y más. Aunque no proporciona el nivel de control de `ggplot`, `qplot` es definitivamente útil, ya que nos permite hacer un diagrama con un pequeño fragmento de código.

Supongamos que tenemos las alturas femeninas en un objeto `x`:

```{r}
x <- heights %>%
filter(sex=="Male") %>%
pull(height)
```

Para hacer un histograma rápido podemos usar:

```{r qplot-example-1, warning=FALSE, message=FALSE, eval=FALSE}
qplot(x)
```

La función adivina que queremos hacer un histograma porque solo proporcionamos una variable. En la sección \@ref(qplot) vimos que si suministramos `qplot` dos variables, crea automáticamente un diagrama de dispersión.

Para hacer un qqplot rápido tienes que usar el `sample` argumento. Tenga en cuenta que podemos agregar capas tal como lo hacemos con `ggplot`.

```{r qplot-example-2, eval=FALSE}
qplot(sample = scale(x)) + geom_abline()
```


Si suministramos un factor y un vector numérico, obtenemos una gráfica como la siguiente. Tenga en cuenta que en el siguiente código estamos utilizando el `data` argumento. Porque el marco de datos no es el primer argumento en `qplot`, tenemos que usar el operador de punto.

```{r qplot-example-3, eval=FALSE}
heights %>% qplot(sex, height, data = .)
```

También podemos seleccionar una geometría específica mediante el uso de `geom` argumento. Entonces, para convertir el diagrama anterior en un diagrama de caja, usamos el siguiente código:

```{r qplot-example-4, eval=FALSE}
heights %>% qplot(sex, height, data = ., geom = "boxplot")
```

También podemos usar el `geom` argumento para generar una gráfica de densidad en lugar de un histograma:

```{r qplot-example-5, eval=FALSE}
qplot(x, geom = "density")
```

Aunque no tanto como con `ggplot`, tenemos cierta flexibilidad para mejorar los resultados de `qplot`. Mirando el archivo de ayuda, vemos varias formas en que podemos mejorar el aspecto del histograma anterior. Aquí hay un ejemplo:

```{r qplot-example-6}
qplot(x, bins=15, color = I("black"), xlab = "Population")
```

**Nota técnica**: La razón por la que usamos `I("black")` es porque queremos `qplot` para tratar `"black"` como un carácter en lugar de convertirlo en un factor, que es el comportamiento predeterminado dentro de `aes`, que se llama internamente aquí. En general, la función `I` se usa en R para decir "mantenerlo como está".




## Ejercicios


1\. Ahora vamos a usar el `geom_histogram` función para hacer un histograma de las alturas en el `height` marco de datos. Al leer la documentación para esta función, vemos que requiere solo una asignación, los valores que se utilizarán para el histograma. Haz un histograma de todas las parcelas.

¿Cuál es la variable que contiene las alturas?

a. `sex`
si. `heights`
c. `height`
re. `heights$height`

2\. Ahora cree un objeto ggplot usando la tubería para asignar los datos de altura a un objeto ggplot. Asignar `height` a los valores de x a través de la `aes` función.

3\. Ahora estamos listos para agregar una capa para hacer realmente el histograma. Utilice el objeto creado en el ejercicio anterior y el `geom_histogram` función para hacer el histograma.

4\. Tenga en cuenta que cuando ejecutamos el código en el ejercicio anterior recibimos la advertencia:
`stat_bin()` utilizando `bins = 30`. Elija un mejor valor con `binwidth`.`

Utilizar el `binwidth` argumento para cambiar el histograma realizado en el ejercicio anterior para usar contenedores de tamaño 1 pulgada.

5\. En lugar de un histograma, vamos a hacer un diagrama de densidad uniforme. En este caso, no haremos un objeto, sino que representaremos el gráfico con una línea de código. Cambie la geometría en el código utilizado anteriormente para hacer una densidad uniforme en lugar de un histograma.

6\. Ahora vamos a hacer un diagrama de densidad para hombres y mujeres por separado. Podemos hacer esto usando el `group` argumento. Asignamos grupos a través del mapeo estético, ya que cada punto necesita un grupo antes de hacer los cálculos necesarios para estimar una densidad.

7\. También podemos asignar grupos a través de `color` argumento. Esto tiene el beneficio adicional de que utiliza el color para distinguir los grupos. Cambie el código anterior para usar color.

8\. También podemos asignar grupos a través de `fill` argumento. Esto tiene el beneficio adicional de que usa colores para distinguir los grupos, de esta manera:


```{r, eval=FALSE}
heights %>%
ggplot(aes(height, fill = sex)) +
geom_density()
```

Sin embargo, aquí la segunda densidad se dibuja sobre la otra. Podemos hacer que las curvas sean más visibles mediante el uso de la combinación alfa para agregar transparencia. Establezca el parámetro alfa a 0.2 en el `geom_density` función para hacer este cambio.








