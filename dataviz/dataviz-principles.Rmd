# Principios de visualización de datos

```{r, echo=FALSE}
img_path <- "dataviz/img"
```

Ya hemos presentado algunas reglas a seguir mientras creamos gráficos para nuestros ejemplos. Aquí, nuestro objetivo es ofrecer algunos principios generales que podemos usar como guía para una visualización de datos efectiva. Gran parte de esta sección se basa en una charla de Karl Broman^[http://kbroman.org/] titulada "Creating Effective Figures and Tables"^[https://www.biostat.wisc.edu/~kbroman/presentations/graphs2017.pdf] e incluye algunas de las figuras que se hicieron con el código que Karl pone a disposición en su repositorio de GitHub^[https://github.com/kbroman/Talk_Graphs], así como las notas de la clase "Introduction to Data Visualization" de Peter Aldhous^[http://paldhous.github.io/ucb/2016/dataviz/index.html]. Siguiendo el enfoque de Karl, mostramos algunos ejemplos de estilos de gráficos que debemos evitar, explicamos cómo mejorarlos y entonces los usamos como motivación para una lista de principios. Además, comparamos y contrastamos los gráficos que siguen estos principios con otros que los ignoran.

Los principios se basan principalmente en investigaciones relacionadas a la manera en que los humanos detectan patrones y hacen comparaciones visuales. Los enfoques preferidos son aquellos que mejor se adaptan a la forma en que nuestros cerebros procesan la información visual. Al escoger las herramientas de visualización, es importante tener en cuenta nuestro objetivo. Podemos estar comparando una cantidad de números suficientemente pequeña que se pueden distinguir, describiendo distribuciones de datos categóricos o valores numéricos, comparando los datos de dos grupos o describiendo la relación entre dos variables y esto afecta la presentación que escojeremos. Como nota final, queremos enfatizar que para un científico de datos es importante adaptar y optimizar los gráficos para la audiencia. Por ejemplo, un gráfico exploratorio hecho para nosotros será diferente a una tabla destinada a comunicar un hallazgo a una audiencia general.

Utilizaremos estos paquetes:


```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(dslabs)
library(gridExtra)
```


## Cómo codificar datos utilizando señales visuales

Comenzamos describiendo algunos principios para codificar datos. Hay varios acercamientos a nuestra disposición que incluyen posición, largo, ángulos, área, brillo y tono de color.


```{r, echo=FALSE}
browsers <- data.frame(Browser = rep(c("Opera","Safari","Firefox","IE","Chrome"),2),
Year = rep(c(2000, 2015), each = 5),
Percentage = c(3,21,23,28,26, 2,22,21,27,29)) %>%
mutate(Browser = reorder(Browser, Percentage))
```


Para ilustrar cómo se comparan algunas de estas estrategias, supongamos que queremos informar los resultados de dos encuestas hipotéticas, tomadas en 2000 y luego en 2015, con respecto a la preferencia de navegador. Para cada año, simplemente estamos comparando cinco cantidades: los cinco porcentajes. Una representación gráfica de porcentajes ampliamente utilizada, y popularizada por Microsoft Excel, es el gráfico circular:


```{r piechart, echo=FALSE}
library(ggthemes)
p1 <- browsers %>% ggplot(aes(x = "", y = Percentage, fill = Browser)) +
geom_bar(width = 1, stat = "identity", col = "black") + coord_polar(theta = "y") +
theme_excel() + xlab("") + ylab("") +
theme(axis.text=element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank()) +
facet_grid(.~Year)
p1
```


Aquí estamos representando cantidades con áreas y ángulos, ya que tanto el ángulo como el área de cada sección del gráfico son proporcionales a la cantidad que representa el sector. Esto resulta ser una opción subóptima dado que, como lo demuestran los estudios de percepción, los humanos no son buenos para cuantificar ángulos con precisión y son aún peores cuando el área es la única señal visual disponible. El gráfico de anillo es un ejemplo de un gráfico que usa solo área:

```{r donutchart, echo=FALSE}
browsers %>% ggplot(aes(x = 2, y = Percentage, fill = Browser)) +
geom_bar(width = 1, stat = "identity", col = "black") +
scale_x_continuous(limits=c(0.5,2.5)) + coord_polar(theta = "y") +
theme_excel() + xlab("") + ylab("") +
theme(axis.text=element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank()) +
facet_grid(.~Year)

```

Para ver cuán difícil es cuantificar los ángulos y el área, recuerden que las clasificaciones y todos los porcentajes en los gráficos anteriores cambiaron de 2000 a 2015. ¿Pueden determinar los porcentajes reales y clasificar la popularidad de los navegadores? ¿Pueden ver cómo los porcentajes cambiaron de 2000 a 2015? No es fácil distinguirlo del gráfico. De hecho, la función  `pie` de la página de ayuda de R señala que:

> Los gráficos circulares son una forma muy mala de mostrar información. El ojo es bueno juzgando medidas lineales y malo juzagando áreas relativas. Un diagrama de barras o de puntos es una forma preferible de mostrar este tipo de datos.


En este caso, simplemente mostrar los números no solo es más claro, sino que también ahorraría costos de impresión si imprime una copia en papel:

```{r, echo=FALSE}
if(knitr::is_html_output()){
browsers %>% spread(Year, Percentage) %>% knitr::kable("html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
browsers %>% spread(Year, Percentage) %>%
knitr::kable("latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

La forma preferida de graficar estas cantidades es usar la longitud y la posición como señales visuales, ya que los humanos son mucho mejores juzgando medidas lineales. El diagrama de barras usa este enfoque al usar barras de longitud proporcionales a las cantidades de interés. Al agregar líneas horizontales a valores estratégicamente elegidos, en este caso en cada múltiplo de 10, aliviamos la carga visual de cuantificar a través de la posición de la parte superior de las barras. Comparen y contrasten la información que podemos extraer de los siguientes dos pares de gráficos.

```{r two-barplots, echo=FALSE, out.width="100%", fig.width = 6, fig.height = 5}
p2 <-browsers %>%
ggplot(aes(Browser, Percentage)) +
geom_bar(stat = "identity", width=0.5) +
ylab("Percent using the Browser") +
facet_grid(.~Year)
grid.arrange(p1, p2, nrow = 2)
```

Observen lo fácil que es ver las diferencias en el diagrama de barras. De hecho, ahora podemos determinar los porcentajes reales siguiendo una línea horizontal hasta el eje-x.

Si, por alguna razón, tienen que hacer un gráfico circular, etiqueten cada sección del círculo con su porcentaje respectivo para que la audiencia no tenga que inferirlos de los ángulos o del área:

```{r excel-barplot, warning = FALSE, message=FALSE, echo=FALSE}
library(scales)
browsers <- filter(browsers, Year == 2015)
at <- with(browsers, 100 - cumsum(c(0,Percentage[-length(Percentage)])) - 0.5*Percentage)
label <- percent(browsers$Percentage/100)
browsers %>% ggplot(aes(x = "", y = Percentage, fill = Browser)) +
geom_bar(width = 1, stat = "identity", col = "black") + coord_polar(theta = "y") +
theme_excel() + xlab("") + ylab("") + ggtitle("2015") +
theme(axis.text=element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank()) +
annotate(geom = "text",
x = 1.62,
y = at,
label = label, size=4)
```

En general, cuando se muestran cantidades, se prefieren la posición y la longitud sobre los ángulos y/o el área. El brillo y el color son aún más difíciles de cuantificar que los ángulos. Pero, como veremos más adelante, a veces son útiles cuando se deben mostrar más de dos dimensiones a la vez.

## Sepa cuándo incluir 0

Cuando se usan diagramas de barras, es erróneo no comenzar las barras en 0. Esto se debe a que, al usar un diagrama de barras, estamos implicando que la longitud es proporcional a las cantidades que se muestran. Al evitar 0, se pueden hacer diferencias relativamente pequeñas verse mucho más grandes de lo que realmente son. Este acercamiento a menudo es utilizado por políticos o medios de comunicación que intentan exagerar la diferencia. A continuación se muestra un ejemplo ilustrativo utilizado por Peter Aldhous en esta conferencia: http://paldhous.github.io/ucb/2016/dataviz/week2.htmlfont^[http://paldhous.github.io/ucb/2016/dataviz/week2.html].

```{r echo=FALSE}
## http://paldhous.github.io/ucb/2016/dataviz/img/class2_8.jpg
knitr::include_graphics(file.path(img_path, "class2_8.jpg"))
```

(Fuente: Fox News, vía Media Matters^[http://mediamatters.org/blog/2013/04/05/fox-news-newest-dishonest-chart-immigration-enf/193507].)

En el gráfico anterior, las detenciones parecen haber casi triplicado cuando, de hecho, solo han aumentado aproximadamente un 16%. Comenzar el gráfico en 0 ilustra esto claramente:

```{r barplot-from-zero-1, echo=FALSE}
data.frame(Year = as.character(c(2011, 2012, 2013)),Southwest_Border_Apprehensions = c(165244,170223,192298)) %>%
ggplot(aes(Year, Southwest_Border_Apprehensions )) +
geom_bar(stat = "identity", fill = "yellow", col = "black", width = 0.65)
```

Abajo vemos otro ejemplo, que se describe en detalle en un artículo del blog "Flowing Data":

```{r, echo=FALSE}
## http://i2.wp.com/flowingdata.com/wp-content/uploads/2012/08/Bush-cuts.png
knitr::include_graphics(file.path(img_path, "Bush-cuts.png"))
```
(Fuente: Fox News, a través de Flowing Data^[http://flowingdata.com/2012/08/06/fox-news-continues-charting-excellence/])

Este gráfico hace que un aumento del 13% parezca cinco veces más grande. Aquí tenemos el gráfico apropiado:

```{r barplot-from-zero-2, echo=FALSE}
data.frame(date = c("Now", "Jan 1, 2013"), tax_rate = c(35, 39.6)) %>%
mutate(date = reorder(date, tax_rate)) %>%
ggplot(aes(date, tax_rate)) +
ylab("") + xlab("") +
geom_bar(stat = "identity", fill = "yellow", col = "black", width = 0.5) +
ggtitle("Top Tax Rate If Bush Tax Cut Expires")
```

Finalmente, aquí tenemos un ejemplo extremo que hace que una diferencia muy pequeña, de menos de 2%, parezca 10 a 100 veces más grande:

```{r, echo=FALSE}
## http://i2.wp.com/flowingdata.com/wp-content/uploads/2012/08/Bush-cuts.png
knitr::include_graphics(file.path(img_path, "venezuela-election.png"))
```

(Fuente:
Venezolana de Televisión vía Pakistan Today^[https://www.pakistantoday.com.pk/2018/05/18/whats-at-stake-in-venezuelan-presidential-vote] y Diego Mariano)

Aquí está el gráfico apropiado:

```{r barplot-from-zero-3, echo=FALSE}
data.frame(Candidate = factor(c("Maduro", "Capriles"), levels = c("Maduro", "Capriles")),
Percent = c(50.66, 49.07)) %>%
ggplot(aes(Candidate, Percent, fill = Candidate)) +
geom_bar(stat = "identity", width = 0.65, show.legend = FALSE)
```

Cuando se usa posición en lugar de longitud, no es necesario incluir 0. Este es  el caso en particular cuando queremos comparar las diferencias entre los grupos en relación con la variabilidad dentro de un grupo. Aquí tenemos un ejemplo ilustrativo que muestra la esperanza de vida promedio de cada país estratificada por continente en 2012:

```{r points-plot-not-from-zero, echo=FALSE, out.width="100%", fig.width = 6, fig.height = 3}
p1 <- gapminder %>% filter(year == 2012) %>%
ggplot(aes(continent, life_expectancy)) +
geom_point()
p2 <- p1 +
scale_y_continuous(limits = c(0, 84))
grid.arrange(p2, p1, ncol = 2)
```

Tengan en cuenta que en el gráfico de la izquierda, que incluye 0, el espacio entre 0 y 43 no agrega información y hace que sea más difícil comparar la variabilidad entre y dentro del grupo.


## No distorsionar cantidades

Durante el discurso del Estado de la Unión de 2011 del Presidente Barack Obama, se utilizó el siguiente gráfico para comparar el PIB de EE. UU. con el PIB de cuatro naciones competidoras:

```{r, echo=FALSE}
## idea from http://paldhous.github.io/ucb/2016/dataviz/img/class2_30.jpg
## screen shot my own from state of the union
knitr::include_graphics(file.path(img_path, "state-of-the-union.png"))
```
(Fuente: The 2011 State of the Union Address^[https://www.youtube.com/watch?v=kl2g40GoRxg])

Si juzgamos por el área de los círculos, Estados Unidos parece tener una economía cinco veces más grande que la de China y más de 30 veces más grande que la de Francia. Sin embargo, si nos fijamos en los números actuales, vemos que este no es el caso. Las proporciones son 2.6 y 5.8 veces mayores que las de China y Francia, respectivamente. La razón de esta distorsión es que el radio del círculo, en lugar del área, se hizo proporcional a la cantidad, lo que implica que la proporción entre las áreas es cuadrada: 2.6 se convierte en 6.5 y 5.8 se convierte en 34.1. Aquí hay una comparación de los círculos que obtenemos si hacemos que el valor sea proporcional al radio y al área:

```{r area-not-radius, echo = FALSE}
gdp <- c(14.6, 5.7, 5.3, 3.3, 2.5)
gdp_data <- data.frame(Country = rep(c("United States", "China", "Japan", "Germany", "France"),2),
y = factor(rep(c("Radius","Area"),each=5), levels = c("Radius", "Area")),
GDP= c(gdp^2/min(gdp^2), gdp/min(gdp))) %>%
mutate(Country = reorder(Country, GDP))
gdp_data %>%
ggplot(aes(Country, y, size = GDP)) +
geom_point(show.legend = FALSE, color = "blue") +
scale_size(range = c(2,25)) +
coord_flip() + ylab("") + xlab("")
```

No sorprende entonces que por defecto __ggplot2__ use el área en lugar del radio. Sin embargo, en este caso, realmente no deberíamos usar el área, ya que podemos usar la posición y la longitud:

```{r barplot-better-than-area, out.width="50%", echo=FALSE}
gdp_data %>%
filter(y == "Area") %>%
ggplot(aes(Country, GDP)) +
geom_bar(stat = "identity", width = 0.5) +
ylab("GDP in trillions of US dollars")
```

## Ordenar categorías por un valor significativo

Cuando uno de los ejes se usa para mostrar categorías, como se hace en los diagramas de barras, el comportamiento por defecto de __ggplot2__ es ordenar las categorías alfabéticamente cuando se definen por cadenas de caracteres. Si están definidas por factores, se ordenan según los niveles de factores. Raras veces queremos usar el orden alfabético. En cambio, debemos ordenar por una cantidad significativa. En todos los casos anteriores, los diagramas de barras se ordenaron según los valores que mostraban. La excepción fueron los diagramas de barras comparando navegadores. En ese caso, mantuvimos el orden igual en todos los diagramas de barras para facilitar la comparación. Específicamente, en vez de ordenar los navegadores por separado en los dos años, ordenamos ambos años por el valor promedio de 2000 y 2015.


Anteriormente aprendimos a usar la función `reorder`, que nos ayuda a lograr este objetivo. Para apreciar cómo el orden correcto puede ayudar a transmitir un mensaje, supongamos que queremos crear un gráfico para comparar la tasa de homicidios en todos los estados de EE.UU.. Estamos particularmente interesados en los estados más peligrosos y los más seguros. Tengan en cuenta la diferencia cuando ordenamos alfabéticamente, la accion por defecto, versus cuando ordenamos por la tasa real:

```{r do-not-order-alphabetically, fig.height = 5, echo=FALSE}
data(murders)
p1 <- murders %>% mutate(murder_rate = total/ population * 100000) %>%
ggplot(aes(state, murder_rate)) +
geom_bar(stat="identity") +
coord_flip() +
theme(axis.text.y = element_text(size = 8)) +
xlab("")

p2 <- murders %>% mutate(murder_rate = total/ population * 100000) %>%
mutate(state = reorder(state, murder_rate)) %>%
ggplot(aes(state, murder_rate)) +
geom_bar(stat="identity") +
coord_flip() +
theme(axis.text.y = element_text(size = 8)) +
xlab("")

grid.arrange(p1, p2, ncol = 2)
```

Podemos hacer el segundo gráfico así:

```{r, eval=FALSE}
data(murders)
murders %>% mutate(murder_rate = total/ population * 100000) %>%
mutate(state = reorder(state, murder_rate)) %>%
ggplot(aes(state, murder_rate)) +
geom_bar(stat="identity") +
coord_flip() +
theme(axis.text.y = element_text(size = 6)) +
xlab("")
```

La función `reorder` también nos permite reordenar grupos. Anteriormente vimos un ejemplo relacionado con la distribución de ingresos entre regiones. Aquí vemos las dos versiones graficadas una contra la otra:

```{r reorder-boxplot-example, out.width="100%", echo=FALSE}
past_year <- 1970
p1 <- gapminder %>%
mutate(dollars_per_day = gdp/population/365) %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(region, dollars_per_day)) +
geom_boxplot() +
geom_point() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab("")

p2 <- gapminder %>%
mutate(dollars_per_day = gdp/population/365) %>%
filter(year == past_year & !is.na(gdp)) %>%
mutate(region = reorder(region, dollars_per_day, FUN = median)) %>%
ggplot(aes(region, dollars_per_day)) +
geom_boxplot() +
geom_point() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab("")

grid.arrange(p1, p2, nrow=1)
```

El primer gráfico ordena las regiones alfabéticamente, mientras que el segundo las ordena por la mediana del grupo.

## Mostrar los datos

Nos hemos enfocado en mostrar cantidades únicas en todas las categorías. Ahora cambiamos nuestra atención a la visualización de datos, con un enfoque en la comparación de grupos.

Para motivar nuestro primer principio, "mostrar los datos", volvemos a nuestro ejemplo artificial de describir alturas a ET, un extraterrestre. Esta vez supongamos que ET está interesado en la diferencia de alturas entre hombres y mujeres. Un gráfico comúnmente utilizado para comparaciones entre grupos y popularizado por software como Microsoft Excel, es el _dynamite plot_, que muestra el promedio y los errores estándar (los errores estándar se definen en un capítulo posterior, pero no los confundan con la desviación estándar de los datos). El gráfico se ve así:

```{r show-data-1, echo=FALSE, fig.height=6}
data("heights")
p1 <- heights %>%
group_by(sex) %>%
summarize(average = mean(height), se=sd(height)/sqrt(n())) %>%
ggplot(aes(sex, average)) +
theme_excel() +
geom_errorbar(aes(ymin = average - 2*se, ymax = average+2*se), width = 0.25) +
geom_bar(stat = "identity", width=0.5, fill = "blue", color = "black") +
ylab("Height in inches")
p1
```

El promedio de cada grupo está representado por la parte superior de cada barra y las antenas se extienden desde el promedio al promedio más dos errores estándar. Si todo lo que ET recibe es este gráfico, tendrá poca información sobre qué esperar si se encuentra con un grupo de hombres y mujeres. Las barras van a 0: ¿esto significa que hay humanos pequeños que miden menos de un pie? ¿Todos los varones son más altos que las hembras más altas? ¿Hay una rango de alturas? ET no puede responder a estas preguntas ya que casi no le hemos dado información sobre la distribución de altura.

Esto nos lleva a nuestro primer principio: mostrar los datos. Este código sencillo de __ggplot2__ ya genera un gráfico más informativo que el diagrama de barras al simplemente mostrar todos los puntos de datos:

```{r show-data-2}
heights %>%
ggplot(aes(sex, height)) +
geom_point()
```

El gráfico anterior nos da una idea del rango de los datos. Sin embargo, este gráfico también tiene limitaciones, ya que realmente no podemos ver todos los `r sum(heights$sex=="Female")` y `r sum(heights$sex == "Male")` puntos graficados para hembras y varones, respectivamente, y muchos puntos están graficados uno encima del otro. Como hemos descrito anteriormente, visualizar la distribución es mucho más informativo. Pero antes de hacer esto, señalamos dos formas en que podemos mejorar un gráfico que muestra todos los puntos.

El primero es agregar _jitter_, que añade un pequeño desplazamiento aleatorio a cada punto. En este caso, agregar _jitter_ horizontal no cambia la interpretación, ya que las alturas de los puntos no cambian, pero minimizamos el número de puntos que se superponen y, por lo tanto, tenemos una mejor idea visual de cómo se distribuyen los datos. Una segunda mejora proviene del uso de _alpha blending_, que hace que los puntos sean algo transparentes. Entre más puntos se superponen, más oscuro será el gráfico, que también nos ayuda tener una idea de cómo se distribuyen los puntos. Aquí está el mismo gráfico con _jitter_ y _alpha blending_:

```{r show-points-with-jitter}
heights %>%
ggplot(aes(sex, height)) +
geom_jitter(width = 0.1, alpha = 0.2)
```

Ahora comenzamos a sentir que, en promedio, los varones son más altos que las hembras. También observamos bandas horizontales oscuras de puntos, que demuestra que muchos estudiantes indican valores que se redondean al entero más cercano.

## Cómo facilitar comparaciones

### Use ejes comunes

Como hay tantos puntos, es más efectivo mostrar distribuciones que puntos individuales. Por lo tanto, mostramos histogramas para cada grupo:

```{r common-axes-histograms-wrong, echo=FALSE}
heights %>%
ggplot(aes(height, ..density..)) +
geom_histogram(binwidth = 1, color="black") +
facet_grid(.~sex, scales = "free_x")
```

Sin embargo, mirando el gráfico arriba, no es inmediatamente obvio que los varones son, en promedio, más altos que las hembras. Tenemos que mirar cuidadosamente para notar que el eje-x tiene un rango más alto de valores en el histograma masculino. Un principio importante aquí es **mantener los ejes iguales** cuando se comparan datos en dos gráficos. A continuación, vemos cómo la comparación se vuelve más fácil:

```{r common-axes-histograms-right, echo=FALSE}
heights %>%
ggplot(aes(height, ..density..)) +
geom_histogram(binwidth = 1, color="black") +
facet_grid(.~sex)
```

### Alinee gráficos verticalmente para ver cambios horizontales y horizontalmente para ver cambios verticales

En estos histogramas, la señal visual relacionada con las disminuciones o los aumentos de altura son los cambios hacia la izquierda o hacia la derecha, respectivamente: los cambios horizontales. Alinear los gráficos verticalmente nos ayuda a ver este cambio cuando los ejes son fijos:

```{r common-axes-histograms-right-2, echo = FALSE}
p2 <- heights %>%
ggplot(aes(height, ..density..)) +
geom_histogram(binwidth = 1, color="black") +
facet_grid(sex~.)
p2
```

```{r, eval = FALSE}
heights %>%
ggplot(aes(height, ..density..)) +
geom_histogram(binwidth = 1, color="black") +
facet_grid(sex~.)
```

El gráfico anterior hace que sea mucho más fácil notar que los varones son, en promedio, más altos.

Si queremos obtener el resumen compacto que ofrecen los diagramas de cajas, tenemos que alinearlos horizontalmente ya que, por defecto, los diagramas de cajas se mueven hacia arriba y hacia abajo según los cambios de altura. Siguiendo nuestro principio de "mostrar los datos", superponemos todos los puntos de datos:

```{r boxplot-with-points-with-jitter, echo=FALSE}
p3 <- heights %>%
ggplot(aes(sex, height)) +
geom_boxplot(coef=3) +
geom_jitter(width = 0.1, alpha = 0.2) +
ylab("Height in inches")
p3
```

```{r, eval=FALSE}
heights %>%
ggplot(aes(sex, height)) +
geom_boxplot(coef=3) +
geom_jitter(width = 0.1, alpha = 0.2) +
ylab("Height in inches")
```

Ahora comparen y contrasten estos tres gráficos, basados exactamente en los mismos datos:

```{r show-the-data-comparison, out.width="100%", echo=FALSE}
grid.arrange(p1, p2, p3, ncol = 3)
```

Observen cuánto más aprendemos de los dos gráficos a la derecha. Los diagramas de barras son útiles para mostrar un número, pero no son muy útiles cuando queremos describir distribuciones.

### Considere transformaciones

Hemos motivado el uso de la transformación logarítmica en los casos en que los cambios son multiplicativos. El tamaño de la población fue un ejemplo en el que encontramos que una transformación logarítmica produjo una transformación más informativa.

La combinación de un diagrama de barras elegido incorrectamente y no usar una transformación logarítimica cuando sea necesaria puede ser particularmente distorsionante. Como ejemplo, considere este diagrama de barras que muestra los tamaños de población promedio para cada continente en 2015:

```{r no-transformations-wrong-use-of-barplot, echo=FALSE}
data(gapminder)
p1 <- gapminder %>%
filter(year == 2015) %>%
group_by(continent) %>%
summarize(population = mean(population)) %>%
mutate(continent = reorder(continent, population)) %>%
ggplot(aes(continent, population/10^6)) +
geom_bar(stat = "identity", width=0.5, fill="blue") +
theme_excel() +
ylab("Population in Millions") +
xlab("Continent")
p1
```

Mirando el gráfico anterior, uno concluiría que los países de Asia son mucho más poblados que los de otros continentes. Siguiendo el principio de "mostrar los datos", notamos rápidamente que esto se debe a dos países muy grandes, que suponemos son India y China:

```{r no-transformation, echo=FALSE}
p2 <- gapminder %>% filter(year == 2015) %>%
mutate(continent = reorder(continent, population, median)) %>%
ggplot(aes(continent, population/10^6)) +
ylab("Population in Millions") +
xlab("Continent")
p2 + geom_jitter(width = .1, alpha = .5)
```

El uso de una transformación logarítmica aquí produce un gráfico mucho más informativo. Comparamos el diagrama de barras original con un diagrama de caja usando la transformación de escala logarítmica para el eje-y:


```{r correct-transformation, out.width="100%", echo=FALSE, fig.height=3.5}
p2 <- p2 + geom_boxplot(coef=3) +
geom_jitter(width = .1, alpha = .5) +
scale_y_log10(breaks = c(1,10,100,1000)) +
theme(axis.text.x = element_text(size = 7))
grid.arrange(p1, p2, ncol = 2)
```

Con el nuevo gráfico, nos damos cuenta de que los países de África en realidad tienen una población mediana mayor que los de Asia.

Otras transformaciones que deben considerar son la transformación logística (`logit`), que es útil para ver mejor los cambios en las probabilidades, y la transformación de la raíz cuadrada (`sqrt`), que es útil para conteos.

### Señales visuales que se van a comparar deben estar adyacentes

Para cada continente, comparemos los ingresos en 1970 versus 2010. Al comparar los datos de ingresos entre regiones entre 1970 y 2010, hicimos un gráfico similar al siguiente, pero esta vez investigamos continentes en lugar de regiones.

```{r boxplots-not-adjacent, echo=FALSE}
gapminder %>%
filter(year %in% c(1970, 2010) & !is.na(gdp)) %>%
mutate(dollars_per_day = gdp/population/365) %>%
mutate(labels = paste(year, continent)) %>%
ggplot(aes(labels, dollars_per_day)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
ylab("Income in dollars per day")
```


El comportamiento por defecto de __ggplot2__ es ordenar las etiquetas alfabéticamente para que las etiquetas con 1970 aparezcan antes que las etiquetas con 2010. Esto dificulta las comparaciones porque la distribución de un continente en 1970 está visualmente lejos de su distribución en 2010. Es mucho más fácil hacer la comparación entre 1970 y 2010 para cada continente cuando los diagramas de caja para ese continente están uno al lado del otro:

```{r boxplot-adjacent-comps, echo=FALSE}
gapminder %>%
filter(year %in% c(1970, 2010) & !is.na(gdp)) %>%
mutate(dollars_per_day = gdp/population/365) %>%
mutate(labels = paste(continent, year)) %>%
ggplot(aes(labels, dollars_per_day)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
ylab("Income in dollars per day")
```

### Use color

La comparación se hace aún más fácil si usamos color para denotar las dos cosas que queremos comparar:


```{r boxplot-adjacent-comps-with-color, echo=FALSE}
gapminder %>%
filter(year %in% c(1970, 2010) & !is.na(gdp)) %>%
mutate(dollars_per_day = gdp/population/365, year = factor(year)) %>%
ggplot(aes(continent, dollars_per_day, fill = year)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
ylab("Income in dollars per day")
```


## Piense en los daltónicos

Alrededor de 10% de la población es daltónica. Desafortunadamente, los colores por defecto utilizados en __ggplot2__ no son óptimos para este grupo. Sin embargo, __ggplot2__ hace fácil cambiar la paleta de colores utilizada en los gráficos. Aquí se describe un ejemplo de cómo podemos usar una paleta que considera los daltónicos: [http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palettefont](http:// www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette):

```{r, eval=FALSE}
color_blind_friendly_cols <-
c("#999999", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

Aquí están los colores:
```{r color-blind-friendly-colors, echo=FALSE, fig.height=0.5}
color_blind_friendly_cols <-
c("#999999", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7")

p1 <- data.frame(x=1:8, y=rep(1,8), col = as.character(1:8)) %>%
ggplot(aes(x, y, color = col)) +
geom_point(size=8, show.legend = FALSE) +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())

p1 + scale_color_manual(values=color_blind_friendly_cols)
```

Además, hay varios recursos que pueden ayudarlos a seleccionar colores, por ejemplo este: [http://bconnelly.net/2013/10/creating-colorblind-friendly-figures/font](http://bconnelly.net/2013/10/ creating-colorblind-friendly-figures/).

## Gráficos para dos variables

En general, deben usar diagramas de dispersión para visualizar la relación entre dos variables. Para cada caso en el que hemos examinado la relación entre dos variables, incluyendo asesinatos totales versus tamaño de población, esperanza de vida versus tasas de fertilidad y mortalidad infantil versus ingresos, hemos utilizado diagramas de dispersión y ese es el gráfico que generalmente recomendamos. Sin embargo, hay algunas excepciones y aquí describimos dos gráficos alternativos: el _slope chart_ y el _gráfico Bland-Altman_.

### Slope charts

Una excepción en la que otro tipo de gráfico puede ser más informativo es cuando se comparan variables del mismo tipo, pero en diferentes momentos y para un número relativamente pequeño de comparaciones. Por ejemplo, si estamos comparando la esperanza de vida entre 2010 y 2015. En ese caso, podríamos recomendar un _slope chart_.

No hay geometría para los _slope charts_ en __ggplot2__, pero podemos construir una usando `geom_line`. Necesitamos hacer algunos ajustes para agregar etiquetas. A continuación, mostramos un ejemplo que compara 2010 a 2015 para los grandes países occidentales:

```{r slope-plot}
west <- c("Western Europe","Northern Europe","Southern Europe",
"Northern America","Australia and New Zealand")

dat <- gapminder %>%
filter(year%in% c(2010, 2015) & region %in% west &
!is.na(life_expectancy) & population > 10^7)

dat %>%
mutate(location = ifelse(year == 2010, 1, 2),
location = ifelse(year == 2015 &
country %in% c("United Kingdom", "Portugal"),
location+0.22, location),
hjust = ifelse(year == 2010, 1, 0)) %>%
mutate(year = as.factor(year)) %>%
ggplot(aes(year, life_expectancy, group = country)) +
geom_line(aes(color = country), show.legend = FALSE) +
geom_text(aes(x = location, label = country, hjust = hjust),
show.legend = FALSE) +
xlab("") + ylab("Life Expectancy")
```

Una ventaja del _slope chart_ es que rápidamente nos permite tener una idea de los cambios basados en la pendiente de las líneas. Aunque estamos usando el ángulo como señal visual, también posición para determinar los valores exactos. Comparar las mejoras es un poco más difícil con un diagrama de dispersión:


```{r scatter-plot-instead-of-slope, echo=FALSE}
library(ggrepel)
west <- c("Western Europe","Northern Europe","Southern Europe",
"Northern America","Australia and New Zealand")

dat <- gapminder %>%
filter(year%in% c(2010, 2015) & region %in% west &
!is.na(life_expectancy) & population > 10^7)

dat %>%
mutate(year = paste0("life_expectancy_", year)) %>%
select(country, year, life_expectancy) %>%
spread(year, life_expectancy) %>%
ggplot(aes(x=life_expectancy_2010,y=life_expectancy_2015, label = country)) +
geom_point() + geom_text_repel() +
scale_x_continuous(limits=c(78.5, 83)) +
scale_y_continuous(limits=c(78.5, 83)) +
geom_abline(lty = 2) +
xlab("2010") +
ylab("2015")
```

En el diagrama de dispersión, hemos seguido el principio de _usar ejes comunes_ porque estamos comparando estos antes y después. Sin embargo, si tenemos muchos puntos, los _slope charts_ dejan de ser útiles ya que se hace difícil ver todas las líneas.

### Gráfico Bland-Altman

Como estamos interesados principalmente en la diferencia, tiene sentido dedicarle uno de nuestros ejes. El gráfico Bland-Altman, también conocido como el gráfico de diferencia de medias de Tukey y como el _MA plot_, muestra la diferencia versus el promedio:

```{r, bland-altman}
library(ggrepel)
dat %>%
mutate(year = paste0("life_expectancy_", year)) %>%
select(country, year, life_expectancy) %>%
spread(year, life_expectancy) %>%
mutate(average = (life_expectancy_2015 + life_expectancy_2010)/2,
difference = life_expectancy_2015 - life_expectancy_2010) %>%
ggplot(aes(average, difference, label = country)) +
geom_point() +
geom_text_repel() +
geom_abline(lty = 2) +
xlab("Average of 2010 and 2015") +
ylab("Difference between 2015 and 2010")
```

Aquí, al simplemente mirar el eje-y, rápidamente vemos qué países han mostrado la mayor mejora. También, obtenemos una idea del valor general del eje-x.

## Cómo codificar una tercera variable

Un diagrama de dispersión anterior mostró la relación entre la supervivencia infantil y el ingreso promedio. A continuación se muestra una versión de este gráfico que codifica tres variables: pertenencia a OPEC, región y población.

```{r encoding-third-variable, echo=FALSE}
present_year <- 2010

dat <- gapminder %>%
mutate(region = case_when(
region %in% west ~ "The West",
region %in% "Northern Africa" ~ "Northern Africa",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region == "Southern Asia"~ "Southern Asia",
region %in% c("Central America", "South America", "Caribbean") ~ "Latin America",
continent == "Africa" & region != "Northern Africa" ~ "Sub-Saharan Africa",
region %in% c("Melanesia", "Micronesia", "Polynesia") ~ "Pacific Islands"),
dollars_per_day = gdp/ population/ 365) %>%
filter(year %in% present_year & !is.na(gdp) & !is.na(infant_mortality) & !is.na(region) ) %>%
mutate(OPEC = ifelse(country%in%opec, "Yes", "No"))

dat %>%
ggplot(aes(dollars_per_day, 1 - infant_mortality/1000,
col = region, size = population/10^6,
pch = OPEC)) +
scale_x_continuous(trans = "log2", limits=c(0.25, 150)) +
scale_y_continuous(trans = "logit",limit=c(0.875, .9981),
breaks=c(.85,.90,.95,.99,.995,.998)) +
geom_point(alpha = 0.5) +
ylab("Infant survival proportion")
```

Codificamos variables categóricas con color y forma. Estas formas se pueden controlar con el argumento `shape`. Abajo mostramos las formas disponibles para su uso en R. Para los últimos cinco, el color rellena la forma.

```{r available-shapes, echo=FALSE, fig.height=2.25}
dat=data.frame(x=c(0:25))
ggplot() +
theme_minimal() +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_shape_identity() + scale_y_reverse() +
geom_point(dat, mapping=aes(x%%9, x%/%9, shape=x), size=4, fill="blue") +
geom_text(dat, mapping=aes(x%%9, x%/%9+0.25, label=x), size=4)
```

Para variables continuas, podemos usar color, intensidad o tamaño. A continuación ofrecemos un ejemplo de cómo hacer esto con un estudio de caso.

Al seleccionar colores para cuantificar una variable numérica, elegimos entre dos opciones: secuenciales y divergentes. Los colores secuenciales son adecuados para datos que van de mayor a menor. Los valores altos se distinguen claramente de los valores bajos. Aquí tenemos algunos ejemplos ofrecidos por el paquete `RColorBrewer`:

```{r eval=FALSE}
library(RColorBrewer)
display.brewer.all(type="seq")
```

```{r r-color-brewer-seq, fig.height=3.5, echo=FALSE}
library(RColorBrewer)
rafalib::mypar()
display.brewer.all(type="seq")
```

Los colores divergentes se utilizan para representar valores que divergen de un centro. Ponemos igual énfasis en ambos extremos del rango de datos: más alto que el centro y más bajo que el centro. Un ejemplo de cuándo usaríamos un patrón divergente sería cuando mostramos la altura en cuántas desviaciones estándar están del promedio. Aquí hay algunos ejemplos de patrones divergentes:

```{r eval=FALSE}
library(RColorBrewer)
display.brewer.all(type="div")
```


```{r r-color-brewer-div, fig.height=2.5, echo=FALSE}
library(RColorBrewer)
rafalib::mypar()
display.brewer.all(type="div")
```


## Evite los gráficos pseudo-tridimensionales

La siguiente figura, tomada de la literatura científica^[https://projecteuclid.org/download/pdf_1/euclid.ss/1177010488],
muestra tres variables: dosis, tipo de fármaco y supervivencia. Aunque sus pantallas/páginas de libros son planas y bidimensionales, el gráfico intenta imitar tres dimensiones y asigna una dimensión a cada variable.

```{r, echo=FALSE}
## https://raw.githubusercontent.com/kbroman/Talk_Graphs/master/Figs/fig8b.png
knitr::include_graphics(file.path(img_path,"fig8b.png"))
```
(Imagen cortesía de Karl Broman)

Los humanos no son buenos para ver en tres dimensiones (que explica por qué es difícil estacionar en paralelo) y nuestra limitación es aún peor con respecto a las pseudo-tres dimensiones. Para ver esto, intenten determinar los valores de la variable de supervivencia en el gráfico anterior. ¿Pueden decir cuándo la cinta púrpura se cruza con la roja? Este es un ejemplo en el que podemos fácilmente usar  color para representar la variable categórica en lugar de un pseudo-3D:

```{r colors-for-different-lines, echo=FALSE}
##First read data
url <- "https://github.com/kbroman/Talk_Graphs/raw/master/R/fig8dat.csv"
dat <- read.csv(url)

##Now make alternative plot
dat %>% gather(drug, survival, -log.dose) %>%
mutate(drug = gsub("Drug.","",drug)) %>%
ggplot(aes(log.dose, survival, color = drug)) +
geom_line()
```

Observe cuánto más fácil es determinar los valores de supervivencia.

Pseudo-3D a veces se usa de forma totalmente gratuita: los gráficos se hacen para que se vean en 3D incluso cuando la tercera dimensión no representa una cantidad. Esto solo agrega confusión y hace que sea más difícil transmitir su mensaje. Aquí hay dos ejemplos:

```{r, echo=FALSE, out.width="45%"}
##https://raw.githubusercontent.com/kbroman/Talk_Graphs/master/Figs/fig1e.png
##https://raw.githubusercontent.com/kbroman/Talk_Graphs/master/Figs/fig2d.png
knitr::include_graphics(file.path(img_path,c("fig1e.png", "fig2d.png")))
```
(Imágenes cortesía de Karl Broman)


## Evite demasiados dígitos significativos

Por defecto, el software estadístico como R devuelve muchos dígitos significativos. El comportamiento por defecto en R es mostrar 7 dígitos significativos. Esa cantidad de dígitos a menudo no añade información y el desorden visual agregado puede dificultar que se entienda el mensaje. Como ejemplo, aquí están las tasas de enfermedades por cada 10,000 para California en cinco décadas, calculadas de los totales y la población con R:

```{r, echo=FALSE}
data(us_contagious_diseases)
tmp <- options()$digits
options(digits=7)
dat <- us_contagious_diseases %>%
filter(year %in% seq(1940, 1980, 10) & state == "California" &
disease %in% c("Measles", "Pertussis", "Polio")) %>%
mutate(rate = count/ population * 10000) %>%
mutate(state = reorder(state, rate)) %>%
select(state, year, disease, rate) %>%
spread(disease, rate)
if(knitr::is_html_output()){
knitr::kable(dat, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(dat, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
options(digits=tmp)
```

Estamos reportando precisión de hasta 0.00001 casos por 10,000, un valor muy pequeño en el contexto de los cambios que ocurren a través del tiempo. En este caso, dos cifras significativas son más que suficientes y claramente indican que las tasas están disminuyendo:

```{r, echo = FALSE}
dat <- dat %>%
mutate_at(c("Measles", "Pertussis", "Polio"), ~round(., digits=1))
if(knitr::is_html_output()){
knitr::kable(dat, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(dat, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size=8)
}
```

Para cambiar el número de dígitos significativos o redondear números usamos `signif` y `round`. Pueden definir el número de dígitos significativos a nivel mundial configurando opciones como esta: `options(digits = 3)`.


Otro principio relacionado con la visualización de tablas es colocar los valores que se comparan en columnas en lugar de filas. Observen que nuestra tabla anterior es más fácil de leer que esta:

```{r, echo=FALSE}
dat <- us_contagious_diseases %>%
filter(year %in% seq(1940, 1980, 10) & state == "California" &
disease %in% c("Measles", "Pertussis", "Polio")) %>%
mutate(rate = count/ population * 10000) %>%
mutate(state = reorder(state, rate)) %>%
select(state, year, disease, rate) %>%
spread(year, rate) %>%
mutate_if(is.numeric, round, digits=1)
if(knitr::is_html_output()){
knitr::kable(dat, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(dat, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

## Conozca a su audiencia

Los gráficos se pueden usar para 1) nuestros propios análisis exploratorios de datos, 2) para transmitir un mensaje a los expertos o 3) para ayudar a contar una historia a una audiencia general. Asegúrense de que el público destinario comprenda cada elemento del gráfico.

Como un ejemplo sencillo, considere que para su propia exploración puede ser más útil transformar logarítmicamente los datos y luego graficarlos. Sin embargo, para una audiencia general que no está familiarizada con la conversión de valores logarítmicos a las medidas originales, será mucho más fácil entender el uso de una escala logarítmica para el eje en lugar de los valores transformados logarítmicamente.


## Ejercicios


Para estos ejercicios, utilizaremos los datos de vacunas en el paquete __dslabs__:

```{r}
library(dslabs)
data(us_contagious_diseases)
```

1\. Los gráficos circulares son apropiados:

a. Cuando queremos mostrar porcentajes.
b. Cuando __ggplot2__ no está disponible.
c. Cuando estoy jugando frisbee.
d. Nunca. Los diagramas de barras y las tablas siempre son mejores.

2\. ¿Cuál es el problema con el siguiente gráfico?

```{r baplot-not-from-zero-exercises, echo=FALSE, message=FALSE}
library(tidyverse)
ds_theme_set()
data.frame(candidate=c("Clinton","Trump"), electoral_votes = c(232, 306)) %>%
ggplot(aes(candidate, electoral_votes)) +
geom_bar(stat = "identity", width=0.5, color =1, fill = c("Blue","Red")) +
coord_cartesian(ylim=c(200,310)) +
ylab("Electoral Votes") +
xlab("") +
ggtitle("Results of Presidential Election 2016")
```

a. Los valores están mal. La votación final fue de 306 a 232.
b. El eje no comienza en 0. Juzgando por la longitud, parece que Trump recibió 3 veces más votos cuando, de hecho, fue aproximadamente 30% más.
c. Los colores deben ser iguales.
d. Los porcentajes deben mostrarse como un gráfico circular.


3\. Mire a los siguientes dos gráficos. Muestran la misma información: tasas de sarampión de 1928 en los 50 estados.

```{r measels-exercise, fig.height = 5, echo=FALSE}
library(gridExtra)
p1 <- us_contagious_diseases %>%
filter(year == 1928 & disease=="Measles" & count>0 & !is.na(population)) %>%
mutate(rate = count/ population * 10000 * 52/ weeks_reporting) %>%
ggplot(aes(state, rate)) +
geom_bar(stat="identity") +
coord_flip() +
xlab("")

p2 <- us_contagious_diseases %>%
filter(year == 1928 & disease=="Measles" & count>0 & !is.na(population)) %>%
mutate(rate = count/ population * 10000*52/ weeks_reporting) %>%
mutate(state = reorder(state, rate)) %>%
ggplot(aes(state, rate)) +
geom_bar(stat="identity") +
coord_flip() +
xlab("")
grid.arrange(p1, p2, ncol = 2)
```
¿Qué gráfico es más fácil de leer si quieren determinar cuáles son los mejores y peores estados en términos de tasas, y por qué?

a. Dan la misma información, por lo que ambos son igual de buenos.
b. El gráfico de la derecha es mejor porque ordena los estados alfabéticamente.
c. El gráfico de la derecha es mejor porque el orden alfabético no tiene nada que ver con la enfermedad y al ordenar según la tasa real, rápidamente vemos los estados con las tasas más altas y más bajas.
d. Ambos gráficos deben ser un gráfico circular.


4\. Para hacer el gráfico de la izquierda, tenemos que reordenar los niveles de las variables de los estados.

```{r}
dat <- us_contagious_diseases %>%
filter(year == 1967 & disease=="Measles" & !is.na(population)) %>%
mutate(rate = count/ population * 10000 * 52/ weeks_reporting)
```


Recuerde lo que sucede cuando hacemos un diagrama de barras:

```{r barplot-plot-exercise-example, fig.height = 5}
dat %>% ggplot(aes(state, rate)) +
geom_bar(stat="identity") +
coord_flip()
```

Defina estos objetos:

```{r, eval=FALSE}
state <- dat$state
rate <- dat$count/dat$population*10000*52/dat$weeks_reporting
```

Redefina el objeto `state` para que los niveles se reordenen. Imprima el nuevo objeto `state` y sus niveles para que pueda ver que los niveles no reordenan el vector.


5\. Ahora edite el código de arriba para redefinir `dat` para que los niveles de la variable `state` se reordenen por la variable `rate`. Luego haga un diagrama de barras usando el código anterior, pero para este nuevo `dat`.


6\. Digamos que está interesado en comparar las tasas de homicidios con armas de fuego en todas las regiones de los EE. UU. Ve este gráfico:


```{r us-murders-barplot}
library(dslabs)
data("murders")
murders %>% mutate(rate = total/population*100000) %>%
group_by(region) %>%
summarize(avg = mean(rate)) %>%
mutate(region = factor(region)) %>%
ggplot(aes(region, avg)) +
geom_bar(stat="identity") +
ylab("Murder Rate Average")
```


y decide mudarse a un estado en la región occidental. ¿Cuál es el problema principal con esta interpretación?

a. Las categorías están ordenadas alfabéticamente.
b. El gráfico no muestra errores estándar.
c. El gráfico no muestra todos los datos. No vemos la variabilidad dentro de una región y es posible que los estados más seguros no estén en el occidente.
d. El noreste tiene el promedio más bajo.


7\. Haga un diagrama de cajas de las tasas de asesinatos que se definen como:

```{r, eval = FALSE}
data("murders")
murders %>% mutate(rate = total/population*100000)
```

por región, mostrando todos los puntos y ordenando las regiones por su tasa mediana.


8\. Los gráficos a continuación muestran tres variables continuas.

```{r pseudo-3d-exercise, fig.width=7, fig.height = 3.708, echo=FALSE}
library(scatterplot3d)
library(RColorBrewer)
set.seed(1)
n <- 25
group <- rep(1,n)
group[1:(round(n/2))] <- 2
x <- rnorm(n, group, .33)
y <- rnorm(n, group, .33)
z <- rnorm(n)
rafalib::mypar()
scatterplot3d(x,y,z, color = group, pch=16, ylab="")
text(8.25, -1.5, label = "y")
abline(v=4, col=3)
```

La línea $x=2$ parece separar los puntos. Pero en realidad no es el caso, como vemos cuando graficamos los datos en un par de puntos bidimensionales.

```{r pseud-3d-exercise-2, echo=FALSE, fig.height = 3}
rafalib::mypar(1,2)
plot(x,y, col=group, pch =16)
abline(v=2, col=3)
plot(x,z,col=group, pch=16)
abline(v=2, col=3)
```

¿Por qué pasa esto?

a. Los humanos no son buenos para leer gráficos pseudo-3D.
b. Debe haber un error en el código.
c. Los colores nos confunden.
d. Los diagramas de dispersión no se deben usar para comparar dos variables cuando tenemos acceso a tres variables.


9\. Reproduzca el gráfico de imagen que hicimos anteriormente pero para la viruela. Para este gráfico, no incluya años en los que no se indicaron casos en 10 o más semanas.


10\. Ahora reproduzca el gráfico de series de tiempo que hicimos anteriormente, pero esta vez siguiendo las instrucciones de la pregunta anterior.


11\. Para el estado de California, haga gráficos de series de tiempo que muestren las tasas de todas las enfermedades. Incluya solo años en los cuales se proveen datos en 10 o más semanas. Use un color diferente para cada enfermedad.


12\. Ahora haga lo mismo con las tasas para EE. UU.. Sugerencia: calcule la tasa de EE. UU. usando `summarize`, el total de casos dividido por la población total.
