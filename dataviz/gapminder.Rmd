# Visualización de datos en la práctica {#gapminder}

En este capítulo, demostraremos cómo el código relativamente sencillo __ggplot2__  puede crear gráficos perspicaces y estéticamente agradables. Como motivación, crearemos gráficos que nos ayudarán a comprender mejor las tendencias de la salud y la economía mundial. Implementaremos lo que aprendimos en los capítulos \@ref(ggplot2) y \@ref(other-geometries) y aprenderemos a aumentar el código para perfeccionar los gráficos. A medida que avancemos en nuestro estudio de caso, describiremos [fix] los principios generales relevantes de visualización de datos y aprenderemos conceptos como _fabricación_, _gráficos de series de tiempo_, _transformaciones_y_ gráficos de refrigerador_.


## Estudio de caso: nuevas ideas sobre la pobreza

Hans Rosling^[https://en.wikipedia.org/wiki/Hans_Rosling] fue el cofundador de la Fundación Gapminder^[http://www.gapminder.org/], una organización dedicada a educar al público mediante datos para disipar mitos comunes sobre el llamado mundo en desarrollo. La organización utiliza datos para mostrar cómo las tendencias reales en los campos de salud y economía contradicen las narrativas que emanan de la cobertura sensacionalista de los medios de catástrofes, tragedias y otros eventos desafortunados. Como se indica en el sitio web de la Fundación Gapminder: [fix?]

>>> Periodistas y cabilderos cuentan historias dramáticas. Ese es su trabajo. Cuentan historias sobre eventos extraordinarios y personas inusuales. Las pilas de historias dramáticas se acumulan en las mentes de las personas en una visión del mundo demasiado dramática y fuertes sentimientos de estrés negativo: "¡El mundo está empeorando!", "¡Somos nosotros contra ellos!", "¡Otras personas son extrañas!", " ¡La población sigue creciendo! " y "a nadie le importa!"

[fix] Hans Rosling reportó tendencias basadas en datos reales de una manera dramática propia, utilizando una visualización de datos efectiva. Esta sección se basa en dos charlas que ejemplifican este enfoque educativo: [Nuevas ideas sobre la pobreza]^[https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en] y Las mejores estadísticas que has visto^[https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen]. Específicamente, en esta sección, usamos datos para intentar responder a las siguientes dos preguntas:

1. ¿Es una caracterización justa del mundo de hoy decir que está dividido en naciones ricas occidentales y el mundo en desarrollo de África, Asia y América Latina?
2. ¿Ha empeorado la desigualdad de ingresos en todos los países durante los últimos 40 años?

Para responder a estas preguntas, utilizaremos el set de datos `gapminder` proveído por __dslabs__. Este set de datos se creó utilizando varias hojas de cálculo disponibles de la Fundación Gapminder. Puede acceder a la tabla de esta manera:

```{r load libraries, message=FALSE, echo=TRUE}
library(tidyverse)
library(dslabs)
data(gapminder)
gapminder %>% as_tibble()
```

### Prueba de Hans Rosling

Como se hizo en el video _New Insights on Poverty_, comenzamos probando nuestro conocimiento sobre las diferencias en la mortalidad infantil en diferentes países. Para cada uno de los seis pares de países a continuación, ¿qué país cree que tuvo las tasas de mortalidad infantil más altas en 2015? ¿Qué pares crees que son más similares?

1. Sri Lanka o Turquía
2. Polonia o Corea del Sur
3. Malasia o Rusia
4. Pakistán o Vietnam
5. Tailandia o Sudáfrica

Al responder estas preguntas sin datos, los países no europeos suelen ser elegidos por tener tasas de mortalidad infantil más altas: Sri Lanka sobre Turquía, Corea del Sur sobre Polonia y Malasia sobre Rusia. También es común suponer que los países considerados como parte del mundo en desarrollo: Pakistán, Vietnam, Tailandia y Sudáfrica, tienen tasas de mortalidad igualmente altas.

Para responder estas preguntas __con datos__, podemos usar __dplyr__. Por ejemplo, para la primera comparación vemos que:

```{r, message=FALSE}
gapminder %>%
filter(year == 2015 & country %in% c("Sri Lanka","Turkey")) %>%
select(country, infant_mortality)
```
Turquía tiene la mayor tasa de mortalidad infantil.

Podemos usar este código en todas las comparaciones y encontrar lo siguiente:
```{r, echo = FALSE}
comp_table <- tibble(comparison = rep(1:5, each = 2),
country = c("Sri Lanka", "Turkey", "Poland", "South Korea", "Malaysia", "Russia", "Pakistan","Vietnam","Thailand","South Africa"))

tmp <- gapminder %>%
filter(year == 2015) %>%
select(country, infant_mortality) %>%
mutate(country = as.character(country)) ##to match characters to characters

tab <- inner_join(comp_table, tmp, by = "country") %>% select(-comparison)

tmp <- bind_cols(slice(tab,seq(1,9,2)), slice(tab,seq(2,10,2)))
names(tmp) <- c("country", "infant mortality", "country", "infant mortality")
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Vemos que los países europeos en esta lista tienen tasas de mortalidad infantil más altas: Polonia tiene una tasa más alta que Corea del Sur y Rusia tiene una tasa más alta que Malasia. También vemos que Pakistán tiene una tasa mucho más alta que Vietnam, y Sudáfrica tiene una tasa mucho más alta que Tailandia. Resulta que cuando Hans Rosling dio este cuestionario a grupos educados de personas, el puntaje promedio fue inferior a 2.5 de 5, peor que lo que hubieran obtenido si hubieran adivinado al azar. Esto implica que más que ignorantes, estamos mal informados. En este capítulo vemos cómo la visualización de datos nos ayuda a informarnos.

## Gráfico de dispersión

La razón de esto se deriva de la noción preconcebida de que el mundo está dividido en dos grupos: el mundo occidental (Europa occidental y América del Norte), caracterizado por una larga vida y familias pequeñas, frente al mundo en desarrollo (África, Asia y América Latina ) caracterizados por cortos períodos de vida y familias numerosas. ¿Pero los datos respaldan esta visión dicotómica?

Los datos necesarios para responder esta pregunta también están disponibles en nuestro `gapminder` mesa. Usando nuestras habilidades de visualización de datos recién aprendidas, podremos enfrentar este desafío.

Para analizar esta visión del mundo, nuestro primer diagrama es un diagrama de dispersión de la esperanza de vida versus las tasas de fertilidad (número promedio de hijos por mujer). Comenzamos mirando los datos de hace unos 50 años, cuando quizás esta visión se consolidó por primera vez en nuestras mentes.

```{r fertility-versus-life-expectancy-1962, warning=FALSE}
filter(gapminder, year == 1962) %>%
ggplot(aes(fertility, life_expectancy)) +
geom_point()
```

La mayoría de los puntos se dividen en dos categorías distintas:

1. Esperanza de vida alrededor de 70 años y 3 o menos hijos por familia.
2. Esperanza de vida inferior a 65 años y más de 5 niños por familia.

Para confirmar que estos países son de las regiones que esperamos, podemos usar el color para representar el continente.

```{r fertility-versus-life-expectancy-1962-with-color}
filter(gapminder, year == 1962) %>%
ggplot( aes(fertility, life_expectancy, color = continent)) +
geom_point()
```

En 1962, la visión de "Occidente versus mundo en desarrollo" se basó en alguna realidad. ¿Sigue siendo así 50 años después?

## Facetado

Podríamos graficar fácilmente los datos de 2012 de la misma manera que lo hicimos para 1962. Sin embargo, para hacer comparaciones, es preferible trazar lado a lado. En __ggplot2__, podemos lograr esto _faceting_ variables: estratificamos los datos por alguna variable y hacemos la misma gráfica para cada estrato.

Para lograr facetas, agregamos una capa con la función `facet_grid`, que separa automáticamente las parcelas. Esta función le permite facetar por hasta dos variables usando columnas para representar una variable y filas para representar la otra. La función espera que las variables de fila y columna estén separadas por un `~`. Aquí hay un ejemplo de un diagrama de dispersión con `facet_grid` agregado como la última capa:

```{r fertility-versus-life-expectancy-facet, warning=FALSE, out.width="100%"}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(continent~year)
```

Vemos una parcela para cada par continente/ año. Sin embargo, esto es solo un ejemplo y más de lo que queremos, que es simplemente comparar 1962 y 2012. En este caso, solo hay una variable y usamos `.` para hacerle saber a Facet que no estamos usando una de las variables:

```{r fertility-versus-life-expectancy-two-years, warning=FALSE, out.width="100%", fig.height=3}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(. ~ year)
```

este gráfico muestra claramente que la mayoría de los países se han mudado del _desarrollo_del_conjunto_al_mundo_ occidental. En 2012, la visión del mundo occidental versus el mundo en desarrollo ya no tiene sentido. Esto es particularmente claro cuando se compara Europa con Asia, la última de las cuales incluye varios países que han realizado grandes mejoras.

### `facet_wrap`

Para explorar cómo sucedió esta transformación a través de los años, podemos hacer el gráfico durante varios años. Por ejemplo, podemos agregar 1970, 1980, 1990 y 2000. Si hacemos esto, no queremos todas las parcelas en la misma fila, el comportamiento predeterminado de `facet_grid`, ya que se volverán demasiado delgados para mostrar los datos. En cambio, querremos usar múltiples filas y columnas. La función `facet_wrap` nos permite hacer esto envolviendo automáticamente la serie de gráficos para que cada pantalla tenga dimensiones visibles:


```{r fertility-versus-life-expectancy-five-years, out.width="100%"}
years <- c(1962, 1980, 1990, 2000, 2012)
continents <- c("Europe", "Asia")
gapminder %>%
filter(year %in% years & continent %in% continents) %>%
ggplot( aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(~year)
```

Este gráfico muestra claramente cómo la mayoría de los países asiáticos han mejorado a un ritmo mucho más rápido que los europeos.

### Escalas fijas para mejores comparaciones

La elección predeterminada del rango de los ejes es importante. Cuando no se usa `facet`, este rango está determinado por los datos que se muestran en el gráfico. Cuando usas `facet`, este rango está determinado por los datos que se muestran en todos los gráficos y, por lo tanto, se mantienen fijos en todos los gráficos. Esto hace que las comparaciones entre parcelas sean mucho más fáciles. Por ejemplo, en la gráfica anterior, podemos ver que la esperanza de vida ha aumentado y la fertilidad ha disminuido en la mayoría de los países. Vemos esto porque la nube de puntos se mueve. Este no es el caso si ajustamos las escalas:

```{r facet-without-fixed-scales, warning=FALSE}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(. ~ year, scales = "free")
```

En la gráfica anterior, debemos prestar especial atención al rango para notar que la gráfica de la derecha tiene una mayor esperanza de vida.

## Gráficos de series de tiempo

Las visualizaciones anteriores ilustran efectivamente que los datos ya no son compatibles con la visión del mundo occidental frente a la del mundo en desarrollo. Una vez que vemos estas gráficos, surgen nuevas preguntas. Por ejemplo, ¿qué países están mejorando más y cuáles menos? ¿La mejora fue constante durante los últimos 50 años o se aceleró más durante ciertos períodos? Para una mirada más cercana que puede ayudar a responder estas preguntas, presentamos _gráficos de series de tiempo_.

Las gráficas de series de tiempo tienen tiempo en el eje xy un resultado o medida de interés en el eje y. Por ejemplo, aquí hay una gráfica de tendencia de las tasas de fertilidad de Estados Unidos:

```{r fertility-time-series-plot-points, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_point()
```

Vemos que la tendencia no es lineal en absoluto. En cambio, durante los años sesenta y setenta se produce una fuerte caída por debajo de 2. Luego, la tendencia vuelve a 2 y se estabiliza durante los años noventa.

Cuando los puntos están regularmente y densamente espaciados, como están aquí, creamos curvas uniendo los puntos con líneas, para transmitir que estos datos provienen de una sola serie, aquí un país. Para hacer esto, usamos el `geom_line` funcionar en lugar de `geom_point`.

```{r fertility-time-series-plot-curve, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_line()
```

Esto es particularmente útil cuando miramos dos países. Si subconjuntos los datos para incluir dos países, uno de Europa y uno de Asia, entonces adapte el código anterior:

```{r wrong-time-series-plot, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries) %>%
ggplot(aes(year,fertility)) +
geom_line()
```

Desafortunadamente, esta es __no__ el gráfico que queremos. En lugar de una línea para cada país, se unen los puntos para ambos países. Esto es realmente esperado ya que no hemos dicho `ggplot` nada sobre querer dos líneas separadas. Dejar `ggplot` sabemos que hay dos curvas que deben hacerse por separado, asignamos cada punto a un `group`, uno para cada país:


```{r time-series-two-curves, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year, fertility, group = country)) +
geom_line()
```

¿Pero qué línea va con qué país? Podemos asignar colores para hacer esta distinción.
Un efecto secundario útil de usar el `color` el argumento para asignar diferentes colores a los diferentes países es que los datos se agrupan automáticamente:

```{r fertility-time-series-plot}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year,fertility, col = country)) +
geom_line()
```

La gráfica muestra claramente cómo la tasa de fertilidad de Corea del Sur cayó drásticamente durante los años sesenta y setenta, y en 1990 tenía una tasa similar a la de Alemania.

### Etiquetas en lugar de leyendas

Para los gráficos de tendencias, recomendamos etiquetar las líneas en lugar de usar leyendas, ya que el espectador puede ver rápidamente qué línea es qué país. Esta sugerencia en realidad se aplica a la mayoría de las parcelas: el etiquetado generalmente se prefiere a las leyendas.

Demostramos cómo podemos hacer esto usando los datos de esperanza de vida. Definimos una tabla de datos con las ubicaciones de las etiquetas y luego usamos una segunda asignación solo para estas etiquetas:

```{r labels-better-than-legends}
labels <- data.frame(country = countries, x = c(1975,1965), y = c(60,72))

gapminder %>%
filter(country %in% countries) %>%
ggplot(aes(year, life_expectancy, col = country)) +
geom_line() +
geom_text(data = labels, aes(x, y, label = country), size = 5) +
theme(legend.position = "none")
```

La gráfica muestra claramente cómo una mejora en la esperanza de vida siguió a las caídas en las tasas de fertilidad. En 1960, los alemanes vivieron 15 años más que los surcoreanos, aunque para 2010 la brecha está completamente cerrada. Ejemplifica la mejora que muchos países no occidentales han logrado en los últimos 40 años.



## Transformaciones de datos

Ahora cambiamos nuestra atención a la segunda pregunta relacionada con la idea común de que la distribución de la riqueza en todo el mundo ha empeorado durante las últimas décadas. Cuando se pregunta al público general si los países pobres se han vuelto más pobres y los países ricos se han vuelto más ricos, la mayoría responde que sí. Mediante el uso de estratificación, histogramas, densidades suaves y diagramas de caja, podremos entender si este es realmente el caso. Primero aprendemos cómo las transformaciones a veces pueden ayudar a proporcionar resúmenes y tramas más informativos.

Los `gapminder` la tabla de datos incluye una columna con el producto interno bruto (PIB) de los países. El PIB mide el valor de mercado de los bienes y servicios producidos por un país en un año. El PIB por persona a menudo se usa como un resumen aproximado de la riqueza de un país. Aquí dividimos esta cantidad por 365 para obtener la medida más interpretable _dólares por día_. Utilizando los dólares estadounidenses actuales como una unidad, una persona que sobrevive con un ingreso de menos de $ 2 por día se define que vive en la "pobreza absoluta". Agregamos esta variable a la tabla de datos:


```{r}
gapminder <- gapminder %>% mutate(dollars_per_day = gdp/population/365)
```

Los valores del PIB se ajustan a la inflación y representan dólares estadounidenses actuales, por lo que estos valores deben ser comparables a lo largo de los años. Por supuesto, estos son promedios de país y dentro de cada país hay mucha variabilidad. Todos los gráficos y las ideas que se describen a continuación se refieren a los promedios de los países y no a las personas.

### Transformación de registro

Aquí hay un histograma de ingresos diarios desde 1970:

```{r dollars-per-day-distribution}
past_year <- 1970
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black")
```

Utilizamos el `color = "black"` argumento para dibujar un límite y distinguir claramente los contenedores.

En este gráfico, vemos que para la mayoría de los países, los promedios están por debajo de \$10 a day. However, the majority of the x-axis is dedicated to the `r filter(gapminder, year == past_year & !is.na(gdp)) %>% summarise(x = sum(dollars_per_day>10)) %>% pull(x)` countries with averages above \$ 10. Por lo tanto, el gráfico no es muy informativa sobre países con valores inferiores a \$ 10 por día.

Podría ser más informativo poder ver rápidamente cuántos países tienen ingresos diarios promedio de aproximadamente $1 (extremely poor), \$ 2 (muy pobre), \$4 (poor), \$ 8 (medio), \$16 (well off), \$ 32 (rico), \$ 64 (muy rico) por día. Estos cambios son multiplicativos y las transformaciones logarítmicas convierten los cambios multiplicativos en aditivos: cuando se usa la base 2, la duplicación de un valor se convierte en un aumento de 1.

Aquí está la distribución si aplicamos una transformación log base 2:
```{r dollars-per-day-distribution-log}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(log2(dollars_per_day))) +
geom_histogram(binwidth = 1, color = "black")
```

En cierto modo, esto proporciona un acercamiento de los países de ingresos medios a bajos.

### ¿Qué base?

En el caso anterior, utilizamos la base 2 en las transformaciones de registro. Otras opciones comunes son base $\mathrm{e}$ (el registro natural) y la base 10.

En general, no recomendamos utilizar el registro natural para la exploración y visualización de datos. Esto es porque mientras $2^2, 2^3, 2^4, \dots$ o $10^2, 10^3, \dots$ son fáciles de calcular en nuestras cabezas, lo mismo no es cierto para $\mathrm{e}^2, \mathrm{e}^3, \dots$, por lo que la escala no es intuitiva ni fácil de interpretar.

En el ejemplo de dólares por día, utilizamos la base 2 en lugar de la base 10 porque el rango resultante es más fácil de interpretar. El rango de los valores que se trazan es `r with(filter(gapminder, year==past_year), range(dollars_per_day, na.rm=TRUE))`.

En la base 10, esto se convierte en un rango que incluye muy pocos enteros: solo 0 y 1.
Con la base dos, nuestro rango incluye -2, -1, 0, 1, 2, 3, 4 y 5. Es más fácil calcular $2^x$ y $10^x$ cuando $x$ es un entero y entre -10 y 10, por lo que preferimos tener enteros más pequeños en la escala. Otra consecuencia de un rango limitado es que elegir el ancho de la bandeja es más difícil. Con log base 2, sabemos que un binwidth de 1 se traducirá en un bin con rango $x$ a $2x$.

Para un ejemplo en el que la base 10 tiene más sentido, considere el tamaño de la población. Un registro base 10 es preferible ya que el rango para estos es:

```{r}
filter(gapminder, year == past_year) %>%
summarize(min = min(population), max = max(population))
```

Aquí está el histograma de los valores transformados:

```{r population-histogram-log10}
gapminder %>%
filter(year == past_year) %>%
ggplot(aes(log10(population))) +
geom_histogram(binwidth = 0.5, color = "black")
```

En lo anterior, vemos rápidamente que las poblaciones de los países oscilan entre diez mil y diez mil millones.

### ¿Transformar los valores o la escala?

Hay dos formas en que podemos usar las transformaciones de registros en las parcelas. Podemos registrar los valores antes de trazarlos o usar escalas de registro en los ejes. Ambos enfoques son útiles y tienen diferentes puntos fuertes. Si registramos los datos, podemos interpretar más fácilmente los valores intermedios en la escala. Por ejemplo, si vemos:

`----1----x----2--------3----`

para el registro de datos transformados, sabemos que el valor de $x$ es de aproximadamente 1.5. Si las escalas están registradas:

`----1----x----10------100---`

entonces, para determinar `x`, necesitamos calcular $10^{1.5}$, que no es fácil de hacer en nuestras cabezas. La ventaja de usar escalas registradas es que vemos los valores originales en los ejes. Sin embargo, la ventaja de mostrar escalas registradas es que los valores originales se muestran en el gráfico, que son más fáciles de interpretar. Por ejemplo, veríamos "32 dólares por día" en lugar de "5 log base 2 dólares por día".

Como aprendimos anteriormente, si queremos escalar el eje con registros, podemos usar el `scale_x_continuous` función. En lugar de registrar los valores primero, aplicamos esta capa:

```{r dollars-per-day-log-scale}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2")
```

Tenga en cuenta que la transformación log base 10 tiene su propia función: `scale_x_log10()`, pero actualmente la base 2 no, aunque podríamos definir fácilmente la nuestra.

Hay otras transformaciones disponibles a través de `trans` argumento. Como aprendemos más adelante, la raíz cuadrada ( `sqrt`) la transformación es útil cuando se consideran los recuentos. La transformación logística ( `logit`) es útil cuando se grafican proporciones entre 0 y 1. El `reverse` la transformación es útil cuando queremos que los valores más pequeños estén a la derecha o arriba.

## Visualizando distribuciones multimodales

En el histograma anterior vemos dos _bumps_: uno a aproximadamente 4 y otro a aproximadamente 32. En estadística, estos baches a veces se denominan _modes_. El modo de una distribución es el valor con la frecuencia más alta. El modo de distribución normal es el promedio. Cuando una distribución, como la anterior, no disminuye monotónicamente del modo, llamamos a las ubicaciones donde sube y baja de nuevo _modes locales_y decimos que la distribución tiene_modos múltiples_.

El histograma anterior sugiere que la distribución del ingreso del país en 1970 tiene dos modos: uno a aproximadamente 2 dólares por día (1 en la escala log 2) y otro a aproximadamente 32 dólares por día (5 en la escala log 2). Esta _bimodalidad_ es consistente con un mundo dicotómico compuesto por países con ingresos promedio inferiores a $ 8 (3 en la escala log 2) por día y países por encima de eso.

## Comparar múltiples distribuciones con gráficos de caja y gráficos de cresta

Un histograma nos mostró que los valores de distribución del ingreso de 1970 muestran una dicotomía. Sin embargo, el histograma no nos muestra si los dos grupos de países están en el oeste frente al mundo en desarrollo.

Comencemos examinando rápidamente los datos por región. Reordenamos las regiones por el valor medio y usamos una escala logarítmica.

```{r}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
mutate(region = reorder(region, dollars_per_day, FUN = median)) %>%
ggplot(aes(dollars_per_day, region)) +
geom_point() +
scale_x_continuous(trans = "log2")
```

Ya podemos ver que efectivamente existe una dicotomía "oeste versus el resto": vemos dos grupos claros, con el grupo rico compuesto por América del Norte, Europa del Norte y del Oeste, Nueva Zelanda y Australia. Definimos grupos basados en esta observación:

```{r}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe","Southern Europe",
"Northern America",
"Australia and New Zealand") ~ "West",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region %in% c("Caribbean", "Central America",
"South America") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
TRUE ~ "Others"))
```

Convertimos esto `group` variable en un factor para controlar el orden de los niveles:

```{r}
gapminder <- gapminder %>%
mutate(group = factor(group, levels = c("Others", "Latin America",
"East Asia", "Sub-Saharan",
"West")))
```


En la siguiente sección mostramos cómo visualizar y comparar distribuciones entre grupos.

### Boxplots

El análisis exploratorio de datos anterior reveló dos características sobre la distribución del ingreso promedio en 1970. Usando un histograma, encontramos una distribución bimodal con los modos relacionados con los países pobres y ricos. Ahora queremos comparar la distribución entre estos cinco grupos para confirmar la dicotomía "oeste versus el resto". El número de puntos en cada categoría es lo suficientemente grande como para que un diagrama de resumen pueda ser útil. Podríamos generar cinco histogramas o cinco gráficos de densidad, pero puede ser más práctico tener todos los resúmenes visuales en un gráfico. Por lo tanto, comenzamos apilando diagramas de caja uno al lado del otro. Tenga en cuenta que agregamos la capa `theme(axis.text.x = element_text(angle = 90, hjust = 1))` para convertir las etiquetas de grupo en verticales, ya que no encajan si las mostramos horizontalmente, y quitar la etiqueta del eje para hacer espacio.


```{r dollars-per-day-boxplot}
p <- gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
scale_y_continuous(trans = "log2") +
xlab("") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
p
```

Los diagramas de caja tienen la limitación de que al resumir los datos en cinco números, podríamos perder características importantes de los datos. Una forma de evitar esto es mostrando los datos.

```{r dollars-per-day-boxplot-with-data}
p + geom_point(alpha = 0.5)
```


### Parcelas de cresta

Mostrar cada punto individual no siempre revela características importantes de la distribución. Aunque no es el caso aquí, cuando el número de puntos de datos es tan grande que hay un trazado excesivo, mostrar los datos puede ser contraproducente. Los diagramas de caja ayudan con esto al proporcionar un resumen de cinco números, pero esto también tiene limitaciones. Por ejemplo, boxplots no nos permitirá descubrir distribuciones bimodales. Para ver esto, tenga en cuenta que las dos parcelas siguientes resumen el mismo set de datos:

```{r boxplot-dont-show-bimodal, warning=FALSE, out.width="100%", message = FALSE, echo=FALSE, fig.height=3}
set.seed(1987)
z <- sample(c(0,1), 1000, replace = TRUE, prob = c(0.25, 0.75))
x <- rnorm(100)*z + rnorm(100, 5)*(1 - z)
p1 <- qplot(x, geom = "density", fill = 1, show.legend=FALSE, alpha = 0.2) +
scale_x_continuous(limits=c(-4,8.5))
p2 <- qplot("", x, geom="boxplot")
gridExtra::grid.arrange(p1, p2, nrow = 1)
```

En los casos en que nos preocupa que el resumen de diagrama de caja sea demasiado simplista, podemos mostrar densidades suaves o histogramas apilados. Nos referimos a estos como _ridge plots_. Como estamos acostumbrados a visualizar densidades con valores en el eje x, las apilamos verticalmente. Además, debido a que se necesita más espacio en este enfoque, es conveniente superponerlos. El paquete __ggridges__ proporciona una función conveniente para hacer esto. Aquí están los datos de ingresos que se muestran arriba con diagramas de caja pero con un diagrama de nevera.

```{r ridge-plot, message=FALSE}
library(ggridges)
p <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2")
p + geom_density_ridges()
```

Tenga en cuenta que tenemos que invertir el `x` y `y` usado para el diagrama de caja. Un útil `geom_density_ridges` el parámetro es `scale`, que le permite determinar la cantidad de superposición, con `scale = 1` lo que significa que no hay superposición y valores más grandes que resultan en una mayor superposición.

Si el número de puntos de datos es lo suficientemente pequeño, podemos agregarlos al diagrama de cresta usando el siguiente código:

```{r ridge-plot-with-points, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE)
```

De manera predeterminada, la altura de los puntos está alterada y no debe interpretarse de ninguna manera. Para mostrar puntos de datos, pero sin usar jitter, podemos usar el siguiente código para agregar lo que se conoce como una "representación sólida" de los datos.
```{r ridge-plot-with-rug, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE,
position = position_points_jitter(height = 0),
point_shape = '|', point_size = 3,
point_alpha = 1, alpha = 0.7)
```


### Ejemplo: distribuciones de ingresos de 1970 versus 2010

La exploración de datos muestra claramente que en 1970 hubo una dicotomía "oeste versus el resto". ¿Pero persiste esta dicotomía? Vamos a usar `facet_grid` vea cómo han cambiado las distribuciones. Para comenzar, nos centraremos en dos grupos: el oeste y el resto. Hacemos cuatro histogramas.

```{r income-hist-west-v-developing-two-years}
past_year <- 1970
present_year <- 2010
years <- c(past_year, present_year)
gapminder %>%
filter(year %in% years & !is.na(gdp)) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Antes de interpretar los hallazgos de este gráfico, notamos que hay más países representados en los histogramas de 2010 que en 1970: los recuentos totales son mayores. Una razón para esto es que varios países se fundaron después de 1970. Por ejemplo, la Unión Soviética se dividió en varios países durante la década de 1990. Otra razón es que los datos estaban disponibles para más países en 2010.

Rehacemos las parcelas utilizando solo países con datos disponibles para ambos años. En la parte de discusión de datos de este libro, aprenderemos herramientas __tidyverse__ que nos permiten escribir código eficiente para esto, pero aquí podemos usar código simple usando `intersect` función:

```{r}
country_list_1 <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list_2 <- gapminder %>%
filter(year == present_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list <- intersect(country_list_1, country_list_2)
```

Estas `r length(country_list)` cuenta para
`r round(gapminder %>% filter(year==present_year) %>% summarize(perc=sum(population[country%in%country_list], na.rm=TRUE)/sum(population, na.rm=TRUE)) %>% pull(perc)*100 )`% de la población mundial, por lo que este subconjunto debe ser representativo.

Vamos a rehacer el gráfico, pero solo para este subconjunto simplemente agregando ` country %in% country_list` al `filter` función:

```{r income-histogram-west-v-devel, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Ahora vemos que los países ricos se han vuelto un poco más ricos, pero en términos de porcentaje, los países pobres parecen haber mejorado más. En particular, vemos que la proporción de países en desarrollo que ganan más de $ 16 por día aumentó sustancialmente.

Para ver qué regiones específicas mejoraron más, podemos rehacer los diagramas de caja que hicimos anteriormente, pero ahora agregamos el año 2010 y luego usamos faceta para comparar los dos años.


```{r income-histogram-by-region, out.width="100%"}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("") +
facet_grid(. ~ year)
```

Aquí, hacemos una pausa para presentar otra poderosa función __ggplot2__. Como queremos comparar cada región antes y después, sería conveniente tener el `r past_year` diagrama de caja al lado del `r present_year` diagrama de caja para cada región. En general, las comparaciones son más fáciles cuando los datos se trazan uno al lado del otro.

Entonces, en lugar de facetar, mantenemos los datos de cada año juntos y pedimos colorearlos (o rellenarlos) según el año. Tenga en cuenta que los grupos se separan automáticamente por año y cada par de diagramas de caja se dibujan uno al lado del otro. Como el año es un número, lo convertimos en un factor ya que __ggplot2__ asigna automáticamente un color a cada categoría de un factor. Tenga en cuenta que tenemos que convertir las columnas del año de numérico a factor.

```{r income-histogram-west-v-devel-by-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = factor(year)) %>%
ggplot(aes(group, dollars_per_day, fill = year)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("")
```

Finalmente, señalamos que si lo que más nos interesa es comparar los valores de antes y después, podría tener más sentido trazar los aumentos porcentuales. Todavía no estamos listos para aprender a codificar esto, pero así es como se vería el gráfico:

```{r income-west-v-devel-before-after-ratio, echo=FALSE, warning=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = ifelse(year == past_year, "past", "present")) %>%
select(country, group, year, dollars_per_day) %>%
spread(year, dollars_per_day) %>%
mutate(percent_increase = (present-past)/past*100) %>%
mutate(group = reorder(group, percent_increase, FUN = median)) %>%
ggplot(aes(group, percent_increase)) +
geom_boxplot() +
geom_point(show.legend = FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab("") +
ylab(paste("Percent increase:", past_year, "to", present_year))
```


La exploración previa de datos sugirió que la brecha de ingresos entre países ricos y pobres se ha reducido considerablemente durante los últimos 40 años.
Usamos una serie de histogramas y diagramas de caja para ver esto. Sugerimos una forma sucinta de transmitir este mensaje con una soel gráfico.

Comencemos observando que las gráficas de densidad para la distribución del ingreso en `r past_year` y `r present_year` entregar el mensaje de que la brecha se está cerrando:

```{r income-smooth-density-by-year, out.width="100%", fig.height=3}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(dollars_per_day)) +
geom_density(fill = "grey") +
scale_x_continuous(trans = "log2") +
facet_grid(. ~ year)
```

En el `r past_year` trama, vemos dos modos claros: países pobres y ricos. En `r present_year`, parece que algunos de los países pobres se han desplazado hacia la derecha, cerrando la brecha.

El siguiente mensaje que debemos transmitir es que la razón de este cambio en la distribución es que varios países pobres se hicieron más ricos, en lugar de que algunos países ricos se volvieran más pobres. Para hacer esto, podemos asignar un color a los grupos que identificamos durante la exploración de datos.

Sin embargo, primero tenemos que aprender a hacer estas densidades suaves de una manera que conserve la información sobre el número de países en cada grupo. Para entender por qué necesitamos esto, tenga en cuenta la discrepancia en el tamaño de cada grupo:

```{r, echo=FALSE}
tmp <- gapminder %>%
filter(year == past_year & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
group_by(group) %>%
summarize(n=n()) %>%
spread(group, n)
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Pero cuando superponemos dos densidades, el valor predeterminado es que el área representada por cada distribución sume 1, independientemente del tamaño de cada grupo:

```{r income-smooth-density-by-year-west-v-developing}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2") +
geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

Esto hace que parezca que hay el mismo número de países en cada grupo. Para cambiar esto, necesitaremos aprender a acceder a las variables calculadas con `geom_density` función.

### Acceso a variables calculadas

Para que las áreas de estas densidades sean proporcionales al tamaño de los grupos, simplemente podemos multiplicar los valores del eje y por el tamaño del grupo. Desde el `geom_density` archivo de ayuda, vemos que las funciones calculan una variable llamada `count` eso hace exactamente esto. Queremos que esta variable esté en el eje y en lugar de la densidad.

En __ggplot2__, accedemos a estas variables rodeando el nombre con dos puntos. Por lo tanto, utilizaremos el siguiente mapeo:

```{r, eval=FALSE}
aes(x = dollars_per_day, y = ..count..)
```

Ahora podemos crear el diagrama deseado simplemente cambiando el mapeo en el fragmento de código anterior. También ampliaremos los límites del eje x.


```{r income-smooth-density-counts}
p <- gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, y = ..count.., fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300))

p + geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

Si queremos que las densidades sean más suaves, usamos el `bw` argumento para que se use el mismo ancho de banda en cada densidad. Seleccionamos 0,75 después de probar varios valores.

```{r income-smooth-density-counts-by-year}
p + geom_density(alpha = 0.2, bw = 0.75) + facet_grid(year ~ .)
```

Esta trama ahora muestra lo que está sucediendo muy claramente. La distribución del mundo en desarrollo está cambiando. Aparece un tercer modo formado por los países que más redujeron la brecha.

Para visualizar si alguno de los grupos definidos anteriormente está manejando esto, podemos hacer rápidamente un diagrama de cresta:

```{r ridge-plot-income-five-regions, warning=FALSE, message=FALSE}
gapminder %>%
filter(year %in% years & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2") +
geom_density_ridges(adjust = 1.5) +
facet_grid(. ~ year)
```

Otra forma de lograr esto es apilando las densidades una encima de la otra:

```{r income-smooth-density-counts-by-region-and-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") +
facet_grid(year ~ .)
```

Aquí podemos ver claramente cómo las distribuciones para Asia Oriental, América Latina y otros se desplazan notablemente hacia la derecha. Mientras que África subsahariana permanece estancada.

Tenga en cuenta que ordenamos los niveles del grupo para que la densidad de Occidente se grafica primero, luego África subsahariana. Tener los dos extremos trazados primero nos permite ver mejor la bimodalidad restante.


### Densidades ponderadas

Como punto final, notamos que estas distribuciones pesan lo mismo para todos los países. Entonces, si la mayoría de la población está mejorando, pero viviendo en un país muy grande, como China, podríamos no apreciar esto. De hecho, podemos pesar las densidades suaves usando el `weight` argumento de mapeo. el gráfico se ve así:

```{r income-smooth-density-counts-by-region-year-weighted, warning=FALSE, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group, weight = weight)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") + facet_grid(year ~ .)
```

Esta figura en particular muestra muy claramente cómo se está cerrando la brecha de distribución de ingresos con la mayoría de los pobres que quedan en el África subsahariana.


## La falacia ecológica y la importancia de mostrar los datos

A lo largo de esta sección, hemos estado comparando regiones del mundo. Hemos visto que, en promedio, algunas regiones obtienen mejores resultados que otras. En esta sección, nos enfocamos en describir la importancia de la variabilidad dentro de los grupos al examinar la relación entre las tasas de mortalidad infantil de un país y el ingreso promedio.

Definimos algunas regiones más y comparamos los promedios entre regiones:

```{r ecological-fallacy-averages, echo=FALSE}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe",
"Southern Europe", "Northern America",
"Australia and New Zealand") ~ "West",
region %in% "Northern Africa" ~ "Northern Africa",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region == "Southern Asia"~ "Southern Asia",
region %in% c("Central America", "South America",
"Caribbean") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
region %in% c("Melanesia", "Micronesia",
"Polynesia") ~ "Pacific Islands"))
surv_income <- gapminder %>%
filter(year %in% present_year & !is.na(gdp) &
!is.na(infant_mortality) & !is.na(group)) %>%
group_by(group) %>%
summarize(income = sum(gdp)/sum(population)/365,
infant_survival_rate =
1 - sum(infant_mortality/1000*population)/sum(population))

#surv_income %>% arrange(income) %>% print(n=nrow(surv_income))

surv_income %>% ggplot(aes(income, infant_survival_rate, label = group, color = group)) +
scale_x_continuous(trans = "log2", limits = c(0.25, 150)) +
scale_y_continuous(trans = "logit", limit = c(0.875, .9981),
breaks = c(.85,.90,.95,.99,.995,.998)) +
geom_label_repel(size = 3, show.legend = FALSE)
```

La relación entre estas dos variables es casi perfectamente lineal y el gráfico muestra una diferencia dramática. Mientras que en Occidente muere menos del 0.5% de los bebés, ¡en África subsahariana la tasa es superior al 6%!

Tenga en cuenta que el gráfico utiliza una nueva transformación, la transformación logística.

### Transformación logística {#logit}
La transformación logística o logit para una proporción o tasa $p$ se define como:

$$f(p) = \log \left( \frac{p}{1-p} \right)$$

Cuando $p$ es una proporción o probabilidad, la cantidad que se registra, $p/(1-p)$, se llama _odds_. En este caso $p$ es la proporción de bebés que sobrevivieron. Las probabilidades nos dicen cuántos más bebés se espera que sobrevivan que que mueran. La transformación logarítmica lo hace simétrico. Si las tasas son las mismas, entonces las probabilidades de registro son 0. Los aumentos o disminuciones de pliegues se convierten en incrementos positivos y negativos, respectivamente.

Esta escala es útil cuando queremos resaltar diferencias cercanas a 0 o 1. Para las tasas de supervivencia, esto es importante porque una tasa de supervivencia del 90% es inaceptable, mientras que una supervivencia del 99% es relativamente buena. Preferiríamos mucho una tasa de supervivencia más cercana al 99.9%. Queremos que nuestra escala resalte estas diferencias y el logit lo hace. Tenga en cuenta que 99.9/ 0.1 es aproximadamente 10 veces más grande que 99/1, que es aproximadamente 10 veces más grande que 90/10. Al usar el registro, estos cambios de plegado se convierten en aumentos constantes.

### Mostrar los datos

Ahora, de vuelta a nuestra trama. Con base en la gráfica anterior, ¿concluimos que un país con bajos ingresos está destinado a tener una tasa de supervivencia baja? ¿Llegamos a la conclusión de que las tasas de supervivencia en el África subsahariana son más bajas que en el sur de Asia, que a su vez son más bajas que en las islas del Pacífico, y así sucesivamente?

Saltar a esta conclusión basada en una gráfica que muestra promedios se denomina falacia ecológica. La relación casi perfecta entre las tasas de supervivencia y los ingresos solo se observa para los promedios a nivel regional. Una vez que mostramos todos los datos, vemos una historia algo más complicada:

```{r ecological-fallacy-all-data, echo=FALSE}
library(ggrepel)
highlight <- c("Sierra Leone", "Mauritius", "Sudan", "Botswana", "Tunisia",
"Cambodia","Singapore","Chile", "Haiti", "Bolivia",
"United States","Sweden", "Angola", "Serbia")

gapminder %>% filter(year %in% present_year & !is.na(gdp) & !is.na(infant_mortality) & !is.na(group) ) %>%
mutate(country_name = ifelse(country %in% highlight, as.character(country), "")) %>%
ggplot(aes(dollars_per_day, 1 - infant_mortality/1000, col = group, label = country_name)) +
scale_x_continuous(trans = "log2", limits=c(0.25, 150)) +
scale_y_continuous(trans = "logit",limit=c(0.875, .9981),
breaks=c(.85,.90,.95,.99,.995,.998)) +
geom_point(alpha = 0.5, size = 3) +
geom_text_repel(size = 4, show.legend = FALSE)
```

Específicamente, vemos que hay una gran cantidad de variabilidad. Vemos que los países de las mismas regiones pueden ser bastante diferentes y que los países con los mismos ingresos pueden tener diferentes tasas de supervivencia. Por ejemplo, mientras que, en promedio, el África subsahariana tuvo los peores resultados económicos y de salud, existe una gran variabilidad dentro de ese grupo. Mauricio y Botswana están mejor que Angola y Sierra Leona, con Mauricio comparable a los países occidentales.





