# Visualización de datos en la práctica {#gapminder}

En este capítulo, demostraremos cómo el código relativamente sencillo __ggplot2__  puede crear gráficos perspicaces y estéticamente agradables. Como motivación, crearemos gráficos que nos ayudarán a comprender mejor las tendencias de la salud y la economía mundial. Implementaremos lo que aprendimos en los capítulos \@ref(ggplot2) y \@ref(other-geometries) y aprenderemos a aumentar el código para perfeccionar los gráficos. A medida que avancemos en nuestro estudio de caso, describiremos [fix] los principios generales mas relevantes  la visualización de datos y aprenderemos conceptos como _faceting_, _gráficos de series de tiempo_, _transformaciones_ y _ridge plots_.


## Estudio de caso: nuevas ideas sobre la pobreza

Hans Rosling^[https://en.wikipedia.org/wiki/Hans_Rosling] fue el cofundador de la Fundación Gapminder^[http://www.gapminder.org/], una organización dedicada a educar al público mediante datos para disipar mitos comunes sobre el llamado mundo en desarrollo. La organización utiliza datos para mostrar cómo las tendencias reales en los campos de salud y economía contradicen las narrativas que emanan de la cobertura sensacionalista de los medios de catástrofes, tragedias y otros eventos desafortunados. Como se indica en el sitio web de la Fundación Gapminder: [fix?]

>>> Los periodistas y los cabilderos cuentan historias dramáticas. Ese es su trabajo. Cuentan historias sobre eventos extraordinarios y personas inusuales. Las pilas de historias dramáticas se acumulan en las mentes de las personas en una visión del mundo demasiado dramática y fuertes sentimientos de estrés negativo: "¡El mundo está empeorando!", "¡Somos nosotros contra ellos!", "¡Otras personas son extrañas!", " ¡La población sigue creciendo! " y "a nadie le importa!"

[fix] Hans Rosling reportó tendencias basadas en datos reales de una manera dramática propia, utilizando una visualización de datos efectiva. Esta sección se basa en dos charlas que ejemplifican este enfoque educativo: [Nuevas ideas sobre la pobreza]^[https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en] y Las mejores estadísticas que has visto^[https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen]. Específicamente, en esta sección, usamos datos para intentar responder a las siguientes dos preguntas:

1. ¿Es una caracterización justa del mundo de hoy decir que está dividido en naciones ricas occidentales y el mundo en desarrollo de África, Asia y América Latina?
2. ¿Ha empeorado la desigualdad de ingresos en todos los países durante los últimos 40 años?

Para responder a estas preguntas, utilizaremos el set de datos `gapminder` proveído por __dslabs__. Este set de datos se creó utilizando varias hojas de cálculo disponibles de la Fundación Gapminder. Pueden acceder a la tabla de esta manera:

```{r load libraries, message=FALSE, echo=TRUE}
library(tidyverse)
library(dslabs)
data(gapminder)
gapminder %>% as_tibble()
```

### La prueba de Hans Rosling

Igual que en el video _New Insights on Poverty_, comenzamos probando nuestros conocimientos sobre las diferencias en la mortalidad infantil en diferentes países. [fix] Para cada uno de los seis pares de países a continuación, ¿qué países creen que tuvieron las tasas de mortalidad infantil más altas en 2015? ¿Qué pares creen que son más similares?

1. Sri Lanka o Turquía
2. Polonia o Corea del Sur
3. Malasia o Rusia
4. Pakistán o Vietnam
5. Tailandia o Sudáfrica

Al responder a estas preguntas sin datos, los países no europeos suelen ser elegidos como los que tienen tasas de mortalidad infantil más altas: Sri Lanka sobre Turquía, Corea del Sur sobre Polonia y Malasia sobre Rusia. También es común suponer que los países considerados como parte del mundo en desarrollo: Pakistán, Vietnam, Tailandia y Sudáfrica, tienen tasas de mortalidad igualmente altas.

Para responder estas preguntas __con datos__, podemos usar __dplyr__. Por ejemplo, para la primera comparación vemos que:

```{r, message=FALSE}
gapminder %>%
filter(year == 2015 & country %in% c("Sri Lanka","Turkey")) %>%
select(country, infant_mortality)
```
Turquía tiene la mayor tasa de mortalidad infantil.

Podemos usar este código en todas las comparaciones y descubrimos lo siguiente:
```{r, echo = FALSE}
comp_table <- tibble(comparison = rep(1:5, each = 2),
country = c("Sri Lanka", "Turkey", "Poland", "South Korea", "Malaysia", "Russia", "Pakistan","Vietnam","Thailand","South Africa"))

tmp <- gapminder %>%
filter(year == 2015) %>%
select(country, infant_mortality) %>%
mutate(country = as.character(country)) ##to match characters to characters

tab <- inner_join(comp_table, tmp, by = "country") %>% select(-comparison)

tmp <- bind_cols(slice(tab,seq(1,9,2)), slice(tab,seq(2,10,2)))
names(tmp) <- c("country", "infant mortality", "country", "infant mortality")
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Vemos que los países europeos en esta lista tienen tasas de mortalidad infantil más altas: Polonia tiene una tasa más alta que Corea del Sur y Rusia tiene una tasa más alta que Malasia. También vemos que Pakistán tiene una tasa mucho más alta que Vietnam, y Sudáfrica tiene una tasa mucho más alta que Tailandia. Resulta que cuando Hans Rosling le dio este cuestionario a grupos de personas educadas, el puntaje promedio fue inferior a 2.5 de 5, peor que lo que hubieran obtenido si hubieran adivinado al azar. Esto implica que más que ignorantes, estamos mal informados. En este capítulo vemos cómo la visualización de datos nos ayuda a informarnos.

## Diagrama de dispersión

[fix que 'esto'?] La razón por esto se deriva de la noción preconcebida de que el mundo está dividido en dos grupos: el mundo occidental (Europa occidental y América del Norte), caracterizado por una larga vida y familias pequeñas, versus el mundo en desarrollo (África, Asia y América Latina ) caracterizados por cortos períodos de vida y familias numerosas. ¿Pero los datos respaldan esta visión dicotómica?

Los datos necesarios para responder a esta pregunta también están disponibles en nuestra tabla `gapminder`. Usando nuestras recién aprendidas habilidades de visualización de datos, podremos enfrentar este desafío.

Para analizar esta visión del mundo, nuestro primer gráfico es un diagrama de dispersión de la esperanza de vida versus las tasas de fertilidad (número promedio de hijos por mujer). Comenzamos mirando los datos de hace unos 50 años, cuando quizás esta visión se consolidó por primera vez en nuestras mentes.

```{r fertility-versus-life-expectancy-1962, warning=FALSE}
filter(gapminder, year == 1962) %>%
ggplot(aes(fertility, life_expectancy)) +
geom_point()
```

La mayoría de puntos se dividen en dos categorías distintas:

1. Esperanza de vida alrededor de 70 años y 3 o menos hijos por familia.
2. Esperanza de vida inferior a 65 años y más de 5 niños por familia.

Para confirmar que estos países son de las regiones que esperamos, podemos usar un color para representar un continente.

```{r fertility-versus-life-expectancy-1962-with-color}
filter(gapminder, year == 1962) %>%
ggplot( aes(fertility, life_expectancy, color = continent)) +
geom_point()
```

En 1962, la visión de "El Occidente versus el mundo en desarrollo" se basó en cierta realidad. ¿Sigue siendo así 50 años después?

## Separar en facetas

Podríamos graficar fácilmente los datos de 2012 de la misma manera que lo hicimos para 1962. Sin embargo, para hacer comparaciones, es preferible graficar lado a lado. En __ggplot2__, [fix] podemos lograr esto separando en _facetas_ a las variables: estratificamos los datos por alguna variable y hacemos el mismo gráfico para cada estrato.

[fix] Para separar en facetas, agregamos una capa con la función `facet_grid`, que automáticamente separa los gráficos. Esta función le permite facetar por hasta dos variables usando columnas para representar una variable y filas para representar la otra. La función espera que las variables de fila y columna estén separadas por un `~`. Aquí vemos un ejemplo de un diagrama de dispersión donde agregramos `facet_grid` como la última capa:

```{r fertility-versus-life-expectancy-facet, warning=FALSE, out.width="100%"}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(continent~year)
```

Vemos un gráfico para cada par continente/año. Sin embargo, esto es solo un ejemplo y más de lo que queremos, que es simplemente comparar 1962 y 2012. En este caso, solo hay una variable y usamos `.` para que [fix necesita algun tipo de highlight 'facet'?] facet sepa que no estamos usando una de las variables:

```{r fertility-versus-life-expectancy-two-years, warning=FALSE, out.width="100%", fig.height=3}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(. ~ year)
```

[fix] Este gráfico muestra claramente que la mayoría de los países se han mudado del conjunto _mundo en desarrollo_ al conjunto de _mundo occidental_. En 2012, la visión del mundo occidental versus el mundo en desarrollo ya no tiene sentido. Esto es particularmente claro cuando se compara Europa con Asia, la última de las cuales incluye varios países que han realizado grandes mejoras.

### `facet_wrap`

Para explorar cómo sucedió esta transformación a través de los años, podemos hacer el gráfico para varios años. Por ejemplo, podemos agregar 1970, 1980, 1990 y 2000. Si hacemos esto, no queremos a todos los gráficos en la misma fila, que es lo que por defecto `facet_grid` hace, puesto que aparecerán demasiado delgados para mostrar los datos. En cambio, queremos usar múltiples filas y columnas. La función `facet_wrap` nos permite hacer esto [fix] envolviendo automáticamente la serie de gráficos para que cada imagen tenga dimensiones visibles:


```{r fertility-versus-life-expectancy-five-years, out.width="100%"}
years <- c(1962, 1980, 1990, 2000, 2012)
continents <- c("Europe", "Asia")
gapminder %>%
filter(year %in% years & continent %in% continents) %>%
ggplot( aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(~year)
```

Este gráfico muestra claramente cómo la mayoría de los países asiáticos han mejorado a un ritmo mucho más rápido que los europeos.

### Escalas fijas para mejores comparaciones

La elección por defecto del rango de los ejes es importante. Cuando no se usa `facet`, este rango está determinado por los datos que se muestran en el gráfico. Cuando usan `facet`, este rango está determinado por los datos que se muestran en todos los gráficos y, por lo tanto, se mantienen fijos en todos los gráficos. Esto hace que las comparaciones entre gráficos sean mucho más fáciles. Por ejemplo, en el gráfico anterior, podemos ver que la esperanza de vida ha aumentado y la fertilidad ha disminuido en la mayoría de los países. Vemos esto porque la nube de puntos se mueve. Este no es el caso si ajustamos las escalas:

```{r facet-without-fixed-scales, warning=FALSE}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(. ~ year, scales = "free")
```

En el gráfico anterior, debemos prestar especial atención al rango para notar que el gráfico de la derecha tiene una mayor esperanza de vida.

## Gráficos de series de tiempo

Las visualizaciones anteriores ilustran efectivamente que los datos ya no son compatibles con la visión del mundo occidental frente al mundo en desarrollo. Al ver estos gráficos, surgen nuevas preguntas. Por ejemplo, ¿qué países están mejorando más y cuáles menos? ¿La mejora fue constante durante los últimos 50 años o se aceleró más durante ciertos períodos? [fix] Para una mirada más cercana/más detenida que pueda ayudar a responder estas preguntas, presentamos _gráficos de series de tiempo_ (_time series plots_ en inglés).

Los gráficas de series de tiempo tienen tiempo en el eje x y un resultado o medida de interés en el eje y. Por ejemplo, aquí vemos una gráfica de tendencia de las tasas de fertilidad de Estados Unidos:

```{r fertility-time-series-plot-points, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_point()
```

Observamos que la tendencia no es lineal en absoluto, sino que durante los años sesenta y setenta se produce una fuerte caída por debajo de 2. Luego, la tendencia vuelve a 2 y se estabiliza durante los años noventa.

Cuando los puntos están regular y densamente espaciados, como vemos aquí, creamos curvas uniendo los puntos con líneas, para transmitir que estos datos provienen de una sola serie, aquí un país. Para hacer esto, usamos la función `geom_line` en vez de `geom_point`.

```{r fertility-time-series-plot-curve, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_line()
```

Esto es particularmente útil cuando comparamos dos países. Si creamos un subconjunto de los datos para incluir dos países, uno de Europa y uno de Asia, entonces adaptamos el código anterior:

```{r wrong-time-series-plot, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries) %>%
ggplot(aes(year,fertility)) +
geom_line()
```

Desafortunadamente, este __no__ es el gráfico que queremos. En lugar de una línea para cada país, se unen los puntos para ambos países. Sin embargo, esto es esperado ya que no le hemos dicho a `ggplot` nada sobre querer dos líneas separadas. Para que `ggplot` entienda que hay dos curvas que se deben hacer por separado, asignamos cada punto a un `group`, uno para cada país:


```{r time-series-two-curves, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year, fertility, group = country)) +
geom_line()
```

¿Pero qué línea va con qué país? Podemos asignar colores para hacer esta distinción.
Un efecto secundario útil de usar el argumento `color` para asignar diferentes colores a los diferentes países es que los datos se agrupan automáticamente:

```{r fertility-time-series-plot}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year,fertility, col = country)) +
geom_line()
```

El gráfico muestra claramente cómo la tasa de fertilidad de Corea del Sur cayó drásticamente durante los años sesenta y setenta, y en 1990 tuvo una tasa similar a la de Alemania.

### Etiquetas en lugar de leyendas

Para los gráficos de tendencias, recomendamos etiquetar las líneas en lugar de usar leyendas, ya que el espectador puede ver rápidamente qué línea es de qué país. Esta sugerencia aplica a la mayoría de los gráficos: las etiquetas generalmente se prefieren a las leyendas.

Demostramos cómo podemos hacer esto usando los datos de esperanza de vida. Definimos una tabla de datos con las ubicaciones de las etiquetas y luego usamos una segunda asignación solo para estas etiquetas:

```{r labels-better-than-legends}
labels <- data.frame(country = countries, x = c(1975,1965), y = c(60,72))

gapminder %>%
filter(country %in% countries) %>%
ggplot(aes(year, life_expectancy, col = country)) +
geom_line() +
geom_text(data = labels, aes(x, y, label = country), size = 5) +
theme(legend.position = "none")
```

El gráfico muestra claramente cómo una mejora en la esperanza de vida siguió a las caídas en las tasas de fertilidad. En 1960, los alemanes vivieron 15 años más que los surcoreanos, aunque para 2010 la brecha está completamente cerrada. Ejemplifica la mejora que muchos países no occidentales han logrado en los últimos 40 años.



## Transformaciones de datos

Ahora cambiamos nuestra atención a la segunda pregunta relacionada con la idea común de que la distribución de la riqueza en todo el mundo ha empeorado durante las últimas décadas. Cuando se le pregunta al público en general si los países pobres se han vuelto más pobres y los países ricos se han vuelto más ricos, la mayoría responde que sí. Mediante el uso de estratificación, histogramas, densidades suaves y diagramas de caja, podremos ver si este realmente es el caso. Primero, aprenderemos cómo las transformaciones a veces pueden ayudar a proporcionar resúmenes y gráficos más informativos.

[fix] La tabla de datos `gapminder` incluye una columna con el producto interno bruto, o GDP por sus siglas en inglés, de los países. El GDP mide el valor de mercado de los bienes y servicios producidos por un país en un año. El GDP por persona a menudo se usa como un resumen aproximado de la riqueza de un país. Aquí dividimos esta cantidad por 365 para obtener la medida más interpretable _dólares por día_. Utilizando los dólares estadounidenses actuales como una unidad, una persona que sobrevive con un ingreso de menos de $2 por día se define que vive en la "pobreza absoluta". Agregamos esta variable a la tabla de datos:


```{r}
gapminder <- gapminder %>% mutate(dollars_per_day = gdp/population/365)
```

Los valores del GDP se ajustan a la inflación y representan dólares estadounidenses actuales, por lo que estos valores deben ser comparables a lo largo de los años. Por supuesto, estos son promedios de país y dentro de cada país hay mucha variabilidad. Todos los gráficos y las ideas que se describen a continuación se refieren a los promedios de los países y no a los individuos.

### Transformación logarítmica

Abajo tenemos un histograma de ingresos diarios desde 1970:

```{r dollars-per-day-distribution}
past_year <- 1970
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black")
```

Utilizamos el argumento `color = "black"`para dibujar un límite y distinguir claramente los compartimientos.

En este gráfico, vemos que para la mayoría de los países, los promedios están por debajo de \$10 a day. Sin embargo, del eje x está dedicado a  `r filter(gapminder, year == past_year & !is.na(gdp)) %>% summarise(x = sum(dollars_per_day>10)) %>% pull(x)` países con promdeio de menos de \$ 10. Por lo tanto, el gráfico no es muy informativo con respecto a países con valores inferiores a \$ 10 por día.

Podría ser más informativo poder ver rápidamente cuántos países tienen ingresos diarios promedio de aproximadamente [fix] $1 (extremadamente pobre), \$ 2 (muy pobre), \$4 (pobre), \$ 8 (promedio/middle), \$16 (well off/acomodado), \$ 32 (rico), \$ 64 (muy rico) por día. Estos cambios son multiplicativos y las transformaciones logarítmicas convierten los cambios multiplicativos en aditivos: cuando se usa la base 2, la duplicación de un valor se convierte en un aumento de 1.

Aquí tenemos la distribución si aplicamos [fix] una transformación log base 2:
```{r dollars-per-day-distribution-log}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(log2(dollars_per_day))) +
geom_histogram(binwidth = 1, color = "black")
```

[fix] Así logramos una mirada mas detenida de los países de ingresos medios a bajos.

### ¿Qué base?

En el caso anterior, utilizamos la base 2 en las transformaciones logarítmicas. Otras opciones comunes son base $\mathrm{e}$ (el logaritmo natural) y la base 10.

En general, no recomendamos utilizar el logaritmo natural para la exploración y visualización de datos. La razón es porque mientras $2^2, 2^3, 2^4, \dots$ o $10^2, 10^3, \dots$ son fáciles de calcular en nuestras cabezas, lo mismo no es cierto para $\mathrm{e}^2, \mathrm{e}^3, \dots$, por lo que la escala no es intuitiva ni fácil de interpretar.

En el ejemplo de dólares por día, utilizamos la base 2 en lugar de la base 10 porque el rango resultante es más fácil de interpretar. El rango de los valores que se trazan es `r with(filter(gapminder, year==past_year), range(dollars_per_day, na.rm=TRUE))`.

En la base 10, esto se convierte en un rango que incluye muy pocos enteros: solo 0 y 1. Con la base dos, nuestro rango incluye -2, -1, 0, 1, 2, 3, 4 y 5. Es más fácil calcular $2^x$ y $10^x$ cuando $x$ es un entero y entre -10 y 10, por lo que preferimos tener enteros más pequeños en la escala. Otra consecuencia de un rango limitado es que elegir [fix] el ancho del compartimiento (_binwidth_ en inglés) es más difícil. Con log base 2, sabemos que un[fix] ancho de comportimiento de 1 se convertirá en un compartimiento con rango $x$ a $2x$.

Para un ejemplo en el que la base 10 tiene más sentido, considere los tamaños de poblaciones. Un registro base 10 es preferible ya que el rango para estos es:

```{r}
filter(gapminder, year == past_year) %>%
summarize(min = min(population), max = max(population))
```

Abajo tenemos el histograma de los valores transformados:

```{r population-histogram-log10}
gapminder %>%
filter(year == past_year) %>%
ggplot(aes(log10(population))) +
geom_histogram(binwidth = 0.5, color = "black")
```

En lo anterior, vemos rápidamente que las poblaciones de los países oscilan entre diez mil y diez mil millones.

### ¿Transformar los valores o la escala?

Hay dos formas en que podemos usar las transformaciones logarítmicas en los gráficos. Podemos registrar los valores antes de graficarlos o usar [fix] escalas logarítmicas de registro/log scales en los ejes. Ambos enfoques son útiles y tienen diferentes ventajas. Si [fix]  log/ registramos los datos, podemos interpretar más fácilmente los valores intermedios en la escala. Por ejemplo, si vemos:

`----1----x----2--------3----`

para [fix] el registro de datos transformados/log transformed data, sabemos que el valor de $x$ es de aproximadamente 1.5. Si las escalas están registradas:

`----1----x----10------100---`

entonces, para determinar `x`, necesitamos calcular $10^{1.5}$, que no es fácil de calcular mentalmente. La ventaja de usar escalas [fix] registradas/logged scales es que vemos los valores originales en los ejes. Sin embargo, la ventaja de mostrar [fix] registradas/logged scales escalas registradas es que los valores originales se muestran en el gráfico, [fix] donde es (que es?) más fáciles de interpretar. Por ejemplo, veríamos "32 dólares por día" en lugar de "5 log base 2 dólares por día".

Como aprendimos anteriormente, si queremos escalar el eje con [fix] registros/logs, podemos usar la función `scale_x_continuous`. En lugar  [fix] de registrar/logging los valores primero, aplicamos esta capa:

```{r dollars-per-day-log-scale}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2")
```

Tengan en cuenta que la  [fix]transformación log base 10 tiene su propia función: `scale_x_log10()`, pero actualmente la base 2 no tiene, aunque fácilmente podríamos definir una.

[fix] Hay otras transformaciones disponibles a través del argumento `trans`. Como aprendemos más adelante, la transformación de raíz cuadrada (`sqrt`) es útil cuando se consideran los recuentos. La transformación logística (`logit`) es útil cuando se grafican proporciones entre 0 y 1. La transformación `reverse` es útil cuando queremos que los valores más pequeños estén a la derecha o arriba/encima.

## Cómo visualizar distribuciones multimodales

En el histograma anterior vemos dos [fix] _bumps_/protuberaciones: uno a aproximadamente 4 y otro a aproximadamente 32. En estadística, estos _bumps_ a veces se denominan la _moda_ (_modes_ en inglés). La moda de una distribución es el valor con la frecuencia más alta. La moda de distribución normal es el promedio. Cuando una distribución, como la anterior, no disminuye monotónicamente de la moda, llamamos a los lugares donde sube y baja de nuevo _modas locales_ (_local modes_ en inglés) y decimos que la distribución tiene [fix] _modas múltiples_.

El histograma anterior sugiere que la distribución del ingreso [fix singular?] del país en 1970 tiene dos modas: uno a aproximadamente 2 dólares por día (1 en la escala log 2) y otro a aproximadamente 32 dólares por día (5 en la escala log 2). Esta _bimodalidad_ es consistente con un mundo dicotómico compuesto por países con ingresos promedio inferiores a $8 (3 en la escala log 2) por día y países por encima de eso.

## Cómo comparar múltiples distribuciones con diagramas de caja y gráficos _ridge_

De acuerdo con el histograma, los valores de distribución del ingreso de 1970 muestran una dicotomía. Sin embargo, el histograma no nos muestra si los dos grupos de países están en el _oeste_ o forman parte del mundo _en desarrollo_.

Comencemos examinando rápidamente los datos por región. Reordenamos las regiones por la mediana y usamos una escala logarítmica.

```{r}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
mutate(region = reorder(region, dollars_per_day, FUN = median)) %>%
ggplot(aes(dollars_per_day, region)) +
geom_point() +
scale_x_continuous(trans = "log2")
```

Ya podemos ver que efectivamente existe una dicotomía "el oeste versus el resto": hay dos grupos claros, con el grupo rico compuesto por América del Norte, Europa del Norte y del Oeste, Nueva Zelanda y Australia. Definimos grupos basados en esta observación:

```{r}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe","Southern Europe",
"Northern America",
"Australia and New Zealand") ~ "West",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region %in% c("Caribbean", "Central America",
"South America") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
TRUE ~ "Others"))
```

Convertimos esta variable `group` en un factor para controlar el orden de los niveles:

```{r}
gapminder <- gapminder %>%
mutate(group = factor(group, levels = c("Others", "Latin America",
"East Asia", "Sub-Saharan",
"West")))
```


En la siguiente sección mostramos cómo visualizar y comparar distribuciones entre grupos.

### Diagrama de caja

El anterior análisis exploratorio de datos reveló dos características sobre la distribución de ingreso promedio en 1970. Usando un histograma, encontramos una distribución bimodal con los modos relacionados con los países pobres y ricos. Ahora queremos comparar la distribución entre estos cinco grupos para confirmar la dicotomía "el oeste versus el resto". El número de puntos en cada categoría es lo suficientemente grande como para que un gráfico de resumen pueda ser útil. Podríamos generar cinco histogramas o cinco gráficos de densidad, pero puede ser más práctico tener todos los resúmenes visuales en un gráfico. Por lo tanto, comenzamos apilando diagramas de caja uno al lado del otro. Tengan en cuenta que agregamos la capa `theme(axis.text.x = element_text(angle = 90, hjust = 1))` para que las etiquetas de grupo sean verticales, puesto que no encajan si las mostramos horizontalmente, y para quitar la etiqueta del eje a fin de hacer espacio.


```{r dollars-per-day-boxplot}
p <- gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
scale_y_continuous(trans = "log2") +
xlab("") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
p
```

Los diagramas de caja tienen la limitación de que al resumir los datos en cinco números, podríamos perder características importantes de los datos. Una forma de evitar esto es mostrando los datos.

```{r dollars-per-day-boxplot-with-data}
p + geom_point(alpha = 0.5)
```


### Gráficos _ridge_

Mostrar cada punto individual no siempre revela características importantes de la distribución. Aunque no es el caso aquí, cuando el número de puntos de datos es tan grande que hay[fix] _un trazado excesivo_/overplotting, mostrar los datos puede ser contraproducente. Los diagramas de caja ayudan con esto al proporcionar un resumen de cinco números, pero esto también tiene limitaciones. Por ejemplo, los diagramas de caja no nos permiten descubrir distribuciones bimodales. Para ver esto, miren los dos gráficos abajo que resumen el mismo set de datos:

```{r boxplot-dont-show-bimodal, warning=FALSE, out.width="100%", message = FALSE, echo=FALSE, fig.height=3}
set.seed(1987)
z <- sample(c(0,1), 1000, replace = TRUE, prob = c(0.25, 0.75))
x <- rnorm(100)*z + rnorm(100, 5)*(1 - z)
p1 <- qplot(x, geom = "density", fill = 1, show.legend=FALSE, alpha = 0.2) +
scale_x_continuous(limits=c(-4,8.5))
p2 <- qplot("", x, geom="boxplot")
gridExtra::grid.arrange(p1, p2, nrow = 1)
```

En los casos en que nos preocupa que el resumen de diagrama de caja sea demasiado simplista, podemos mostrar densidades suaves o histogramas apilados. Nos referimos a estos como _gráficos ridge_. Como estamos acostumbrados a visualizar densidades con valores en el eje x, las apilamos verticalmente. Además, debido a que se necesita más espacio en este enfoque, es conveniente superponerlos. El paquete __ggridges__ incluye una función conveniente para hacer esto. Abajo vemos los datos de ingresos que se muestran arriba con diagramas de caja pero ahora visualizados caso con un _gráfico ridge_.

```{r ridge-plot, message=FALSE}
library(ggridges)
p <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2")
p + geom_density_ridges()
```

Tengan en cuenta que tenemos que invertir el `x` y `y` usado para el diagrama de caja. [fix] Un parametro útil de `geom_density_ridges` es `scale`, que les permite determinar la cantidad de superposición, con `scale = 1` significando que no hay superposición y valores más grandes resultando en mayor superposición.

Si el número de puntos de datos es lo suficientemente pequeño, podemos agregarlos al gráfico _ridge_ usando el siguiente código:

```{r ridge-plot-with-points, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE)
```

[fix]Por defecto, la altura de los puntos está _jittered_ y no se interpretar de ninguna manera. Para mostrar puntos de datos, pero sin usar _jitter_, podemos usar el siguiente código para agregar lo que se conoce como una _rug representation_ de los datos.
```{r ridge-plot-with-rug, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE,
position = position_points_jitter(height = 0),
point_shape = '|', point_size = 3,
point_alpha = 1, alpha = 0.7)
```


### Ejemplo: distribuciones de ingresos de 1970 versus 2010

La exploración de datos muestra claramente que en 1970 hubo una dicotomía del "oeste versus el resto". ¿Pero persiste esta dicotomía? Vamos a usar `facet_grid` para ver cómo han cambiado las distribuciones. Para comenzar, nos enfocamos en dos grupos: el oeste y el resto. Hacemos cuatro histogramas.

```{r income-hist-west-v-developing-two-years}
past_year <- 1970
present_year <- 2010
years <- c(past_year, present_year)
gapminder %>%
filter(year %in% years & !is.na(gdp)) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Antes de interpretar los hallazgos de este gráfico, notamos que hay más países representados en los histogramas de 2010 que en 1970: los recuentos totales son mayores. Una razón para esto es que varios países se fundaron después de 1970. Por ejemplo, la Unión Soviética se dividió en varios países durante la década de 1990. Otra razón es que hay mas datos disponibles para más países en 2010.

Rehacemos los gráficos utilizando solo países con datos disponibles para ambos años. En la parte sobre _data wrangling_ de este libro, aprenderemos herramientas de __tidyverse__ que nos permitará escribir código eficiente para esto, pero aquí podemos usar un código sencilla usando la función `intersect:

```{r}
country_list_1 <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list_2 <- gapminder %>%
filter(year == present_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list <- intersect(country_list_1, country_list_2)
```

Estas `r length(country_list)` cuentan para
`r round(gapminder %>% filter(year==present_year) %>% summarize(perc=sum(population[country%in%country_list], na.rm=TRUE)/sum(population, na.rm=TRUE)) %>% pull(perc)*100 )`% de la población mundial, por lo que este subconjunto debe ser representativo.

Vamos a rehacer el gráfico, pero solo para este subconjunto simplemente agregando ` country %in% country_list` a la función `filter`:

```{r income-histogram-west-v-devel, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Ahora vemos que los países ricos se han vuelto un poco más ricos, pero en términos de porcentaje, los países pobres parecen haber mejorado más. En particular, vemos que la proporción de países _en desarrollo_ que ganan más de $ 16 por día aumentó sustancialmente.

Para ver qué regiones específicas mejoraron más, podemos rehacer los diagramas de caja que hicimos anteriormente, pero ahora agregamos el año 2010 y luego usamos _facet_ para comparar los dos años.


```{r income-histogram-by-region, out.width="100%"}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("") +
facet_grid(. ~ year)
```

Aquí, pausamos para presentar otro poderoso [fix] atributo de __ggplot2__. Como queremos comparar cada región antes y después, sería conveniente tener el diagrama de caja de `r past_year` al lado del de `r present_year` para cada región. En general, las comparaciones son más fáciles cuando los datos se grafican uno al lado del otro.

Entonces, en lugar de [fix] facetar, mantenemos los datos de cada año juntos y pedimos colorearlos (o rellenarlos) según el año. Tengan en cuenta que los grupos se separan automáticamente por año y cada par de diagramas de caja se dibujan uno al lado del otro. Como el año es un número, lo convertimos en un factor ya que __ggplot2__ asigna automáticamente un color a cada categoría de un factor. Recuerden que tenemos que convertir las columnas del año de numérico a factor.

```{r income-histogram-west-v-devel-by-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = factor(year)) %>%
ggplot(aes(group, dollars_per_day, fill = year)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("")
```

Finalmente, señalamos que si lo más que nos interesa es comparar los valores de antes y después, podría tener más sentido graficar los aumentos porcentuales. Todavía no estamos listos para aprender a codificar esto, pero así es como se vería el gráfico:

```{r income-west-v-devel-before-after-ratio, echo=FALSE, warning=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = ifelse(year == past_year, "past", "present")) %>%
select(country, group, year, dollars_per_day) %>%
spread(year, dollars_per_day) %>%
mutate(percent_increase = (present-past)/past*100) %>%
mutate(group = reorder(group, percent_increase, FUN = median)) %>%
ggplot(aes(group, percent_increase)) +
geom_boxplot() +
geom_point(show.legend = FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab("") +
ylab(paste("Percent increase:", past_year, "to", present_year))
```


La exploración previa de datos sugirió que la brecha de ingresos entre países ricos y pobres se ha reducido considerablemente durante los últimos 40 años. Usamos una serie de histogramas y de diagramas de caja para ver esto. Sugerimos una forma sucinta de transmitir este mensaje con solo un gráfico.

Empecemos observando que los gráficos de densidad para la distribución del ingreso en `r past_year` y `r present_year` transmiten el mensaje de que la brecha se está cerrando:

```{r income-smooth-density-by-year, out.width="100%", fig.height=3}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(dollars_per_day)) +
geom_density(fill = "grey") +
scale_x_continuous(trans = "log2") +
facet_grid(. ~ year)
```

[fix]En el gráfico de `r past_year`, vemos dos modas claras: países pobres y ricos. En `r present_year`, parece que algunos de los países pobres se han desplazado hacia la derecha, cerrando la brecha.

El próximo mensaje que debemos transmitir es que la razón de este cambio en distribución es que varios países pobres se hicieron más ricos, en lugar de que algunos países ricos se hicieron más pobres. Para hacer esto, podemos asignar un color a los grupos que identificamos durante la exploración de datos.

Sin embargo, primero tenemos que aprender a hacer estas densidades suaves de una manera que conserve la información sobre el número de países en cada grupo. Para entender por qué necesitamos esto, tengan en cuenta la discrepancia en el tamaño de cada grupo:

```{r, echo=FALSE}
tmp <- gapminder %>%
filter(year == past_year & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
group_by(group) %>%
summarize(n=n()) %>%
spread(group, n)
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Pero cuando superponemos dos densidades, [fix] 'the default' = la acción/comportamiento por defecto/el valor predeterminado es que el área representada por cada distribución sume a 1, independientemente del tamaño de cada grupo:

```{r income-smooth-density-by-year-west-v-developing}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2") +
geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

Esto hace que parezca que hay el mismo número de países en cada grupo. Para cambiar esto, necesitaremos aprender a acceder a las variables calculadas con la función `geom_density`.

### [fix] Acceso a variables calculadas

Para que las áreas de estas densidades sean proporcionales al tamaño de los grupos, simplemente podemos multiplicar los valores del eje y por el tamaño del grupo. En el archivo de ayuda de `geom_density`, vemos que las funciones calculan una variable denominada `count` que hace exactamente esto. Queremos que esta variable esté en el eje y en lugar de la densidad.

En __ggplot2__, accedemos a estas variables rodeando el nombre con dos puntos. Por lo tanto, utilizaremos el siguiente mapeo:

```{r, eval=FALSE}
aes(x = dollars_per_day, y = ..count..)
```

Ahora podemos crear el diagrama deseado simplemente cambiando el mapeo en el fragmento del código anterior. También ampliaremos los límites del eje x.


```{r income-smooth-density-counts}
p <- gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, y = ..count.., fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300))

p + geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

Si queremos que las densidades sean más suaves, usamos el argumento `bw` para que se use el mismo [fix] bandwith/binwidthancho de banda en cada densidad. Seleccionamos 0.75 después de probar varios valores.

```{r income-smooth-density-counts-by-year}
p + geom_density(alpha = 0.2, bw = 0.75) + facet_grid(year ~ .)
```

Este gráfico ahora muestra lo que está sucediendo muy claramente. La distribución del mundo en desarrollo está cambiando.[fix] Aparece una tercera moda formada por los países que más redujeron la brecha.

Para visualizar si alguno de los grupos definidos anteriormente[fix] está dirigiendo esto, rápidamente podemos hacer un _gráfico ridge_:

```{r ridge-plot-income-five-regions, warning=FALSE, message=FALSE}
gapminder %>%
filter(year %in% years & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2") +
geom_density_ridges(adjust = 1.5) +
facet_grid(. ~ year)
```

Otra forma de lograr esto es apilando las densidades una encima de otra:

```{r income-smooth-density-counts-by-region-and-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") +
facet_grid(year ~ .)
```

Aquí podemos ver claramente cómo las distribuciones para Asia Oriental, América Latina y otros se desplazan notablemente hacia la derecha. Mientras que África subsahariana permanece estancada.

Noten que ordenamos los niveles del grupo para que la densidad del Occidente se grafique primero, luego África subsahariana. Tener los dos extremos graficados primero nos permite ver mejor la bimodalidad restante.


###[fix] Densidades ponderadas/weighted densities

Como punto final, notamos que estas distribuciones pesan lo mismo para todos los países. Entonces, si la mayoría de la población está mejorando, pero viviendo en un país muy grande, como China, podríamos no apreciar esto. De hecho, podemos [fix]pesar las densidades suaves usando el argumento de mapeo `weight`. El gráfico se ve así:

```{r income-smooth-density-counts-by-region-year-weighted, warning=FALSE, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group, weight = weight)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") + facet_grid(year ~ .)
```

[fix reword in english too?]Esta figura en particular muestra muy claramente cómo se está cerrando la brecha de distribución de ingresos con la mayoría de los pobres residiendo en el África subsahariana.


## La falacia ecológica y la importancia de mostrar los datos

A lo largo de esta sección, hemos estado comparando regiones del mundo. Hemos visto que, en promedio, algunas regiones obtienen mejores resultados que otras. En esta sección, nos enfocamos en describir la importancia de la variabilidad dentro de los grupos al examinar la relación entre las tasas de mortalidad infantil de un país y el ingreso promedio.

Definimos algunas regiones más y comparamos los promedios entre regiones:

```{r ecological-fallacy-averages, echo=FALSE}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe",
"Southern Europe", "Northern America",
"Australia and New Zealand") ~ "West",
region %in% "Northern Africa" ~ "Northern Africa",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region == "Southern Asia"~ "Southern Asia",
region %in% c("Central America", "South America",
"Caribbean") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
region %in% c("Melanesia", "Micronesia",
"Polynesia") ~ "Pacific Islands"))
surv_income <- gapminder %>%
filter(year %in% present_year & !is.na(gdp) &
!is.na(infant_mortality) & !is.na(group)) %>%
group_by(group) %>%
summarize(income = sum(gdp)/sum(population)/365,
infant_survival_rate =
1 - sum(infant_mortality/1000*population)/sum(population))

#surv_income %>% arrange(income) %>% print(n=nrow(surv_income))

surv_income %>% ggplot(aes(income, infant_survival_rate, label = group, color = group)) +
scale_x_continuous(trans = "log2", limits = c(0.25, 150)) +
scale_y_continuous(trans = "logit", limit = c(0.875, .9981),
breaks = c(.85,.90,.95,.99,.995,.998)) +
geom_label_repel(size = 3, show.legend = FALSE)
```

La relación entre estas dos variables es casi perfectamente lineal y el gráfico muestra una diferencia dramática. Mientras que en el Occidente muere menos del 0.5% de los bebés, ¡en África subsahariana la tasa es superior al 6%!

Tengan en cuenta que el gráfico utiliza una nueva transformación, la transformación logística.

### Transformación logística {#logit}
La transformación logística o logit para una proporción o tasa $p$ se define como:

$$f(p) = \log \left( \frac{p}{1-p} \right)$$

Cuando $p$ es una proporción o probabilidad, la cantidad que se registra, $p/(1-p)$, [fix traduzco? probabilidades?] se llama _odds_. En este caso $p$ es la proporción de bebés que sobrevivieron. Los _odds_ nos dicen cuántos más bebés se espera que sobrevivan a que mueran. La transformación logarítmica lo hace simétrico. Si las tasas son iguales, entonces las probabilidades de registro son 0. Los aumentos o disminuciones de [fix] folds/pliegues se convierten en incrementos positivos y negativos, respectivamente.

Esta escala es útil cuando queremos resaltar diferencias cercanas a 0 o 1. Para las tasas de supervivencia, esto es importante porque una tasa de supervivencia del 90% es inaceptable, mientras que una supervivencia del 99% es relativamente buena. Preferiríamos mucho una tasa de supervivencia más cercana al 99.9%. Queremos que nuestra escala resalte estas diferencias y el logit lo hace. Tengan en cuenta que 99.9/ 0.1 es aproximadamente 10 veces más grande que 99/1, que es aproximadamente 10 veces más grande que 90/10. Al usar el registro, estos [fix] fold changes/cambios de plegado se convierten en aumentos constantes.

### Mostrar los datos

Ahora, de vuelta a nuestro gráfico. Basado en el gráfico anterior, ¿concluimos que un país con bajos ingresos está destinado a tener una tasa de supervivencia baja? ¿Llegamos a la conclusión de que las tasas de supervivencia en el África subsahariana son más bajas que en el sur de Asia, que a su vez son más bajas que en las islas del Pacífico, y así sucesivamente?

Saltar a esta conclusión basada en un gráfico que muestra promedios se denomina _falacia ecológica_. La relación casi perfecta entre las tasas de supervivencia y los ingresos solo se observa para los promedios a nivel regional. Una vez que mostramos todos los datos, vemos una historia más complicada:

```{r ecological-fallacy-all-data, echo=FALSE}
library(ggrepel)
highlight <- c("Sierra Leone", "Mauritius", "Sudan", "Botswana", "Tunisia",
"Cambodia","Singapore","Chile", "Haiti", "Bolivia",
"United States","Sweden", "Angola", "Serbia")

gapminder %>% filter(year %in% present_year & !is.na(gdp) & !is.na(infant_mortality) & !is.na(group) ) %>%
mutate(country_name = ifelse(country %in% highlight, as.character(country), "")) %>%
ggplot(aes(dollars_per_day, 1 - infant_mortality/1000, col = group, label = country_name)) +
scale_x_continuous(trans = "log2", limits=c(0.25, 150)) +
scale_y_continuous(trans = "logit",limit=c(0.875, .9981),
breaks=c(.85,.90,.95,.99,.995,.998)) +
geom_point(alpha = 0.5, size = 3) +
geom_text_repel(size = 4, show.legend = FALSE)
```

Específicamente, vemos que hay una gran cantidad de variabilidad. Vemos que los países de las mismas regiones pueden ser bastante diferentes y que los países con los mismos ingresos pueden tener diferentes tasas de supervivencia. Por ejemplo, mientras que, en promedio, África subsahariana tuvo los peores resultados económicos y de salud, existe una gran variabilidad dentro de ese grupo. Mauricio y Botswana están mejores que Angola y Sierra Leona, con Mauricio comparable a los países occidentales.





