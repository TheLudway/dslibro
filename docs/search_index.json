[
["index.html", "Introducción a la Ciencia de Datos Análisis de datos y algoritmos de predicción con R Prefacio", " Introducción a la Ciencia de Datos Análisis de datos y algoritmos de predicción con R Rafael A. Irizarry 2020-04-06 Prefacio Este libro comenzó como las notas utilizadas para enseñar la clase de HarvardX Data Science Series1. El código Rmarkdown que se usó para generar el libro está disponible en GitHub2. Tengan en cuenta que el tema gráfico utilizado para los gráficos a lo largo del libro se pueden recrear utilizando la función ds_theme_set() del paquete dslabs. Un PDF de la versión en inglés de este libro está disponible en Leanpub3. Una copia impresa de la versión en inglés de este libro está disponible en CRC Press4. Este trabajo se publica bajo la licencia Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Internacional CC BY-NC-SA 4.0. Hacemos anuncios relacionados al libro en Twitter. Para la información más reciente, siga @rafalab. https://www.edx.org/professional-certificate/harvardx-data-science↩ https://github.com/rafalab/dsbook↩ https://leanpub.com/datasciencebook↩ https://www.crcpress.com/Introduction-to-Data-Science-Data-Analysis-and-Prediction-Algorithms-with/Irizarry/p/book/9780367357986↩ "],
["agradecimientos.html", "Agradecimientos", " Agradecimientos Este libro está dedicado a todas las personas involucradas en la construcción y el mantenimiento de R y los paquetes R que utilizamos en el texto. Un agradecimiento especial a los desarrolladores y los mantenedores de base R, el tidyverse y el paquete caret. Un agradecimiento especial a mi tidyverse gurú David Robinson y a Amy Gill por docenas de comentarios, cambios y sugerencias. Además, muchas gracias a Stephanie Hicks, que dos veces sirvió como co-instructora en mis clases de ciencias de datos, y a Yihui Xie, que pacientemente toleró mis multiples preguntas sobre bookdown. Gracias también a Karl Broman, de quien tomé prestadas ideas para las secciones sobre la visualización de datos y las herramientas de productividad, y a Hector Corrada-Bravo, por sus consejos sobre cómo mejor enseñar machine learning. Gracias a Peter Aldhous, de quien tomé prestadas ideas para la sección sobre los principios de la visualización de datos y a Jenny Bryan por escribir Happy Git y GitHub for the useR, que influyeron en nuestros capítulos de Git. Gracias a Alyssa Frazee por ayudar a crear el problema de tarea que se convirtió en el capítulo sobre los sistemas de recomendación y a Amanda Cox por proporcionar los datos de los exámenes de los Regentes de Nueva York. Además, muchas gracias a Jeff Leek, Roger Peng y Brian Caffo, cuya clase inspiró la forma en que se divide este libro y a Garrett Grolemund y Hadley Wickham por abrir el código de reserva para su libro R for Data Science. Finalmente, gracias a Alex Nones por corregir el manuscrito durante sus diversas etapas. Este libro fue concebido durante la enseñanza de varios cursos de estadística aplicada, comenzando hace más de quince años. Los profesores asistentes que trabajaron conmigo a lo largo de los años hicieron importantes contribuciones indirectas a este libro. La última versión de este curso es una serie de HarvardX coordinada por Heather Sternshein y Zofia Gajdos. Les agradecemos sus contribuciones. También estamos agradecidos a todos los estudiantes cuyas preguntas y comentarios nos ayudaron a mejorar el libro. Los cursos fueron parcialmente financiados por el subsidio del NIH R25GM114818. Agradecemos los Institutos Nacionales de Salud por su apoyo. Un agradecimiento especial a todos aquellos que editaron el libro a través de pull requests de GitHub o hicieron sugerencias creando un issue o enviando un correo electrónico: nickyfoto (Huang Qiang) desautm (Marc-André Désautels), michaschwab (Michail Schwab) alvarolarreategui (Alvaro Larreategui), jakevc (Jake VanCampen), omerta (Guillermo Lengemann), espinielli (Enrico Spinielli), asimumba(Aaron Simumba) braunschweig (Maldewar), gwierzchowski (Grzegorz Wierzchowski), technocrat (Richard Careaga) atzakas, defeit (David Emerson Feit), shiraamitchell (Shira Mitchell) Nathalie-S, andreashandel (Andreas Handel) berkowitze (Elias Berkowitz) Dean-Webb (Dean Webber), mohayusuf, jimrothstein, mPloenzke (Matthew Ploenzke), NicholasDowand (Nicholas Dow) kant (Darío Hereñú), debbieyuster (Debbie Yuster), tuanchauict (Tuan Chau), phzeller, David D. Kane, El Mustapha El Abbassi y Vadim Zipunnikov. La traducción del libro al español estuvo a cargo de Alex Nones. Agradecemos a todos los que contribuyeron a esta traducción. Ilia Ushkin and Dustin Tingley generaron un primer borrador usando un programa de traducción automática. A través de Twitter @R4DS_es y @lacion (Laura Ación) proveyeron importante información sobre recursos existentes. Varios otros contribuyeron a traves de Twitter, GitHub, o email: @hortizzuazaga (Humberto Ortiz), @ribnikov (Jose Matestadístico), @jarangoo (Julián A.), @DiegoV_O_ (Diego), @BrunoContrerasM (BContreras Moreira), @a2kimura (Alejandro Kimura), @Emilio_NTN (Emilio García Morán), @beto_bfr (betofogo), @jdieramon (Jose V. Die), @yabellini (Yanina Bellini Saibene), @symusicgroup (Ismael Rudas), @criztinaz (Cristina Zenteno), @controlnegativo (Cristina de Dios), @d_olivaw (Elio Campitelli), @aguerri_jc (Jesús C. Aguerri), @pincheippie (Francisco, en casa) @compBiology (Pedro Madrigal), @RLadiesCuerna (RLadies Cuernavaca), @thecarpentries, eead-csic-compbio (CSIC &amp; Fundación ARAID), pablormier (Pablo R. Mier), josschavezf (Joselyn Chavez), jmcastagnetto (Jesus M. Castagnetto), ismaelrudas, AnaBVA (Ana B. Villaseñor Altamirano), Héctor Corrada-Bravo, Rafael A. Arce Nazario, Luis R. Pericchi Guerra, y María E. Perez Hernández. "],
["introduccion.html", "Introducción Los casos de estudio ¿Quién encontrará útil este libro? ¿Que cubre este libro? ¿Qué no cubre este libro?", " Introducción La demanda de profesionales cualificados en ciencias de datos en la industria, la academia y el gobierno está creciendo rápidamente. Este libro presenta conceptos y destrezas que pueden ayudarles a enfrentar los desafíos del análisis de datos en situaciones reales. El texto abarca los conceptos de probabilidad, inferencia estadística, regresión lineal y machine learning. También les ayudará a desarrollar destrezas como la programación en R, el wrangling de datos, dplyr, la visualización de datos con ggplot2, la creación de algoritmos con caret, la organización de archivos con UNIX/Linux shell, el control de versiones con Git y GitHub y la preparación de documentos reproducibles con knitr y R markdown. El libro se divide en seis partes: R, Visualización de datos, Wrangling de datos, Estadísticas con R, Machine Learning y Herramientas de productividad. Cada parte tiene varios capítulos que se deben presentar como una sola clase e incluye docenas de ejercicios distribuidos a través de los capítulos. Los casos de estudio A lo largo del libro, utilizamos casos de estudio motivantes. En cada caso de estudio, intentamos imitar de manera realista la experiencia de los científicos de datos. Para cada uno de los conceptos que discutimos, comenzamos haciendo preguntas específicas a las que entonces respondemos mediante un análisis de datos. Aprendemos los conceptos como un medio para responder a las preguntas. Ejemplos de los casos de estudio que incluimos en este libro son: Caso de estudio Concepto Tasas de asesinatos en Estados Unidos por estado Conceptos básicos de R Alturas de estudiantes Resúmenes estadísticos Tendencias en la salud y la economía mundial Visualización de datos El impacto de las vacunas en las tasas de enfermedades infecciosas Visualización de datos La crisis financiera de 2007-2008 Probabilidad Previsión de elecciones Inferencia estadística Alturas autoreportadas de estudiantes Wrangling de datos Money Ball: Construyendo un equipo de béisbol Regresión lineal MNIST: Procesamiento de imagen de dígitos escritos a mano Machine Learning Sistemas de recomendación de películas Machine Learning ¿Quién encontrará útil este libro? El próposito de este libro es servir como un texto para un primer curso de ciencia de datos. No es necesario tener conocimientos previos de R, aunque algo de experiencia en la programación puede ser útil. Los conceptos estadísticos utilizados para responder a las preguntas de los casos de estudio se presentan solo brevemente, y por tanto recomendamos un libro de texto de Probabilidad y Estadística para los que quieran entender a fondo estos conceptos. Al leer y comprender todos los capítulos y completar todos los ejercicios, los estudiantes estarán bien posicionados para realizar tareas básicas de análisis de datos y aprender los conceptos y las destrezas más avanzadas que son necesarios para convertirse en expertos. ¿Que cubre este libro? Comenzamos repasando los conceptos básicos de R y el tidyverse. Aprenderán R a lo largo del libro, pero en la primera parte nos dedicamos a revisar los componentes básicos necesarios para seguir aprendiendo. La creciente disponibilidad de conjuntos de datos informativos y de herramientas de software ha llevado a una mayor dependencia de la visualización de datos en muchos campos. En la segunda parte, demostramos cómo usar ggplot2 para generar gráficos y describir principios importantes de la visualización de datos. En la tercera parte demostramos la importancia de las estadísticas en el análisis de datos respondiendo a preguntas de estudios de caso usando la probabilidad, la inferencia y la regresión con R. La cuarta parte utiliza varios ejemplos para familiarizar a los lectores con el wrangling de datos. Entre las destrezas específicas que estudiamos están la extracción de la web (web scraping en inglés), el uso de expresiones regulares y la unión y la remodelación de tablas de datos. Hacemos esto usando las herramientas de tidyverse. En la quinta parte presentamos varios desafíos que nos llevan a introducir el machine learning. Aprendemos a usar el paquete caret para construir algoritmos de predicción que incluyen K-nearest neighbors y random forests. En la parte final, ofrecemos una breve introducción a las herramientas de productividad que usamos diariamente en los proyectos de ciencia de datos. Estas son RStudio, UNIX/Linux shell, Git y GitHub, y knitr y R Markdown. ¿Qué no cubre este libro? Este libro se enfoca en los aspectos del análisis de datos de la ciencia de datos. Por consiguiente, no discutimos aspectos relacionados con el manejo de datos (data management en inglés) o la ingeniería. Aunque la programación en R es una parte esencial del libro, no enseñamos temas informáticos más avanzados como las estructuras de datos, la optimización y la teoría de algoritmos. Del mismo modo, no discutimos temas como los servicios web, los gráficos interactivos, la computación paralela y el procesamiento de flujos de datos (data streaming processing en inglés). Los conceptos estadísticos se presentan principalmente como herramientas para resolver problemas y no se incluyen descripciones teóricas en profundidad en este libro. "],
["getting-started.html", "Capítulo 1 Comenzando con R y RStudio 1.1 ¿Por qué R? 1.2 La consola R 1.3 scripts 1.4 RStudio 1.5 Instalación de paquetes de R", " Capítulo 1 Comenzando con R y RStudio 1.1 ¿Por qué R? R no es un lenguaje de programación como C o Java. No fue creado por ingenieros de software para el desarrollo de software, sino por estadísticos como un ambiente interactivo para el análisis de datos. Pueden leer la historia completa en el artículo “Una breve historia de S”5. La interactividad es una característica indispensable en la ciencia de datos porque, como pronto aprenderán, la capacidad de explorar rápidamente los datos es necesario para el éxito en este campo. Sin embargo, igual que en otros lenguajes de programación, en R pueden guardar su trabajo como scripts, o secuencias de comandos, que se pueden ejecutar fácilmente en cualquier momento. Estos scripts sirven como un registro del análisis que realizaron, una característica clave que facilita el trabajo reproducible. Los programadores expertos no deben esperar que R siga las convenciones a que están acostumbrados, ya que se sentirán decepcionados. Si son pacientes, apreciarán la gran ventaja de R cuando se trata del análisis de datos y, específicamente, de la visualización de datos. Otras características atractivas de R son: R es gratuito y de código abierto6. Se ejecuta en todas las plataformas principales: Windows, Mac Os, UNIX/ Linux. Los scripts y los objetos de datos se pueden compartir sin problemas entre plataformas. Existe una comunidad grande, creciente y activa de usuarios de R y, como resultado, hay numerosos recursos para aprender y hacer preguntas789. Es fácil para otras personas contribuir complementos (add-ons en inglés) que les permiten a los desarrolladores compartir implementaciones de software de nuevas metodologías de ciencia de datos. Esto les da a los usuarios de R acceso temprano a los últimos métodos y herramientas que se desarrollan para una amplia variedad de disciplinas, incluyendo la ecología, la biología molecular, las ciencias sociales y la geografía, entre otros campos. 1.2 La consola R El análisis de datos interactivo generalmente ocurre en la consola R que ejecuta comandos a medida que los escriban. Hay varias formas de obtener acceso a una consola R. Una es simplemente iniciando R en su computadora. La consola se ve así: Como ejemplo rápido, intenten usar la consola para calcular una propina de 15% en una comida que cuesta $19.71: 0.15 * 19.71 #&gt; [1] 2.96 ** Ojo: En este libro, los cuadros grises se utilizan para mostrar el código R escrito en la consola R. El símbolo #&gt; se usa para denotar el output de la consola R. ** 1.3 scripts Una de las grandes ventajas de R sobre el software de análisis de apuntar y hacer clic es que pueden guardar su trabajo como scripts, que entonces pueden editar y guardar con un editor de texto. El material de este libro se desarrolló utilizando el Integrated Development Environment (IDE) de RStudio10. RStudio incluye un editor con muchas características específicas de R, una consola para ejecutar su código y otros paneles útiles, incluso uno para mostrar figuras. La mayoría de consolas de R disponibles en la web también incluyen un panel para editar scripts, pero no todas les permiten guardar los scripts para su uso posterior. Todos los scripts de R utilizados para generar este libro se pueden encontrar en GitHub11. 1.4 RStudio RStudio será nuestra plataforma de lanzamiento para los proyectos de ciencia de datos. No sólo nos provee un editor para crear y editar nuestros scripts, sino que también ofrece muchas otras herramientas útiles. En esta sección, repasaremos algunos de los conceptos básicos. 1.4.1 Paneles Cuando inicien RStudio por primera vez, verán tres paneles. El panel izquierdo muestra la consola R. A la derecha, el panel superior incluye pestañas como Environment y History, mientras que el panel inferior muestra cinco pestañas: File, Plots, Packages, Help y Viewer (estas pestañas pueden ser diferentes en las nuevas versiones de RStudio). Pueden hacer clic en cada pestaña para moverse por las diferentes opciones. Para iniciar un nuevo script, hagan clic en File, entonces New File y luego R Script. Esto inicia un nuevo panel a la izquierda y es aquí donde pueden comenzar a escribir su script. 1.4.2 Key bindings Muchas de las tareas que realizamos con el mouse se pueden lograr con una combinación de teclas (key bindings en inglés). Por ejemplo, acabamos de mostrar cómo usar el mouse para iniciar un nuevo script, pero también se puede usar la siguiente combinación de teclas: Ctrl + Shift + N en Windows y Command + Shift + N en la Mac. Aunque en este tutorial a menudo mostramos cómo usar el mouse, recomendamos encarecidamente que memoricen las combinaciones de teclas para las operaciones que usan con mayor frecuencia. RStudio incluye una hoja de referencia (cheat sheet en inglés) útil con los comandos más utilizados. Pueden obtenerla directamente de RStudio así: Recomendamos tener esto a mano para poder buscar las combinaciones de teclas cuando se encuentren apuntando y haciendo clic repetidas veces. 1.4.3 Cómo ejecutar comandos mientras edita scripts Hay muchos editores diseñados específicamente para la codificación. Estos son útiles porque el color y la indentación se agregan automáticamente para que el código sea más legible. RStudio es uno de estos editores y se desarrolló específicamente para R. Una de las principales ventajas que RStudio tiene sobre otros editores es que podemos probar nuestro código fácilmente mientras editamos nuestros scripts. A continuación ofrecemos un ejemplo. Comencemos abriendo un nuevo script como lo hicimos antes. Entonces, nombremos el script. Podemos hacer esto a través del editor guardando el nuevo script actual sin nombre. Para empezar, hagan clic en el icono de guardar o usando la combinación de teclas Ctrl + S en Windows y Command + S en la Mac. Al intentar guardar el documento por primera vez, RStudio le pedirá un nombre. Una buena convención es usar un nombre descriptivo, con letras minúsculas, sin espacios, sólo guiones para separar las palabras y luego seguido del sufijo .R. Llamaremos a este script: my-first-script.R. Ahora estamos listos para comenzar a editar nuestro primer script. Las primeras líneas de código en un script de R se dedican a cargar los paquetes que usaremos. Otra característica útil de RStudio es que una vez escribimos library(), RStudio comienza a completar automáticamente lo que estamos escribiendo con los paquetes que hemos instalado. Observen lo que sucede cuando escribimos library(ti): Otra característica que pueden haber notado es que cuando escriben library( el segundo paréntesis se agrega automáticamente. Esto les ayudará a evitar uno de los errores más comunes en la codificación: olvidar cerrar un paréntesis. Ahora podemos continuar escribiendo código. Como ejemplo, crearemos un gráfico que muestre los totales de asesinatos versus los totales de población por estado de EE.UU.. Una vez que hayan terminado de escribir el código necesario para hacer este gráfico, pueden probarlo ejecutando el código. Para hacer esto, hagan clic en el botón Run en la parte derecha superior del panel de edición. También pueden usar la combinación de teclas: Ctrl + Shift + Enter en Windows o Command + Shift + Return en Mac. Tan pronto corran el código, verán que este aparece en la consola R y, en este caso, el gráfico que resulta aparece en la consola de gráficos. Recuerden que la consola de gráficos tiene una interfaz útil que le permite hacer clic hacia delante o hacia atrás en diferentes gráficos, hacer zoom en el gráfico o guardar los gráficos como archivos. Para ejecutar una línea a la vez en lugar del script completo, pueden usar Control-Enter en Windows y Command-Return en Mac. 1.4.4 Cómo cambiar las opciones globales Pueden cambiar el aspecto y la funcionalidad de RStudio bastante. Para cambiar las opciones globales, hagan clic en Tools y luego en Global Options …. Como ejemplo, mostramos cómo hacer un cambio que sumamente recomendamos: cambiar el Save workspace to .RData on exit a Never y desmarcar Restore .RData into workspace at start. Por defecto, cuando uno sale de R, el programa guarda todos los objetos que ha creado en un archivo llamado .RData. Esto ocurre para que, cuando reinicien la sesión en el mismo archivo, el programa cargue estos objetos. Sin embargo, encontramos que esto causa confusión, especialmente cuando compartimos código con colegas y suponemos que tienen este archivo .RData. Para cambiar estas opciones, hagan que su configuración General se vea así: 1.5 Instalación de paquetes de R La funcionalidad que una nueva instalación de R ofrece es sólo una pequeña fracción de lo que es posible. De hecho, nos referimos a lo que obtienen después de su primera instalación como base R. La funcionalidad adicional proviene de complementos disponibles de los desarrolladores. Actualmente hay cientos de estos disponibles de CRAN y muchos otros compartidos a través de otros repositorios como GitHub. Sin embargo, debido a que no todo el mundo necesita todas las funciones disponibles, R pone a disposición diferentes componentes a través de paquetes (packages en inglés). R facilita la instalación de paquetes desde R. Por ejemplo, para instalar el paquete dslabs, que usamos para compartir los sets de datos y códigos relacionados con este libro, deben escribir: install.packages(&quot;dslabs&quot;) En RStudio, pueden navegar a la pestaña Tools y seleccionar Install packages. Luego podemos cargar el paquete en nuestras sesiones R usando la función library: library(dslabs) A medida que vayan leyendo este libro, verán que cargamos paquetes sin instalarlos. Esto se debe a que una vez que instalen un paquete, permanece instalado y sólo necesita cargarse con library. El paquete permanece cargado hasta que terminemos con la sesión R. Si intentan cargar un paquete y obtienen un error, probablemente significa que no lo han instalado. Podemos instalar más de un paquete a la vez proveyendo un vector de caracteres a esta función: install.packages(c(&quot;tidyverse&quot;, &quot;dslabs&quot;)) Tengan en cuenta que la instalación de tidyverse en realidad instala varios paquetes. Esto ocurre comúnmente cuando un paquete tiene * dependencias *, o usa funciones de otros paquetes. Cuando cargan un paquete usando library, también cargan sus dependencias. Una vez que los paquetes estén instalados, pueden cargarlos en R y no necesitan instalarlos nuevamente, a menos que instalen una versión nueva de R. Recuerden que los paquetes están instalados en R y no en RStudio. Es útil mantener una lista de todos los paquetes que necesitan para su trabajo en un script porque si tienen que realizar una instalación nueva de R, pueden reinstalar todos sus paquetes simplemente ejecutando un script. Pueden ver todos los paquetes que han instalado utilizando la siguiente función: installed.packages() https://pdfs.semanticscholar.org/9b48/46f192aa37ca122cfabb1ed1b59866d8bfda.pdf↩ https://opensource.org/history↩ https://stats.stackexchange.com/questions/138/free-resources-for-learning-r↩ https://www.r-project.org/help.html↩ https://stackoverflow.com/documentation/r/topics↩ https://www.rstudio.com/↩ https://github.com/rafalab/dsbook↩ "],
["r-basics.html", "Capítulo 2 Lo básico de R 2.1 Caso de estudio: los asesinatos con armas en EE. UU. 2.2 Lo básico 2.3 Ejercicios 2.4 Tipos de datos 2.5 Ejercicios 2.6 Vectores 2.7 La conversión forzada 2.8 Ejercicios 2.9 Sorting 2.10 Ejercicios 2.11 Aritmética de vectores 2.12 Ejercicios 2.13 Indexación 2.14 Ejercicios 2.15 Gráficos básicos 2.16 Ejercicios", " Capítulo 2 Lo básico de R En este libro, utilizaremos el ambiente de software R para todo nuestro análisis. Aprenderán R y las técnicas de análisis de datos simultáneamente. Por tanto, para continuar necesitarán acceso a R. También recomendamos el uso de un Integrated Development Environment (IDE), como RStudio, para guardar su trabajo. Recuerden que es común que un curso o taller ofrezca acceso a un ambiente de R y a un IDE a través de su navegador de web, como lo hace RStudio cloud12. Si tienen acceso a dicho recurso, no necesitan instalar R ni RStudio. Sin embargo, si eventualmente quieren convertirse en analistas expertos de datos, recomendamos instalar estas herramientas en su computadora13. Tanto R como RStudio son gratuitos y están disponibles en línea. 2.1 Caso de estudio: los asesinatos con armas en EE. UU. Imagínese que vive en Europa y se le ofrece un trabajo en una empresa estadounidense con muchas ubicaciones por todo EE. UU.. Es un gran trabajo, pero noticias con titulares como Tasa de homicidios con armas de fuego de EE. UU. más alta que en otros países desarrollados14. ¿Se preocupa? Gráficos como el siguiente pueden preocuparle aún más: O peor aún, esta versión de everytown.org: Pero entonces se recuerda que Estados Unidos es un país grande y diverso, con 50 estados muy diferentes, además del Distrito de Columbia (DC). California, por ejemplo, tiene una población más grande que Canadá, y 20 estados de EE. UU. tienen poblaciones más grandes que la de Noruega. En algunos aspectos, la variabilidad entre los estados de EE. UU. es parecida a la variabilidad entre los países de Europa. Además, aunque no se incluyen en los cuadros anteriores, las tasas de asesinatos en Lituania, Ucrania y Rusia son superiores a cuatro por cada 100.000. Entonces, es posible que las noticias que le preocupan sean demasiado superficiales. Tiene opciones de dónde puede vivir y desea determinar la seguridad de cada estado en particular. Obtendremos algunas ideas al examinar los datos relacionados con homicidios con armas de fuego de EE. UU. en 2010 usando R. Antes de comenzar con nuestro ejemplo, necesitamos discutir la logística, así como algunos de los componentes básicos necesarios para obtener destrezas más avanzadas de R. Recuerden que la utilidad de algunos de estos componentes básicos no siempre es inmediatamente obvia, pero luego en el libro apreciarán haber dominado estas destrezas. 2.2 Lo básico Antes de empezar con el set de datos motivante, necesitamos repasar los conceptos básicos de R. 2.2.1 Objetos Supongamos que unos estudiantes de secundaria nos piden ayuda para resolver varias ecuaciones cuadráticas de la forma \\(ax^2+bx+c = 0\\). La fórmula cuadrática nos ofrece las soluciones: \\[ \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\,\\, \\mbox{ and } \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\] que por supuesto cambian dependiendo de los valores de \\(a\\), \\(b\\) y \\(c\\). Una ventaja de los lenguajes de programación es poder definir variables y escribir expresiones con estas, como se hace en las matemáticas, para obtener una solución numérica. Escribiremos un código general para la ecuación cuadrática a continuación, pero si nos piden resolver \\(x^2 + x -1 = 0\\), entonces definimos: a &lt;- 1 b &lt;- 1 c &lt;- -1 que almacena los valores para su uso posterior. Usamos &lt;- para asignar valores a las variables. También podemos asignar valores usando = en lugar de &lt;-, pero recomendamos no usar = para evitar confusión. Copien y peguen el código anterior en su consola para definir las tres variables. Tengan en cuenta que R no imprime nada cuando hacemos esta asignación. Esto significa que los objetos se definieron con éxito. Si hubieran cometido un error, habría aparecido un mensaje de error. Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe a y este muestra el valor almacenado: a #&gt; [1] 1 Una forma más explícita de pedirle a R que nos muestre el valor almacenado en a es usar print así: print(a) #&gt; [1] 1 Usamos el término objeto para describir cosas que están almacenadas en R. Las variables son ejemplos, pero los objetos también pueden ser entidades más complicadas como las funciones, que se describen más adelante. 2.2.2 El espacio de trabajo A medida que definimos objetos en la consola, estamos cambiando el espacio de trabajo (workspace en inglés). Pueden ver todas las variables guardadas en su espacio de trabajo al escribir: ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;dat&quot; &quot;img_path&quot; &quot;murders&quot; En RStudio, la pestaña Environment muestra los valores: Deberíamos ver a, b y c. Si intentan recuperar el valor de una variable que no está en sus espacios de trabajo, recibirán un mensaje de error. Por ejemplo, si escriben x, verán lo siguiente: Error: object 'x' not found. Ahora, dado que estos valores se guardan en variables, para resolver nuestra ecuación, utilizamos la fórmula cuadrática: (-b + sqrt(b^2 - 4*a*c) )/ ( 2*a ) #&gt; [1] 0.618 (-b - sqrt(b^2 - 4*a*c) )/ ( 2*a ) #&gt; [1] -1.62 2.2.3 Funciones Una vez que definan las variables, el proceso de análisis de datos generalmente se puede describir como una serie de funciones aplicadas a los datos. R incluye varias funciones predefinidas y la mayoría de las líneas de análisis que construimos hacen uso extensivo de ellas. Ya usamos las funciones install.packages, library y ls. También usamos la función sqrt para solucionar la ecuación cuadrática anterior. Hay muchas más funciones predefinidas y hasta más se pueden añadir a través de paquetes. Estas no aparecen en sus espacios de trabajo porque no las definieron, pero están disponibles para su uso inmediato. En general, necesitamos usar paréntesis para evaluar una función. Si escriben ls, la función no se evalúa y en cambio R les muestra el código que la define. Si escriben ls(), la función se evalúa y, como ya se mostró, vemos objetos en el espacio de trabajo. A diferencia de ls, la mayoría de las funciones requieren uno o más argumentos. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función log. Recuerden que anteriormente definimos a como 1: log(8) #&gt; [1] 2.08 log(a) #&gt; [1] 0 Pueden averiguar lo que la función espera y lo que hace revisando unos manuales muy útiles incluidos en R. Pueden obtener ayuda utilizando la función help así: help(&quot;log&quot;) Para la mayoría de las funciones, también podemos usar esta abreviatura: ?log La página de ayuda les mostrará qué argumentos espera la función. Por ejemplo, log necesita x y base para correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Pueden determinar cuáles son opcionales notando en el documento de ayuda cuáles valores predeterminados se asignan con =. Definir estos es opcional. Por ejemplo, la base de la función log por defecto es base = exp(1) haciendo log el logaritmo natural por defecto. Para echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, pueden escribir: args(log) #&gt; function (x, base = exp(1)) #&gt; NULL Pueden cambiar los valores predeterminados simplemente asignando otro objeto: log(8, base = 2) #&gt; [1] 3 Recuerden que no hemos estado especificando el argumento x como tal: log(x = 8, base = 2) #&gt; [1] 3 El código anterior funciona, pero también podemos ahorrarnos un poco de tecleo: si no usan un nombre de argumento, R supone que están ingresando argumentos en el orden en que se muestran en el archivo de ayuda o por args. Entonces, al no usar los nombres, R supone que los argumentos son x seguido por base: log(8,2) #&gt; [1] 3 Si usan los nombres de los argumentos, podemos incluirlos en el orden en que queramos: log(base = 2, x = 8) #&gt; [1] 3 Para especificar argumentos, debemos usar = y no &lt;-. Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estas, las más utilizados son los operadores aritméticos y relacionales. Por ejemplo: 2^3 #&gt; [1] 8 Pueden ver los operadores aritméticos al escribir: help(&quot;+&quot;) o ?&quot;+&quot; y los operadores relacionales al escribir: help(&quot;&gt;&quot;) o ?&quot;&gt;&quot; 2.2.4 Otros objetos predefinidos Hay varios sets de datos que se incluyen para que los usuarios practiquen y prueben las funciones. Pueden ver todos los sets de datos disponibles escribiendo: data() Esto les muestra el nombre del objeto para estos sets de datos. Estos sets de datos son objetos que se pueden usar simplemente escribiendo el nombre. Por ejemplo, si escriben: co2 R les mostrará los datos de concentración de CO2 atmosférico de Mauna Loa. Otros objetos predefinidos son cantidades matemáticas, como la constante \\(\\pi\\) y \\(\\infty\\): pi #&gt; [1] 3.14 Inf+1 #&gt; [1] Inf 2.2.5 Nombres de variables Hemos usado las letras a, b y c como nombres de variables, pero estos pueden ser casi cualquier cosa. Algunas reglas básicas en R son que los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R. Por ejemplo, no nombren una de sus variables install.packages escribiendo algo como: install.packages &lt;- 2. Una buena convención a seguir es usar palabras significativas que describan lo que están almacenado, usar solo minúsculas y usar guiones bajos como sustituto de espacios. Para las ecuaciones cuadráticas, podríamos usar algo como: solution_1 &lt;- (-b + sqrt(b^2 - 4*a*c))/ (2*a) solution_2 &lt;- (-b - sqrt(b^2 - 4*a*c))/ (2*a) Para obtener más consejos, recomendamos estudiar la guía de estilo de Hadley Wickham15. 2.2.6 Cómo guardar su espacio de trabajo Los valores permanecen en el espacio de trabajo hasta que finalicen sus sesiones o las borren con la función rm. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, al salir de R, el programa les pregunta si desean guardar su espacio de trabajo. Si lo guardan, la próxima vez que inicien R, el programa restaurará el espacio de trabajo. Recomendamos no guardar el espacio de trabajo así porque, a medida que comiencen a trabajar en diferentes proyectos, será más difícil darle seguimiento de lo que se guarda. En cambio, les recomendamos que le asignen al espacio de trabajo un nombre específico. Pueden hacer esto usando las funciones save o save.image. Para cargar, usen la función load. Al guardar un espacio de trabajo, recomendamos el sufijo rda o RData. En RStudio, también pueden hacerlo navegando a la pestaña Session y eligiendo Save Workspace as. Luego pueden cargarlo usando las opciones Load Workspace en la misma pestaña. Para aprender más, lean las páginas de ayuda (help pages en inglés) en save, save.image y load. 2.2.7 Scripts motivantes Para resolver otra ecuación como \\(3x^2 + 2x -1\\), podemos copiar y pegar el código anterior, redefinir las variables y volver a calcular la solución: a &lt;- 3 b &lt;- 2 c &lt;- -1 (-b + sqrt(b^2 - 4*a*c))/ (2*a) (-b - sqrt(b^2 - 4*a*c))/ (2*a) Al crear y guardar un script con el código anterior, ya no tendrán que volver a escribirlo todo cada vez, sino simplemente cambiar los nombres de las variables. Intenten escribir la secuencia de comandos anteriores en un editor y observen lo fácil que es cambiar las variables y recibir una respuesta. 2.2.8 Cómo comentar su código Si una línea de código R comienza con el símbolo #, no se evalúa. Podemos usar esto para escribir recordatorios de por qué escribimos un código particular. Por ejemplo, en el script anterior, podríamos agregar: ## Código para calcular la solución a la ecuación cuadrática de la forma ax^2 + bx + c ## definir las variables a &lt;- 3 b &lt;- 2 c &lt;- -1 ## ahora calcule la solución (-b + sqrt(b^2 - 4*a*c))/ (2*a) (-b - sqrt(b^2 - 4*a*c))/ (2*a) 2.3 Ejercicios 1. ¿Cuál es la suma de los primeros 100 números enteros positivos? La fórmula para la suma de enteros \\(1\\) a \\(n\\) es \\(n(n+1)/2\\). Defina \\(n=100\\) y luego use R para calcular la suma de \\(1\\) a \\(100\\) usando la fórmula. ¿Cuál es la suma? 2. Ahora use la misma fórmula para calcular la suma de los enteros del 1 a 1000. 3. Mire el resultado de escribir el siguiente código en R: n &lt;- 1000 x &lt;- seq(1, n) sum(x) Basado en el resultado, ¿qué cree que hacen las funciones seq y sum? Puede usar help. sum crea una lista de números y seq los suma. seq crea una lista de números y sum los suma. seq crea una lista aleatoria y sum calcula la suma de 1 a 1000. sum siempre devuelve el mismo número. 4. En las matemáticas y la programación, decimos que evaluamos una función cuando reemplazamos el argumento con un número dado. Entonces si escribimos sqrt(4), evaluamos la función sqrt. En R, se puede evaluar una función dentro de otra función. Las evaluaciones suceden de adentro hacia afuera. Use una línea de código para calcular el logaritmo, en base 10, de la raíz cuadrada de 100. 5. ¿Cuál de los siguientes siempre devolverá el valor numérico almacenado en x? Puede intentar los ejemplos y usar el sistema de ayuda si lo desea. log(10^x) log10(x^10) log(exp(x)) exp(log(x, base = 2)) 2.4 Tipos de datos Las variables en R pueden ser de diferentes tipos. Por ejemplo, necesitamos distinguir números de cadenas de caracteres y tablas de listas sencillas de números. La función class nos ayuda a determinar qué tipo de objeto tenemos: a &lt;- 2 class(a) #&gt; [1] &quot;numeric&quot; Para trabajar eficientemente en R, es importante aprender los diferentes tipos de variables y qué podemos hacer con ellos. 2.4.1 data frames Hasta ahora, las variables que hemos definido son solo un número. Esto no es muy útil para almacenar datos. La forma más común de almacenar un set de datos en R es usando un data frame. Conceptualmente, podemos pensar en un data frame como una tabla con filas que representan observaciones y con columnas que representan las diferentes variables recopiladas para cada observación. Los data frames son particularmente útiles para sets de datos porque podemos combinar diferentes tipos de datos en un solo objeto. Una gran proporción de los retos del análisis de datos comienza con datos almacenados en un data frame. Por ejemplo, almacenamos los datos para nuestro ejemplo motivante en un data frame. Pueden tener acceso a este set de datos cargando el paquete dslabs y entonces utilizando la función data para cargar el set de datos murders : library(dslabs) data(murders) Para verificar que esto es un data frame, escribimos: class(murders) #&gt; [1] &quot;data.frame&quot; 2.4.2 Cómo examinar un objeto La función str es útil para obtener más información sobre la estructura de un objeto: str(murders) #&gt; &#39;data.frame&#39;: 51 obs. of 5 variables: #&gt; $ state : chr &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... #&gt; $ abb : chr &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; ... #&gt; $ region : Factor w/ 4 levels &quot;Northeast&quot;,&quot;South&quot;,..: 2 4 4 2 4 4 1 2 2 #&gt; 2 ... #&gt; $ population: num 4779736 710231 6392017 2915918 37253956 ... #&gt; $ total : num 135 19 232 93 1257 ... Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 51 filas (50 estados más DC) y cinco variables. Podemos mostrar las primeras seis líneas usando la función head: head(murders) #&gt; state abb region population total #&gt; 1 Alabama AL South 4779736 135 #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 #&gt; 4 Arkansas AR South 2915918 93 #&gt; 5 California CA West 37253956 1257 #&gt; 6 Colorado CO West 5029196 65 En este set de datos, cada estado se considera una observación y se incluyen cinco variables para cada estado. Antes de continuar con la respuesta a nuestra pregunta original sobre los diferentes estados, repasemos más sobre los componentes de este objeto. 2.4.3 El operador de acceso: $ Para nuestro análisis, necesitaremos acceso a las diferentes variables representadas por columnas incluidas en este data frame. Para hacer esto, utilizamos el operador de acceso $ de la siguiente manera: murders$population #&gt; [1] 4779736 710231 6392017 2915918 37253956 5029196 3574097 #&gt; [8] 897934 601723 19687653 9920000 1360301 1567582 12830632 #&gt; [15] 6483802 3046355 2853118 4339367 4533372 1328361 5773552 #&gt; [22] 6547629 9883640 5303925 2967297 5988927 989415 1826341 #&gt; [29] 2700551 1316470 8791894 2059179 19378102 9535483 672591 #&gt; [36] 11536504 3751351 3831074 12702379 1052567 4625364 814180 #&gt; [43] 6346105 25145561 2763885 625741 8001024 6724540 1852994 #&gt; [50] 5686986 563626 ¿Pero cómo supimos usar population? Anteriormente, aplicando la función str al objeto murders, revelamos los nombres de cada una de las cinco variables almacenadas en esta tabla. Podemos tener acceso rápido a los nombres de las variables usando: names(murders) #&gt; [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; Es importante saber que el orden de las entradas en murders$population conserva el orden de las filas en nuestra tabla de datos. Esto luego nos permitirá manipular una variable basada en los resultados de otra. Por ejemplo, podremos ordenar los nombres de los estados según el número de asesinatos. Consejo: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. Escriban murders$p y luego presionen la tecla tab en su teclado. Esta funcionalidad y muchas otras características útiles de autocompletar están disponibles en RStudio. 2.4.4 Vectores: numéricos, de caracteres y lógicos El objeto murders$population no es un número sino varios. Llamamos vectores a este tipo de objeto. Un solo número es técnicamente un vector de longitud 1, pero en general usamos el término vectores para referirnos a objetos con varias entradas. La función length les dice cuántas entradas hay en el vector: pop &lt;- murders$population length(pop) #&gt; [1] 51 Este vector particular es numérico ya que los tamaños de la población son números: class(pop) #&gt; [1] &quot;numeric&quot; En un vector numérico, cada entrada debe ser un número. Para almacenar una cadena de caracteres, los vectores también pueden ser de la clase carácter. Por ejemplo, los nombres de los estados son caracteres: class(murders$state) #&gt; [1] &quot;character&quot; Al igual que con los vectores numéricos, todas las entradas en un vector de caracteres deben ser un carácter. Otro tipo importante de vectores son los vectores lógicos. Estos deben ser TRUE o FALSE. z &lt;- 3 == 2 z #&gt; [1] FALSE class(z) #&gt; [1] &quot;logical&quot; Aquí el == es un operador relacional que pregunta si 3 es igual a 2. En R, usar solo un = asigna una variable, pero si usan dos == entonces evalúa si los objetos son iguales. Pueden ver esto al escribir: ?Comparison En futuras secciones, observarán lo útil que pueden ser los operadores relacionales. Discutimos las características más importantes de los vectores después de los siguientes ejercicios. Avanzado: Matemáticamente, los valores en pop son números enteros y hay una clase de enteros en R. Sin embargo, por defecto, a los números se les asigna una clase numérica incluso cuando son enteros redondos. Por ejemplo, class(1) devuelve numérico. Pueden convertirlo en un entero de clase con la función as.integer() o agregando un L así: 1L. Tengan en cuenta la clase escribiendo: class(1L) 2.4.5 Factores En el set de datos murders, se podría esperar que la región también sea un vector de caracteres. Sin embargo, no lo es: class(murders$region) #&gt; [1] &quot;factor&quot; Es un factor. Los factores son útiles para almacenar datos categóricos. Podemos ver que solo hay cuatro regiones al utilizar la función levels: levels(murders$region) #&gt; [1] &quot;Northeast&quot; &quot;South&quot; &quot;North Central&quot; &quot;West&quot; En el fondo, R almacena estos levels como números enteros y mantiene un mapa para llevar un registro de las etiquetas. Esto es más eficiente en terminos de memoria que almacenar todos los caracteres. Recuerden que el orden de los levels es diferente del orden en que aparecen en el objeto factor. El valor por defecto de los levels es seguir el orden alfabético. Sin embargo, a veces queremos que los levels sigan un orden diferente. Tendremos varios ejemplos de esto en la parte del libro sobre la visualización de datos. La función reorder nos permite cambiar el orden de los levels de un factor variable según un resumen calculado en un vector numérico. Demostremos esto con un ejemplo sencillo. Supongamos que queremos los levels de la región ordenados según el número total de asesinatos en vez de por orden alfabético. Si hay valores asociados con cada level, podemos usar reorder y especificar un resumen de datos para determinar el orden. El siguiente código toma la suma del total de asesinatos en cada región y reordena el factor según estas sumas. region &lt;- murders$region value &lt;- murders$total region &lt;- reorder(region, value, FUN = sum) levels(region) #&gt; [1] &quot;Northeast&quot; &quot;North Central&quot; &quot;West&quot; &quot;South&quot; El nuevo orden concuerda con el hecho de que hay menos asesinatos en el Noreste y más en el Sur. Advertencia: Los factores pueden causar confusión ya que a veces se comportan como caracteres y otras veces no. Como resultado, estos son una fuente común de errores. 2.4.6 Listas Los data frames son un caso especial de listas. Cubriremos las listas con más detalle más adelante, pero sabemos que son útiles porque pueden almacenar cualquier combinación de diferentes tipos de datos. Aquí creamos una lista para servir de ejemplo: record #&gt; $name #&gt; [1] &quot;John Doe&quot; #&gt; #&gt; $student_id #&gt; [1] 1234 #&gt; #&gt; $grades #&gt; [1] 95 82 91 97 93 #&gt; #&gt; $final_grade #&gt; [1] &quot;A&quot; class(record) #&gt; [1] &quot;list&quot; Al igual que con los data frames, pueden extraer los componentes de una lista con el operador de acceso: $. De hecho, los data frames son un tipo de lista. record$student_id #&gt; [1] 1234 También podemos usar corchetes dobles ( [[) así: record[[&quot;student_id&quot;]] #&gt; [1] 1234 Deben acostumbrarse al hecho de que en R a menudo hay varias formas de hacer lo mismo, como tener acceso a las entradas. También pueden encontrar listas sin nombres de variables: record2 #&gt; [[1]] #&gt; [1] &quot;John Doe&quot; #&gt; #&gt; [[2]] #&gt; [1] 1234 Si una lista no tiene nombres, no pueden extraer los elementos con $, pero pueden usar el método de corchetes. En vez de proveer el nombre de la variable, pueden proveer el índice de la lista de la siguiente manera: record2[[1]] #&gt; [1] &quot;John Doe&quot; No usaremos listas hasta más tarde, pero es posible que encuentren una en sus propias exploraciones de R. Por eso, les mostramos algunos conceptos básicos aquí. 2.4.7 Matrices Las matrices son otro tipo de objeto común en R. Las matrices son similares a los data frames en que son bidimensionales: tienen filas y columnas. Sin embargo, al igual que los vectores numéricos, de caracteres y lógicos, las entradas en las matrices deben ser del mismo tipo. Por esta razón, los data frames son mucho más útiles para almacenar datos, ya que podemos tener caracteres, factores y números en ellos. No obstante, las matrices tienen una gran ventaja sobre los data frames: podemos realizar operaciones de álgebra de matrices, una técnica matemática poderosa. No describimos estas operaciones en este libro, pero gran parte de lo que sucede en segundo plano cuando realiza un análisis de datos involucra matrices. Cubrimos las matrices con más detalle en el Capítulo ?? pero también las discutimos brevemente aquí, ya que algunas de las funciones que aprenderemos devuelven matrices. Podemos definir una matriz usando la función matrix. Necesitamos especificar el número de filas y columnas: mat &lt;- matrix(1:12, 4, 3) mat #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 Pueden acceder a entradas específicas en una matriz usando corchetes ( [). Si desean la segunda fila, tercera columna, usen: mat[2, 3] #&gt; [1] 10 Si desean toda la segunda fila, dejen vacío el lugar de la columna: mat[2, ] #&gt; [1] 2 6 10 Tengan en cuenta que esto devuelve un vector, no una matriz. Del mismo modo, si desean la tercera columna completa, dejen el lugar de la fila vacío: mat[, 3] #&gt; [1] 9 10 11 12 Esto también es un vector, no una matriz. Pueden acceder a más de una columna o más de una fila si lo desean. Esto les dará una nueva matriz. mat[, 2:3] #&gt; [,1] [,2] #&gt; [1,] 5 9 #&gt; [2,] 6 10 #&gt; [3,] 7 11 #&gt; [4,] 8 12 Pueden crear subconjuntos basados tanto en las filas como en las columnas: mat[1:2, 2:3] #&gt; [,1] [,2] #&gt; [1,] 5 9 #&gt; [2,] 6 10 Podemos convertir las matrices en data frames usando la función as.data.frame: as.data.frame(mat) #&gt; V1 V2 V3 #&gt; 1 1 5 9 #&gt; 2 2 6 10 #&gt; 3 3 7 11 #&gt; 4 4 8 12 También podemos usar corchetes individuales ( [) para acceder a las filas y las columnas de un data frame: data(&quot;murders&quot;) murders[25, 1] #&gt; [1] &quot;Mississippi&quot; murders[2:3, ] #&gt; state abb region population total #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 2.5 Ejercicios 1. Cargue el set de datos de asesinatos de EE. UU.. library(dslabs) data(murders) Use la función str para examinar la estructura del objeto murders. ¿Cuál de las siguientes opciones describe mejor las variables representadas en este data frame? Los 51 estados. Las tasas de asesinatos para los 50 estados y DC. El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población y el número total de asesinatos para 2010 del estado. str no muestra información relevante. 2. ¿Cuáles son los nombres de las columnas utilizados por el data frame para estas cinco variables? 3. Use el operador de acceso $ para extraer las abreviaturas de los estados y asignarlas al objeto a. ¿Cuál es la clase de este objeto? 4. Ahora use los corchetes para extraer las abreviaturas de los estados y asignarlas al objeto b. Utilice la función identical para determinar si a y b son iguales. 5. Vimos que la columna region almacena un factor. Puede corroborar esto escribiendo: class(murders$region) Con una línea de código, use las funciones levels y length para determinar el número de regiones definidas por este set de datos. 6. La función table toma un vector y devuelve la frecuencia de cada elemento. Puede ver rápidamente cuántos estados hay en cada región aplicando esta función. Use esta función en una línea de código para crear una tabla de estados por región. 2.6 Vectores En R, los objetos más básicos disponibles para almacenar datos son vectores. Como hemos visto, los sets de datos complejos generalmente se pueden dividir en componentes que son vectores. Por ejemplo, en un data frame, cada columna es un vector. Aquí aprendemos más sobre esta clase importante. 2.6.1 Cómo crear vectores Podemos crear vectores usando la función c, que significa concatenar. Usamos c para concatenar entradas de la siguiente manera: codes &lt;- c(380, 124, 818) codes #&gt; [1] 380 124 818 También podemos crear vectores de caracteres. Usamos las comillas para denotar que las entradas son caracteres en lugar de nombres de variables. country &lt;- c(&quot;italy&quot;, &quot;canada&quot;, &quot;egypt&quot;) En R también pueden usar comillas sencillas: country &lt;- c(&#39;italy&#39;, &#39;canada&#39;, &#39;egypt&#39;) Pero tengan cuidado de no confundir la comilla sencilla ’ con el back quote `. A estas alturas ya deberían saber que si escriben: country &lt;- c(italy, canada, egypt) reciben un error porque las variables italy, canada y egypt no están definidas. Si no usamos las comillas, R busca variables con esos nombres y devuelve un error. 2.6.2 Nombres A veces es útil nombrar las entradas de un vector. Por ejemplo, al definir un vector de códigos de paises, podemos usar los nombres para conectar los dos: codes &lt;- c(italy = 380, canada = 124, egypt = 818) codes #&gt; italy canada egypt #&gt; 380 124 818 El objeto codes sigue siendo un vector numérico: class(codes) #&gt; [1] &quot;numeric&quot; pero con nombres: names(codes) #&gt; [1] &quot;italy&quot; &quot;canada&quot; &quot;egypt&quot; Si el uso de cadenas sin comillas parece confuso, sepan que también pueden usar las comillas: codes &lt;- c(&quot;italy&quot; = 380, &quot;canada&quot; = 124, &quot;egypt&quot; = 818) codes #&gt; italy canada egypt #&gt; 380 124 818 No hay diferencia entre esta llamada a función (function call en inglés) y la anterior. Esta es una de las muchas formas en que R es peculiar en comparación con otros lenguajes. También podemos asignar nombres usando la función names: codes &lt;- c(380, 124, 818) country &lt;- c(&quot;italy&quot;,&quot;canada&quot;,&quot;egypt&quot;) names(codes) &lt;- country codes #&gt; italy canada egypt #&gt; 380 124 818 2.6.3 Secuencias Otra función útil para crear vectores genera secuencias: seq(1, 10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 El primer argumento define el inicio y el segundo define el final que incluimos. El valor por defecto es subir en incrementos de 1, pero un tercer argumento nos permite determinar cuánto saltar: seq(1, 10, 2) #&gt; [1] 1 3 5 7 9 Si queremos enteros consecutivos, podemos usar la siguiente taquigrafía: 1:10 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Cuando usamos estas funciones, R produce números enteros, no numéricos, porque generalmente se usan para indexar algo: class(1:10) #&gt; [1] &quot;integer&quot; Sin embargo, si creamos una secuencia que incluye no enteros, la clase cambia: class(seq(1, 10, 0.5)) #&gt; [1] &quot;numeric&quot; 2.6.4 Cómo crear un subconjunto Usamos los corchetes para tener acceso a elementos específicos de un vector. Para el vector codes que definimos anteriormente, podemos tener acceso al segundo elemento usando: codes[2] #&gt; canada #&gt; 124 Pueden obtener más de una entrada utilizando un vector de entradas múltiples como índice: codes[c(1,3)] #&gt; italy egypt #&gt; 380 818 Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos: codes[1:2] #&gt; italy canada #&gt; 380 124 Si los elementos tienen nombres, también podemos acceder a las entradas utilizando estos nombres. A continuación ofrecemos dos ejemplos: codes[&quot;canada&quot;] #&gt; canada #&gt; 124 codes[c(&quot;egypt&quot;,&quot;italy&quot;)] #&gt; egypt italy #&gt; 818 380 2.7 La conversión forzada En general, la conversión forzada (coercion en inglés) es un intento de R de ser flexible con los tipos de datos. Cuando una entrada no coincide con lo esperado, algunas de las funciones predefinidas de R tratan de adivinar lo que uno intentaba antes de devolver un mensaje de error. Esto también puede causar confusión. Al no entender la conversión forzada, los programadores pueden volverse locos cuando codifican en R, ya que R se comporta de manera bastante diferente a la mayoría de los otros idiomas en cuanto a esto. Aprendamos más con unos ejemplos. Dijimos que los vectores deben ser todos del mismo tipo. Entonces, si tratamos de combinar, por ejemplo, números y caracteres, pueden esperar un error: x &lt;- c(1, &quot;canada&quot;, 3) ¡Pero no nos da uno, ni siquiera una advertencia! ¿Que pasó? Mire x y su clase: x #&gt; [1] &quot;1&quot; &quot;canada&quot; &quot;3&quot; class(x) #&gt; [1] &quot;character&quot; R forzó una conversión de los datos a caracteres. Como pusimos una cadena de caracteres en el vector, R adivinó que nuestra intención era que el 1 y el 3 fueran las cadenas de caracteres &quot;1&quot; y “3”. El hecho de que ni siquiera emitiera una advertencia es un ejemplo de cómo la conversión forzada puede causar muchos errores inadvertidos en R. R también ofrece funciones para cambiar de un tipo a otro. Por ejemplo, pueden convertir números en caracteres con: x &lt;- 1:5 y &lt;- as.character(x) y #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; Pueden revertir a lo anterior con as.numeric: as.numeric(y) #&gt; [1] 1 2 3 4 5 Esta función es muy útil ya que los sets de datos que incluyen números como cadenas de caracteres son comunes. 2.7.1 Not available (NA) Cuando una función intenta forzar una conversión de un tipo a otro y encuentra un caso imposible, generalmente nos da una advertencia y convierte la entrada en un valor especial llamado NA que significa no disponible (Not Available en inglés). Por ejemplo: x &lt;- c(&quot;1&quot;, &quot;b&quot;, &quot;3&quot;) as.numeric(x) #&gt; Warning: NAs introducidos por coerción #&gt; [1] 1 NA 3 R no sabe el número que querían cuando escribieron b y no lo intenta adivinar. Como científicos de datos, se encontrarán con el NA frecuentemente ya que se usa generalmente para datos faltantes (missing data en inglés), un problema común en los sets de datos del mundo real. 2.8 Ejercicios 1. Use la función c para crear un vector con las temperaturas altas promedio en enero para Beijing, Lagos, París, Río de Janeiro, San Juan y Toronto, que son 35, 88, 42, 84, 81 y 30 grados Fahrenheit. Llame al objeto temp. 2. Ahora cree un vector con los nombres de las ciudades y llame al objeto city. 3. Utilice la función names y los objetos definidos en los ejercicios anteriores para asociar los datos de temperatura con su ciudad correspondiente. 4. Utilice los operadores [ y : para acceder a la temperatura de las tres primeras ciudades de la lista. 5. Utilice el operador [ para acceder a la temperatura de París y San Juan. 6. Utilice el operador : para crear una secuencia de números \\(12,13,14,\\dots,73\\). 7. Cree un vector que contenga todos los números impares positivos menores que 100. 8. Cree un vector de números que comience en 6, no pase 55 y agregue números en incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7, y así sucesivamente. ¿Cuántos números tiene la lista? Sugerencia: use seq y length. 9. ¿Cuál es la clase del siguiente objeto? a &lt;- seq(1, 10, 0.5)? 10. ¿Cuál es la clase del siguiente objeto? a &lt;- seq(1, 10)? 11. La clase de class(a&lt;-1) es numérica, no entero. R por defecto es numérico y para forzar un número entero, debe agregar la letra L. Confirme que la clase de 1L es entero. 12. Defina el siguiente vector: x &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;5&quot;) y oblíguelo a obtener enteros. 2.9 Sorting Ahora que hemos dominado algunos conocimientos básicos de R, intentemos obtener algunos conocimientos sobre la seguridad de los distintos estados en el contexto de los asesinatos con armas de fuego. 2.9.1 sort Digamos que queremos clasificar los estados desde el menor hasta el mayor según los asesinatos con armas de fuego. La función sort ordena un vector en orden creciente. Por lo tanto, podemos ver la mayor cantidad de asesinatos con armas escribiendo: library(dslabs) data(murders) sort(murders$total) #&gt; [1] 2 4 5 5 7 8 11 12 12 16 19 21 22 #&gt; [14] 27 32 36 38 53 63 65 67 84 93 93 97 97 #&gt; [27] 99 111 116 118 120 135 142 207 219 232 246 250 286 #&gt; [40] 293 310 321 351 364 376 413 457 517 669 805 1257 Sin embargo, esto no nos da información sobre qué estados tienen qué total de asesinatos. Por ejemplo, no sabemos qué estado tuvo 1257. 2.9.2 order La función order es mas apropiada para lo que queremos hacer. order toma un vector como entrada, y devuelve el vector de índices que clasifica el vector de entrada. Esto puede ser un poco confuso, así que estudiemos un ejemplo sencillo. Podemos crear un vector y ordenarlo (sort en inglés): x &lt;- c(31, 4, 15, 92, 65) sort(x) #&gt; [1] 4 15 31 65 92 En lugar de ordenar el vector de entrada, la función order devuelve el índice que ordena el vector de entrada: index &lt;- order(x) x[index] #&gt; [1] 4 15 31 65 92 Este es el mismo resultado que le devuelve sort(x). Si miramos este índice, vemos por qué funciona: x #&gt; [1] 31 4 15 92 65 order(x) #&gt; [1] 2 3 1 5 4 La segunda entrada de x es la más pequeña, entonces order(x) comienza con 2. La siguiente más pequeña es la tercera entrada, por lo que la segunda entrada es 3 y así sigue. ¿Cómo nos ayuda esto a ordenar los estados por asesinatos? Primero, recuerden que las entradas de vectores a las que acceden con $ siguen el mismo orden que las filas de la tabla. Por ejemplo, estos dos vectores que contienen el nombre de los estados y sus abreviaturas, respectivamente, siguen el mismo orden: murders$state[1:6] #&gt; [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; &quot;California&quot; #&gt; [6] &quot;Colorado&quot; murders$abb[1:6] #&gt; [1] &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; &quot;CA&quot; &quot;CO&quot; Esto significa que podemos ordenar los nombres de estado según el total de asesinatos. Primero obtenemos el índice que ordena los vectores por el total de asesinatos y luego ponemos el vector de nombres de estado en un índice: ind &lt;- order(murders$total) murders$abb[ind] #&gt; [1] &quot;VT&quot; &quot;ND&quot; &quot;NH&quot; &quot;WY&quot; &quot;HI&quot; &quot;SD&quot; &quot;ME&quot; &quot;ID&quot; &quot;MT&quot; &quot;RI&quot; &quot;AK&quot; &quot;IA&quot; &quot;UT&quot; #&gt; [14] &quot;WV&quot; &quot;NE&quot; &quot;OR&quot; &quot;DE&quot; &quot;MN&quot; &quot;KS&quot; &quot;CO&quot; &quot;NM&quot; &quot;NV&quot; &quot;AR&quot; &quot;WA&quot; &quot;CT&quot; &quot;WI&quot; #&gt; [27] &quot;DC&quot; &quot;OK&quot; &quot;KY&quot; &quot;MA&quot; &quot;MS&quot; &quot;AL&quot; &quot;IN&quot; &quot;SC&quot; &quot;TN&quot; &quot;AZ&quot; &quot;NJ&quot; &quot;VA&quot; &quot;NC&quot; #&gt; [40] &quot;MD&quot; &quot;OH&quot; &quot;MO&quot; &quot;LA&quot; &quot;IL&quot; &quot;GA&quot; &quot;MI&quot; &quot;PA&quot; &quot;NY&quot; &quot;FL&quot; &quot;TX&quot; &quot;CA&quot; De acuerdo con lo anterior, California tuvo la mayor cantidad de asesinatos. 2.9.3 max y which.max Si solo estamos interesados en la entrada con el mayor valor, podemos usar max para ese valor: max(murders$total) #&gt; [1] 1257 y which.max para el índice del valor mayor: i_max &lt;- which.max(murders$total) murders$state[i_max] #&gt; [1] &quot;California&quot; Como mínimo, podemos usar min y which.min del mismo modo. ¿Esto significa que California es el estado más peligroso? En una próxima sección, planteamos que deberíamos considerar las tasas en lugar de los totales. Antes de hacer eso, presentamos una última función relacionada con el orden: rank. 2.9.4 rank Aunque no se usa con tanta frecuencia como order y sort, la función rank también está relacionada con el orden y puede ser útil. Para cualquier vector dado, rank devuelve un vector con el rango de la primera entrada, segunda entrada, etc., del vector de entrada. Aquí tenemos un ejemplo sencillo: x &lt;- c(31, 4, 15, 92, 65) rank(x) #&gt; [1] 3 1 2 5 4 Para resumir, veamos los resultados de las tres funciones que hemos discutido: original sort order rank 31 4 2 3 4 15 3 1 15 31 1 2 92 65 5 5 65 92 4 4 2.9.5 Cuidado con el reciclaje Otra fuente común de errores inadvertidos en R es el uso de reciclaje (recycling en inglés). Hemos visto como los vectores se agregan por elementos. Entonces, si los vectores no coinciden en longitud, es natural suponer que obtendramos un error. Pero ese no es el caso. Vean lo que pasa: x &lt;- c(1,2,3) y &lt;- c(10, 20, 30, 40, 50, 60, 70) x+y #&gt; Warning in x + y: longitud de objeto mayor no es múltiplo de la longitud #&gt; de uno menor #&gt; [1] 11 22 33 41 52 63 71 Recibimos una advertencia, pero no hay error. Para el output, R ha reciclado los números en x. Observen el último dígito de números en el output. 2.10 Ejercicios Para estos ejercicios usaremos el set de datos de asesinatos de EE. UU.. Asegúrese de cargarlo antes de comenzar. library(dslabs) data(&quot;murders&quot;) 1. Utilice el operador $ para acceder a los datos del tamaño de la población y almacenarlos como el objeto pop. Luego use la función sort para redefinir pop para que esté en orden alfabético. Finalmente, use el operador [ para indicar el tamaño de población más pequeño. 2. Ahora, en lugar del tamaño de población más pequeño, encuentre el índice de la entrada con el tamaño de población más pequeño. Sugerencia: use order en lugar de sort. 3. Podemos realizar la misma operación que en el ejercicio anterior usando la función which.min. Escriba una línea de código que haga esto. 4. Ahora sabemos cuán pequeño es el estado más pequeño y qué fila lo representa. ¿Qué estado es? Defina una variable states para ser los nombres de los estados del data frame murders. Indique el nombre del estado con la población más pequeña. 5. Puede crear un data frame utilizando la función data.frame. Aquí un ejemplo: temp &lt;- c(35, 88, 42, 84, 81, 30) city &lt;- c(&quot;Beijing&quot;, &quot;Lagos&quot;, &quot;Paris&quot;, &quot;Rio de Janeiro&quot;, &quot;San Juan&quot;, &quot;Toronto&quot;) city_temps &lt;- data.frame(name = city, temperature = temp) Utilice la función rank para determinar el rango de población de cada estado desde el menos poblado hasta el más poblado. Guarde estos rangos en un objeto llamado ranks, luego cree un data frame con el nombre del estado y su rango. Nombre el data frame my_df. 6. Repita el ejercicio anterior, pero esta vez ordene my_df para que los estados estén en orden de menos poblado a más poblado. Sugerencia: cree un objeto ind que almacene los índices necesarios para poner en orden los valores de la población. Luego use el operador de corchete [ para reordenar cada columna en el data frame. 7. El vector na_example representa una serie de conteos. Puede examinar rápidamente el objeto usando: data(&quot;na_example&quot;) str(na_example) #&gt; int [1:1000] 2 1 3 2 1 3 1 4 3 2 ... Sin embargo, cuando calculamos el promedio con la función mean, obtenemos un NA: mean(na_example) #&gt; [1] NA La función is.na devuelve un vector lógico que nos dice qué entradas son NA. Asigne este vector lógico a un objeto llamado ind y determine cuántos NAs tiene na_example. 8. Ahora calcule nuevamente el promedio, pero solo para las entradas que no son NA. Sugerencia: recuerde el operador !. 2.11 Aritmética de vectores California tuvo la mayor cantidad de asesinatos, pero ¿esto significa que es el estado más peligroso? ¿Qué pasa si solo tiene muchas más personas que cualquier otro estado? Podemos confirmar rápidamente que California tiene la mayor población: library(dslabs) data(&quot;murders&quot;) murders$state[which.max(murders$population)] #&gt; [1] &quot;California&quot; con más de 37 millones de habitantes. Por lo tanto, es injusto comparar los totales si estamos interesados en saber cuán seguro es el estado. Lo que realmente deberíamos calcular son los asesinatos per cápita. Los informes que describimos en la sección motivante utilizan asesinatos por cada 100,000 como la unidad. Para calcular esta cantidad, usamos las poderosas capacidades aritméticas de vectores de R. 2.11.1 Rescaling un vector En R, las operaciones aritméticas en vectores ocurren elemento por elemento. Como ejemplo, supongamos que tenemos la altura en pulgadas (inches en inglés): inches &lt;- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70) y queremos convertirla a centímetros. Observen lo que sucede cuando multiplicamos inches por 2.54: inches * 2.54 #&gt; [1] 175 157 168 178 178 185 170 185 170 178 Arriba, multiplicamos cada elemento por 2.54. Del mismo modo, si para cada entrada queremos calcular cuántas pulgadas más alto, o cuántas más corto, que 69 pulgadas (la altura promedio para hombres), podemos restarlo de cada entrada de esta manera: inches - 69 #&gt; [1] 0 -7 -3 1 1 4 -2 4 -2 1 2.11.2 Dos vectores Si tenemos dos vectores de la misma longitud y los sumamos en R, se agregarán entrada por entrada de la siguiente manera: \\[ \\begin{pmatrix} a\\\\ b\\\\ c\\\\ d \\end{pmatrix} + \\begin{pmatrix} e\\\\ f\\\\ g\\\\ h \\end{pmatrix} = \\begin{pmatrix} a +e\\\\ b + f\\\\ c + g\\\\ d + h \\end{pmatrix} \\] Lo mismo aplica para otras operaciones matemáticas, como -, * y /. Esto implica que para calcular las tasas de asesinatos (murder rates en inglés) simplemente podemos escribir: murder_rate &lt;- murders$total/ murders$population * 100000 Al hacer esto, notamos que California ya no está cerca de la parte superior de la lista. De hecho, podemos usar lo que hemos aprendido para poner a los estados en orden por tasa de asesinatos: murders$abb[order(murder_rate)] #&gt; [1] &quot;VT&quot; &quot;NH&quot; &quot;HI&quot; &quot;ND&quot; &quot;IA&quot; &quot;ID&quot; &quot;UT&quot; &quot;ME&quot; &quot;WY&quot; &quot;OR&quot; &quot;SD&quot; &quot;MN&quot; &quot;MT&quot; #&gt; [14] &quot;CO&quot; &quot;WA&quot; &quot;WV&quot; &quot;RI&quot; &quot;WI&quot; &quot;NE&quot; &quot;MA&quot; &quot;IN&quot; &quot;KS&quot; &quot;NY&quot; &quot;KY&quot; &quot;AK&quot; &quot;OH&quot; #&gt; [27] &quot;CT&quot; &quot;NJ&quot; &quot;AL&quot; &quot;IL&quot; &quot;OK&quot; &quot;NC&quot; &quot;NV&quot; &quot;VA&quot; &quot;AR&quot; &quot;TX&quot; &quot;NM&quot; &quot;CA&quot; &quot;FL&quot; #&gt; [40] &quot;TN&quot; &quot;PA&quot; &quot;AZ&quot; &quot;GA&quot; &quot;MS&quot; &quot;MI&quot; &quot;DE&quot; &quot;SC&quot; &quot;MD&quot; &quot;MO&quot; &quot;LA&quot; &quot;DC&quot; 2.12 Ejercicios 1. Anteriormente creamos este data frame: temp &lt;- c(35, 88, 42, 84, 81, 30) city &lt;- c(&quot;Beijing&quot;, &quot;Lagos&quot;, &quot;Paris&quot;, &quot;Rio de Janeiro&quot;, &quot;San Juan&quot;, &quot;Toronto&quot;) city_temps &lt;- data.frame(name = city, temperature = temp) Vuelva a crear el data frame utilizando el código anterior, pero agregue una línea que convierta la temperatura de Fahrenheit a Celsius. La conversión es \\(C = \\frac{5}{9} \\times (F - 32)\\). 2. ¿Cuál es la siguiente suma? \\(1+1/2^2 + 1/3^2 + \\dots 1/100^2\\)? Sugerencia: gracias a Euler, sabemos que debería estar cerca de \\(\\pi^2/6\\). 3. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en el objeto murder_rate. Luego calcule la tasa promedio de asesinatos para EE. UU. con la función mean. ¿Cuál es el promedio? 2.13 Indexación R provee una forma poderosa y conveniente de indexar vectores. Podemos, por ejemplo, crear un subconjunto de un vector según las propiedades de otro vector. En esta sección, continuamos trabajando con nuestro ejemplo de asesinatos en EE. UU., que podemos cargar así: library(dslabs) data(&quot;murders&quot;) 2.13.1 Crear subconjuntos con lógicos Ahora hemos calculado la tasa de asesinatos usando: murder_rate &lt;- murders$total/ murders$population * 100000 Imagine que se muda de Italia donde, según un informe de noticias, la tasa de asesinatos es solo 0.71 por 100,000. Preferiría mudarse a un estado con una tasa de homicidios similar. Otra característica poderosa de R es que podemos usar lógicas para indexar vectores. Si comparamos un vector con un solo número, R realiza la prueba para cada entrada. Aquí tenemos un ejemplo relacionado con la pregunta anterior: ind &lt;- murder_rate &lt; 0.71 Si en cambio queremos saber si un valor es menor o igual, podemos usar: ind &lt;- murder_rate &lt;= 0.71 Recuerden que recuperamos un vector lógico con TRUE para cada entrada menor o igual a 0.71. Para ver qué estados son estos, podemos aprovechar el hecho de que los vectores se pueden indexar con lógicos. murders$state[ind] #&gt; [1] &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; &quot;North Dakota&quot; #&gt; [5] &quot;Vermont&quot; Para contar cuántos son TRUE, la función sum devuelve la suma de las entradas de un vector y fuerza una conversión de los vectores lógicos a numéricos con TRUE codificado como 1 y FALSE como 0. Así podemos contar los estados usando: sum(ind) #&gt; [1] 5 2.13.2 Operadores lógicos Supongamos que nos gustan las montañas y queremos mudarnos a un estado seguro en la región occidental del país. Queremos que la tasa de asesinatos sea como máximo 1. En este caso, queremos que dos cosas diferentes sean ciertas. Aquí podemos usar el operador lógico and, que en R se representa con &amp;. Esta operación da como resultado TRUE solo cuando ambas lógicas son TRUE, es decir ciertas. Para ver esto, considere este ejemplo: TRUE &amp; TRUE #&gt; [1] TRUE TRUE &amp; FALSE #&gt; [1] FALSE FALSE &amp; FALSE #&gt; [1] FALSE Para nuestro ejemplo, podemos formar dos lógicos: west &lt;- murders$region == &quot;West&quot; safe &lt;- murder_rate &lt;= 1 y podemos usar el &amp; para obtener un vector lógico que nos dice qué estados satisfacen ambas condiciones: ind &lt;- safe &amp; west murders$state[ind] #&gt; [1] &quot;Hawaii&quot; &quot;Idaho&quot; &quot;Oregon&quot; &quot;Utah&quot; &quot;Wyoming&quot; 2.13.3 which Supongamos que queremos ver la tasa de asesinatos de California. Para este tipo de operación, es conveniente convertir vectores lógicos en índices en lugar de mantener vectores lógicos largos. La función which nos dice qué entradas de un vector lógico son TRUE. Entonces podemos escribir: ind &lt;- which(murders$state == &quot;California&quot;) murder_rate[ind] #&gt; [1] 3.37 2.13.4 match Si en lugar de un solo estado queremos averiguar las tasas de homicidio de varios estados, digamos Nueva York, Florida y Texas, podemos usar la función match. Esta función nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector: ind &lt;- match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) ind #&gt; [1] 33 10 44 Ahora podemos ver las tasas de asesinatos: murder_rate[ind] #&gt; [1] 2.67 3.40 3.20 2.13.5 %in% Si en lugar de un índice queremos un lógico que nos diga si cada elemento de un primer vector está en un segundo vector, podemos usar la función %in%. Imaginemos que no están seguros si Boston, Dakota y Washington son estados. Pueden averiguar así: c(&quot;Boston&quot;, &quot;Dakota&quot;, &quot;Washington&quot;) %in% murders$state #&gt; [1] FALSE FALSE TRUE Tengan en cuenta que estaremos usando %in% frecuentemente a lo largo del libro. Avanzado: Hay una conexión entre match y %in% mediante which. Para ver esto, observen que las siguientes dos líneas producen el mismo índice (aunque en orden diferente): match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) #&gt; [1] 33 10 44 which(murders$state%in%c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;)) #&gt; [1] 10 33 44 2.14 Ejercicios Empiece cargando el paquete y los datos. library(dslabs) data(murders) 1. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en un objeto llamado murder_rate. Luego use operadores lógicos para crear un vector lógico llamado low que nos dice qué entradas de murder_rate son inferiores a 1. 2. Ahora use los resultados del ejercicio anterior y la función which para determinar los índices de murder_rate asociados con valores inferiores a 1. 3. Use los resultados del ejercicio anterior para indicar los nombres de los estados con tasas de asesinatos inferiores a 1. 4. Ahora extienda el código de los ejercicios 2 y 3 para indicar los estados del noreste con tasas de homicidios inferiores a 1. Sugerencia: use el vector lógico predefinido low y el operador lógico &amp;. 5. En un ejercicio anterior, calculamos la tasa de homicidios para cada estado y el promedio de estos números. ¿Cuántos estados están por debajo del promedio? 6. Use la función match para identificar los estados con abreviaturas AK, MI e IA. Sugerencia: comience definiendo un índice de las entradas de murders$abb que coinciden con las tres abreviaturas. Entonces use el operador [ para extraer los estados. 7. Utilice el operador %in% para crear un vector lógico que responda a la pregunta: ¿cuáles de las siguientes son abreviaturas reales: MA, ME, MI, MO, MU? 8. Extienda el código que usó en el ejercicio 7 para averiguar la única entrada que no es una abreviatura real. Sugerencia: use el operador !, que convierte FALSE a TRUE y viceversa, y entonces which para obtener un índice. 2.15 Gráficos básicos En el capitulo ?? describimos un paquete complementario que ofrece un enfoque poderoso para producir gráficos (plots en inglés) en R. Luego tenemos una parte completa, “Visualización de datos”, en la que ofrecemos muchos ejemplos. Aquí describimos brevemente algunas de las funciones disponibles en una instalación básica de R. 2.15.1 plot La función plot se puede utilizar para hacer diagramas de dispersión (scatterplots en inglés). Aquí hay un gráfico de total de asesinatos versus población. x &lt;- murders$population/ 10^6 y &lt;- murders$total plot(x, y) Para crear un gráfico rápido que no accede a las variables dos veces, podemos usar la función with: with(murders, plot(population, total)) La función with nos permite usar los nombres en la columna murders en la función plot. También funciona con cualquier data frame y cualquier función. 2.15.2 hist x &lt;- with(murders, total/ population * 100000) hist(x) Podemos ver que hay una amplia gama de valores con la mayoría de ellos entre 2 y 3 y un caso muy extremo con una tasa de asesinatos de más de 15: murders$state[which.max(x)] #&gt; [1] &quot;District of Columbia&quot; 2.15.3 boxplot Los diagramas de caja (boxplots en inglés) también se describirán en la parte del libro “Visualización de datos”. Estos proveen un resumen más conciso que los histogramas, pero son más fáciles de apilar con otros diagramas de caja. Por ejemplo, aquí podemos usarlos para comparar las diferentes regiones: murders$rate &lt;- with(murders, total/ population * 100000) boxplot(rate~region, data = murders) Podemos ver que el Sur tiene tasas de asesinatos más altas que las otras tres regiones. 2.15.4 image La función image muestra los valores en una matriz usando color. Aquí mostramos un ejemplo rápido: x &lt;- matrix(1:120, 12, 10) image(x) 2.16 Ejercicios 1. Hicimos un gráfico de asesinatos totales versus población y notamos una fuerte relación. No es sorprendente que los estados con poblaciones más grandes hayan tenido más asesinatos. library(dslabs) data(murders) population_in_millions &lt;- murders$population/10^6 total_gun_murders &lt;- murders$total plot(population_in_millions, total_gun_murders) Recuerden que muchos estados tienen poblaciones inferiores a 5 millones y están agrupados. Podemos obtener más información al hacer este gráfico en la escala logarítmica. Transforme las variables usando la transformación log10 y luego cree un gráfico de los resultados. 2. Cree un histograma de las poblaciones estatales. 3. Genere diagramas de caja de las poblaciones estatales por región. https://rstudio.cloud↩ https://rafalab.github.io/dsbook/installing-r-rstudio.html↩ http://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership-homicide-rate-higher-than-other-developed-countries/↩ http://adv-r.had.co.nz/Style.html↩ "],
["conceptos-basicos-de-programacion.html", "Capítulo 3 Conceptos básicos de programación 3.1 Expresiones condicionales 3.2 Cómo definir funciones 3.3 Namespaces 3.4 Bucles-for 3.5 Vectorización y funcionales 3.6 Ejercicios", " Capítulo 3 Conceptos básicos de programación Enseñamos R porque facilita enormemente el análisis de datos, el tema principal de este libro. Al codificar en R, podemos eficientemente realizar análisis de datos exploratorios, construir canales de análisis de datos y preparar la visualización de datos para comunicar los resultados. Sin embargo, R no es solo un ambiente de análisis de datos sino un lenguaje de programación. Los programadores avanzados de R pueden desarrollar paquetes complejos e incluso mejorar R, aunque no cubrimos la programación avanzada en este libro. No obstante, en esta sección, presentamos tres conceptos claves de programación: las expresiones condicionales, los bucles-for (for-loops en inglés) y las funciones. Estos no son solo componentes básicos claves para la programación avanzada, sino que a veces son útiles durante el análisis de datos. También notamos que hay varias funciones que se usan ampliamente para programar en R pero que no discutiremos en este libro. Éstos incluyen split, cut, do.call y Reduce, así como el paquete data.table. Vale la pena aprender como usarlos si quieren convertirse en programadores expertos de R. 3.1 Expresiones condicionales Las expresiones condicionales son una de las características básicas de la programación. Se utilizan para lo que se denomina flow control. La expresión condicional más común es la declaración if-else. En R, podemos realizar mucho análisis de datos sin condicionales. Sin embargo, aparecen ocasionalmente y los necesitarán una vez comiencen a escribir sus propias funciones y paquetes. Aquí presentamos un ejemplo muy sencillo que muestra la estructura general de una instrucción if-else. La idea básica es imprimir el recíproco de a a menos que a sea 0: a &lt;- 0 if(a!=0){ print(1/a) } else{ print(&quot;No reciprocal for 0.&quot;) } #&gt; [1] &quot;No reciprocal for 0.&quot; Veamos otro ejemplo usando el set de datos de asesinatos de EE. UU.: library(dslabs) data(murders) murder_rate &lt;- murders$total/ murders$population*100000 Aquí ofrecemos un ejemplo muy sencillo que nos dice qué estados, si los hay, tienen una tasa de homicidios inferior a 0.5 por 100,000. Las declaraciones if nos protegen del caso en el que ningún estado satisface la condición. ind &lt;- which.min(murder_rate) if(murder_rate[ind] &lt; 0.5){ print(murders$state[ind]) } else{ print(&quot;No state has murder rate that low&quot;) } #&gt; [1] &quot;Vermont&quot; Si lo intentamos nuevamente con una tasa de 0.25, obtenemos una respuesta diferente: if(murder_rate[ind] &lt; 0.25){ print(murders$state[ind]) } else{ print(&quot;No state has a murder rate that low.&quot;) } #&gt; [1] &quot;No state has a murder rate that low.&quot; Una función relacionada que es muy útil es ifelse. Esta función toma tres argumentos: un lógico y dos posibles respuestas. Si el lógico es TRUE, devuelve el valor en el segundo argumento, y si es FALSE, devuelve el valor en el tercer argumento. Aquí tenemos un ejemplo: a &lt;- 0 ifelse(a &gt; 0, 1/a, NA) #&gt; [1] NA Esta función es particularmente útil porque sirve para vectores. Esta examina cada entrada del vector lógico y devuelve elementos del vector proporcionados en el segundo argumento, si la entrada es TRUE, o elementos del vector proporcionados en el tercer argumento, si la entrada es FALSE. a &lt;- c(0, 1, 2, -4, 5) result &lt;- ifelse(a &gt; 0, 1/a, NA) Esta tabla nos ayuda a ver qué sucedió: a is_a_positive answer1 answer2 result 0 FALSE Inf NA NA 1 TRUE 1.00 NA 1.0 2 TRUE 0.50 NA 0.5 -4 FALSE -0.25 NA NA 5 TRUE 0.20 NA 0.2 Aquí hay un ejemplo de cómo esta función se puede usar fácilmente para reemplazar todos los valores faltantes en un vector con ceros: data(na_example) no_nas &lt;- ifelse(is.na(na_example), 0, na_example) sum(is.na(no_nas)) #&gt; [1] 0 Otras dos funciones útiles son any y all. La función any toma un vector de lógicos y devuelve TRUE si alguna de las entradas es TRUE. La función all toma un vector de lógicos y devuelve TRUE si todas las entradas son TRUE. Aquí ofrecemos un ejemplo: z &lt;- c(TRUE, TRUE, FALSE) any(z) #&gt; [1] TRUE all(z) #&gt; [1] FALSE 3.2 Cómo definir funciones A medida que adquieran más experiencia, necesitarán realizar las mismas operaciones una y otra vez. Un ejemplo sencillo es el cálculo de promedios. Podemos calcular el promedio de un vector x utilizando las funciones sum y length: sum(x)/length(x). Debido a que hacemos esto repetidas veces, es mucho más eficiente escribir una función que realice esta operación. Esta operación particular es tan común que alguien ya escribió la función mean y se incluye en la base R. Sin embargo, se encontrarán con situaciones en las que la función aún no existe, por lo que R les permite escribir una. Se puede definir una versión sencilla de una función que calcula el promedio así: avg &lt;- function(x){ s &lt;- sum(x) n &lt;- length(x) s/n } Ahora avg es una función que calcula el promedio: x &lt;- 1:100 identical(mean(x), avg(x)) #&gt; [1] TRUE Observen que las variables definidas dentro de una función no se guardan en el espacio de trabajo. Entonces mientras usamos s y n cuando llamamos (call en inglés) avg, los valores se crean y cambian solo durante la llamada. Aquí podemos ver un ejemplo ilustrativo: s &lt;- 3 avg(1:10) #&gt; [1] 5.5 s #&gt; [1] 3 Noten cómo s todavía es 3 después de que llamamos avg. En general, las funciones son objetos, por lo que les asignamos nombres de variables con &lt;-. La función function le dice a R que está a punto de definir una función. La forma general de la definición de una función es así: my_function &lt;- function(VARIABLE_NAME){ perform operations on VARIABLE_NAME and calculate VALUE VALUE } Las funciones que definan pueden tener múltiples argumentos, así como valores predeterminados. Por ejemplo, podemos definir una función que calcule el promedio aritmético o geométrico dependiendo de una variable definida por usuarios como esta: avg &lt;- function(x, arithmetic = TRUE){ n &lt;- length(x) ifelse(arithmetic, sum(x)/n, prod(x)^(1/n)) } Aprenderemos más sobre cómo crear funciones a través de la experiencia a medida que nos enfrentemos a tareas más complejas. 3.3 Namespaces Una vez que comiencen a convertirse en usuarios expertos de R, es probable que necesiten cargar varios complementos de paquetes (add-ons en inglés) para algunos de sus análisis. Tan pronto hagan eso, es probable que descubran que dos paquetes usen el mismo nombre para dos funciones diferentes. Y a menudo estas funciones hacen cosas completamente diferentes. De hecho, ya hemos visto esto porque ambos paquetes de base R dplyr y stats definen una función filter. Hay otros cinco ejemplos en dplyr. Sabemos esto porque cuando cargamos dplyr por primera vez, vemos el siguiente mensaje: The following objects are masked from ‘package:stats’: filter, lag The following objects are masked from ‘package:base’: intersect, setdiff, setequal, union Entonces, ¿qué hace R cuando escribimos filter? ¿Utiliza la función dplyr o la función stats? De nuestro trabajo anterior sabemos que usa dplyr. Pero, ¿qué pasa si queremos usar stats? Estas funciones viven en diferentes namespaces. R seguirá un cierto orden cuando busque una función en estos namespaces. Pueden ver el orden escribiendo: search() La primera entrada en esta lista es el ambiente global que incluye todos los objetos que definan. Entonces, ¿qué pasa si queremos usar el filter stats en lugar del filter dplyr pero dplyr aparece primero en la lista de búsqueda? Pueden forzar el uso de un namespace específico utilizando dos puntos dobles ( ::) así: stats::filter Si queremos estar absolutamente seguros de que usamos el filter dplyr, podemos usar: dplyr::filter Recuerden que si queremos usar una función en un paquete sin cargar el paquete completo, también podemos usar los dos puntos dobles. Para más información sobre este tema más avanzado, recomendamos el libro de paquetes R16. 3.4 Bucles-for La fórmula para la suma de la serie \\(1+2+\\dots+n\\) es \\(n(n+1)/2\\). ¿Qué pasaría si no estuviéramos seguros de que esa era la función correcta? ¿Cómo podríamos verificar? Usando lo que aprendimos sobre las funciones, podemos crear una que calcule \\(S_n\\): compute_s_n &lt;- function(n){ x &lt;- 1:n sum(x) } ¿Cómo podemos calcular \\(S_n\\) para varios valores de \\(n\\), digamos \\(n=1,\\dots,25\\)? ¿Escribimos 25 líneas de código llamando compute_s_n? No. Para eso están los bucles-for en la programación. En este caso, estamos realizando exactamente la misma tarea una y otra vez, y lo único que está cambiando es el valor de \\(n\\). Los bucles-for nos permiten definir el rango que toma nuestra variable (en nuestro ejemplo \\(n=1,\\dots,10\\)), luego cambiar el valor y evaluar la expresión a medida que realice un bucle. Quizás el ejemplo más sencillo de un bucle-for es este código inútil: for(i in 1:5){ print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 Aquí está el bucle-for que escribiríamos para nuestro ejemplo \\(S_n\\): m &lt;- 25 s_n &lt;- vector(length = m) # create an empty vector for(n in 1:m){ s_n[n] &lt;- compute_s_n(n) } En cada iteración \\(n=1\\), \\(n=2\\), etc …, calculamos \\(S_n\\) y lo guardamos en la entrada \\(n\\) de s_n. Ahora podemos crear un gráfico para buscar un patrón: n &lt;- 1:m plot(n, s_n) Si notaron que parece ser cuadrático, van por buen camino porque la fórmula es \\(n(n+1)/2\\). 3.5 Vectorización y funcionales Aunque los bucles-for son un concepto importante para entender, no se usa mucho en R. A medida que aprendan más R, se darán cuenta de que la vectorización es preferible a los bucles-for puesto que resulta en un código más corto y claro. Ya vimos ejemplos en la sección de aritmética de vectores. Una función vectorizada es una función que aplicará la misma operación en cada uno de los vectores. x &lt;- 1:10 sqrt(x) #&gt; [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16 y &lt;- 1:10 x*y #&gt; [1] 1 4 9 16 25 36 49 64 81 100 Para hacer este cálculo, no necesitamos los bucles-for. Sin embargo, no todas las funciones funcionan de esta manera. Por ejemplo, la función que acabamos de escribir, compute_s_n, no funciona elemento por elemento ya que espera un escalar. Este fragmento de código no ejecuta la función en cada entrada de n: n &lt;- 1:25 compute_s_n(n) Los funcionales son funciones que nos ayudan a aplicar la misma función a cada entrada en un vector, matriz, data frame o lista. Aquí cubrimos el funcional que opera en vectores numéricos, lógicos y de caracteres: sapply. La función sapply nos permite realizar operaciones basadas en elementos (element-wise en inglés) en cualquier función. Aquí podemos ver como funciona: x &lt;- 1:10 sapply(x, sqrt) #&gt; [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16 Cada elemento de x se pasa a la función sqrt y devuelve el resultado. Estos resultados se concatenan. En este caso, el resultado es un vector de la misma longitud que el original, x. Esto implica que el bucle-for anterior puede escribirse de la siguiente manera: n &lt;- 1:25 s_n &lt;- sapply(n, compute_s_n) Otros funcionales son apply, lapply, tapply, mapply, vapply y replicate. Usamos principalmente sapply, apply y replicate en este libro, pero recomendamos familiarizarse con los demás ya que pueden ser muy útiles. 3.6 Ejercicios 1. ¿Qué devolverá esta expresión condicional? x &lt;- c(1,2,-3,4) if(all(x&gt;0)){ print(&quot;All Postives&quot;) } else{ print(&quot;Not all positives&quot;) } 2. ¿Cuál de las siguientes expresiones es siempre FALSE cuando al menos una entrada de un vector lógico x es TRUE? all(x) any(x) any(!x) all(!x) 3. La función nchar le dice cuántos caracteres tiene un vector de caracteres. Escriba una línea de código que le asigne al objeto new_names la abreviatura del estado cuando el nombre del estado tiene más de 8 caracteres. 4. Cree una función sum_n que para cualquier valor dado, digamos \\(n\\), calcule la suma de los enteros de 1 a n (inclusive). Use la función para determinar la suma de los enteros de 1 a 5,000. 5. Cree una función altman_plot que toma dos argumentos, x y y, y grafica la diferencia contra la suma. 6. Después de ejecutar el siguiente código, ¿cuál es el valor de x? x &lt;- 3 my_func &lt;- function(y){ x &lt;- 5 y+5 } 7. Escriba una función compute_s_n que para cualquier \\(n\\) calcula la suma \\(S_n = 1^2 + 2^2 + 3^2 + \\dots n^2\\). Indique el valor de la suma cuando \\(n=10\\). 8. Defina un vector numérico vacío s_n de tamaño 25 usando s_n &lt;- vector(&quot;numeric&quot;, 25) y almacene los resultados de \\(S_1, S_2, \\dots S_{25}\\) usando un bucle-for. 9. Repita el ejercicio 8, pero esta vez use sapply. 10. Repita el ejercicio 8, pero esta vez use map_dbl. 11. Grafica \\(S_n\\) versus \\(n\\). Use puntos definidos por \\(n=1,\\dots,25\\). 12. Confirme que la fórmula para esta suma es \\(S_n= n(n+1)(2n+1)/6\\). http://r-pkgs.had.co.nz/namespace.html↩ "],
["tidyverse.html", "Capítulo 4 tidyverse 4.1 Data tidy 4.2 Ejercicios 4.3 Cómo manipular los data frames 4.4 Ejercicios 4.5 El pipe: %&gt;% 4.6 Ejercicios 4.7 Cómo resumir datos 4.8 Cómo ordenar los data frames 4.9 Ejercicios 4.10 Tibbles 4.11 El operador punto 4.12 do 4.13 El paquete purrr 4.14 Los condicionales de tidyverse 4.15 Ejercicios", " Capítulo 4 tidyverse Hasta ahora hemos estado manipulando vectores reordenándolos y creando subconjuntos mediante la indexación. Sin embargo, una vez comencemos los análisis más avanzados, la unidad preferida para el almacenamiento de datos no es el vector sino el data frame. En este capítulo aprenderemos a trabajar directamente con data frames, que facilitan enormemente la organización de información. Utilizaremos data frames para la mayoría de este libro. Nos enfocaremos en un formato de datos específico denominado tidy y en una colección específica de paquetes que son particularmente útiles para trabajar con data tidy que se denomina el tidyverse. Podemos cargar todos los paquetes tidyverse a la vez al instalar y cargar el paquete tidyverse: library(tidyverse) Aprenderemos cómo implementar el enfoque tidyverse a lo largo del libro, pero antes de profundizar en los detalles, en este capítulo presentamos algunos de los aspectos más utilizadas del tidyverse, comenzando con el paquete dplyr para manipular los data frames y el paquete purrr para trabajar con las funciones. Tengan en cuenta que el tidyverse también incluye un paquete para graficar, ggplot2, que presentaremos más adelante en el Capítulo ?? en la parte “Visualización de datos” del libro; el paquete readr discutido en el Capítulo 5; y muchos otros. En este capítulo, primero presentamos el concepto de data tidy y luego demostramos cómo usamos el tidyverse para trabajar con data frames en este formato. 4.1 Data tidy Decimos que una tabla de datos está en formato tidy si cada fila representa una observación y las columnas representan las diferentes variables disponibles para cada una de estas observaciones. El set de datos murders es un ejemplo de un tidy data frame. #&gt; state abb region population total #&gt; 1 Alabama AL South 4779736 135 #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 #&gt; 4 Arkansas AR South 2915918 93 #&gt; 5 California CA West 37253956 1257 #&gt; 6 Colorado CO West 5029196 65 Cada fila representa un estado con cada una de las cinco columnas proveyendo una variable diferente relacionada con estos estados: nombre, abreviatura, región, población y total de asesinatos. Para ver cómo se puede proveer la misma información en diferentes formatos, consideren el siguiente ejemplo: #&gt; country year fertility #&gt; 1 Germany 1960 2.41 #&gt; 2 South Korea 1960 6.16 #&gt; 3 Germany 1961 2.44 #&gt; 4 South Korea 1961 5.99 #&gt; 5 Germany 1962 2.47 #&gt; 6 South Korea 1962 5.79 Este set de datos tidy ofrece tasas de fertilidad para dos países a lo largo de los años. Se considera un set de datos tidy porque cada fila presenta una observación con las tres variables: país, año y tasa de fecundidad. Sin embargo, este set de datos originalmente vino en otro formato y le cambiamos la forma para distribuir a través del paquete dslabs. Originalmente, los datos estaban en el siguiente formato: #&gt; country 1960 1961 1962 #&gt; 1 Germany 2.41 2.44 2.47 #&gt; 2 South Korea 6.16 5.99 5.79 Se provee la misma información, pero hay dos diferencias importantes en el formato: 1) cada fila incluye varias observaciones y 2) una de las variables, año, se almacena en el encabezado. Para que los paquetes del tidyverse se utilicen de manera óptima, le tenemos que cambiar la forma a los datos para que estén en formato tidy, que aprenderán a hacer en la sección “Wrangling de datos” del libro. Hasta entonces, utilizaremos ejemplos de sets de datos que ya están en formato tidy. Aunque no es inmediatamente obvio, a medida que avancen en el libro comenzarán a apreciar las ventajas de trabajar en un marco en el que las funciones usan formatos tidy tanto para inputs como para outputs. Verán cómo esto permite que los analistas de datos se enfoquen en los aspectos más importantes del análisis en lugar del formato de los datos. 4.2 Ejercicios 1. Examine el set de datos incluidos en base R co2. ¿Cuál de los siguientes es cierto? co2 son datos tidy: tiene un año para cada fila. co2 no es tidy: necesitamos al menos una columna con un vector de caracteres. co2 no es tidy: es una matriz en lugar de un data frame. co2 no es tidy: para ser tidy tendríamos que cambiarle la forma (wrangle it en inglés) para tener tres columnas (año, mes y valor), y entonces cada observación de CO2 tendría una fila. 2. Examine el set de datos incluidos en base R ChickWeight. ¿Cuál de los siguientes es cierto? ChickWeight no es tidy: cada pollito tiene más de una fila. ChickWeight es tidy: cada observación (un peso) está representada por una fila. El pollito de donde provino esta medida es una de las variables. ChickWeight no es tidy: nos falta la columna del año. ChickWeight es tidy: se almacena en un data frame. 3. Examine el set de datos predefinido BOD. ¿Cuál de los siguientes es cierto? BOD no es tidy: solo tiene seis filas. BOD no es tidy: la primera columna es solo un índice. BOD es tidy: cada fila es una observación con dos valores (tiempo y demanda) BOD es tidy: todos los sets de datos pequeños son tidy por definición. 4. ¿Cuál de los siguientes sets de datos integrados es tidy? Puede elegir más de uno. BJsales EuStockMarkets DNase Formaldehyde Orange UCBAdmissions 4.3 Cómo manipular los data frames El paquete dplyr del tidyverse ofrece funciones que realizan algunas de las operaciones más comunes cuando se trabaja con los data frames y usa nombres para estas funciones que son relativamente fáciles de recordar. Por ejemplo, para cambiar la tabla de datos agregando una nueva columna, utilizamos mutate. Para filtrar la tabla de datos a un subconjunto de filas, utilizamos filter. Finalmente, para subdividir los datos seleccionando columnas específicas, usamos select. 4.3.1 Cómo agregar una columna con mutate Queremos que toda la información necesaria para nuestro análisis se incluya en la tabla de datos. Entonces, la primera tarea es agregar las tasas de asesinatos a nuestro data frame de asesinatos. La función mutate toma el data frame como primer argumento y el nombre y los valores de la variable como segundo argumento usando la convención name = values. Entonces, para agregar tasas de asesinatos, usamos: library(dslabs) data(&quot;murders&quot;) murders &lt;- mutate(murders, rate = total/ population * 100000) Recuerden que aquí usamos total y population dentro de la función, que son objetos no definidos en nuestro espacio de trabajo. Pero, ¿por qué no recibimos un error? Esta es una de las principales características de dplyr. Las funciones en este paquete, como mutate, saben buscar variables en el data frame que el primer argumento le provee. En la llamada a mutate que vemos arriba, total tendrá los valores de murders$total. Este enfoque hace que el código sea mucho más legible. Podemos ver que se agrega la nueva columna: head(murders) #&gt; state abb region population total rate #&gt; 1 Alabama AL South 4779736 135 2.82 #&gt; 2 Alaska AK West 710231 19 2.68 #&gt; 3 Arizona AZ West 6392017 232 3.63 #&gt; 4 Arkansas AR South 2915918 93 3.19 #&gt; 5 California CA West 37253956 1257 3.37 #&gt; 6 Colorado CO West 5029196 65 1.29 Aunque hemos sobrescrito el original objeto murders, esto no cambia el objeto que se cargó con data(murders). Si cargamos la data murders nuevamente, el original sobrescribirá nuestra versión mutada. 4.3.2 Cómo crear subconjuntos con filter Ahora supongamos que queremos filtrar la tabla de datos para mostrar solo las entradas para las cuales la tasa de homicidios es inferior a 0.71. Para hacer esto usamos la función filter, que toma la tabla de datos como primer argumento y luego la declaración condicional como el segundo. Igual que con mutate, podemos usar los nombres de variables sin comillas de murders dentro de la función y esta sabrá que nos referimos a las columnas y no a los objetos en el espacio de trabajo. filter(murders, rate &lt;= 0.71) #&gt; state abb region population total rate #&gt; 1 Hawaii HI West 1360301 7 0.515 #&gt; 2 Iowa IA North Central 3046355 21 0.689 #&gt; 3 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Vermont VT Northeast 625741 2 0.320 4.3.3 Cómo seleccionar columnas con select Aunque nuestra tabla de datos solo tiene seis columnas, algunas tablas de datos incluyen cientos. Si queremos ver solo algunas columnas, podemos usar la función select de dplyr. En el siguiente código seleccionamos tres, asignamos el resultado a un nuevo objeto y luego filtramos este nuevo objeto: new_table &lt;- select(murders, state, region, rate) filter(new_table, rate &lt;= 0.71) #&gt; state region rate #&gt; 1 Hawaii West 0.515 #&gt; 2 Iowa North Central 0.689 #&gt; 3 New Hampshire Northeast 0.380 #&gt; 4 North Dakota North Central 0.595 #&gt; 5 Vermont Northeast 0.320 En la llamada a select, el primer argumento murders es un objeto, pero state, region y rate son nombres de variables. 4.4 Ejercicios 1. Cargue el paquete dplyr y el set de datos de asesinatos de EE.UU.. library(dplyr) library(dslabs) data(murders) Puede agregar columnas usando la función mutate de dplyr. Esta función reconoce los nombres de la columnas y dentro de la función puede llamarlos sin comillas: murders &lt;- mutate(murders, population_in_millions = population/ 10^6) Podemos escribir population en vez de murders$population. La función mutate sabe que estamos agarrando columnas de murders. Use la función mutate para agregar una columna de asesinatos llamada rate con la tasa de asesinatos por 100,000 como en el código del ejemplo anterior. Asegúrese de redefinir murders como se hizo en el código del ejemplo anterior (murders &lt;- [su código]) para que podamos seguir usando esta variable. 2. Si rank(x) le da el rango de las entradas de x de menor a mayor, rank(-x) le da los rangos de mayor a menor. Use la función mutate para agregar una columna rank que contiene el rango de la tasa de asesinatos de mayor a menor. Asegúrese de redefinir murders para poder seguir usando esta variable. 3. Con dplyr, podemos usar select para mostrar solo ciertas columnas. Por ejemplo, con este código solo mostraríamos los estados y los tamaños de población: select(murders, state, population) %&gt;% head() Utilice select para mostrar los nombres de los estados y las abreviaturas en murders. No redefina murders, solo muestre los resultados. 4. La función filter de dplyr se utiliza para elegir filas específicas del data frame para guardar. A diferencia de select que es para columnas, filter es para filas. Por ejemplo, puede mostrar solo la fila de Nueva York así: filter(murders, state == &quot;New York&quot;) Puede usar otros vectores lógicos para filtrar filas. Utilice filter para mostrar los cinco estados con las tasas de asesinatos más altas. Después de agregar la tasa y el rango de asesinatos, no cambie el set de datos de asesinatos de EE. UU., solo muestre el resultado. Recuerde que puede filtrar basándose en la columna rank. 5. Podemos eliminar filas usando el operador !=. Por ejemplo, para eliminar Florida, haríamos esto: no_florida &lt;- filter(murders, state != &quot;Florida&quot;) Cree un nuevo data frame con el nombre no_south que elimina los estados de la región sur. ¿Cuántos estados hay en esta categoría? Puede usar la función nrow para esto. 6. También podemos usar %in% para filtrar con dplyr. Por lo tanto, puede ver los datos de Nueva York y Texas de esta manera: filter(murders, state %in% c(&quot;New York&quot;, &quot;Texas&quot;)) Cree un nuevo data frame llamado murders_nw con solo los estados del noreste y oeste. ¿Cuántos estados hay en esta categoría? 7. Suponga que desea vivir en el noreste u oeste y desea que la tasa de homicidios sea inferior a 1. Queremos ver los datos de los estados que satisfacen estas opciones. Tenga en cuenta que puede usar operadores lógicos con filter. Aquí hay un ejemplo en el que filtramos para mantener solo estados pequeños en la región noreste. filter(murders, population &lt; 5000000 &amp; region == &quot;Northeast&quot;) Asegúrese que murders ha sido definido con rate y rank y todavía tiene todos los estados. Cree una tabla llamada my_states que contiene filas para los estados que satisfacen ambas condiciones: está en el noreste u oeste y la tasa de homicidios es inferior a 1. Use select para mostrar solo el nombre del estado, la tasa y el rango. 4.5 El pipe: %&gt;% Con dplyr podemos realizar una serie de operaciones, por ejemplo select y entonces filter, enviando los resultados de una función a otra usando lo que se llama el pipe operator: %&gt;%. Algunos detalles se incluyen a continuación. Escribimos el código anterior para mostrar tres variables (estado, región, tasa) para los estados que tienen tasas de asesinatos por debajo de 0.71. Para hacer esto, definimos el objeto intermedio new_table. En dplyr podemos escribir código que se parece más a una descripción de lo que queremos hacer sin objetos intermedios: \\[ \\mbox {original data } \\rightarrow \\mbox { select } \\rightarrow \\mbox { filter } \\] Para tal operación, podemos usar el pipe %&gt;%. El código se ve así: murders %&gt;% select(state, region, rate) %&gt;% filter(rate &lt;= 0.71) #&gt; state region rate #&gt; 1 Hawaii West 0.515 #&gt; 2 Iowa North Central 0.689 #&gt; 3 New Hampshire Northeast 0.380 #&gt; 4 North Dakota North Central 0.595 #&gt; 5 Vermont Northeast 0.320 Esta línea de código es equivalente a las dos líneas de código anteriores. ¿Qué está pasando aquí? En general, el pipe envía el resultado que se encuentra en el lado izquierdo del pipe para ser el primer argumento de la función en el lado derecho del pipe. Aquí vemos un ejemplo sencillo: 16 %&gt;% sqrt() #&gt; [1] 4 Podemos continuar canalizando (piping en inglés) valores a lo largo de: 16 %&gt;% sqrt() %&gt;% log2() #&gt; [1] 2 La declaración anterior es equivalente a log2(sqrt(16)). Recuerde que el pipe envía valores al primer argumento, por lo que podemos definir otros argumentos como si el primer argumento ya estuviera definido: 16 %&gt;% sqrt() %&gt;% log(base = 2) #&gt; [1] 2 Por lo tanto, al usar el pipe con data frames y dplyr, ya no necesitamos especificar el primer argumento requerido puesto que las funciones dplyr que hemos descrito toman todos los datos como el primer argumento. En el código que escribimos: murders %&gt;% select(state, region, rate) %&gt;% filter(rate &lt;= 0.71) murders es el primer argumento de la función select, y el nuevo data frame (anteriormente new_table) es el primer argumento de la función filter. Tengan en cuenta que el pipe funciona bien con las funciones donde el primer argumento son los datos de entrada. Las funciones en los paquetes tidyverse y dplyr tienen este formato y se pueden usar fácilmente con el pipe. 4.6 Ejercicios 1. El pipe %&gt;% se puede usar para realizar operaciones secuencialmente sin tener que definir objetos intermedios. Comience redefiniendo murders para incluir la tasa y el rango. murders &lt;- mutate(murders, rate = total/ population * 100000, rank = rank(-rate)) En la solución al ejercicio anterior, hicimos lo siguiente: my_states &lt;- filter(murders, region %in% c(&quot;Northeast&quot;, &quot;West&quot;) &amp; rate &lt; 1) select(my_states, state, rate, rank) El pipe %&gt;% nos permite realizar ambas operaciones secuencialmente sin tener que definir una variable intermedia my_states. Por lo tanto, podríamos haber mutado y seleccionado en la misma línea de esta manera: mutate(murders, rate = total/ population * 100000, rank = rank(-rate)) %&gt;% select(state, rate, rank) Note que select ya no tiene un data frame como primer argumento. Se supone que el primer argumento sea el resultado de la operación realizada justo antes de %&gt;%. Repita el ejercicio anterior, pero ahora, en lugar de crear un nuevo objeto, muestre el resultado y solo incluya las columnas de estado, velocidad y rango. Use un pipe %&gt;% para hacer esto en una sola línea. 2. Reinicie murders a la tabla original usando data(murders). Use un pipe para crear un nuevo data frame llamado my_states que considera solo los estados del noreste u oeste que tienen una tasa de homicidios inferior a 1 y contiene solo las columnas de estado, tasa y rango. El pipe también debe tener cuatro componentes separados por tres %&gt;%. El código debería verse algo similar a lo siguiente: my_states &lt;- murders %&gt;% mutate SOMETHING %&gt;% filter SOMETHING %&gt;% select SOMETHING 4.7 Cómo resumir datos Una parte importante del análisis exploratorio de datos es resumir los datos. La desviación promedio y estándar son dos ejemplos de estadísticas de resumen ampliamente utilizadas. A menudo se pueden obtener resúmenes más informativos dividiendo primero los datos en grupos. En esta sección, cubrimos dos nuevos verbos de dplyr que facilitan estos cálculos: summarize y group_by. Aprendemos a acceder a los valores resultantes utilizando la función pull. 4.7.1 summarize La función summarize de dplyr ofrece una forma de calcular estadísticas de resumen con código intuitivo y legible. Comenzamos con un ejemplo sencillo basado en alturas. El set de datos heights incluye las alturas y el sexo reportado por los estudiantes en una encuesta en clase. library(dplyr) library(dslabs) data(heights) El siguiente código calcula la desviación promedio y estándar para las hembras: s &lt;- heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(average = mean(height), standard_deviation = sd(height)) s #&gt; average standard_deviation #&gt; 1 64.9 3.76 Esto toma nuestra tabla de datos original como entrada, la filtra para incluir solo a las filas representando hembras y luego produce una nueva tabla resumida con solo el promedio y la desviación estándar de las alturas. Podemos elegir los nombres de las columnas de la tabla resultante. Por ejemplo, arriba decidimos usar average y standard_deviation, pero podríamos haber usado otros nombres de la misma manera. Como la tabla resultante almacenada en s es un data frame, podemos acceder a los componentes con el operador de acceso $: s$average #&gt; [1] 64.9 s$standard_deviation #&gt; [1] 3.76 Igual que con la mayoría de las otras funciones de dplyr, summarize conoce los nombres de las variables y podemos usarlas directamente. Entonces, cuando escribimos mean(height) dentro de la llamada a la función summarize, la función accede a la columna con el nombre “height”, o altura, y luego calcula el promedio del vector numérico resultante. Podemos calcular cualquier otro resumen que opera en vectores y devuelve un solo valor. Por ejemplo, podemos agregar las alturas mediana, mínima y máxima de esta manera: heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(median = median(height), minimum = min(height), maximum = max(height)) #&gt; median minimum maximum #&gt; 1 65 51 79 Podemos obtener estos tres valores con solo una línea usando la función quantile: por ejemplo, quantile(x, c(0,0.5,1)) devuelve el mínimo (percentil 0), la mediana (percentil 50) y el máximo (percentil 100) del vector x. Sin embargo, si intentamos usar una función como esta que devuelve dos o más valores dentro de summarize: heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(range = quantile(height, c(0, 0.5, 1))) recibiremos un error: Error: expecting result of length one, got : 2. Con la función summarize, solo podemos llamar a funciones que devuelven un solo valor. En la sección 4.12, aprenderemos cómo lidiar con funciones que devuelven más de un valor. Para otro ejemplo de cómo podemos usar la función summarize, calculemos la tasa promedio de asesinatos en Estados Unidos. Recuerden que nuestra tabla de datos incluye los asesinatos totales y el tamaño de la población para cada estado y ya hemos usado dplyr para agregar una columna de índice de asesinatos: murders &lt;- murders %&gt;% mutate(rate = total/population*100000) Recuerden que la tasa de asesinatos en EE. UU. no es el promedio de las tasas de asesinatos estatales: summarize(murders, mean(rate)) #&gt; mean(rate) #&gt; 1 2.78 Esto se debe a que en el cálculo anterior, los estados pequeños tienen el mismo peso que los grandes. La tasa de homicidios de Estados Unidos es el número total de asesinatos en Estados Unidos dividido por la población total. Entonces el cálculo correcto es: us_murder_rate &lt;- murders %&gt;% summarize(rate = sum(total)/ sum(population) * 100000) us_murder_rate #&gt; rate #&gt; 1 3.03 Este cálculo cuenta estados más grandes proporcionalmente a su tamaño, lo que da como resultado un valor mayor. 4.7.2 pull El objeto us_murder_rate definido anteriormente representa solo un número. Sin embargo, lo estamos almacenando en un data frame: class(us_murder_rate) #&gt; [1] &quot;data.frame&quot; ya que, como la mayoría de las funciones de dplyr, summarize siempre devuelve un data frame. Esto podría ser problemático si queremos usar este resultado con funciones que requieren un valor numérico. Aquí mostramos un truco útil para acceder a los valores almacenados en los datos cuando usamos pipes: cuando un objeto de datos se canaliza (is piped en inglés), ese objeto y sus columnas se pueden acceder usando la función pull. Para entender lo que queremos decir, consideren esta línea de código: us_murder_rate %&gt;% pull(rate) #&gt; [1] 3.03 Esto devuelve el valor en la columna rate de us_murder_rate haciéndolo equivalente a us_murder_rate$rate. Para obtener un número de la tabla de datos original con una línea de código, podemos escribir: us_murder_rate &lt;- murders %&gt;% summarize(rate = sum(total)/ sum(population) * 100000) %&gt;% pull(rate) us_murder_rate #&gt; [1] 3.03 que ahora es numérico: class(us_murder_rate) #&gt; [1] &quot;numeric&quot; 4.7.3 Cómo agrupar y luego resumir con group_by Una operación común en la exploración de datos es dividir primero los datos en grupos y luego calcular resúmenes para cada grupo. Por ejemplo, podemos querer calcular la desviación promedio y estándar para las alturas de hombres y mujeres por separado. La función group_by nos ayuda a hacer esto. Si escribimos esto: heights %&gt;% group_by(sex) #&gt; # A tibble: 1,050 x 2 #&gt; # Groups: sex [2] #&gt; sex height #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Male 75 #&gt; 2 Male 70 #&gt; 3 Male 68 #&gt; 4 Male 74 #&gt; 5 Male 61 #&gt; # … with 1,045 more rows El resultado no se ve muy diferente de heights, excepto que vemos Groups: sex [2] cuando imprimimos el objeto. Aunque no es inmediatamente obvio por su apariencia, esto ahora es un data frame especial llamado un grouped data frame, y las funciones de dplyr, en particular summarize, se comportarán de manera diferente cuando actúen sobre este objeto. Conceptualmente, pueden pensar en esta tabla como muchas tablas, con las mismas columnas pero no necesariamente el mismo número de filas, apiladas juntas en un objeto. Cuando resumimos los datos después de la agrupación, esto es lo que sucede: heights %&gt;% group_by(sex) %&gt;% summarize(average = mean(height), standard_deviation = sd(height)) #&gt; # A tibble: 2 x 3 #&gt; sex average standard_deviation #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Female 64.9 3.76 #&gt; 2 Male 69.3 3.61 La función summarize aplica el resumen a cada grupo por separado. Para ver otro ejemplo, calculemos la tasa media de asesinatos en las cuatro regiones del país: murders %&gt;% group_by(region) %&gt;% summarize(median_rate = median(rate)) #&gt; # A tibble: 4 x 2 #&gt; region median_rate #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Northeast 1.80 #&gt; 2 South 3.40 #&gt; 3 North Central 1.97 #&gt; 4 West 1.29 4.8 Cómo ordenar los data frames Al examinar un set de datos, a menudo es conveniente ordenar, numérica o alfabéticamente, basado en una o más de las columnas de la tabla. Conocemos las funciones order y sort, pero para ordenar tablas enteras, la función arrange de dplyr es útil. Por ejemplo, aquí ordenamos los estados según el tamaño de la población: murders %&gt;% arrange(population) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Wyoming WY West 563626 5 0.887 #&gt; 2 District of Columbia DC South 601723 99 16.453 #&gt; 3 Vermont VT Northeast 625741 2 0.320 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Alaska AK West 710231 19 2.675 #&gt; 6 South Dakota SD North Central 814180 8 0.983 Con arrange podemos decidir cuál columna usar para ordenar. Para ver los estados por población, de menor a mayor, organizamos por el rate : murders %&gt;% arrange(rate) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Vermont VT Northeast 625741 2 0.320 #&gt; 2 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 3 Hawaii HI West 1360301 7 0.515 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Iowa IA North Central 3046355 21 0.689 #&gt; 6 Idaho ID West 1567582 12 0.766 Tengan en cuenta que el comportamiento por defecto es ordenar en orden ascendente. En dplyr, la función desc transforma un vector para que esté en orden descendente. Para ordenar la tabla en orden descendente, podemos escribir: murders %&gt;% arrange(desc(rate)) 4.8.1 Cómo ordenar anidadamente Si estamos ordenando una columna cuando hay empates, podemos usar una segunda columna para romper el empate. Del mismo modo, se puede usar una tercera columna para romper empates entre la primera y la segunda, y así sucesivamente. Aquí ordenamos por region, luego dentro de la región ordenamos por tasa de asesinatos: murders %&gt;% arrange(region, rate) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Vermont VT Northeast 625741 2 0.320 #&gt; 2 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 3 Maine ME Northeast 1328361 11 0.828 #&gt; 4 Rhode Island RI Northeast 1052567 16 1.520 #&gt; 5 Massachusetts MA Northeast 6547629 118 1.802 #&gt; 6 New York NY Northeast 19378102 517 2.668 4.8.2 Los primeros \\(n\\) En el código anterior, usamos la función head para evitar que la página se llene con todo el set de datos. Si queremos ver una mayor proporción, podemos usar la funcióntop_n. Esta función toma un data frame como primer argumento, el número de filas para mostrar en el segundo y la variable para filtrar en el tercero. Aquí hay un ejemplo de cómo ver las 5 filas superiores: murders %&gt;% top_n(5, rate) #&gt; state abb region population total rate #&gt; 1 District of Columbia DC South 601723 99 16.45 #&gt; 2 Louisiana LA South 4533372 351 7.74 #&gt; 3 Maryland MD South 5773552 293 5.07 #&gt; 4 Missouri MO North Central 5988927 321 5.36 #&gt; 5 South Carolina SC South 4625364 207 4.48 Tengan en cuenta que las filas no están ordenadas por rate, solo filtradas. Si queremos ordenar, necesitamos usar arrange. Recuerden que si el tercer argumento se deja en blanco, top_n filtra por la última columna. 4.9 Ejercicios Para estos ejercicios, utilizaremos los datos de la encuesta recopilada por el Centro Nacional de Estadísticas de Salud de Estados Unidos (NCHS, por sus siglas en inglés). Este centro ha realizado una serie de encuestas de salud y nutrición desde la década de 1960. A partir de 1999, alrededor de 5,000 individuos de todas las edades han sido entrevistados cada año y completan el componente de examen de salud de la encuesta. Parte de los datos está disponible a través del paquete NHANES. Una vez que instalen el paquete NHANES, pueden cargar los datos así: library(NHANES) data(NHANES) Los datos NHANES tienen muchos valores faltantes. Las funciones mean y sd devolverán NA si alguna de las entradas del vector de entrada es un NA. Aquí hay un ejemplo: library(dslabs) data(na_example) mean(na_example) #&gt; [1] NA sd(na_example) #&gt; [1] NA Para ignorar los NAs podemos usar el argumento na.rm: mean(na_example, na.rm = TRUE) #&gt; [1] 2.3 sd(na_example, na.rm = TRUE) #&gt; [1] 1.22 Exploremos ahora los datos de NHANES. 1. Le ofrecemos algunos datos básicos sobre la presión arterial. Primero, seleccionemos un grupo para establecer el estándar. Utilizaremos hembras de 20 a 29 años. AgeDecade es una variable categórica con estas edades. Tenga en cuenta que la categoría está codificada como “20-29”, ¡con un espacio al frente! ¿Cuál es el promedio y la desviación estándar de la presión arterial sistólica según se guarda en el variable BPSysAve? Guárdela en una variable llamada ref. Sugerencia: use filter y summarize y use el argumento na.rm = TRUE al calcular el promedio y la desviación estándar. También puede filtrar los valores de NA utilizando filter. 2. Usando un pipe, asigne el promedio a una variable numérica ref_avg. Sugerencia: use el código similar al anterior y luego pull. 3. Ahora indique los valores mínimo y máximo para el mismo grupo. 4. Calcule el promedio y la desviación estándar para las hembras, pero para cada grupo de edad por separado en lugar de una década seleccionada como en la pregunta 1. Tenga en cuenta que los grupos de edad se definen por AgeDecade. Sugerencia: en lugar de filtrar por edad y género, filtre por Gender y luego use group_by. 5. Repita el ejercicio 4 para los machos. 6. Podemos combinar ambos resúmenes para los ejercicios 4 y 5 en una línea de código. Esto es porque group_by nos permite agrupar por más de una variable. Obtenga una gran tabla de resumen usando group_by(AgeDecade, Gender). 7. Para los machos entre las edades de 40-49, compare la presión arterial sistólica según raza, como aparece en la variable Race1. Ordene la tabla resultante según la presión arterial sistólica promedio de más baja a más alta. 4.10 Tibbles Los datos tidy deben almacenarse en data frames. Discutimos el data frame en la Sección 2.4.1 y hemos estado usando el data frame murders en todo el libro. En la sección 4.7.3 presentamos la función group_by, que permite estratificar los datos antes de calcular las estadísticas de resumen. Pero, ¿dónde se almacena la información del grupo en el data frame? murders %&gt;% group_by(region) #&gt; # A tibble: 51 x 6 #&gt; # Groups: region [4] #&gt; state abb region population total rate #&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alabama AL South 4779736 135 2.82 #&gt; 2 Alaska AK West 710231 19 2.68 #&gt; 3 Arizona AZ West 6392017 232 3.63 #&gt; 4 Arkansas AR South 2915918 93 3.19 #&gt; 5 California CA West 37253956 1257 3.37 #&gt; # … with 46 more rows Observen que no hay columnas con esta información. Pero si miran el output anterior, verán la línea A tibble seguida por unas dimensiones. Podemos aprender la clase del objeto devuelto usando: murders %&gt;% group_by(region) %&gt;% class() #&gt; [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; El tbl es un tipo especial de data frame. Las funciones group_by y summarize siempre devuelven este tipo de data frame. La función group_by devuelve un tipo especial de tbl, el grouped_df. Discutiremos esto más adelante. Por coherencia, los verbos de manipulación dplyr ( select, filter, mutate y arrange) preservan la clase del input: si reciben un data frame regular, devuelven un data frame regular, mientras que si reciben un tibble, devuelven un tibble. Pero los tibbles son el formato preferido por el tidyverse y, como resultado, las funciones tidyverse que producen un data frame desde cero devuelven un tibble. Por ejemplo, en el capítulo 5 veremos que las funciones del tidyverse que se usan para importar datos crean tibbles. Los tibbles son muy similares a los data frames. De hecho, pueden pensar en ellos como una versión moderna de data frames. Sin embargo, hay tres diferencias importantes que describiremos a continuación. 4.10.1 Los tibbles se ven mejor El método de impresión para tibbles es más legible que el de un data frame. Para ver esto, comparen el output de escribir murders y el output de asesinatos si los convertimos en un tibble. Podemos hacer esto usando as_tibble(murders). Si usan RStudio, el output para un tibble se ajusta al tamaño de sus ventanas. Para ver esto, cambien el ancho de su consola R y observen cómo se muestran más/menos columnas. 4.10.2 Los subconjuntos de tibbles son tibbles Si creamos subconjuntos de las columnas de un data frame, le pueden devolver un objeto que no es un data frame, como un vector o escalar. Por ejemplo: class(murders[,4]) #&gt; [1] &quot;numeric&quot; no es un data frame. Con tibbles esto no sucede: class(as_tibble(murders)[,4]) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Esto es útil en el tidyverse ya que las funciones requieren data frames como input. Con tibbles, si desean acceder al vector que define una columna y no recuperar un data frame, deben usar el operador de acceso $: class(as_tibble(murders)$population) #&gt; [1] &quot;numeric&quot; Una característica relacionada es que tibbles les dará una advertencia si intentan acceder a una columna que no existe. Por ejemplo, si escribimos accidentalmente Population en lugar de population vemos que: murders$Population #&gt; NULL devuelve un NULL sin advertencia, lo que puede dificultar la depuración. Por el contrario, si intentamos esto con un tibble, obtenemos una advertencia informativa: as_tibble(murders)$Population #&gt; Warning: Unknown or uninitialised column: &#39;Population&#39;. #&gt; NULL 4.10.3 Los tibbles pueden tener entradas complejas Si bien las columnas del data frame deben ser vectores de números, cadenas o valores lógicos, los tibbles pueden tener objetos más complejos, como listas o funciones. Además, podemos crear tibbles con funciones: tibble(id = c(1, 2, 3), func = c(mean, median, sd)) #&gt; # A tibble: 3 x 2 #&gt; id func #&gt; &lt;dbl&gt; &lt;list&gt; #&gt; 1 1 &lt;fn&gt; #&gt; 2 2 &lt;fn&gt; #&gt; 3 3 &lt;fn&gt; 4.10.4 Los tibbles se pueden agrupar La función group_by devuelve un tipo especial de tibble: un tibble agrupado. Esta clase almacena información que les permite saber qué filas están en qué grupos. Las funciones tidyverse, en particular la función summarize, son conscientes de la información del grupo. 4.10.5 Cómo crear un tibble usando tibble en lugar de data.frame A veces es útil para nosotros crear nuestros propios data frames. Para crear un data frame en formato tibble, pueden utilizar la función tibble. grades &lt;- tibble(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90)) Tengan en cuenta que la base R (sin paquetes cargados) tiene una función con un nombre muy similar, data.frame, que se puede usar para crear un data frame regular en vez de un tibble. Otra diferencia importante es que por defecto data.frame fuerza una conversion de caracteres en factores sin proveer una advertencia o un mensaje: grades &lt;- data.frame(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90)) class(grades$names) #&gt; [1] &quot;factor&quot; Para evitar esto, usamos el argumento bastante engorroso stringsAsFactors: grades &lt;- data.frame(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90), stringsAsFactors = FALSE) class(grades$names) #&gt; [1] &quot;character&quot; Para convertir un data frame normal en un tibble, pueden usar la función as_tibble. as_tibble(grades) %&gt;% class() #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 4.11 El operador punto Una de las ventajas de utilizar el pipe %&gt;% es que no tenemos que seguir nombrando nuevos objetos mientras manipulamos el data frame. Recuerden que si queremos calcular la tasa de asesinatos promedio para los estados del sur, en lugar de escribir: tab_1 &lt;- filter(murders, region == &quot;South&quot;) tab_2 &lt;- mutate(tab_1, rate = total/ population * 10^5) rates &lt;- tab_2$rate median(rates) #&gt; [1] 3.4 podemos evitar definir nuevos objetos intermedios escribiendo: filter(murders, region == &quot;South&quot;) %&gt;% mutate(rate = total/ population * 10^5) %&gt;% summarize(median = median(rate)) %&gt;% pull(median) #&gt; [1] 3.4 Podemos hacer esto porque cada una de estas funciones toma un data frame como primer argumento. Pero, ¿qué pasa si queremos acceder a un componente del data frame? Por ejemplo, ¿qué pasa si la función pull no está disponible y queremos acceder tab_2$rate? ¿Qué nombre de data frame usamos? La respuesta es el operador punto (dot operator en inglés). Por ejemplo, para acceder al vector de velocidad sin la función pull, podríamos usar: rates &lt;-filter(murders, region == &quot;South&quot;) %&gt;% mutate(rate = total/ population * 10^5) %&gt;% .$rate median(rates) #&gt; [1] 3.4 En la siguiente sección, veremos otras instancias en las que usar el . es útil. 4.12 do Las funciones del tidyverse saben interpretar tibbles agrupados. Además, para facilitar la secuencia de comandos a través del pipe %&gt;%, las funciones del tidyverse constantemente devuelven data frames, ya que esto asegura que el output de una función sea aceptada como el input de otra. Pero la mayoría de las funciones de R no reconocen los tibbles agrupados ni devuelven data frames. La función quantile es un ejemplo que describimos en la Sección 4.7.1. La función do sirve como puente entre las funciones de R, como quantile y el tidyverse. La función doentiende tibbles agrupados y siempre devuelve un data frame. En la sección 4.7.1, notamos que si intentamos usar quantile para obtener el mínimo, la mediana y el máximo en una llamada, recibiremos un error: Error: expecting result of length one, got : 2. data(heights) heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(range = quantile(height, c(0, 0.5, 1))) Podemos usar la función do para arreglar esto. Primero tenemos que escribir una función que se ajuste al enfoque del tidyverse: es decir, recibe un data frame y devuelve un data frame. my_summary &lt;- function(dat){ x &lt;- quantile(dat$height, c(0, 0.5, 1)) tibble(min = x[1], median = x[2], max = x[3]) } Ahora podemos aplicar la función al set de datos de alturas para obtener los resúmenes: heights %&gt;% group_by(sex) %&gt;% my_summary #&gt; # A tibble: 1 x 3 #&gt; min median max #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 50 68.5 82.7 Pero esto no es lo que queremos. Queremos un resumen para cada sexo y el código devolvió solo un resumen. Esto es porque my_summary no es parte del tidyverse y no sabe cómo manejar los tibbles agrupados. do hace esta conexión: heights %&gt;% group_by(sex) %&gt;% do(my_summary(.)) #&gt; # A tibble: 2 x 4 #&gt; # Groups: sex [2] #&gt; sex min median max #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Female 51 65.0 79 #&gt; 2 Male 50 69 82.7 Recuerden que aquí necesitamos usar el operador punto. El tibble creado por group_by se canaliza a do. Dentro de la llamada a do, el nombre de este tibble es . y queremos enviarlo a my_summary. Si no usan el punto, entonces my_summary no tiene ningún argumento y devuelve un error que nos dice que falta el argument &quot;dat&quot; . Pueden ver el error escribiendo: heights %&gt;% group_by(sex) %&gt;% do(my_summary()) Si no usan el paréntesis, entonces la función no se ejecuta y en su lugar do intenta devolver la función. Esto da un error porque do siempre debe devolver un data frame. Pueden ver el error escribiendo: heights %&gt;% group_by(sex) %&gt;% do(my_summary) 4.13 El paquete purrr En la sección 3.5 aprendimos sobre la función sapply, que nos permitió aplicar la misma función a cada elemento de un vector. Construimos una función y utilizamos sapply para calcular la suma de los primeros n enteros para varios valores de n así: compute_s_n &lt;- function(n){ x &lt;- 1:n sum(x) } n &lt;- 1:25 s_n &lt;- sapply(n, compute_s_n) Este tipo de operación, que aplica la misma función o procedimiento a elementos de un objeto, es bastante común en el análisis de datos. El paquete purrr incluye funciones similares a sapply pero que interactúan mejor con otras funciones del tidyverse. La principal ventaja es que podemos controlar mejor el tipo de resultado de las funciones. En contraste, sapply puede devolver varios tipos de objetos diferentes, convirtiéndolos cuando sea conveniente. Las funciones de purrr nunca harán esto: devolverán objetos de un tipo específico o devolverán un error si esto no es posible. La primera función de purrr que aprenderemos es map, que funciona muy similar a sapply pero siempre, sin excepción, devuelve una lista: library(purrr) s_n &lt;- map(n, compute_s_n) class(s_n) #&gt; [1] &quot;list&quot; Si queremos un vector numérico, podemos usar map_dbl que siempre devuelve un vector de valores numéricos. s_n &lt;- map_dbl(n, compute_s_n) class(s_n) #&gt; [1] &quot;numeric&quot; Esto produce los mismos resultados que la llamada sapply que vemos arriba. Una función de purrr particularmente útil para interactuar con el resto del tidyverse es map_df, que siempre devuelve un tibble data frame. Sin embargo, la función que se llama debe devolver un vector o una lista con nombres. Por esta razón, el siguiente código daría como resultado un error Argument 1 must have names: s_n &lt;- map_df(n, compute_s_n) Necesitamos cambiar la función para arreglar esto: compute_s_n &lt;- function(n){ x &lt;- 1:n tibble(sum = sum(x)) } s_n &lt;- map_df(n, compute_s_n) El paquete purrr ofrece mucha más funcionalidad no discutida aquí. Para obtener más detalles, puede consultar este recurso en línea. 4.14 Los condicionales de tidyverse Un análisis de datos típicos frecuentemente implicará una o más operaciones condicionales. En la sección 3.1 describimos la función ifelse, que utilizaremos ampliamente en este libro. En esta sección presentamos dos funciones de dplyr que ofrecen una funcionalidad adicional para realizar operaciones condicionales. 4.14.1 case_when La función case_when es útil para vectorizar declaraciones condicionales. Esto es similar a ifelse pero puede generar cualquier cantidad de valores, en lugar de solo TRUE o FALSE. Aquí hay un ejemplo que divide los números en negativo, positivo y 0: x &lt;- c(-2, -1, 0, 1, 2) case_when(x &lt; 0 ~ &quot;Negative&quot;, x &gt; 0 ~ &quot;Positive&quot;, TRUE ~ &quot;Zero&quot;) #&gt; [1] &quot;Negative&quot; &quot;Negative&quot; &quot;Zero&quot; &quot;Positive&quot; &quot;Positive&quot; Un uso común de esta función es definir unas variables categóricas basadas en variables existentes. Por ejemplo, supongamos que queremos comparar las tasas de homicidios en cuatro grupos de estados: New England, West Coast, South y Other. Para cada estado, primero preguntamos si está en New England. Si la respuesta es no, entonces preguntamos si está en el West Coast, y si no, preguntamos si está en el South y, si no, entonces asignamos ninguna de las anteriores (Other). Aquí vemos como usamos case_when para hacer esto: murders %&gt;% mutate(group = case_when( abb %in% c(&quot;ME&quot;, &quot;NH&quot;, &quot;VT&quot;, &quot;MA&quot;, &quot;RI&quot;, &quot;CT&quot;) ~ &quot;New England&quot;, abb %in% c(&quot;WA&quot;, &quot;OR&quot;, &quot;CA&quot;) ~ &quot;West Coast&quot;, region == &quot;South&quot; ~ &quot;South&quot;, TRUE ~ &quot;Other&quot;)) %&gt;% group_by(group) %&gt;% summarize(rate = sum(total)/ sum(population) * 10^5) #&gt; # A tibble: 4 x 2 #&gt; group rate #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 New England 1.72 #&gt; 2 Other 2.71 #&gt; 3 South 3.63 #&gt; 4 West Coast 2.90 4.14.2 between Una operación común en el análisis de datos es determinar si un valor cae dentro de un intervalo. Podemos verificar esto usando condicionales. Por ejemplo, para verificar si los elementos de un vector x están entre a y b podemos escribir: x &gt;= a &amp; x &lt;= b Sin embargo, esto puede volverse engorroso, especialmente dentro del enfoque tidyverse. La función between realiza la misma operación: between(x, a, b) 4.15 Ejercicios 1. Cargue el set de datos murders. ¿Cuál de los siguientes es cierto? murders está en formato tidy y se almacena en un tibble. murders está en formato tidy y se almacena en un data frame. murders no está en formato tidy y se almacena en un tibble. murders no está en formato tidy y se almacena en un data frame. 2. Utilice as_tibble para convertir la tabla de datos murders en un tibble y guárdelo en un objeto llamado murders_tibble. 3. Utilice la función group_by para convertir murders en un tibble que se agrupa por región. 4. Escriba el código tidyverse que es equivalente a este código: exp(mean(log(murders$population))) Escríbalo usando el pipe para que cada función se llame sin argumentos. Use el operador punto para acceder a la población. Sugerencia: el código debe comenzar con murders %&gt;%. 5. Utilice el map_df para crear un data frame con tres columnas que se denominan n, s_n y s_n_2. La primera columna debe contener los números del 1 al 100. La segunda y la tercera columna deben contener la suma del 1 al 100 \\(n\\) con \\(n\\) representando el número de fila. "],
["importing-data.html", "Capítulo 5 Importando datos 5.1 Las rutas y el directorio de trabajo 5.2 Los paquetes readr y readxl 5.3 Ejercicios 5.4 Cómo descargar archivos 5.5 Las funciones de importación de base R 5.6 Archivos de texto versus archivos binarios 5.7 Unicode versus ASCII 5.8 Cómo organizar datos con hojas de cálculo 5.9 Ejercicios", " Capítulo 5 Importando datos Hemos estado usando sets de datos ya almacenados como objetos R. Los científicos de datos rara vez tendrán tanta suerte y frecuentemente tendrán que importar datos a R desde un archivo, una base de datos u otras fuentes. Actualmente, una de las formas más comunes de almacenar y compartir datos para el análisis es a través de hojas de cálculo electrónicas. Una hoja de cálculo almacena datos en filas y columnas. Básicamente es una versión de archivo de un data frame. Al guardar dicha tabla en un archivo de computadora, uno necesita una manera de definir cuándo termina una nueva fila o columna y cuando comienza la otra. Esto a su vez define las celdas en las que se almacenan los valores individuales. Al crear hojas de cálculo con archivos de texto, como esas creadas con un editor de texto sencillo, se define una nueva fila con un return y se separan las columnas con un carácter especial predefinido. Los caracteres más comunes son coma ( ,), punto y coma ( ;), espacio ( ) y el tab (un número predeterminado de espacios o \\t). Aquí tenemos un ejemplo de cómo se ve un archivo separado por comas si lo abrimos con un editor básico de texto: La primera fila contiene nombres de columnas en lugar de datos. Nos referimos a esto como un encabezado (header en inglés), y cuando leemos (read-in en inglés) datos de una hoja de cálculo es importante saber si el archivo tiene un encabezado o no. La mayoría de las funciones de lectura suponen que hay un encabezado. Para saber si el archivo tiene un encabezado, miren el archivo antes de intentar leerlo. Esto se puede hacer con un editor de texto o con RStudio. En RStudio, podemos hacerlo abriendo el archivo en el editor o navegando a la ubicación del archivo, haciendo doble clic en el archivo y presionando View File. Sin embargo, no todos los archivos de hojas de cálculo están en formato de texto. Las hojas de cálculo de Google (Google Sheets en inglés), por ejemplo, se acceden con un navegador. Otro ejemplo es el formato propietario utilizado por Microsoft Excel, que no se puede ver con un editor de texto. A pesar de esto y debido a la popularidad del software Microsoft Excel, este formato se utiliza ampliamente. Comenzamos este capítulo describiendo las diferencias entre archivos de texto (ASCII), Unicode y binarios y cómo estas afectan la forma en que los importamos. Luego explicamos los conceptos de rutas de archivos y directorios de trabajo, que son esenciales para comprender cómo importar datos de manera efectiva. Entonces presentamos los paquetes readr y readxl y las funciones disponibles para importar hojas de cálculo en R. Finalmente, ofrecemos algunas recomendaciones sobre cómo almacenar y organizar datos en archivos. Los desafíos más complejos, sin embargo, como la extracción de datos de páginas web o de documentos PDF, se discutirán en la parte del libro “Wrangling de datos”. 5.1 Las rutas y el directorio de trabajo El primer paso para importar datos desde una hoja de cálculo es ubicar el archivo que contiene los datos. Aunque no lo recomendamos, pueden utilizar un enfoque similar al que usan para abrir archivos en Microsoft Excel haciendo clic en el menú de “File” de RStudio, haciendo clic en “Import Dataset” y luego haciendo clic en las carpetas hasta encontrar el archivo. Queremos poder escribir código en lugar de estar apuntando y haciendo clic. Las claves y los conceptos que necesitamos para aprender a hacer esto se describen en detalle en la parte del libro “Herramientas de productividad”. Aquí ofrecemos una descripción general de los conceptos básicos. El principal reto de este primer paso es permitir que las funciones de R que realizan la importación sepan dónde buscar el archivo que contiene los datos. La forma más sencilla de hacer esto es tener una copia del archivo en la carpeta donde las funciones de importación buscan por defecto. Una vez que hagamos esto, solo tenemos que proveerle el nombre del archivo a la función de importación. El paquete dslabs incluye una hoja de cálculo que contiene los datos de los asesinatos de EE. UU. Encontrar este archivo no es obvio, pero las siguientes líneas de código copian el archivo a la carpeta en la que R busca por defecto. A continuación explicamos cómo funcionan estas líneas. filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) file.copy(fullpath, &quot;murders.csv&quot;) Este código no lee los datos en R, solo copia un archivo. Pero una vez copie el archivo, podemos importar los datos con solo una línea de código. Aquí usamos la función read_csv del paquete readr, que forma parte del tidyverse. library(tidyverse) dat &lt;- read_csv(filename) Los datos se importan y almacenan en dat. El resto de esta sección define algunos conceptos importantes y ofrece una visión general de cómo escribimos código para que R pueda encontrar los archivos que queremos importar. Capítulo ?? ofrece más detalles sobre este tema. 5.1.1 El sistema de archivos Pueden pensar en el sistema de archivos (file system en inglés) de su computadora como una serie de carpetas anidadas, cada una con otras carpetas y archivos. Los científicos de datos se refieren a las carpetas como directorios y a la carpeta que contiene todas las demás carpetas como el directorio raíz (root directory en inglés). El directorio en el que estamos ubicados actualmente se llama el directorio de trabajo (working directory en inglés). Por lo tanto, el directorio de trabajo cambia a medida que se muevan por las carpetas: considérenlo como su ubicación actual. 5.1.2 Las rutas relativas y completas La ruta (path en inglés) de un archivo es una lista de nombres de directorios que se pueden considerar instrucciones sobre en qué carpetas hacer clic y en qué orden encontrar el archivo. Si estas instrucciones son para encontrar el archivo desde el directorio raíz, nos referiremos a ellas como la ruta completa (full path en inglés). Si las instrucciones son para encontrar el archivo desde el directorio de trabajo, nos referimos a ellas como una ruta relativa (relative path en inglés). Sección ?? ofrece más detalles sobre este tema. Para ver un ejemplo de una ruta completa en sus sistemas, escriban lo siguiente: system.file(package = &quot;dslabs&quot;) Las cadenas separadas por barras son los nombres de los directorios. La primera barra diagonal representa el directorio raíz y sabemos que esta es una ruta completa porque comienza con una barra diagonal. Si el primer nombre del directorio aparece sin una barra diagonal en el comienzo, entonces R supone que la ruta es relativa. Podemos usar la función list.files para ver ejemplos de rutas relativas: dir &lt;- system.file(package = &quot;dslabs&quot;) list.files(path = dir) #&gt; [1] &quot;data&quot; &quot;DESCRIPTION&quot; &quot;extdata&quot; &quot;help&quot; #&gt; [5] &quot;html&quot; &quot;INDEX&quot; &quot;Meta&quot; &quot;NAMESPACE&quot; #&gt; [9] &quot;R&quot; &quot;script&quot; Estas rutas relativas nos dan la localización de los archivos o directorios si comenzamos en el directorio con la ruta completa. Por ejemplo, la ruta completa al directorio help en el ejemplo anterior es: /Library/Frameworks/R.framework/Versions/3.5/Resources/library/dslabs/help. Nota: Probablemente no harán mucho uso de la función system.file en su trabajo diario de análisis de datos. Lo presentamos en esta sección porque facilita el intercambio de hojas de cálculo al incluirlas en el paquete dslabs. Raramente tendrán el lujo de tener datos incluidos en paquetes que ya han instalado. Sin embargo, con frecuencia necesitarán navegar por rutas completas y relativas e importar datos con formato de hoja de cálculo. 5.1.3 El directorio de trabajo Recomendamos escribir solo rutas relativas en su código ya que las rutas completas son exclusivas de sus computadoras y Uds. quieren que su código sea portátil. Pueden obtener la ruta completa de su directorio de trabajo sin escribirla explícitamente utilizando la función getwd: wd &lt;- getwd() Si necesitan cambiar su directorio de trabajo, pueden usar la función setwd o pueden cambiarlo a través de RStudio haciendo clic en “Session”. 5.1.4 Cómo generar los nombres de ruta Otro ejemplo de cómo obtener una ruta completa sin escribirla explícitamente se ofreció arriba cuando creamos el objeto fullpath de esta manera: filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) La función system.file provee la ruta completa de la carpeta que contiene todos los archivos y directorios relevantes para el paquete especificado por el argumento package. Al explorar los directorios en dir, nos encontramos con que extdata contiene el archivo que queremos: dir &lt;- system.file(package = &quot;dslabs&quot;) filename %in% list.files(file.path(dir, &quot;extdata&quot;)) #&gt; [1] TRUE La función system.file nos permite proveer un subdirectorio como primer argumento, para que podamos obtener la ruta completa del directorio extdata así: dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) La función file.path se usa para combinar los nombres de directorios para producir la ruta completa del archivo que queremos importar. fullpath &lt;- file.path(dir, filename) 5.1.5 Cómo copiar los archivos usando rutas La última línea de código que usamos para copiar el archivo en nuestro directorio de inicio usó la función file.copy. Esta toma dos argumentos: el nombre del archivo para copiar y el nombre que se usará en el nuevo directorio. file.copy(fullpath, &quot;murders.csv&quot;) #&gt; [1] TRUE Si un archivo se copia exitosamente, la función file.copy devuelve TRUE. Tengan en cuenta que le estamos dando al archivo el mismo nombre, murders.csv, pero podríamos haberle dado cualquier nombre. También recuerden que al no iniciar la cadena con una barra diagonal, R supone que esta es una ruta relativa y copia el archivo al directorio de trabajo. Deberían poder ver el archivo en su directorio de trabajo usando: list.files() 5.2 Los paquetes readr y readxl En esta sección presentamos las principales funciones de importación del tidyverse. Utilizaremos el archivo murders.csv del paquete dslabs como ejemplo. Para simplificar la ilustración, copiaremos el archivo a nuestro directorio de trabajo usando el siguiente código: filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) file.copy(fullpath, &quot;murders.csv&quot;) 5.2.1 readr El paquete readr incluye funciones para leer datos almacenados en hojas de cálculo. readr es parte del paquete tidyverse, o pueden cargarlo directamente así: library(readr) Las siguientes funciones están disponibles para leer hojas de cálculo: Función Formato Sufijo típico read_table valores separados por espacios en blanco txt read_csv valores separados por comas csv read_csv2 valores separados por punto y coma csv read_tsv valores separados delimitados por tabulaciones tsv read_delim formato de archivo de texto general, debe definir delimitador txt Aunque el sufijo generalmente nos indica qué tipo de archivo es, no hay garantía de que estos siempre coincidan. Podemos abrir el archivo para echar un vistazo o usar la función read_lines para ver algunas líneas: read_lines(&quot;murders.csv&quot;, n_max = 3) #&gt; [1] &quot;state,abb,region,population,total&quot; #&gt; [2] &quot;Alabama,AL,South,4779736,135&quot; #&gt; [3] &quot;Alaska,AK,West,710231,19&quot; Esto también muestra que hay un encabezado. Ahora estamos listos para leer los datos en R. Del sufijo .csv y del vistazo al archivo, sabemos que tenemos que usar read_csv: dat &lt;- read_csv(filename) #&gt; Parsed with column specification: #&gt; cols( #&gt; state = col_character(), #&gt; abb = col_character(), #&gt; region = col_character(), #&gt; population = col_double(), #&gt; total = col_double() #&gt; ) Tengan en cuenta que recibimos un mensaje informándonos qué tipos de datos se utilizaron para cada columna. También observen que dat es un tibble, no solo un data frame. Esto es porque read_csv es un leedor (parser en inglés) del tidyverse. Podemos confirmar que los datos se han leído de la siguiente manera: View(dat) Finalmente, recuerden que también podemos usar la ruta completa para el archivo: dat &lt;- read_csv(fullpath) 5.2.2 readxl Pueden cargar el paquete readxl usando: library(readxl) El paquete ofrece funciones para leer formatos de Microsoft Excel: Función Formato Sufijo típico read_excel detectar automáticamente el formato xls, xlsx read_xls formato original xls read_xlsx nuevo formato xlsx Los formatos de Microsoft Excel le permiten tener más de una hoja de cálculo en un archivo. Estos se conocen como hojas (sheets en inglés). Las funciones enumeradas anteriormente leen la primera hoja por defecto, pero también podemos leer las otras. La función excel_sheets nos da los nombres de todas las hojas en un archivo de Excel. Estos nombres entonces se pueden pasar al argumento sheet en las tres funciones anteriores para leer hojas distintas a la primera. 5.3 Ejercicios 1. Utilice la función read_csv para leer cada uno de los archivos que el siguiente código guarda en el objeto files: path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) files &lt;- list.files(path) files 2. Observe que el último, el archivo olive, nos da una advertencia. Esto se debe a que a la primera línea del archivo le falta el encabezado de la primera columna. Lea el archivo de ayuda para read_csv para aprender cómo leer el archivo sin leer este encabezado. Si omite el encabezado, no debería recibir esta advertencia. Guarde el resultado en un objeto llamado dat. 3. Un problema con el enfoque anterior es que no sabemos qué representan las columnas. Escriba: names(dat) para confirmar que los nombres no son informativos. Utilice la función readLines para leer solo la primera línea (luego aprenderemos cómo extraer valores del output). 5.4 Cómo descargar archivos Otro lugar común donde residen los datos es en el internet. Cuando estos datos están en archivos, podemos descargarlos y luego importarlos, o incluso leerlos directamente de la web. Por ejemplo, notamos que como nuestro paquete dslabs está en GitHub, el archivo que descargamos con el paquete tiene una URL: url &lt;- &quot;https://raw.githubusercontent.com/rafalab/dslabs/master/inst/ extdata/murders.csv&quot; El archivo read_csv puede leer estos archivos directamente: dat &lt;- read_csv(url) Si quieren tener una copia local del archivo, pueden usar la función download.file: download.file(url, &quot;murders.csv&quot;) Esto descargará el archivo y lo guardará en su sistema con el nombre murders.csv. Pueden usar cualquier nombre aquí, no necesariamente murders.csv. Recuerden que al usar download.file deben tener cuidado ya que sobrescribirá los archivos existentes sin previo aviso. Dos funciones que a veces son útiles al descargar datos del internet son tempdir y tempfile. La primera crea un directorio con un nombre aleatorio que es muy probable que sea único. Igualmente, tempfile crea una cadena de caracteres, no un archivo, que probablemente sea un nombre de archivo único. Entonces pueden ejecutar un comando, como el siguiente, que borra el archivo temporal una vez que importe los datos: tmp_filename &lt;- tempfile() download.file(url, tmp_filename) dat &lt;- read_csv(tmp_filename) file.remove(tmp_filename) 5.5 Las funciones de importación de base R La base R también provee funciones de importación. Estos tienen nombres similares a esas del tidyverse, por ejemplo read.table, read.csv y read.delim. Sin embargo, hay par de diferencias importantes. Para mostrar esto, leemos los datos con una función de base R: dat2 &lt;- read.csv(filename) Una diferencia importante es que los caracteres se convierten en factores: class(dat2$abb) #&gt; [1] &quot;factor&quot; class(dat2$region) #&gt; [1] &quot;factor&quot; Esto se puede evitar definiendo el argumento stringsAsFactors como FALSE. dat &lt;- read.csv(&quot;murders.csv&quot;, stringsAsFactors = FALSE) class(dat$state) #&gt; [1] &quot;character&quot; En nuestra experiencia, esto puede ser motivo de confusión ya que una variable que se guardó como caracteres en el archivo se convierte en factores, independientemente de lo que represente la variable. De hecho, es altamente recomendable siempre definir stringsAsFactors=FALSE para ser su enfoque por defecto cuando usan los leedores de base R. Pueden fácilmente convertir las columnas deseadas en factores después de importar datos. 5.5.1 scan Al leer hojas de cálculo, muchas cosas pueden salir mal. El archivo puede tener un encabezado multilíneal, pueden faltar celdas, o puede usar una codificación inesperada17. Les recomendamos que lean esta publicación sobre problemas comunes: https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about -unicode-and-character-sets-no-excuses/. Con experiencia, aprenderán a manejar los diferentes retos. Además, les ayudará leer detenidamente los archivos de ayuda para las funciones discutidas aquí. Con scan pueden leer cada celda de un archivo, como vemos aquí: path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) filename &lt;- &quot;murders.csv&quot; x &lt;- scan(file.path(path, filename), sep=&quot;,&quot;, what = &quot;c&quot;) x[1:10] #&gt; [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; #&gt; [6] &quot;Alabama&quot; &quot;AL&quot; &quot;South&quot; &quot;4779736&quot; &quot;135&quot; Noten que el tidyverse incluye read_lines, una función igualmente útil. 5.6 Archivos de texto versus archivos binarios En la ciencia de datos, los archivos generalmente se pueden clasificar en dos categorías: archivos de texto (también conocidos como archivos ASCII) y archivos binarios. Ya han trabajado con archivos de texto. Todos sus scripts de R son archivos de texto igual que los archivos de R markdown utilizados para crear este libro. Las tablas csv que han leído también son archivos de texto. Una gran ventaja de estos archivos es que podemos “mirarlos” fácilmente sin tener que comprar ningún tipo de software especial o seguir instrucciones complicadas. Se puede usar cualquier editor de texto para examinar un archivo de texto, incluyendo los editores disponibles gratuitamente como RStudio, Notepad, textEdit, vi, emacs, nano y pico. Para ver esto, intenten abrir un archivo csv con la herramienta de RStudio “Open file”. Deberían poder ver el contenido directamente en su editor. Sin embargo, si intentan abrir, digamos, un archivo Excel xls, jpg o png, no podrán ver nada inmediatamente útil. Estos son archivos binarios. Los archivos de Excel son carpetas comprimidas con varios archivos de texto dentro de ellas. Pero la principal distinción aquí es que los archivos de texto se pueden examinar fácilmente. Aunque R incluye herramientas para leer archivos binarios ampliamente utilizados, como archivos xls, en general es mejor encontrar sets de datos almacenados en archivos de texto. Del mismo modo, al compartir datos, es mejor que estén disponibles como archivos de texto siempre que el almacenamiento no sea un problema (los archivos binarios son mucho más eficientes para ahorrar espacio en su disco). En general, los formatos de texto facilitan el intercambio de datos, ya que no requieren software comercial para trabajar con los datos. Extraer datos de una hoja de cálculo almacenada como un archivo de texto es quizás la forma más fácil de llevar datos de un archivo a una sesión R. Desafortunadamente, las hojas de cálculo no siempre están disponibles y el hecho de que puedan ver los archivos de texto no necesariamente implica que extraer datos de ellos sea sencillo. En la parte del libro “Wrangling de datos” aprendemos a extraer datos de archivos de texto más complejos, como los archivos html. 5.7 Unicode versus ASCII Una trampa en la ciencia de datos es suponer que un archivo es un archivo de texto ASCII cuando en actualidad es otra cosa que puede parecerse mucho a un archivo de texto ASCII: un archivo de texto Unicode. Para comprender la diferencia entre estos, recuerden que todo en una computadora necesita convertirse eventualmente en 0s y 1s. ASCII es una codificación (encoding en inglés) que define una correspondencia entre caracteres y números. ASCII usa 7 bits (0s y 1s) que resulta en \\(2^7 = 128\\) elementos únicos, suficientes para codificar todos los caracteres en un teclado en inglés. Sin embargo, otros idiomas, como el español, usan caracteres no incluidos en esta codificación. Por ejemplo, las tildes no están codificadas por ASCII. Por esta razón, se definió una nueva codificación que utiliza más de 7 bits: Unicode. Cuando se utiliza Unicode, se puede elegir entre 8, 16 y 32 bits abreviados UTF-8, UTF-16 y UTF-32 respectivamente. RStudio usa la codificación UTF-8 por defecto. Aunque no entraremos en detalles sobre cómo lidiar con las diferentes codificaciones aquí, es importante que sepan que existen diferentes codificaciones para que pueden diagnosticar bien un problema si lo encuentran. Una forma en que se manifiestan los problemas es cuando surjen caracteres de “aspecto extraño” que no esperaban. Esta discusión de StackOverflow es un ejemplo: https://stackoverflow.com/questions/18789330/r-on-windows-character-encoding-hell. 5.8 Cómo organizar datos con hojas de cálculo Aunque este libro se enfoca casi exclusivamente en el análisis de datos, el manejo de datos también es una parte importante de la ciencia de datos. Como explicamos en la introducción, no cubrimos este tema. Sin embargo, con bastante frecuencia los analistas de datos necesitan recopilar datos, o trabajar con otros que recopilan datos, de manera que la forma más conveniente de almacenarlos es en una hoja de cálculo. Aunque completar una hoja de cálculo a mano es una práctica que no recomendamos y preferimos que el proceso se automatice lo más posible, a veces no queda otro remedio. Por lo tanto, en esta sección, ofrecemos recomendaciones sobre cómo organizar los datos en una hoja de cálculo. Aunque hay paquetes R diseñados para leer hojas de cálculo de Microsoft Excel, generalmente queremos evitar este formato. Recomendamos Google Sheets como una herramienta de software gratuita. Abajo resumimos las recomendaciones hechas en una publicación de Karl Broman y Kara Woo18. Favor de leer el artículo completo para más detalles importantes. Sea coherente - Antes de empezar a ingresar datos, tenga un plan. Una vez lo tenga, sea consistente y sígalo. Elija buenos nombres para las cosas: Los nombres que elija para los objetos, los archivos y los directorios deben ser memorables, fáciles de deletrear y descriptivos. Este es un equilibrio difícil de lograr y requiere tiempo y reflexión. Una regla importante a seguir es no usar espacios, usar guiones bajos _ o guiones en su lugar -. Además, evite los símbolos; es mejor utilizar las letras y los números. Escriba fechas como AAAA-MM-DD - Para evitar confusión, recomendamos utilizar el estándar global ISO 8601. Evite las celdas vacías - Llene todas las celdas y use un código común para los datos faltantes. Ponga solo una cosa en cada celda - Es mejor agregar columnas para almacenar la información adicional en vez de tener más de una pieza de información en una celda. Hazlo un rectángulo - La hoja de cálculo debe ser un rectángulo. Crea un diccionario de datos - Si necesita explicar cosas, por ejemplo cuáles son las columnas o cuáles son las etiquetas utilizadas para las variables categóricas, hágalo en un archivo separado. No haga cálculos en los archivos de datos sin procesar - Excel le permite realizar cálculos. No haga esto parte de su hoja de cálculo. El código para los cálculos debe estar en un script. No use color o resaltado como datos - La mayoría de funciones de importación no pueden importar esta información. En cambio, codifique esta información como una variable. Respalde su información: Respalde sus datos frecuentemente. Utilice la validación de datos para evitar errores - Aproveche las herramientas en su software de hoja de cálculo para que el proceso sea lo más libre posible de errores y de lesiones por estrés repetitivo. Guarde los datos como archivos de texto - Guarde los archivos para compartir en formato delimitado por comas o tabs. 5.9 Ejercicios 1. Elija una medida que pueda tomar regularmente. Por ejemplo, su peso diario o cuánto tiempo le toma correr 8 kilometros. Mantenga una hoja de cálculo que incluya la fecha, la hora, la medición y cualquier otra variable informativa que considere valiosa. Haga esto por 2 semanas. Luego haga un gráfico. https://en.wikipedia.org/wiki/Character_encoding↩ https://www.tandfonline.com/doi/abs/10.1080/00031305.2017.1375989↩ "]
]
