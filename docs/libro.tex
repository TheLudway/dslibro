% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
]{krantz}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Introducción a la ciencia de datos},
  pdfauthor={Rafael A. Irizarry},
  colorlinks=true,
  linkcolor=Maroon,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[left=1.5in, right=1.5in, top=1.25in, bottom=1.25in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.14,0.14,0.14}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.43,0.43,0.43}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
%\usepackage{booktabs}
\usepackage{float}
\usepackage{emptypage}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Introducción a la ciencia de datos}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Análisis de datos y algoritmos de predicción con R}
\author{Rafael A. Irizarry}
\date{2021-05-24}

\begin{document}
\maketitle

\renewcommand*\contentsname{Contenido}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\listoftables
\listoffigures
\hypertarget{prefacio}{%
\chapter*{Prefacio}\label{prefacio}}


Este libro comenzó como las notas utilizadas para enseñar las clases de
HarvardX \href{https://www.edx.org/professional-certificate/harvardx-data-science}{Data Science Series}\footnote{\url{https://www.edx.org/professional-certificate/harvardx-data-science}}.

El código Rmarkdown que se usó para generar el libro está disponible en \href{https://github.com/rafalab/dsbook}{GitHub}\footnote{\url{https://github.com/rafalab/dsbook}}. El tema gráfico utilizado para los gráficos a lo largo del libro se pueden recrear utilizando la función \texttt{ds\_theme\_set()} del paquete \textbf{dslabs}.

Un PDF de la versión en inglés de este libro está disponible en \href{https://leanpub.com/datasciencebook}{Leanpub}\footnote{\url{https://leanpub.com/datasciencebook}}.

Una copia impresa de la versión en inglés de este libro está disponible en \href{https://www.crcpress.com/Introduction-to-Data-Science-Data-Analysis-and-Prediction-Algorithms-with/Irizarry/p/book/9780367357986}{CRC Press}\footnote{ \url{https://www.crcpress.com/Introduction-to-Data-Science-Data-Analysis-and-Prediction-Algorithms-with/Irizarry/p/book/9780367357986}}.

Este trabajo se publica bajo la licencia Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Internacional \href{https://creativecommons.org/licenses/by-nc-sa/4.0}{CC BY-NC-SA 4.0}.

Hacemos anuncios relacionados al libro en Twitter. Para la información más reciente, siga \href{https://twitter.com/rafalab}{@rafalab}.

\hypertarget{agradecimientos}{%
\chapter*{Agradecimientos}\label{agradecimientos}}


Este libro está dedicado a todas las personas involucradas en la construcción y el mantenimiento de R y los paquetes R que utilizamos en el texto. Un agradecimiento especial a los desarrolladores y los mantenedores de base R, el \emph{tidyverse} y el paquete \textbf{caret}.

Un agradecimiento especial a mi \emph{tidyverse} gurú David Robinson y a Amy Gill por docenas de comentarios, cambios y sugerencias. Además, muchas gracias a Stephanie Hicks, que dos veces sirvió como co-instructora en mis clases de ciencias de datos, y a Yihui Xie, que pacientemente toleró mis multiples preguntas sobre bookdown. Gracias también a Karl Broman, de quien tomé prestadas ideas para las secciones sobre la visualización de datos y las herramientas de productividad, y a Hector Corrada-Bravo, por sus consejos sobre cómo mejor enseñar \emph{machine learning}. Gracias a Peter Aldhous, de quien tomé prestadas ideas para la sección sobre los principios de la visualización de datos y a Jenny Bryan por escribir \emph{Happy Git} y \emph{GitHub for the useR}, que influyeron en nuestros capítulos de Git. Gracias a Alyssa Frazee por ayudar a crear el problema de tarea que se convirtió en el capítulo sobre los sistemas de recomendación y a Amanda Cox por proporcionar los datos de los exámenes de los Regentes de Nueva York. Además, muchas gracias a Jeff Leek, Roger Peng y Brian Caffo, cuya clase inspiró la forma en que se divide este libro y a Garrett Grolemund y Hadley Wickham por abrir el código para su libro R for Data Science. Finalmente, gracias a Alex Nones por corregir el manuscrito durante sus diversas etapas.

Este libro fue concebido durante la enseñanza de varios cursos de estadística aplicada, comenzando hace más de quince años. Los profesores asistentes que trabajaron conmigo a lo largo de los años hicieron importantes contribuciones indirectas a este libro. La última versión de este curso es una serie de HarvardX coordinada por Heather Sternshein y Zofia Gajdos. Les agradecemos sus contribuciones. También estamos agradecidos a todos los estudiantes cuyas preguntas y comentarios nos ayudaron a mejorar el libro. Los cursos fueron parcialmente financiados por el subsidio del NIH R25GM114818. Agradecemos los Institutos Nacionales de Salud por su apoyo.

Un agradecimiento especial a todos aquellos que editaron el libro a través de \emph{pull requests} de GitHub o hicieron sugerencias creando un \emph{issue} o enviando un correo electrónico: \texttt{nickyfoto} (Huang Qiang) \texttt{desautm} (Marc-André Désautels), \texttt{michaschwab} (Michail Schwab) \texttt{alvarolarreategui} (Alvaro Larreategui), \texttt{jakevc} (Jake VanCampen), \texttt{omerta} (Guillermo Lengemann), \texttt{espinielli} (Enrico Spinielli), \texttt{asimumba}(Aaron Simumba) \texttt{braunschweig} (Maldewar), \texttt{gwierzchowski} (Grzegorz Wierzchowski), \texttt{technocrat} (Richard Careaga) \texttt{atzakas}, \texttt{defeit} (David Emerson Feit), \texttt{shiraamitchell} (Shira Mitchell) \texttt{Nathalie-S}, \texttt{andreashandel} (Andreas Handel) \texttt{berkowitze} (Elias Berkowitz) \texttt{Dean-Webb} (Dean Webber), \texttt{mohayusuf}, \texttt{jimrothstein}, \texttt{mPloenzke} (Matthew Ploenzke), \texttt{NicholasDowand} (Nicholas Dow) \texttt{kant} (Darío Hereñú), \texttt{debbieyuster} (Debbie Yuster), \texttt{tuanchauict} (Tuan Chau), \texttt{phzeller}, David D. Kane, El Mustapha El Abbassi y Vadim Zipunnikov.

La traducción del libro al español estuvo a cargo de Alex Nones. Agradecemos a todos los que contribuyeron a esta traducción. Ilia Ushkin y Dustin Tingley generaron un primer borrador usando un programa de traducción automática. A través de Twitter @R4DS\_es y @\emph{lacion} (Laura Ación) proveyeron importante información sobre recursos existentes. Varios otros contribuyeron a través de Twitter, GitHub, o email: @hortizzuazaga (Humberto Ortiz), @ribnikov (Jose Matestadístico), @jarangoo (Julián A.), @DiegoV\_O\_
(Diego), @BrunoContrerasM (BContreras Moreira), @a2kimura (Alejandro Kimura), @Emilio\_NTN (Emilio García Morán), @beto\_bfr (betofogo), @jdieramon (Jose V. Die), @yabellini (Yanina Bellini Saibene), @symusicgroup (Ismael Rudas), @criztinaz (Cristina Zenteno), @controlnegativo (Cristina de Dios), @d\_olivaw (Elio Campitelli), @aguerri\_jc (Jesús C. Aguerri), @pincheippie (Francisco, en casa) @compBiology (Pedro Madrigal), @RLadiesCuerna (RLadies Cuernavaca), @thecarpentries, @midnucas, \texttt{eead-csic-compbio} (CSIC \& Fundación ARAID), \texttt{pablormier} (Pablo R. Mier), \texttt{josschavezf} (Joselyn Chavez), \texttt{jmcastagnetto} (Jesus M. Castagnetto), \texttt{ismaelrudas}, \texttt{AnaBVA} (Ana B. Villaseñor Altamirano), @pabloguti3rr3z (Pablo Gutiérrez), Héctor Corrada-Bravo, Rafael A. Arce Nazario, Luis R. Pericchi Guerra, María E. Perez Hernández, Juan Carlos Perdomo, Anamari Irizarry y Amed Irizarry.

\hypertarget{introducciuxf3n}{%
\chapter*{Introducción}\label{introducciuxf3n}}


La demanda de profesionales cualificados en ciencias de datos en la industria, la academia y el gobierno está creciendo rápidamente. Este libro presenta conceptos y destrezas que pueden ayudarles a enfrentar los desafíos del análisis de datos en situaciones reales. El texto abarca los conceptos de probabilidad, inferencia estadística, regresión lineal y \emph{machine learning}. También les ayudará a desarrollar destrezas como la programación en R, el \emph{wrangling} de datos, \textbf{dplyr}, la visualización de datos con \textbf{ggplot2}, la creación de algoritmos con \textbf{caret}, la organización de archivos con UNIX/Linux \emph{shell}, el control de versiones con Git y GitHub y la preparación de documentos reproducibles con \textbf{knitr} y R markdown. El libro se divide en seis partes: \textbf{R}, \textbf{Visualización de datos}, \textbf{\emph{Wrangling} de datos}, \textbf{Estadísticas con R}, \textbf{\emph{Machine Learning}} y \textbf{Herramientas de productividad}. Cada parte tiene varios capítulos que se deben presentar como una sola clase e incluye docenas de ejercicios distribuidos a través de los capítulos.

\hypertarget{los-casos-de-estudio}{%
\section*{Los casos de estudio}\label{los-casos-de-estudio}}


A lo largo del libro, utilizamos casos de estudio motivantes. En cada caso de estudio, intentamos imitar de manera realista la experiencia de los científicos de datos. Para cada uno de los conceptos que discutimos, comenzamos haciendo preguntas específicas a las que entonces respondemos mediante un análisis de datos. Aprendemos los conceptos como un medio para responder a las preguntas. Ejemplos de los casos de estudio que incluimos en este libro son:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.40}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.30}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.30}}@{}}
\toprule
Caso de estudio & Concepto & \\
\midrule
\endhead
Tasas de asesinatos en Estados Unidos por estado & Conceptos básicos de R & \\
Alturas de estudiantes & Resúmenes estadísticos & \\
Tendencias en la salud y la economía mundial & Visualización de datos & \\
El impacto de las vacunas en las tasas de enfermedades infecciosas & Visualización de datos & \\
La crisis financiera de 2007-2008 & Probabilidad & \\
Previsión de elecciones & Inferencia estadística & \\
Alturas autoreportadas de estudiantes & \emph{Wrangling} de datos & \\
\emph{Moneyball}: Construyendo un equipo de béisbol & Regresión lineal & \\
MNIST: Procesamiento de imagen de dígitos escritos a mano & \emph{Machine Learning} & \\
Sistemas de recomendación de películas & \emph{Machine Learning} & \\
\bottomrule
\end{longtable}

\hypertarget{quiuxe9n-encontraruxe1-uxfatil-este-libro}{%
\section*{¿Quién encontrará útil este libro?}\label{quiuxe9n-encontraruxe1-uxfatil-este-libro}}


El próposito de este libro es servir como un texto para un primer curso de ciencia de datos. No es necesario tener conocimientos previos de R, aunque algo de experiencia en la programación puede ser útil. Los conceptos estadísticos utilizados para responder a las preguntas de los casos de estudio se presentan solo brevemente y, por lo tanto, recomendamos un libro de texto de probabilidad y estadística para los que quieran entender a fondo estos conceptos. Al leer y comprender todos los capítulos y completar todos los ejercicios, los estudiantes estarán bien posicionados para realizar tareas básicas de análisis de datos y aprender los conceptos y las destrezas más avanzadas que son necesarios para convertirse en expertos.

\hypertarget{que-cubre-este-libro}{%
\section*{¿Que cubre este libro?}\label{que-cubre-este-libro}}


Comenzamos repasando los \textbf{conceptos básicos de R} y el \textbf{tidyverse}. Aprenderán R a lo largo del libro, pero en la primera parte nos dedicamos a revisar los componentes básicos necesarios para seguir aprendiendo.

La creciente disponibilidad de sets de datos informativos y de herramientas de software ha conducido a que más y más campos dependan de la \textbf{visualización de datos}. En la segunda parte, demostramos cómo usar \textbf{ggplot2} para generar gráficos y describir principios importantes de la visualización de datos.

En la tercera parte, demostramos la importancia de las estadísticas en el análisis de datos respondiendo a preguntas de estudios de caso usando la \textbf{probabilidad}, la \textbf{inferencia} y la \textbf{regresión} con R.

La cuarta parte utiliza varios ejemplos para familiarizar a los lectores con el \textbf{\emph{wrangling} de datos}. Entre las destrezas específicas que estudiamos están la extracción de la web (\emph{web scraping} en inglés), el uso de expresiones regulares y la unión y el cambio de formato de tablas de datos. Hacemos esto usando las herramientas de \textbf{tidyverse}.

En la quinta parte presentamos varios desafíos que nos llevan a introducir \textbf{\emph{machine learning}}. Aprendemos a usar el paquete \textbf{caret} para construir algoritmos de predicción que incluyen k vecinos más cercanos y bosques aleatorios.

En la parte final, ofrecemos una breve introducción a las \textbf{herramientas de productividad} que usamos diariamente en los proyectos de ciencia de datos. Estas son RStudio, UNIX/Linux shell, Git y GitHub, y \textbf{knitr} y R Markdown.

\hypertarget{quuxe9-no-cubre-este-libro}{%
\section*{¿Qué no cubre este libro?}\label{quuxe9-no-cubre-este-libro}}


Este libro se enfoca en los aspectos del análisis de datos de la ciencia de datos. Por consiguiente, no discutimos aspectos relacionados con el manejo de datos (\emph{data management} en inglés) o la ingeniería. Aunque la programación en R es una parte esencial del libro, no enseñamos temas informáticos más avanzados como las estructuras de datos, la optimización y la teoría de algoritmos. Del mismo modo, no discutimos temas como los servicios web, los gráficos interactivos, la computación paralela y el procesamiento de flujos de datos (\emph{data streaming processing} en inglés). Los conceptos estadísticos se presentan principalmente como herramientas para resolver problemas y no se incluyen descripciones teóricas detalladas en este libro.

\hypertarget{getting-started}{%
\chapter{Comenzando con R y RStudio}\label{getting-started}}

\hypertarget{por-quuxe9-r}{%
\section{¿Por qué R?}\label{por-quuxe9-r}}

R no es un lenguaje de programación como C o Java. No fue creado por ingenieros de software para el desarrollo de software, sino por estadísticos como un ambiente interactivo para el análisis de datos. Pueden leer la historia completa en el artículo \emph{A Brief History of S}\footnote{\url{https://pdfs.semanticscholar.org/9b48/46f192aa37ca122cfabb1ed1b59866d8bfda.pdf}}. La interactividad es una característica indispensable en la ciencia de datos porque, como pronto aprenderán, la capacidad de explorar rápidamente los datos es necesario para el éxito en este campo. Sin embargo, igual que en otros lenguajes de programación, en R pueden guardar su trabajo como una secuencia de comandos, conocida como un \emph{script}, que se pueden ejecutar fácilmente en cualquier momento. Estos \emph{scripts} sirven como un registro del análisis que realizaron, una característica clave que facilita el trabajo reproducible. Los programadores expertos no deben esperar que R siga las convenciones a que están acostumbrados, ya que se sentirán decepcionados. Si son pacientes, apreciarán la gran ventaja de R cuando se trata del análisis de datos y, específicamente, de la visualización de datos.

Otras características atractivas de R son:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  R es gratuito y de código abierto\footnote{\url{https://opensource.org/history}}.
\item
  Se ejecuta en todas las plataformas principales: Windows, Mac Os, UNIX/Linux.
\item
  Los \emph{scripts} y los objetos de datos se pueden compartir sin problemas entre plataformas.
\item
  Existe una comunidad grande, creciente y activa de usuarios de R y, como resultado, hay numerosos recursos para aprender y hacer preguntas\footnote{\url{https://stats.stackexchange.com/questions/138/free-resources-for-learning-r}} \footnote{\url{https://www.r-project.org/help.html}}.
\item
  Es fácil para otras personas contribuir complementos (\emph{add-ons} en inglés) que les permiten a los desarrolladores compartir implementaciones de software de nuevas metodologías de ciencia de datos. Esto les da a los usuarios de R acceso temprano a los métodos y herramientas más recientes que se desarrollan para una amplia variedad de disciplinas, incluyendo la ecología, la biología molecular, las ciencias sociales y la geografía, entre otros campos.
\end{enumerate}

\hypertarget{la-consola-r}{%
\section{La consola R}\label{la-consola-r}}

El análisis de datos interactivo generalmente ocurre en la consola R que ejecuta comandos a medida que los escriban. Hay varias formas de obtener acceso a una consola R. Una es simplemente iniciando R en su computadora. La consola se ve así:

\begin{center}\includegraphics[width=4in]{R/img/R_console} \end{center}

Como ejemplo rápido, intenten usar la consola para calcular una propina de 15\% en una comida que cuesta \$19.71:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.15} \SpecialCharTok{*} \FloatTok{19.71}
\CommentTok{\#\textgreater{} [1] 2.96}
\end{Highlighting}
\end{Shaded}

\textbf{Ojo: En este libro, los cuadros grises se utilizan para mostrar el código R escrito en la consola R. El símbolo \texttt{\#\textgreater{}} se usa para denotar el \emph{output} de la consola R.}

\hypertarget{scripts}{%
\section{\texorpdfstring{\emph{Scripts}}{Scripts}}\label{scripts}}

Una de las grandes ventajas de R sobre el software de análisis de apuntar y hacer clic es que pueden guardar su trabajo como \emph{scripts}, que entonces pueden editar y guardar con un editor de texto. El material de este libro se desarrolló utilizando el \emph{Integrated Development Environment} (IDE) de RStudio\footnote{\url{https://www.rstudio.com/}}. RStudio incluye un editor con muchas características específicas de R, una consola para ejecutar su código y otros paneles útiles, incluso uno para mostrar figuras.

\begin{center}\includegraphics[width=4in]{R/img/RStudio} \end{center}

La mayoría de consolas de R disponibles en la web también incluyen un panel para editar \emph{scripts}, pero no todas les permiten guardar los \emph{scripts} para su uso posterior.

Todos los \emph{scripts} de R utilizados para generar este libro se pueden encontrar en GitHub\footnote{\url{https://github.com/rafalab/dsbook}}.

\hypertarget{rstudio}{%
\section{RStudio}\label{rstudio}}

RStudio será nuestra plataforma de lanzamiento para los proyectos de ciencia de datos. No sólo nos provee un editor para crear y editar nuestros \emph{scripts}, sino que también ofrece muchas otras herramientas útiles. En esta sección repasaremos algunos de los conceptos básicos.

\hypertarget{paneles}{%
\subsection{Paneles}\label{paneles}}

Cuando inicien RStudio por primera vez, verán tres paneles. El panel izquierdo muestra la consola R. A la derecha, el panel superior incluye pestañas como \emph{Environment} y \emph{History}, mientras que el panel inferior muestra cinco pestañas: \emph{File}, \emph{Plots}, \emph{Packages}, \emph{Help} y \emph{Viewer} (estas pestañas pueden ser diferentes en las nuevas versiones de RStudio). Pueden hacer clic en cada pestaña para moverse por las diferentes opciones.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_21_16} \end{center}

Para iniciar un nuevo \emph{script}, hagan clic en \emph{File}, entonces \emph{New File} y luego \emph{R Script}.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_21_42} \end{center}

Esto inicia un nuevo panel a la izquierda y es aquí donde pueden comenzar a escribir su \emph{script}.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_21_49} \end{center}

\hypertarget{atajos-de-teclado}{%
\subsection{Atajos de teclado}\label{atajos-de-teclado}}

Aunque en este tutorial a menudo mostramos cómo usar el mouse, \textbf{les recomendamos que memoricen los atajos de teclado (\emph{key bindings} en inglés) para las operaciones que usan con mayor frecuencia}. RStudio incluye una hoja de referencia (\emph{cheat sheet} en inglés) útil con los comandos más utilizados. Pueden obtenerla directamente de RStudio así:

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_22_20} \end{center}

Recomendamos tener esto a mano para poder buscar las combinaciones de teclas cuando se encuentren apuntando y haciendo clic repetidas veces. Pueden encontrar versiones en español aquí: \url{https://www.rstudio.com/resources/cheatsheets/}.

\hypertarget{cuxf3mo-ejecutar-comandos-mientras-editan-scripts}{%
\subsection{\texorpdfstring{Cómo ejecutar comandos mientras editan \emph{scripts}}{Cómo ejecutar comandos mientras editan scripts}}\label{cuxf3mo-ejecutar-comandos-mientras-editan-scripts}}

Hay muchos editores diseñados específicamente para la codificación. Estos son útiles porque el color y la indentación se agregan automáticamente para que el código sea más legible. RStudio es uno de estos editores y se desarrolló específicamente para R. Una de las principales ventajas que RStudio tiene sobre otros editores es que podemos probar nuestro código fácilmente mientras editamos nuestros \emph{scripts}. A continuación ofrecemos un ejemplo.

Comencemos abriendo un nuevo \emph{script} como lo hicimos antes. Entonces, nombremos el \emph{script}. Podemos hacer esto a través del editor guardando el nuevo \emph{script} actual sin nombre. Para empezar, hagan clic en el icono de guardar o usando la combinación de teclas Ctrl + S en Windows y Command + S en Mac.

Al intentar guardar el documento por primera vez, RStudio le pedirá un nombre. Una buena convención es usar un nombre descriptivo, con letras minúsculas, sin espacios, sólo guiones para separar las palabras y luego seguido del sufijo \emph{.R}. Llamaremos a este \emph{script}: \emph{my-first-script.R}.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_27_44} \end{center}

Ahora estamos listos para comenzar a editar nuestro primer \emph{script}. Las primeras líneas de código en un \emph{script} de R se dedican a cargar los paquetes que usaremos. Otra característica útil de RStudio es que una vez escribimos \texttt{library()}, RStudio comienza a completar automáticamente lo que estamos escribiendo con los paquetes que hemos instalado. Observen lo que sucede cuando escribimos \texttt{library(ti)}:

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_29_47} \end{center}

Otra característica que pueden haber notado es que cuando escriben \texttt{library(} el segundo paréntesis se agrega automáticamente. Esto les ayudará a evitar uno de los errores más comunes en la codificación: olvidar de cerrar un paréntesis.

Ahora podemos continuar escribiendo código. Como ejemplo, crearemos un gráfico que muestre los totales de asesinatos versus los totales de población por estado de EE.UU. Una vez que hayan terminado de escribir el código necesario para hacer este gráfico, pueden probarlo \emph{ejecutando} el código. Para hacer esto, hagan clic en el botón \emph{Run} en la parte derecha superior del panel de edición. También pueden usar la combinación de teclas: Ctrl + Shift + Enter en Windows o Command + Shift + Return en Mac.

Tan pronto corran el código, verán que este aparece en la consola R y, en este caso, el gráfico que resulta aparece en la consola de gráficos. Noten que la consola de gráficos tiene una interfaz útil que les permite hacer clic hacia delante o hacia atrás en diferentes gráficos, hacer zoom en el gráfico o guardar los gráficos como archivos.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_45_18} \end{center}

Para ejecutar una línea a la vez en lugar del \emph{script} completo, pueden usar Control-Enter en Windows y Command-Return en Mac.

\hypertarget{cuxf3mo-cambiar-las-opciones-globales}{%
\subsection{Cómo cambiar las opciones globales}\label{cuxf3mo-cambiar-las-opciones-globales}}

Pueden cambiar bastante el aspecto y la funcionalidad de RStudio.

Para cambiar las opciones globales, hagan clic en \emph{Tools} y luego en \emph{Global Options \ldots{}}.

Como ejemplo, mostramos cómo hacer un cambio que \textbf{sumamente recomendamos}: cambiar el \emph{Save workspace to .RData on exit} a \emph{Never} y desmarcar \emph{Restore .RData into workspace at start}. Por defecto, cuando salen de R, el programa guarda todos los objetos que han creado en un archivo llamado .RData. Esto ocurre para que cuando reinicien la sesión en el mismo archivo, el programa cargue estos objetos. Sin embargo, encontramos que esto causa confusión, especialmente cuando compartimos código con colegas y suponemos que tienen este archivo .RData. Para cambiar estas opciones, hagan que su configuración \emph{General} se vea así:

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_56_08} \end{center}

\hypertarget{instalaciuxf3n-de-paquetes-de-r}{%
\section{Instalación de paquetes de R}\label{instalaciuxf3n-de-paquetes-de-r}}

La funcionalidad que una nueva instalación de R ofrece es sólo una pequeña fracción de lo que es posible. De hecho, nos referimos a lo que obtienen después de su primera instalación como \emph{base R}. La funcionalidad adicional proviene de complementos disponibles de los desarrolladores. Actualmente hay cientos de estos disponibles de CRAN y muchos otros compartidos a través de otros repositorios como GitHub. Sin embargo, debido a que no todo el mundo necesita todas las funciones disponibles, R pone a disposición diferentes componentes a través de paquetes (\emph{packages} en inglés). R facilita la instalación de paquetes desde R. Por ejemplo, para instalar el paquete \textbf{dslabs}, que usamos para compartir los sets de datos y códigos relacionados con este libro, deben escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"dslabs"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En RStudio pueden navegar a la pestaña \emph{Tools} y seleccionar \emph{Install packages}. Luego, podemos cargar el paquete en nuestras sesiones de R usando la función \texttt{library}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\end{Highlighting}
\end{Shaded}

A medida que vayan leyendo este libro, verán que cargamos paquetes sin instalarlos. Esto se debe a que una vez que instalen un paquete, permanece instalado y sólo necesita cargarse con \texttt{library}. El paquete permanece cargado hasta que terminemos con la sesión R. Si intentan cargar un paquete y obtienen un error, probablemente significa que no lo han instalado.

Podemos instalar más de un paquete a la vez al proveerle un vector de caracteres a esta función:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{, }\StringTok{"dslabs"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que la instalación de \textbf{tidyverse} instala varios paquetes. Esto ocurre comúnmente cuando un paquete tiene \emph{dependencias}, es decir usa funciones de otros paquetes. Cuando cargan un paquete usando \texttt{library}, también cargan sus dependencias.

Una vez que los paquetes estén instalados, pueden cargarlos en R y no necesitan instalarlos nuevamente, a menos que instalen una versión nueva de R. Recuerden que los paquetes están instalados en R y no en RStudio.

Es útil mantener una lista de todos los paquetes que necesitan para su trabajo en un \emph{script} porque si tienen que realizar una instalación nueva de R, pueden reinstalar todos sus paquetes simplemente ejecutando un \emph{script}.

Pueden ver todos los paquetes que han instalado utilizando la siguiente función:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{installed.packages}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-r}{%
\part{R}\label{part-r}}

\hypertarget{r-basics}{%
\chapter{Lo básico de R}\label{r-basics}}

En este libro, utilizaremos el ambiente de software R para todo nuestro análisis. Aprenderán R y las técnicas de análisis de datos simultáneamente. Por lo tanto, para continuar necesitarán acceso a R. También recomendamos el uso de un \emph{Entorno de Desarrollo Integrado} (IDE), como RStudio, para guardar su trabajo. Recuerden que es común que un curso o taller ofrezca acceso a un ambiente de R y a un IDE a través de su navegador de web, como lo hace RStudio cloud\footnote{\url{https://rstudio.cloud}}. Si tienen acceso a dicho recurso, no necesitan instalar R ni RStudio. Sin embargo, si eventualmente quieren convertirse en analistas expertos de datos, recomendamos instalar estas herramientas en su computadora\footnote{\url{https://rafalab.github.io/dsbook/installing-r-rstudio.html}}.
Tanto R como RStudio son gratuitos y están disponibles en línea.

\hypertarget{caso-de-estudio-los-asesinatos-con-armas-en-ee.-uu.}{%
\section{Caso de estudio: los asesinatos con armas en EE. UU.}\label{caso-de-estudio-los-asesinatos-con-armas-en-ee.-uu.}}

Imagínense que viven en Europa y se les ofrece un trabajo en una empresa estadounidense con muchas ubicaciones por todo EE. UU. Es un gran trabajo, pero noticias con titulares como \textbf{Tasa de homicidios con armas de fuego de EE. UU. más alta que en otros países desarrollados}\footnote{\url{http://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership-homicide-rate-higher-than-other-developed-countries/}}. ¿Se preocupan? Gráficos como el siguiente pueden preocuparle aún más:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/murder-rate-example-1-1} \end{center}

O peor aún, esta versión de \href{https://everytownresearch.org}{everytown.org}:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/murder-rate-example-2-1} \end{center}

Pero entonces se recuerdan que Estados Unidos es un país grande y diverso, con 50 estados muy diferentes, además del Distrito de Columbia (DC).

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/us-murders-by-state-map-1} \end{center}

California, por ejemplo, tiene una población más grande que Canadá, y 20 estados de EE. UU. tienen poblaciones más grandes que la de Noruega. En algunos aspectos, la variabilidad entre los estados de EE. UU. es parecida a la variabilidad entre los países de Europa. Además, aunque no se incluyen en los cuadros anteriores, las tasas de asesinatos en Lituania, Ucrania y Rusia son superiores a cuatro por cada 100,000. Entonces, es posible que las noticias que les preocupan sean demasiado superficiales. Tienen opciones de dónde pueden vivir y desean determinar la seguridad de cada estado en particular. Obtendremos algunas ideas al examinar los datos relacionados con asesinatos con armas de fuego de EE. UU. en 2010 usando R.

Antes de comenzar con nuestro ejemplo, necesitamos discutir la logística, así como algunos de los componentes básicos necesarios para obtener destrezas más avanzadas de R. Recuerden que la utilidad de algunos de estos componentes básicos no siempre es inmediatamente obvia, pero más tarde en el libro apreciarán haber dominado estas destrezas.

\hypertarget{lo-buxe1sico}{%
\section{Lo básico}\label{lo-buxe1sico}}

Antes de empezar con el set de datos motivante, necesitamos repasar los conceptos básicos de R.

\hypertarget{objetos}{%
\subsection{Objetos}\label{objetos}}

Supongan que unos estudiantes de secundaria nos piden ayuda para resolver varias ecuaciones cuadráticas de la forma \(ax^2+bx+c = 0\). La fórmula cuadrática nos ofrece las soluciones:

\[
\frac{-b - \sqrt{b^2 - 4ac}}{2a}\,\, \mbox{ and } \frac{-b + \sqrt{b^2 - 4ac}}{2a}
\]
que por supuesto cambian dependiendo de los valores de \(a\), \(b\) y \(c\). Una ventaja de los lenguajes de programación es poder definir variables y escribir expresiones con estas, como se hace en las matemáticas, para obtener una solución numérica. Escribiremos un código general para la ecuación cuadrática a continuación, pero si nos piden resolver \(x^2 + x -1 = 0\), entonces definimos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{c }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

que almacena los valores para su uso posterior. Usamos \texttt{\textless{}-} para asignar valores a las variables.

También podemos asignar valores usando \texttt{=} en lugar de \texttt{\textless{}-}, pero recomendamos no usar \texttt{=} para evitar confusión.

Copien y peguen el código anterior en su consola para definir las tres variables. Tengan en cuenta que R no imprime nada cuando hacemos esta asignación. Esto significa que los objetos se definieron con éxito. Si hubieran cometido un error, recibirían un mensaje de error.

Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe \texttt{a} y R nos muestra el valor almacenado:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

Una forma más explícita de pedirle a R que nos muestre el valor almacenado en \texttt{a} es usar \texttt{print} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(a)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

Usamos el término \emph{objeto} para describir cosas que están almacenadas en R. Las variables son un ejemplo, pero los objetos también pueden ser entidades más complicadas como las funciones, que se describen más adelante.

\hypertarget{el-espacio-de-trabajo}{%
\subsection{El espacio de trabajo}\label{el-espacio-de-trabajo}}

A medida que definimos objetos en la consola, estamos cambiando el \emph{espacio de trabajo} (\emph{workspace} en inglés). Pueden ver todas las variables guardadas en su espacio de trabajo al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "a"        "b"        "c"        "dat"      "img\_path" "murders"}
\end{Highlighting}
\end{Shaded}

En RStudio, la pestaña \emph{Environment} muestra los valores:

\begin{center}\includegraphics[width=0.7\linewidth]{R/img/rstudio-environment} \end{center}

Deberíamos ver \texttt{a}, \texttt{b} y \texttt{c}. Si intentan obtener el valor de una variable que no está en su espacio de trabajo, recibirán un mensaje de error. Por ejemplo, si escriben \texttt{x}, verán lo siguiente: \texttt{Error:\ object\ \textquotesingle{}x\textquotesingle{}\ not\ found}.

Ahora, dado que estos valores se guardan en variables, para resolver nuestra ecuación, utilizamos la fórmula cuadrática:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{+} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c) )}\SpecialCharTok{/}\NormalTok{ ( }\DecValTok{2}\SpecialCharTok{*}\NormalTok{a )}
\CommentTok{\#\textgreater{} [1] 0.618}
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{{-}} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c) )}\SpecialCharTok{/}\NormalTok{ ( }\DecValTok{2}\SpecialCharTok{*}\NormalTok{a )}
\CommentTok{\#\textgreater{} [1] {-}1.62}
\end{Highlighting}
\end{Shaded}

\hypertarget{funciones}{%
\subsection{Funciones}\label{funciones}}

Una vez que definan las variables, el proceso de análisis de datos generalmente se puede describir como una serie de funciones aplicadas a los datos. R incluye varias funciones predefinidas y la mayoría de las líneas de análisis que construimos hacen uso extensivo de ellas.

Ya usamos las funciones \texttt{install.packages}, \texttt{library} y \texttt{ls}. También usamos la función \texttt{sqrt} para solucionar la ecuación cuadrática anterior. Hay muchas más funciones predefinidas y se pueden añadir hasta más a través de paquetes. Estas no aparecen en sus espacios de trabajo porque no las definieron, pero están disponibles para su uso inmediato.

En general, necesitamos usar paréntesis para evaluar una función. Si escriben \texttt{ls}, la función no se evalúa y en cambio R les muestra el código que la define. Si escriben \texttt{ls()}, la función se evalúa y, como ya se mostró, vemos objetos en el espacio de trabajo.

A diferencia de \texttt{ls}, la mayoría de las funciones requieren uno o más argumentos. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función \texttt{log}. Recuerden que anteriormente definimos \texttt{a} como 1:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2.08}
\FunctionTok{log}\NormalTok{(a)}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

Pueden averiguar lo que la función espera y lo que hace revisando unos manuales muy útiles incluidos en R. Pueden obtener ayuda utilizando la función \texttt{help} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(}\StringTok{"log"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para la mayoría de las funciones, también podemos usar esta abreviatura:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?log}
\end{Highlighting}
\end{Shaded}

La página de ayuda les mostrará qué argumentos espera la función. Por ejemplo, \texttt{log} necesita \texttt{x} y \texttt{base} para correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Pueden determinar cuáles son opcionales notando en el documento de ayuda cuáles valores predeterminados se asignan con \texttt{=}. Definir estos es opcional. Por ejemplo, la base de la función \texttt{log} por defecto es \texttt{base\ =\ exp(1)} que hace \texttt{log} el logaritmo natural por defecto.

Para echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, pueden escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(log)}
\CommentTok{\#\textgreater{} function (x, base = exp(1)) }
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

Pueden cambiar los valores predeterminados simplemente asignando otro objeto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{, }\AttributeTok{base =} \DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Recuerden que no hemos estado especificando el argumento \texttt{x} como tal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\AttributeTok{x =} \DecValTok{8}\NormalTok{, }\AttributeTok{base =} \DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

El código anterior funciona, pero también podemos ahorrarnos un poco de escritura: si no usan un nombre de argumento, R supone que están ingresando argumentos en el orden en que se muestran en la página de ayuda o por \texttt{args}. Entonces, al no usar los nombres, R supone que los argumentos son \texttt{x} seguido por \texttt{base}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Si usan los nombres de los argumentos, podemos incluirlos en el orden en que queramos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\AttributeTok{base =} \DecValTok{2}\NormalTok{, }\AttributeTok{x =} \DecValTok{8}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Para especificar argumentos, debemos usar \texttt{=} y no \texttt{\textless{}-}.

Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estas, las más utilizados son los operadores aritméticos y relacionales. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{\^{}}\DecValTok{3}
\CommentTok{\#\textgreater{} [1] 8}
\end{Highlighting}
\end{Shaded}

Pueden ver los operadores aritméticos al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(}\StringTok{"+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

o

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?}\StringTok{"+"}
\end{Highlighting}
\end{Shaded}

y los operadores relacionales al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(}\StringTok{"\textgreater{}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

o

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?}\StringTok{"\textgreater{}"}
\end{Highlighting}
\end{Shaded}

\hypertarget{otros-objetos-predefinidos}{%
\subsection{Otros objetos predefinidos}\label{otros-objetos-predefinidos}}

Hay varios sets de datos que se incluyen para que los usuarios practiquen y prueben las funciones. Pueden ver todos los sets de datos disponibles escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Esto les muestra el nombre del objeto para estos sets de datos. Estos sets de datos son objetos que se pueden usar simplemente escribiendo el nombre. Por ejemplo, si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{co2}
\end{Highlighting}
\end{Shaded}

R les mostrará los datos de concentración de CO2 atmosférico de Mauna Loa.

Otros objetos predefinidos son cantidades matemáticas, como la constante \(\pi\) e \(\infty\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi}
\CommentTok{\#\textgreater{} [1] 3.14}
\ConstantTok{Inf}\SpecialCharTok{+}\DecValTok{1}
\CommentTok{\#\textgreater{} [1] Inf}
\end{Highlighting}
\end{Shaded}

\hypertarget{nombres-de-variables}{%
\subsection{Nombres de variables}\label{nombres-de-variables}}

Hemos usado las letras \texttt{a}, \texttt{b} y \texttt{c} como nombres de variables, pero estos pueden ser casi cualquier cosa. Algunas reglas básicas en R son que los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R. Por ejemplo, no nombren una de sus variables \texttt{install.packages} escribiendo algo como:
\texttt{install.packages\ \textless{}-\ 2}.

Una buena convención a seguir es usar palabras significativas que describan lo que están almacenado, usar solo minúsculas y usar guiones bajos como sustituto de espacios. Para las ecuaciones cuadráticas, podríamos usar algo como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{solution\_1 }\OtherTok{\textless{}{-}}\NormalTok{ (}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{+} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c))}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\NormalTok{solution\_2 }\OtherTok{\textless{}{-}}\NormalTok{ (}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{{-}} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c))}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

Para obtener más consejos, recomendamos estudiar la guía de estilo de Hadley Wickham\footnote{\url{http://adv-r.had.co.nz/Style.html}}.

\hypertarget{cuxf3mo-guardar-su-espacio-de-trabajo}{%
\subsection{Cómo guardar su espacio de trabajo}\label{cuxf3mo-guardar-su-espacio-de-trabajo}}

Los valores permanecen en el espacio de trabajo hasta que finalicen sus sesiones o las borren con la función \texttt{rm}. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, al salir de R, el programa les pregunta si desean guardar su espacio de trabajo. Si lo guardan, la próxima vez que inicien R, el programa restaurará el espacio de trabajo.

Sin embargo, no recomendamos guardar el espacio de trabajo así porque, a medida que comiencen a trabajar en diferentes proyectos, será más difícil darle seguimiento de lo que guardan. En cambio, les recomendamos que le asignen al espacio de trabajo un nombre específico. Pueden hacer esto usando las funciones \texttt{save} o \texttt{save.image}. Para cargar, usen la función \texttt{load}. Al guardar un espacio de trabajo, recomendamos el sufijo \texttt{rda} o \texttt{RData}. En RStudio, también pueden hacerlo navegando a la pestaña \emph{Session} y eligiendo \emph{Save Workspace as}. Luego pueden cargarlo usando las opciones \emph{Load Workspace} en la misma pestaña. Para aprender más, lean las páginas de ayuda (\emph{help pages} en inglés) en \texttt{save}, \texttt{save.image} y \texttt{load}.

\hypertarget{scripts-motivantes}{%
\subsection{\texorpdfstring{\emph{Scripts} motivantes}{Scripts motivantes}}\label{scripts-motivantes}}

Para resolver otra ecuación como \(3x^2 + 2x -1\), podemos copiar y pegar el código anterior, redefinir las variables y volver a calcular la solución:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{c }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{+} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c))}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{{-}} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c))}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

Al crear y guardar un \emph{script} con el código anterior, ya no tendrán que volver a escribirlo todo cada vez, sino simplemente cambiar los nombres de las variables. Intenten escribir la secuencia de comandos anteriores en un editor y observen lo fácil que es cambiar las variables y recibir una respuesta.

\hypertarget{cuxf3mo-comentar-su-cuxf3digo}{%
\subsection{Cómo comentar su código}\label{cuxf3mo-comentar-su-cuxf3digo}}

Si una línea de código R comienza con el símbolo \texttt{\#}, no se evalúa. Podemos usar esto para escribir recordatorios de por qué escribimos un código particular. Por ejemplo, en el \emph{script} anterior, podríamos añadir:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Código para calcular la solución a la }
\DocumentationTok{\#\# ecuación cuadrática de la forma ax\^{}2 + bx + c}
\DocumentationTok{\#\# definir las variables}
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{c }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{1}

\DocumentationTok{\#\# ahora calcule la solución}
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{+} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c)) }\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{b }\SpecialCharTok{{-}} \FunctionTok{sqrt}\NormalTok{(b}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{4}\SpecialCharTok{*}\NormalTok{a}\SpecialCharTok{*}\NormalTok{c)) }\SpecialCharTok{/}\NormalTok{ (}\DecValTok{2}\SpecialCharTok{*}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios}{%
\section{Ejercicios}\label{ejercicios}}

1. ¿Cuál es la suma de los primeros 100 números enteros positivos? La fórmula para la suma de enteros \(1\) a \(n\) es \(n(n+1)/2\). Defina \(n=100\) y luego use R para calcular la suma de \(1\) a \(100\) usando la fórmula. ¿Cuál es la suma?

2. Ahora use la misma fórmula para calcular la suma de los enteros del 1 a 1000.

3. Mire el resultado de escribir el siguiente código en R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, n)}
\FunctionTok{sum}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Basado en el resultado, ¿qué cree que hacen las funciones \texttt{seq} y \texttt{sum}? Puede usar \texttt{help}.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{sum} crea una lista de números y \texttt{seq} los suma.
\item
  \texttt{seq} crea una lista de números y \texttt{sum} los suma.
\item
  \texttt{seq} crea una lista aleatoria y \texttt{sum} calcula la suma de 1 a 1000.
\item
  \texttt{sum} siempre devuelve el mismo número.
\end{enumerate}

4. En las matemáticas y la programación decimos que evaluamos una función cuando reemplazamos el argumento con un número dado. Entonces si escribimos \texttt{sqrt(4)}, evaluamos la función \texttt{sqrt}. En R se puede evaluar una función dentro de otra función. Las evaluaciones suceden de adentro hacia afuera. Use una línea de código para calcular el logaritmo, en base 10, de la raíz cuadrada de 100.

5. ¿Cuál de los siguientes siempre devolverá el valor numérico almacenado en \texttt{x}? Puede intentar los ejemplos y usar el sistema de ayuda si lo desea.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{log(10\^{}x)}
\item
  \texttt{log10(x\^{}10)}
\item
  \texttt{log(exp(x))}
\item
  \texttt{exp(log(x,\ base\ =\ 2))}
\end{enumerate}

\hypertarget{tipos-de-datos}{%
\section{Tipos de datos}\label{tipos-de-datos}}

Las variables en R pueden ser de diferentes tipos. Por ejemplo, necesitamos distinguir números de cadenas de caracteres y tablas de listas sencillas de números. La función \texttt{class} nos ayuda a determinar qué tipo de objeto tenemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{2}
\FunctionTok{class}\NormalTok{(a)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

Para trabajar eficientemente en R, es importante aprender los diferentes tipos de variables y qué podemos hacer con ellos.

\hypertarget{data-frames}{%
\subsection{\texorpdfstring{\emph{Data frames}}{Data frames}}\label{data-frames}}

Hasta ahora, las variables que hemos definido son solo un número. Esto no es muy útil para almacenar datos. La forma más común de almacenar un set de datos en R es usando un \emph{data frame}. Conceptualmente, podemos pensar en un \emph{data frame} como una tabla con filas que representan observaciones y con columnas que representan las diferentes variables recopiladas para cada observación. Los \emph{data frames} son particularmente útiles para sets de datos porque podemos combinar diferentes tipos de datos en un solo objeto.

Una gran proporción de los retos del análisis de datos comienza con datos almacenados en un \emph{data frame}. Por ejemplo, almacenamos los datos para nuestro ejemplo motivante en un \emph{data frame}. Pueden tener acceso a este set de datos cargando el paquete \textbf{dslabs} y entonces utilizando la función \texttt{data} para cargar el set de datos \texttt{murders} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

Para verificar que esto es un \emph{data frame}, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(murders)}
\CommentTok{\#\textgreater{} [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-examinar-un-objeto}{%
\subsection{Cómo examinar un objeto}\label{cuxf3mo-examinar-un-objeto}}

La función \texttt{str} es útil para obtener más información sobre la estructura de un objeto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(murders)}
\CommentTok{\#\textgreater{} \textquotesingle{}data.frame\textquotesingle{}:    51 obs. of  5 variables:}
\CommentTok{\#\textgreater{} $ state : chr "Alabama" "Alaska" "Arizona" "Arkansas" ...}
\CommentTok{\#\textgreater{} $ abb : chr "AL" "AK" "AZ" "AR" ...}
\CommentTok{\#\textgreater{} $ region : Factor w/ 4 levels "Northeast","South",..: 2 4 4 2 4 4 1 2 2}
\CommentTok{\#\textgreater{}    2 ...}
\CommentTok{\#\textgreater{} $ population: num 4779736 710231 6392017 2915918 37253956 ...}
\CommentTok{\#\textgreater{} $ total : num 135 19 232 93 1257 ...}
\end{Highlighting}
\end{Shaded}

Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 51 filas (50 estados más DC) y cinco variables. Podemos mostrar las primeras seis líneas usando la función \texttt{head}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(murders)}
\CommentTok{\#\textgreater{}        state abb region population total}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65}
\end{Highlighting}
\end{Shaded}

En este set de datos, cada estado se considera una observación y se incluyen cinco variables para cada estado.

Antes de continuar respondiendo a nuestra pregunta original sobre los diferentes estados, repasemos más sobre los componentes de este objeto.

\hypertarget{el-operador-de-acceso}{%
\subsection{\texorpdfstring{El operador de acceso: \texttt{\$}}{El operador de acceso: \$}}\label{el-operador-de-acceso}}

Para nuestro análisis, necesitaremos acceso a las diferentes variables representadas por columnas incluidas en este \emph{data frame}. Para hacer esto, utilizamos el operador de acceso \texttt{\$} de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{population}
\CommentTok{\#\textgreater{}  [1]  4779736   710231  6392017  2915918 37253956  5029196  3574097}
\CommentTok{\#\textgreater{}  [8]   897934   601723 19687653  9920000  1360301  1567582 12830632}
\CommentTok{\#\textgreater{} [15]  6483802  3046355  2853118  4339367  4533372  1328361  5773552}
\CommentTok{\#\textgreater{} [22]  6547629  9883640  5303925  2967297  5988927   989415  1826341}
\CommentTok{\#\textgreater{} [29]  2700551  1316470  8791894  2059179 19378102  9535483   672591}
\CommentTok{\#\textgreater{} [36] 11536504  3751351  3831074 12702379  1052567  4625364   814180}
\CommentTok{\#\textgreater{} [43]  6346105 25145561  2763885   625741  8001024  6724540  1852994}
\CommentTok{\#\textgreater{} [50]  5686986   563626}
\end{Highlighting}
\end{Shaded}

¿Pero cómo supimos usar \texttt{population}? Anteriormente, aplicando la función \texttt{str} al objeto \texttt{murders}, revelamos los nombres de cada una de las cinco variables almacenadas en esta tabla. Podemos tener acceso rápido a los nombres de las variables usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(murders)}
\CommentTok{\#\textgreater{} [1] "state"      "abb"        "region"     "population" "total"}
\end{Highlighting}
\end{Shaded}

Es importante saber que el orden de las entradas en \texttt{murders\$population} conserva el orden de las filas en nuestra tabla de datos. Esto luego nos permitirá manipular una variable basada en los resultados de otra. Por ejemplo, podremos ordenar los nombres de los estados según el número de asesinatos.

\textbf{Consejo}: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. Escriban \texttt{murders\$p} y luego presionen la tecla \emph{tab} en su teclado. Esta funcionalidad y muchas otras características útiles de autocompletar están disponibles en RStudio.

\hypertarget{vectores-numuxe9ricos-de-caracteres-y-luxf3gicos}{%
\subsection{Vectores: numéricos, de caracteres y lógicos}\label{vectores-numuxe9ricos-de-caracteres-y-luxf3gicos}}

El objeto \texttt{murders\$population} no es un número sino varios. Llamamos \emph{vectores} a este tipo de objeto. Un solo número es técnicamente un vector de longitud 1, pero en general usamos el término vectores para referirnos a objetos con varias entradas. La función \texttt{length} les dice cuántas entradas hay en el vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population}
\FunctionTok{length}\NormalTok{(pop)}
\CommentTok{\#\textgreater{} [1] 51}
\end{Highlighting}
\end{Shaded}

Este vector particular es \emph{numérico} ya que los tamaños de la población son números:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(pop)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

En un vector numérico cada entrada debe ser un número.

Para almacenar una cadena de caracteres, los vectores también pueden ser de la clase \emph{carácter}. Por ejemplo, los nombres de los estados son caracteres:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{state)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

Al igual que con los vectores numéricos, todas las entradas en un vector de caracteres deben ser un carácter.

Otro tipo importante de vectores son los \emph{vectores lógicos}. Estos deben ser \texttt{TRUE} o \texttt{FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \DecValTok{3} \SpecialCharTok{==} \DecValTok{2}
\NormalTok{z}
\CommentTok{\#\textgreater{} [1] FALSE}
\FunctionTok{class}\NormalTok{(z)}
\CommentTok{\#\textgreater{} [1] "logical"}
\end{Highlighting}
\end{Shaded}

Aquí el \texttt{==} es un operador relacional que pregunta si 3 es igual a 2. En R, usar solo un \texttt{=} asigna una variable, pero si usan dos \texttt{==}, entonces evalúa si los objetos son iguales.

Pueden ver esto al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?Comparison}
\end{Highlighting}
\end{Shaded}

En futuras secciones, observarán lo útil que pueden ser los operadores relacionales.

Discutimos las características más importantes de los vectores después de los siguientes ejercicios.

\textbf{Avanzado}: Matemáticamente, los valores en \texttt{pop} son números enteros y hay una clase de enteros en R. Sin embargo, por defecto, a los números se les asigna una clase numérica incluso cuando son enteros redondos. Por ejemplo, \texttt{class(1)} devuelve numérico. Pueden convertirlo en un entero de clase con la función \texttt{as.integer()} o agregando un \texttt{L} así: \texttt{1L}. Tengan en cuenta la clase escribiendo: \texttt{class(1L)}.

\hypertarget{factors}{%
\subsection{Factores}\label{factors}}

En el set de datos \texttt{murders}, se podría esperar que la región también sea un vector de caracteres. Sin embargo, no lo es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{region)}
\CommentTok{\#\textgreater{} [1] "factor"}
\end{Highlighting}
\end{Shaded}

Es un \emph{factor}. Los factores son útiles para almacenar datos categóricos. Podemos ver que solo hay cuatro regiones al utilizar la función \texttt{levels}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{region)}
\CommentTok{\#\textgreater{} [1] "Northeast"     "South"         "North Central" "West"}
\end{Highlighting}
\end{Shaded}

En el fondo, R almacena estos \emph{levels} como números enteros y mantiene un mapa para llevar un registro de las etiquetas. Esto es más eficiente en terminos de memoria que almacenar todos los caracteres.

Tengan en cuenta que los niveles tienen un orden diferente al orden de aparición en el factor. En R, por defecto, los niveles se ordenan alfabéticamente. Sin embargo, a menudo queremos que los niveles sigan un orden diferente. Pueden especificar un orden a través del argumento \texttt{levels} cuando crean el factor con la función \texttt{factor}. Por ejemplo, en el set de datos de asesinatos, las regiones se ordenan de este a oeste. La función \texttt{reorder} nos permite cambiar el orden de los niveles de un factor según un resumen calculado en un vector numérico. Demostraremos esto con un ejemplo sencillo y veremos otros más avanzados en la parte Visualización de Datos del libro.

Supongan que queremos que los \emph{levels} de la región se ordenen según el número total de asesinatos en vez de por orden alfabético. Si hay valores asociados con cada \emph{level}, podemos usar \texttt{reorder} y especificar un resumen de datos para determinar el orden. El siguiente código toma la suma del total de asesinatos en cada región y reordena el factor según estas sumas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{region }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{region}
\NormalTok{value }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}
\NormalTok{region }\OtherTok{\textless{}{-}} \FunctionTok{reorder}\NormalTok{(region, value, }\AttributeTok{FUN =}\NormalTok{ sum)}
\FunctionTok{levels}\NormalTok{(region)}
\CommentTok{\#\textgreater{} [1] "Northeast"     "North Central" "West"          "South"}
\end{Highlighting}
\end{Shaded}

El nuevo orden concuerda con el hecho de que hay menos asesinatos en el Noreste y más en el Sur.

\textbf{Advertencia}: Los factores pueden causar confusión ya que a veces se comportan como caracteres y otras veces no. Como resultado, estos son una fuente común de errores.

\hypertarget{listas}{%
\subsection{Listas}\label{listas}}

Los \emph{data frames} son un caso especial de \emph{listas}. Las listas son útiles porque pueden almacenar cualquier combinación de diferentes tipos de datos. Pueden crear una lista utilizando la función \texttt{lista} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{name =} \StringTok{"John Doe"}\NormalTok{,}
               \AttributeTok{student\_id =} \DecValTok{1234}\NormalTok{,}
               \AttributeTok{grades =} \FunctionTok{c}\NormalTok{(}\DecValTok{95}\NormalTok{, }\DecValTok{82}\NormalTok{, }\DecValTok{91}\NormalTok{, }\DecValTok{97}\NormalTok{, }\DecValTok{93}\NormalTok{),}
               \AttributeTok{final\_grade =} \StringTok{"A"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La función \texttt{c} se describe en la sección \ref{vectors}.

Esta lista incluye un carácter, un número, un vector con cinco números y otro carácter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record}
\CommentTok{\#\textgreater{} $name}
\CommentTok{\#\textgreater{} [1] "John Doe"}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} $student\_id}
\CommentTok{\#\textgreater{} [1] 1234}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} $grades}
\CommentTok{\#\textgreater{} [1] 95 82 91 97 93}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} $final\_grade}
\CommentTok{\#\textgreater{} [1] "A"}
\FunctionTok{class}\NormalTok{(record)}
\CommentTok{\#\textgreater{} [1] "list"}
\end{Highlighting}
\end{Shaded}

Al igual que con los \emph{data frames}, pueden extraer los componentes de una lista con el operador de acceso: \texttt{\$}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record}\SpecialCharTok{$}\NormalTok{student\_id}
\CommentTok{\#\textgreater{} [1] 1234}
\end{Highlighting}
\end{Shaded}

También podemos usar corchetes dobles (\texttt{{[}{[}}) así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record[[}\StringTok{"student\_id"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 1234}
\end{Highlighting}
\end{Shaded}

Deben acostumbrarse al hecho de que, en R, frecuentemente hay varias formas de hacer lo mismo, como tener acceso a las entradas.

También pueden encontrar listas sin nombres de variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record2 }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"John Doe"}\NormalTok{, }\DecValTok{1234}\NormalTok{)}
\NormalTok{record2}
\CommentTok{\#\textgreater{} [[1]]}
\CommentTok{\#\textgreater{} [1] "John Doe"}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]]}
\CommentTok{\#\textgreater{} [1] 1234}
\end{Highlighting}
\end{Shaded}

Si una lista no tiene nombres, no pueden extraer los elementos con \texttt{\$}, pero todavía pueden usar el método de corchetes. En vez de proveer el nombre de la variable, pueden proveer el índice de la lista de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record2[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] "John Doe"}
\end{Highlighting}
\end{Shaded}

No usaremos listas hasta más tarde, pero es posible que encuentren una en sus propias exploraciones de R. Por eso, les mostramos algunos conceptos básicos aquí.

\hypertarget{matrices}{%
\subsection{Matrices}\label{matrices}}

Las matrices son otro tipo de objeto común en R. Las matrices son similares a los \emph{data frames} en que son bidimensionales: tienen filas y columnas. Sin embargo, al igual que los vectores numéricos, de caracteres y lógicos, las entradas en las matrices deben ser del mismo tipo. Por esta razón, los \emph{data frames} son mucho más útiles para almacenar datos, ya que podemos tener caracteres, factores y números en ellos.

No obstante, las matrices tienen una gran ventaja sobre los \emph{data frames}: podemos realizar operaciones de álgebra de matrices, una técnica matemática poderosa. No describimos estas operaciones en este libro, pero gran parte de lo que sucede en segundo plano cuando se realiza un análisis de datos involucra matrices. Cubrimos las matrices con más detalle en el Capítulo \ref{matrix-algebra} pero también las discutimos brevemente aquí, ya que algunas de las funciones que aprenderemos devuelven matrices.

Podemos definir una matriz usando la función \texttt{matrix}. Necesitamos especificar el número de filas y columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{12}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mat}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3]}
\CommentTok{\#\textgreater{} [1,]    1    5    9}
\CommentTok{\#\textgreater{} [2,]    2    6   10}
\CommentTok{\#\textgreater{} [3,]    3    7   11}
\CommentTok{\#\textgreater{} [4,]    4    8   12}
\end{Highlighting}
\end{Shaded}

Pueden acceder a entradas específicas en una matriz usando corchetes (\texttt{{[}}). Si desean la segunda fila, tercera columna, escriban:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat[}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 10}
\end{Highlighting}
\end{Shaded}

Si desean toda la segunda fila, dejen vacío el lugar de la columna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat[}\DecValTok{2}\NormalTok{, ]}
\CommentTok{\#\textgreater{} [1]  2  6 10}
\end{Highlighting}
\end{Shaded}

Noten que esto devuelve un vector, no una matriz.

Del mismo modo, si desean la tercera columna completa, dejen el lugar de la fila vacío:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat[, }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1]  9 10 11 12}
\end{Highlighting}
\end{Shaded}

Esto también es un vector, no una matriz.

Pueden acceder a más de una columna o más de una fila si lo desean. Esto les dará una nueva matriz:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat[, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]    5    9}
\CommentTok{\#\textgreater{} [2,]    6   10}
\CommentTok{\#\textgreater{} [3,]    7   11}
\CommentTok{\#\textgreater{} [4,]    8   12}
\end{Highlighting}
\end{Shaded}

Pueden crear subconjuntos basados tanto en las filas como en las columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]    5    9}
\CommentTok{\#\textgreater{} [2,]    6   10}
\end{Highlighting}
\end{Shaded}

Podemos convertir las matrices en \emph{data frames} usando la función \texttt{as.data.frame}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.data.frame}\NormalTok{(mat)}
\CommentTok{\#\textgreater{}   V1 V2 V3}
\CommentTok{\#\textgreater{} 1  1  5  9}
\CommentTok{\#\textgreater{} 2  2  6 10}
\CommentTok{\#\textgreater{} 3  3  7 11}
\CommentTok{\#\textgreater{} 4  4  8 12}
\end{Highlighting}
\end{Shaded}

También podemos usar corchetes individuales (\texttt{{[}}) para acceder a las filas y las columnas de un \emph{data frame}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders[}\DecValTok{25}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "Mississippi"}
\NormalTok{murders[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, ]}
\CommentTok{\#\textgreater{}     state abb region population total}
\CommentTok{\#\textgreater{} 2  Alaska  AK   West     710231    19}
\CommentTok{\#\textgreater{} 3 Arizona  AZ   West    6392017   232}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-1}{%
\section{Ejercicios}\label{ejercicios-1}}

1. Cargue el set de datos de asesinatos de EE.UU.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

Use la función \texttt{str} para examinar la estructura del objeto \texttt{murders}. ¿Cuál de las siguientes opciones describe mejor las variables representadas en este \emph{data frame}?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Los 51 estados.
\item
  Las tasas de asesinatos para los 50 estados y DC.
\item
  El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población y el número total de asesinatos para 2010 del estado.
\item
  \texttt{str} no muestra información relevante.
\end{enumerate}

2. ¿Cuáles son los nombres de las columnas utilizados por el \emph{data frame} para estas cinco variables?

3. Use el operador de acceso \texttt{\$} para extraer las abreviaturas de los estados y asignarlas al objeto \texttt{a}. ¿Cuál es la clase de este objeto?

4. Ahora use los corchetes para extraer las abreviaturas de los estados y asignarlas al objeto \texttt{b}. Utilice la función \texttt{identical} para determinar si \texttt{a} y \texttt{b} son iguales.

5. Vimos que la columna \texttt{region} almacena un factor. Puede corroborar esto escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{region)}
\end{Highlighting}
\end{Shaded}

Con una línea de código, use las funciones \texttt{levels} y \texttt{length} para determinar el número de regiones definidas por este set de datos.

6. La función \texttt{table} toma un vector y devuelve la frecuencia de cada elemento. Puede ver rápidamente cuántos estados hay en cada región aplicando esta función. Use esta función en una línea de código para crear una tabla de estados por región.

\hypertarget{vectors}{%
\section{Vectores}\label{vectors}}

En R, los objetos más básicos disponibles para almacenar datos son \emph{vectores}. Como hemos visto, los sets de datos complejos generalmente se pueden dividir en componentes que son vectores. Por ejemplo, en un \emph{data frame}, cada columna es un vector. Aquí aprendemos más sobre esta clase importante.

\hypertarget{cuxf3mo-crear-vectores}{%
\subsection{Cómo crear vectores}\label{cuxf3mo-crear-vectores}}

Podemos crear vectores usando la función \texttt{c}, que significa \emph{concatenar}. Usamos \texttt{c} para concatenar entradas de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{380}\NormalTok{, }\DecValTok{124}\NormalTok{, }\DecValTok{818}\NormalTok{)}
\NormalTok{codes}
\CommentTok{\#\textgreater{} [1] 380 124 818}
\end{Highlighting}
\end{Shaded}

También podemos crear vectores de caracteres. Usamos las comillas para denotar que las entradas son caracteres en lugar de nombres de variables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{country }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"italy"}\NormalTok{, }\StringTok{"canada"}\NormalTok{, }\StringTok{"egypt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En R, también pueden usar comillas sencillas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{country }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}italy\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}canada\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}egypt\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pero tengan cuidado de no confundir la comilla sencilla ' con el \emph{back quote} `.

A estas alturas ya deberían saber que si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{country }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(italy, canada, egypt)}
\end{Highlighting}
\end{Shaded}

recibirán un error porque las variables \texttt{italy}, \texttt{canada} y \texttt{egypt} no están definidas. Si no usamos las comillas, R busca variables con esos nombres y devuelve un error.

\hypertarget{nombres}{%
\subsection{Nombres}\label{nombres}}

A veces es útil nombrar las entradas de un vector. Por ejemplo, al definir un vector de códigos de paises, podemos usar los nombres para conectar los dos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\AttributeTok{italy =} \DecValTok{380}\NormalTok{, }\AttributeTok{canada =} \DecValTok{124}\NormalTok{, }\AttributeTok{egypt =} \DecValTok{818}\NormalTok{)}
\NormalTok{codes}
\CommentTok{\#\textgreater{}  italy canada  egypt }
\CommentTok{\#\textgreater{}    380    124    818}
\end{Highlighting}
\end{Shaded}

El objeto \texttt{codes} sigue siendo un vector numérico:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(codes)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

pero con nombres:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(codes)}
\CommentTok{\#\textgreater{} [1] "italy"  "canada" "egypt"}
\end{Highlighting}
\end{Shaded}

Si el uso de cadenas sin comillas parece confuso, sepan que también pueden usar las comillas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"italy"} \OtherTok{=} \DecValTok{380}\NormalTok{, }\StringTok{"canada"} \OtherTok{=} \DecValTok{124}\NormalTok{, }\StringTok{"egypt"} \OtherTok{=} \DecValTok{818}\NormalTok{)}
\NormalTok{codes}
\CommentTok{\#\textgreater{}  italy canada  egypt }
\CommentTok{\#\textgreater{}    380    124    818}
\end{Highlighting}
\end{Shaded}

No hay diferencia entre esta llamada a una función (\emph{function call} en inglés) y la anterior. Esta es una de las muchas formas en que R es peculiar en comparación con otros lenguajes.

También podemos asignar nombres usando la función \texttt{names}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{380}\NormalTok{, }\DecValTok{124}\NormalTok{, }\DecValTok{818}\NormalTok{)}
\NormalTok{country }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"italy"}\NormalTok{,}\StringTok{"canada"}\NormalTok{,}\StringTok{"egypt"}\NormalTok{)}
\FunctionTok{names}\NormalTok{(codes) }\OtherTok{\textless{}{-}}\NormalTok{ country}
\NormalTok{codes}
\CommentTok{\#\textgreater{}  italy canada  egypt }
\CommentTok{\#\textgreater{}    380    124    818}
\end{Highlighting}
\end{Shaded}

\hypertarget{secuencias}{%
\subsection{Secuencias}\label{secuencias}}

Otra función útil para crear vectores genera secuencias:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

El primer argumento define el inicio y el segundo define el final que se incluye en el vector. El valor por defecto es subir en incrementos de 1, pero un tercer argumento nos permite determinar cuánto saltar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1 3 5 7 9}
\end{Highlighting}
\end{Shaded}

Si queremos enteros consecutivos, podemos usar la siguiente abreviación:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Cuando usamos estas funciones, R produce números enteros, no numéricos, porque generalmente se usan para indexar algo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "integer"}
\end{Highlighting}
\end{Shaded}

Sin embargo, si creamos una secuencia que incluye no enteros, la clase cambia:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{0.5}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-crear-un-subconjunto}{%
\subsection{Cómo crear un subconjunto}\label{cuxf3mo-crear-un-subconjunto}}

Usamos los corchetes para tener acceso a elementos específicos de un vector. Para el vector \texttt{codes} que definimos anteriormente, podemos tener acceso al segundo elemento usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} canada }
\CommentTok{\#\textgreater{}    124}
\end{Highlighting}
\end{Shaded}

Pueden obtener más de una entrada utilizando un vector de entradas múltiples como índice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\CommentTok{\#\textgreater{} italy egypt }
\CommentTok{\#\textgreater{}   380   818}
\end{Highlighting}
\end{Shaded}

Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{}  italy canada }
\CommentTok{\#\textgreater{}    380    124}
\end{Highlighting}
\end{Shaded}

Si los elementos tienen nombres, también podemos acceder a las entradas utilizando estos nombres. A continuación ofrecemos dos ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\StringTok{"canada"}\NormalTok{]}
\CommentTok{\#\textgreater{} canada }
\CommentTok{\#\textgreater{}    124}
\NormalTok{codes[}\FunctionTok{c}\NormalTok{(}\StringTok{"egypt"}\NormalTok{,}\StringTok{"italy"}\NormalTok{)]}
\CommentTok{\#\textgreater{} egypt italy }
\CommentTok{\#\textgreater{}   818   380}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-conversiuxf3n-forzada}{%
\section{La conversión forzada}\label{la-conversiuxf3n-forzada}}

En general, la \emph{conversión forzada} (\emph{coercion} en inglés) es un intento de R de ser flexible con los tipos de datos. Cuando una entrada no coincide con lo esperado, algunas de las funciones predefinidas de R tratan de adivinar lo que uno intentaba antes de devolver un mensaje de error. Esto también puede causar confusión. Al no entender la conversión forzada, los programadores pueden volverse locos cuando codifican en R, ya que R se comporta de manera bastante diferente a la mayoría de los otros idiomas en cuanto a esto. Aprendamos más con unos ejemplos.

Dijimos que los vectores deben ser todos del mismo tipo. Entonces, si tratamos de combinar, por ejemplo, números y caracteres, pueden esperar un error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{"canada"}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

¡Pero no nos da un error, ni siquiera una advertencia! ¿Que pasó? Miren \texttt{x} y su clase:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{\#\textgreater{} [1] "1"      "canada" "3"}
\FunctionTok{class}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

R forzó una conversión de los datos a caracteres. Como pusimos una cadena de caracteres en el vector, R adivinó que nuestra intención era que el 1 y el 3 fueran las cadenas de caracteres \texttt{"1"} y ``\texttt{3}''. El hecho de que ni siquiera emitiera una advertencia es un ejemplo de cómo la conversión forzada puede causar muchos errores inadvertidos en R.

R también ofrece funciones para cambiar de un tipo a otro. Por ejemplo, pueden convertir números en caracteres con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(x)}
\NormalTok{y}
\CommentTok{\#\textgreater{} [1] "1" "2" "3" "4" "5"}
\end{Highlighting}
\end{Shaded}

Pueden revertir a lo anterior con \texttt{as.numeric}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5}
\end{Highlighting}
\end{Shaded}

Esta función es muy útil ya que los sets de datos que incluyen números como cadenas de caracteres son comunes.

\hypertarget{not-available-na}{%
\subsection{\texorpdfstring{\emph{Not available} (NA)}{Not available (NA)}}\label{not-available-na}}

Cuando una función intenta forzar una conversión de un tipo a otro y encuentra un caso imposible, generalmente nos da una advertencia y convierte la entrada en un valor especial llamado \texttt{NA} que significa \emph{no disponible} (\emph{Not Available} en inglés). Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"3"}\NormalTok{)}
\FunctionTok{as.numeric}\NormalTok{(x)}
\CommentTok{\#\textgreater{} Warning: NAs introducidos por coerción}
\CommentTok{\#\textgreater{} [1]  1 NA  3}
\end{Highlighting}
\end{Shaded}

R no sabe el número que querían cuando escribieron \texttt{b} y no lo intenta adivinar.

Como científicos de datos, se encontrarán con el \texttt{NA} frecuentemente ya que se usa generalmente para datos faltantes (\emph{missing data} en inglés), un problema común en los sets de datos del mundo real.

\hypertarget{ejercicios-2}{%
\section{Ejercicios}\label{ejercicios-2}}

1. Use la función \texttt{c} para crear un vector con las temperaturas altas promedio en enero para Beijing, Lagos, París, Río de Janeiro, San Juan y Toronto, que son 35, 88, 42, 84, 81 y 30 grados Fahrenheit. Llame al objeto \texttt{temp}.

2. Ahora cree un vector con los nombres de las ciudades y llame al objeto \texttt{city}.

3. Utilice la función \texttt{names} y los objetos definidos en los ejercicios anteriores para asociar los datos de temperatura con su ciudad correspondiente.

4. Utilice los operadores \texttt{{[}} y \texttt{:} para acceder a la temperatura de las tres primeras ciudades de la lista.

5. Utilice el operador \texttt{{[}} para acceder a la temperatura de París y San Juan.

6. Utilice el operador \texttt{:} para crear una secuencia de números \(12,13,14,\dots,73\).

7. Cree un vector que contenga todos los números impares positivos menores que 100.

8. Cree un vector de números que comience en 6, no pase 55 y agregue números en incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7, y así sucesivamente. ¿Cuántos números tiene la lista? Sugerencia: use \texttt{seq} y \texttt{length}.

9. ¿Cuál es la clase del siguiente objeto \texttt{a\ \textless{}-\ seq(1,\ 10,\ 0.5)}?

10. ¿Cuál es la clase del siguiente objeto \texttt{a\ \textless{}-\ seq(1,\ 10)}?

11. La clase de \texttt{class(a\textless{}-1)} es numérica, no entero. R por defecto es numérico y para forzar un número entero, debe añadir la letra \texttt{L}. Confirme que la clase de \texttt{1L} es entero.

12. Defina el siguiente vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"3"}\NormalTok{, }\StringTok{"5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y oblíguelo a obtener enteros.

\hypertarget{sorting}{%
\section{\texorpdfstring{\emph{Sorting}}{Sorting}}\label{sorting}}

Ahora que hemos dominado algunos conocimientos básicos de R, intentemos obtener algunos conocimientos sobre la seguridad de los distintos estados en el contexto de los asesinatos con armas de fuego.

\hypertarget{sort}{%
\subsection{\texorpdfstring{\texttt{sort}}{sort}}\label{sort}}

Digamos que queremos clasificar los estados desde el menor hasta el mayor según los asesinatos con armas de fuego. La función \texttt{sort} ordena un vector en orden creciente. Por lo tanto, podemos ver la mayor cantidad de asesinatos con armas escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\FunctionTok{sort}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{total)}
\CommentTok{\#\textgreater{}  [1]    2    4    5    5    7    8   11   12   12   16   19   21   22}
\CommentTok{\#\textgreater{} [14]   27   32   36   38   53   63   65   67   84   93   93   97   97}
\CommentTok{\#\textgreater{} [27]   99  111  116  118  120  135  142  207  219  232  246  250  286}
\CommentTok{\#\textgreater{} [40]  293  310  321  351  364  376  413  457  517  669  805 1257}
\end{Highlighting}
\end{Shaded}

Sin embargo, esto no nos da información sobre qué estados tienen qué total de asesinatos. Por ejemplo, no sabemos qué estado tuvo 1257.

\hypertarget{order}{%
\subsection{\texorpdfstring{\texttt{order}}{order}}\label{order}}

La función \texttt{order} es mas apropiada para lo que queremos hacer. \texttt{order} toma un vector como entrada y devuelve el vector de índices que clasifica el vector de entrada. Esto puede ser un poco confuso, así que estudiemos un ejemplo sencillo. Podemos crear un vector y ordenarlo (\emph{sort} en inglés):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{31}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{92}\NormalTok{, }\DecValTok{65}\NormalTok{)}
\FunctionTok{sort}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1]  4 15 31 65 92}
\end{Highlighting}
\end{Shaded}

En lugar de ordenar el vector de entrada, la función \texttt{order} devuelve el índice que ordena el vector de entrada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{order}\NormalTok{(x)}
\NormalTok{x[index]}
\CommentTok{\#\textgreater{} [1]  4 15 31 65 92}
\end{Highlighting}
\end{Shaded}

Este es el mismo resultado que le devuelve \texttt{sort(x)}. Si miramos este índice, vemos por qué funciona:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{\#\textgreater{} [1] 31  4 15 92 65}
\FunctionTok{order}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 2 3 1 5 4}
\end{Highlighting}
\end{Shaded}

La segunda entrada de \texttt{x} es la más pequeña, entonces \texttt{order(x)} comienza con \texttt{2}. La siguiente más pequeña es la tercera entrada, por lo que la segunda entrada es \texttt{3} y así sigue.

¿Cómo nos ayuda esto a ordenar los estados por asesinatos? Primero, recuerden que las entradas de vectores a las que acceden con \texttt{\$} siguen el mismo orden que las filas de la tabla. Por ejemplo, estos dos vectores que contienen el nombre de los estados y sus abreviaturas, respectivamente, siguen el mismo orden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "Alabama"    "Alaska"     "Arizona"    "Arkansas"   "California"}
\CommentTok{\#\textgreater{} [6] "Colorado"}
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{abb[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "AL" "AK" "AZ" "AR" "CA" "CO"}
\end{Highlighting}
\end{Shaded}

Esto significa que podemos ordenar los nombres de estado según el total de asesinatos. Primero obtenemos el índice que ordena los vectores por el total de asesinatos y luego ponemos el vector de nombres de estado en un índice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{order}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{total)}
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{abb[ind]}
\CommentTok{\#\textgreater{}  [1] "VT" "ND" "NH" "WY" "HI" "SD" "ME" "ID" "MT" "RI" "AK" "IA" "UT"}
\CommentTok{\#\textgreater{} [14] "WV" "NE" "OR" "DE" "MN" "KS" "CO" "NM" "NV" "AR" "WA" "CT" "WI"}
\CommentTok{\#\textgreater{} [27] "DC" "OK" "KY" "MA" "MS" "AL" "IN" "SC" "TN" "AZ" "NJ" "VA" "NC"}
\CommentTok{\#\textgreater{} [40] "MD" "OH" "MO" "LA" "IL" "GA" "MI" "PA" "NY" "FL" "TX" "CA"}
\end{Highlighting}
\end{Shaded}

De acuerdo con lo anterior, California tuvo la mayor cantidad de asesinatos.

\hypertarget{max-y-which.max}{%
\subsection{\texorpdfstring{\texttt{max} y \texttt{which.max}}{max y which.max}}\label{max-y-which.max}}

Si solo estamos interesados en la entrada con el mayor valor, podemos usar \texttt{max}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{total)}
\CommentTok{\#\textgreater{} [1] 1257}
\end{Highlighting}
\end{Shaded}

y \texttt{which.max} para el índice del valor mayor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_max }\OtherTok{\textless{}{-}} \FunctionTok{which.max}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{total)}
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[i\_max]}
\CommentTok{\#\textgreater{} [1] "California"}
\end{Highlighting}
\end{Shaded}

Para el mínimo, podemos usar \texttt{min} y \texttt{which.min} del mismo modo.

¿Esto significa que California es el estado más peligroso? En una próxima sección, planteamos que deberíamos considerar las tasas en lugar de los totales. Antes de hacer eso, presentamos una última función relacionada con el orden: \texttt{rank}.

\hypertarget{rank}{%
\subsection{\texorpdfstring{\texttt{rank}}{rank}}\label{rank}}

Aunque no se usa con tanta frecuencia como \texttt{order} y \texttt{sort}, la función \texttt{rank} también está relacionada con el orden y puede ser útil.
Para cualquier vector dado, \texttt{rank} devuelve un vector con el rango de la primera entrada, segunda entrada, etc., del vector de entrada. Aquí tenemos un ejemplo sencillo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{31}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{92}\NormalTok{, }\DecValTok{65}\NormalTok{)}
\FunctionTok{rank}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 3 1 2 5 4}
\end{Highlighting}
\end{Shaded}

Para resumir, veamos los resultados de las tres funciones que hemos discutido:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{rrrr}
\toprule
original & sort & order & rank\\
\midrule
31 & 4 & 2 & 3\\
4 & 15 & 3 & 1\\
15 & 31 & 1 & 2\\
92 & 65 & 5 & 5\\
65 & 92 & 4 & 4\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

\hypertarget{cuidado-con-el-reciclaje}{%
\subsection{Cuidado con el reciclaje}\label{cuidado-con-el-reciclaje}}

Otra fuente común de errores inadvertidos en R es el uso de \emph{reciclaje} (\emph{recycling} en inglés). Hemos visto como los vectores se agregan por elementos. Entonces, si los vectores no coinciden en longitud, es natural suponer que vamos a ver un error. Pero ese no es el caso. Vean lo que pasa:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\NormalTok{x}\SpecialCharTok{+}\NormalTok{y}
\CommentTok{\#\textgreater{} Warning in x + y: longitud de objeto mayor no es múltiplo de la}
\CommentTok{\#\textgreater{} longitud de uno menor}
\CommentTok{\#\textgreater{} [1] 11 22 33 41 52 63 71}
\end{Highlighting}
\end{Shaded}

Recibimos una advertencia, pero no hay error. Para el \emph{output}, R ha reciclado los números en \texttt{x}. Observen el último dígito de números en el \emph{output}.

\hypertarget{ejercicios-3}{%
\section{Ejercicios}\label{ejercicios-3}}

Para estos ejercicios usaremos el set de datos de asesinatos de EE. UU. Asegúrense de cargarlo antes de comenzar.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

1. Utilice el operador \texttt{\$} para acceder a los datos del tamaño de la población y almacenarlos como el objeto \texttt{pop}. Luego, use la función \texttt{sort} para redefinir \texttt{pop} para que esté en orden alfabético. Finalmente, use el operador \texttt{{[}} para indicar el tamaño de población más pequeño.

2. Ahora, en lugar del tamaño de población más pequeño, encuentre el índice de la entrada con el tamaño de población más pequeño. Sugerencia: use \texttt{order} en lugar de \texttt{sort}.

3. Podemos realizar la misma operación que en el ejercicio anterior usando la función \texttt{which.min}. Escriba una línea de código que haga esto.

4. Ahora sabemos cuán pequeño es el estado más pequeño y qué fila lo representa. ¿Qué estado es? Defina una variable \texttt{states} para ser los nombres de los estados del \emph{data frame} \texttt{murders}. Indique el nombre del estado con la población más pequeña.

5. Puede crear un \emph{data frame} utilizando la función \texttt{data.frame}. Aquí un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{city }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{,}
          \StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}
\NormalTok{city\_temps }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{name =}\NormalTok{ city, }\AttributeTok{temperature =}\NormalTok{ temp)}
\end{Highlighting}
\end{Shaded}

Utilice la función \texttt{rank} para determinar el rango de población de cada estado desde el menos poblado hasta el más poblado. Guarde estos rangos en un objeto llamado \texttt{ranks}. Luego, cree un \emph{data frame} con el nombre del estado y su rango. Nombre el \emph{data frame} \texttt{my\_df}.

6. Repita el ejercicio anterior, pero esta vez ordene \texttt{my\_df} para que los estados estén en orden de menos poblado a más poblado. Sugerencia: cree un objeto \texttt{ind} que almacene los índices necesarios para poner en orden los valores de la población. Luego, use el operador de corchete \texttt{{[}} para reordenar cada columna en el \emph{data frame}.

7. El vector \texttt{na\_example} representa una serie de conteos. Puede examinar rápidamente el objeto usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"na\_example"}\NormalTok{)}
\FunctionTok{str}\NormalTok{(na\_example)}
\CommentTok{\#\textgreater{}  int [1:1000] 2 1 3 2 1 3 1 4 3 2 ...}
\end{Highlighting}
\end{Shaded}

Sin embargo, cuando calculamos el promedio con la función \texttt{mean}, obtenemos un \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(na\_example)}
\CommentTok{\#\textgreater{} [1] NA}
\end{Highlighting}
\end{Shaded}

La función \texttt{is.na} devuelve un vector lógico que nos dice qué entradas son \texttt{NA}. Asigne este vector lógico a un objeto llamado \texttt{ind} y determine cuántos \texttt{NA}s tiene \texttt{na\_example}.

8. Ahora calcule nuevamente el promedio, pero solo para las entradas que no son \texttt{NA}. Sugerencia: recuerde el operador \texttt{!}.

\hypertarget{aritmuxe9tica-de-vectores}{%
\section{Aritmética de vectores}\label{aritmuxe9tica-de-vectores}}

California tuvo la mayor cantidad de asesinatos, pero ¿esto significa que es el estado más peligroso? ¿Qué pasa si solo tiene muchas más personas que cualquier otro estado? Podemos confirmar rápidamente que California tiene la mayor población:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[}\FunctionTok{which.max}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{population)]}
\CommentTok{\#\textgreater{} [1] "California"}
\end{Highlighting}
\end{Shaded}

con más de 37 millones de habitantes. Por lo tanto, es injusto comparar los totales si estamos interesados en saber cuán seguro es el estado. Lo que realmente deberíamos calcular son los asesinatos per cápita. Los informes que describimos en la sección motivante utilizan asesinatos por cada 100,000 como la unidad. Para calcular esta cantidad, usamos las poderosas capacidades aritméticas de vectores de R.

\hypertarget{rescaling-un-vector}{%
\subsection{\texorpdfstring{\emph{Rescaling} un vector}{Rescaling un vector}}\label{rescaling-un-vector}}

En R, las operaciones aritméticas en vectores ocurren elemento por elemento. Como ejemplo, supongan que tenemos la altura en pulgadas (\emph{inches} en inglés):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{inches }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{69}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{66}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{73}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{73}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y queremos convertirla a centímetros. Observen lo que sucede cuando multiplicamos \texttt{inches} por 2.54:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{inches }\SpecialCharTok{*} \FloatTok{2.54}
\CommentTok{\#\textgreater{}  [1] 175 157 168 178 178 185 170 185 170 178}
\end{Highlighting}
\end{Shaded}

Arriba, multiplicamos cada elemento por 2.54. Del mismo modo, si para cada entrada queremos calcular cuántas pulgadas más alto, o cuántas más corto, que 69 pulgadas (la altura promedio para hombres), podemos restarlo de cada entrada de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{inches }\SpecialCharTok{{-}} \DecValTok{69}
\CommentTok{\#\textgreater{}  [1]  0 {-}7 {-}3  1  1  4 {-}2  4 {-}2  1}
\end{Highlighting}
\end{Shaded}

\hypertarget{dos-vectores}{%
\subsection{Dos vectores}\label{dos-vectores}}

Si tenemos dos vectores de la misma longitud y los sumamos en R, se agregarán entrada por entrada de la siguiente manera:

\[
\begin{pmatrix}
a\\
b\\
c\\
d
\end{pmatrix}
+
\begin{pmatrix}
e\\
f\\
g\\
h
\end{pmatrix}
=
\begin{pmatrix}
a +e\\
b + f\\
c + g\\
d + h
\end{pmatrix}
\]

Lo mismo aplica para otras operaciones matemáticas, como \texttt{-}, \texttt{*} y \texttt{/}.

Esto implica que para calcular las tasas de asesinatos (\emph{murder rates} en inglés) simplemente podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murder\_rate }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}\SpecialCharTok{/}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population }\SpecialCharTok{*} \DecValTok{100000}
\end{Highlighting}
\end{Shaded}

Al hacer esto, notamos que California ya no está cerca de la parte superior de la lista. De hecho, podemos usar lo que hemos aprendido para poner a los estados en orden por tasa de asesinatos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{abb[}\FunctionTok{order}\NormalTok{(murder\_rate)]}
\CommentTok{\#\textgreater{}  [1] "VT" "NH" "HI" "ND" "IA" "ID" "UT" "ME" "WY" "OR" "SD" "MN" "MT"}
\CommentTok{\#\textgreater{} [14] "CO" "WA" "WV" "RI" "WI" "NE" "MA" "IN" "KS" "NY" "KY" "AK" "OH"}
\CommentTok{\#\textgreater{} [27] "CT" "NJ" "AL" "IL" "OK" "NC" "NV" "VA" "AR" "TX" "NM" "CA" "FL"}
\CommentTok{\#\textgreater{} [40] "TN" "PA" "AZ" "GA" "MS" "MI" "DE" "SC" "MD" "MO" "LA" "DC"}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-4}{%
\section{Ejercicios}\label{ejercicios-4}}

1. Anteriormente, creamos este \emph{data frame}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{city }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{,}
          \StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}
\NormalTok{city\_temps }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{name =}\NormalTok{ city, }\AttributeTok{temperature =}\NormalTok{ temp)}
\end{Highlighting}
\end{Shaded}

Vuelva a crear el \emph{data frame} utilizando el código anterior, pero agregue una línea que convierta la temperatura de Fahrenheit a Celsius. La conversión es \(C = \frac{5}{9} \times (F - 32)\).

2. ¿Cuál es la siguiente suma \(1+1/2^2 + 1/3^2 + \dots 1/100^2\)? Sugerencia: gracias a Euler, sabemos que debería estar cerca de \(\pi^2/6\).

3. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en el objeto \texttt{murder\_rate}. Luego, calcule la tasa promedio de asesinatos para EE. UU. con la función \texttt{mean}. ¿Cuál es el promedio?

\hypertarget{indexaciuxf3n}{%
\section{Indexación}\label{indexaciuxf3n}}

R provee una forma poderosa y conveniente de indexar vectores. Podemos, por ejemplo, crear un subconjunto de un vector según las propiedades de otro vector. En esta sección, continuamos trabajando con nuestro ejemplo de asesinatos en EE. UU., que podemos cargar así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-crear-subconjuntos-con-luxf3gicos}{%
\subsection{Cómo crear subconjuntos con lógicos}\label{cuxf3mo-crear-subconjuntos-con-luxf3gicos}}

Ahora hemos calculado la tasa de asesinatos usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murder\_rate }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}\SpecialCharTok{/}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population }\SpecialCharTok{*} \DecValTok{100000}
\end{Highlighting}
\end{Shaded}

Imaginen que se mudan de Italia donde, según un informe de noticias, la tasa de asesinatos es solo 0.71 por 100,000. Preferirían mudarse a un estado con una tasa de asesinatos similar. Otra característica poderosa de R es que podemos usar lógicas para indexar vectores. Si comparamos un vector con un solo número, R realiza la prueba para cada entrada. Aquí tenemos un ejemplo relacionado con la pregunta anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}}\NormalTok{ murder\_rate }\SpecialCharTok{\textless{}} \FloatTok{0.71}
\end{Highlighting}
\end{Shaded}

Si en cambio queremos saber si un valor es menor o igual, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}}\NormalTok{ murder\_rate }\SpecialCharTok{\textless{}=} \FloatTok{0.71}
\end{Highlighting}
\end{Shaded}

Recuerden que devuelve un vector lógico con \texttt{TRUE} para cada entrada menor o igual a 0.71. Para ver qué estados son estos, podemos aprovechar el hecho de que los vectores se pueden indexar con lógicos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[ind]}
\CommentTok{\#\textgreater{} [1] "Hawaii"        "Iowa"          "New Hampshire" "North Dakota" }
\CommentTok{\#\textgreater{} [5] "Vermont"}
\end{Highlighting}
\end{Shaded}

Para contar cuántos son \emph{TRUE}, la función \texttt{sum} devuelve la suma de las entradas de un vector y fuerza una conversión de los vectores lógicos a numéricos con \texttt{TRUE} codificado como 1 y \texttt{FALSE} como 0. Así podemos contar los estados usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(ind)}
\CommentTok{\#\textgreater{} [1] 5}
\end{Highlighting}
\end{Shaded}

\hypertarget{operadores-luxf3gicos}{%
\subsection{Operadores lógicos}\label{operadores-luxf3gicos}}

Supongan que nos gustan las montañas y queremos mudarnos a un estado seguro en la región occidental del país. Queremos que la tasa de asesinatos sea como máximo 1. En este caso, queremos que dos cosas diferentes sean ciertas. Aquí podemos usar el operador lógico \emph{and}, que en R se representa con \texttt{\&}. Esta operación da como resultado \texttt{TRUE} solo cuando ambos lógicos son \texttt{TRUE}, es decir ciertos. Para ver esto, consideren este ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{TRUE} \SpecialCharTok{\&} \ConstantTok{TRUE}
\CommentTok{\#\textgreater{} [1] TRUE}
\ConstantTok{TRUE} \SpecialCharTok{\&} \ConstantTok{FALSE}
\CommentTok{\#\textgreater{} [1] FALSE}
\ConstantTok{FALSE} \SpecialCharTok{\&} \ConstantTok{FALSE}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

Para nuestro ejemplo, podemos formar dos lógicos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{west }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{region }\SpecialCharTok{==} \StringTok{"West"}
\NormalTok{safe }\OtherTok{\textless{}{-}}\NormalTok{ murder\_rate }\SpecialCharTok{\textless{}=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

y podemos usar \texttt{\&} para obtener un vector lógico que nos dice qué estados satisfacen ambas condiciones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}}\NormalTok{ safe }\SpecialCharTok{\&}\NormalTok{ west}
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[ind]}
\CommentTok{\#\textgreater{} [1] "Hawaii"  "Idaho"   "Oregon"  "Utah"    "Wyoming"}
\end{Highlighting}
\end{Shaded}

\hypertarget{which}{%
\subsection{\texorpdfstring{\texttt{which}}{which}}\label{which}}

Supongan que queremos ver la tasa de asesinatos de California. Para este tipo de operación, es conveniente convertir vectores lógicos en índices en lugar de mantener vectores lógicos largos. La función \texttt{which} nos dice qué entradas de un vector lógico son TRUE. Entonces podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{state }\SpecialCharTok{==} \StringTok{"California"}\NormalTok{)}
\NormalTok{murder\_rate[ind]}
\CommentTok{\#\textgreater{} [1] 3.37}
\end{Highlighting}
\end{Shaded}

\hypertarget{match}{%
\subsection{\texorpdfstring{\texttt{match}}{match}}\label{match}}

Si en lugar de un solo estado queremos averiguar las tasas de asesinatos de varios estados, digamos Nueva York, Florida y Texas, podemos usar la función \texttt{match}. Esta función nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{match}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Florida"}\NormalTok{, }\StringTok{"Texas"}\NormalTok{), murders}\SpecialCharTok{$}\NormalTok{state)}
\NormalTok{ind}
\CommentTok{\#\textgreater{} [1] 33 10 44}
\end{Highlighting}
\end{Shaded}

Ahora podemos ver las tasas de asesinatos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murder\_rate[ind]}
\CommentTok{\#\textgreater{} [1] 2.67 3.40 3.20}
\end{Highlighting}
\end{Shaded}

\hypertarget{in}{%
\subsection{\texorpdfstring{\texttt{\%in\%}}{\%in\%}}\label{in}}

Si en lugar de un índice queremos un lógico que nos diga si cada elemento de un primer vector está en un segundo vector, podemos usar la función \texttt{\%in\%}. Imaginen que no están seguros si Boston, Dakota y Washington son estados. Pueden averiguar así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\StringTok{"Boston"}\NormalTok{, }\StringTok{"Dakota"}\NormalTok{, }\StringTok{"Washington"}\NormalTok{) }\SpecialCharTok{\%in\%}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{state}
\CommentTok{\#\textgreater{} [1] FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que estaremos usando \texttt{\%in\%} frecuentemente a lo largo del libro.

\textbf{Avanzado}: Hay una conexión entre \texttt{match} y \texttt{\%in\%} mediante \texttt{which}. Para ver esto, observen que las siguientes dos líneas producen el mismo índice (aunque en orden diferente):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{match}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Florida"}\NormalTok{, }\StringTok{"Texas"}\NormalTok{), murders}\SpecialCharTok{$}\NormalTok{state)}
\CommentTok{\#\textgreater{} [1] 33 10 44}
\FunctionTok{which}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{state}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Florida"}\NormalTok{, }\StringTok{"Texas"}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 10 33 44}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-5}{%
\section{Ejercicios}\label{ejercicios-5}}

Empiece cargando el paquete y los datos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

1. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en un objeto llamado \texttt{murder\_rate}. Luego, use operadores lógicos para crear un vector lógico llamado \texttt{low} que nos dice qué entradas de \texttt{murder\_rate} son inferiores a 1.

2. Ahora use los resultados del ejercicio anterior y la función \texttt{which} para determinar los índices de \texttt{murder\_rate} asociados con valores inferiores a 1.

3. Use los resultados del ejercicio anterior para indicar los nombres de los estados con tasas de asesinatos inferiores a 1.

4. Ahora extienda el código de los ejercicios 2 y 3 para indicar los estados del noreste con tasas de asesinatos inferiores a 1. Sugerencia: use el vector lógico predefinido \texttt{low} y el operador lógico \texttt{\&}.

5. En un ejercicio anterior, calculamos la tasa de asesinatos para cada estado y el promedio de estos números. ¿Cuántos estados están por debajo del promedio?

6. Use la función \emph{match} para identificar los estados con abreviaturas AK, MI e IA. Sugerencia: comience definiendo un índice de las entradas de \texttt{murders\$abb} que coinciden con las tres abreviaturas. Entonces use el operador \texttt{{[}} para extraer los estados.

7. Utilice el operador \texttt{\%in\%} para crear un vector lógico que responda a la pregunta: ¿cuáles de las siguientes son abreviaturas reales: MA, ME, MI, MO, MU?

8. Extienda el código que usó en el ejercicio 7 para averiguar la única entrada que \textbf{no} es una abreviatura real. Sugerencia: use el operador \texttt{!}, que convierte \texttt{FALSE} a \texttt{TRUE} y viceversa, y entonces \texttt{which} para obtener un índice.

\hypertarget{gruxe1ficos-buxe1sicos}{%
\section{Gráficos básicos}\label{gruxe1ficos-buxe1sicos}}

En el capitulo \ref{ggplot2}, describimos un paquete complementario que ofrece un enfoque muy útil para producir gráficos (\emph{plots} en inglés) en R. Luego tenemos una parte entera, ``Visualización de datos'', en la que ofrecemos muchos ejemplos. Aquí describimos brevemente algunas de las funciones disponibles en una instalación básica de R.

\hypertarget{plot}{%
\subsection{\texorpdfstring{\texttt{plot}}{plot}}\label{plot}}

La función \texttt{plot} se puede utilizar para hacer diagramas de dispersión (\emph{scatterplots} en inglés). Abajo tenemos un gráfico de total de asesinatos versus población.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population}\SpecialCharTok{/} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}
\FunctionTok{plot}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.6\linewidth]{libro_files/figure-latex/first-plot-1} \end{center}

Para crear un gráfico rápido que no accede a las variables dos veces, podemos usar la función \texttt{with}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{with}\NormalTok{(murders, }\FunctionTok{plot}\NormalTok{(population, total))}
\end{Highlighting}
\end{Shaded}

La función \texttt{with} nos permite usar los nombres de la columna \texttt{murders} en la función \texttt{plot}. También funciona con cualquier \emph{data frame} y cualquier función.

\hypertarget{hist}{%
\subsection{\texorpdfstring{\texttt{hist}}{hist}}\label{hist}}

Describiremos los histogramas en relación con las distribuciones en la parte del libro ``Visualización de datos''. Aquí simplemente notaremos que los histogramas son un resumen gráfico eficaz de una lista de números que nos ofrece una descripción general de los tipos de valores que tenemos. Podemos hacer un histograma de nuestras tasas de asesinatos al simplemente escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(murders, total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{)}
\FunctionTok{hist}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.6\linewidth]{libro_files/figure-latex/r-base-hist-1} \end{center}

Podemos ver que hay una amplia gama de valores con la mayoría de ellos entre 2 y 3 y un caso muy extremo con una tasa de asesinatos de más de 15:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{state[}\FunctionTok{which.max}\NormalTok{(x)]}
\CommentTok{\#\textgreater{} [1] "District of Columbia"}
\end{Highlighting}
\end{Shaded}

\hypertarget{boxplot}{%
\subsection{\texorpdfstring{\texttt{boxplot}}{boxplot}}\label{boxplot}}

Los diagramas de caja (\emph{boxplots} en inglés) también se describirán en la parte del libro ``Visualización de datos''. Estos proveen un resumen más conciso que los histogramas, pero son más fáciles de apilar con otros diagramas de caja. Por ejemplo, aquí podemos usarlos para comparar las diferentes regiones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{rate }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(murders, total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{)}
\FunctionTok{boxplot}\NormalTok{(rate}\SpecialCharTok{\textasciitilde{}}\NormalTok{region, }\AttributeTok{data =}\NormalTok{ murders)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.6\linewidth]{libro_files/figure-latex/r-base-boxplot-1} \end{center}

Podemos ver que el Sur (\emph{South} en inglés) tiene tasas de asesinatos más altas que las otras tres regiones.

\hypertarget{image}{%
\subsection{\texorpdfstring{\texttt{image}}{image}}\label{image}}

La función \emph{image} muestra los valores en una matriz usando color. Aquí mostramos un ejemplo rápido:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{120}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\FunctionTok{image}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/image-first-example-1} \end{center}

\hypertarget{ejercicios-6}{%
\section{Ejercicios}\label{ejercicios-6}}

1. Hicimos un gráfico de asesinatos totales versus población y notamos una fuerte relación. No es sorprendente que los estados con poblaciones más grandes hayan tenido más asesinatos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\NormalTok{population\_in\_millions }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}
\NormalTok{total\_gun\_murders }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}
\FunctionTok{plot}\NormalTok{(population\_in\_millions, total\_gun\_murders)}
\end{Highlighting}
\end{Shaded}

Recuerden que muchos estados tienen poblaciones inferiores a 5 millones y están agrupados. Podemos obtener más información al hacer este gráfico en la escala logarítmica. Transforme las variables usando la transformación \texttt{log10} y luego cree un gráfico de los resultados.

2. Cree un histograma de las poblaciones estatales.

3. Genere diagramas de caja de las poblaciones estatales por región.

\hypertarget{conceptos-buxe1sicos-de-programaciuxf3n}{%
\chapter{Conceptos básicos de programación}\label{conceptos-buxe1sicos-de-programaciuxf3n}}

\hypertarget{conditionals}{%
\section{Expresiones condicionales}\label{conditionals}}

Las expresiones condicionales son una de las características básicas de la programación. Se utilizan para lo que se denomina \emph{flow control}. La expresión condicional más común es la declaración \emph{if-else}. En R, podemos realizar mucho análisis de datos sin condicionales. Sin embargo, aparecen ocasionalmente y los necesitarán una vez comiencen a escribir sus propias funciones y paquetes.

Aquí presentamos un ejemplo muy sencillo que muestra la estructura general de una instrucción \emph{if-else}. La idea básica es imprimir el recíproco de \texttt{a} a menos que \texttt{a} sea 0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{0}

\ControlFlowTok{if}\NormalTok{(a}\SpecialCharTok{!=}\DecValTok{0}\NormalTok{)\{}
  \FunctionTok{print}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{a)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{\{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"No reciprocal for 0."}\NormalTok{)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] "No reciprocal for 0."}
\end{Highlighting}
\end{Shaded}

Veamos otro ejemplo usando el set de datos de asesinatos de EE. UU.:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\NormalTok{murder\_rate }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}\SpecialCharTok{/}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{population}\SpecialCharTok{*}\DecValTok{100000}
\end{Highlighting}
\end{Shaded}

Aquí ofrecemos un ejemplo muy sencillo que nos dice qué estados, si los hay, tienen una tasa de homicidios inferior a 0.5 por 100,000. Las declaraciones \texttt{if} nos protegen del caso en el que ningún estado satisface la condición.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(murder\_rate)}

\ControlFlowTok{if}\NormalTok{(murder\_rate[ind] }\SpecialCharTok{\textless{}} \FloatTok{0.5}\NormalTok{)\{}
  \FunctionTok{print}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{state[ind])}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{\{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"No state has murder rate that low"}\NormalTok{)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] "Vermont"}
\end{Highlighting}
\end{Shaded}

Si lo intentamos nuevamente con una tasa de 0.25, obtenemos una respuesta diferente:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(murder\_rate[ind] }\SpecialCharTok{\textless{}} \FloatTok{0.25}\NormalTok{)\{}
  \FunctionTok{print}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{state[ind])}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{\{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"No state has a murder rate that low."}\NormalTok{)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] "No state has a murder rate that low."}
\end{Highlighting}
\end{Shaded}

Una función relacionada que es muy útil es \texttt{ifelse}. Esta función toma tres argumentos: un lógico y dos posibles respuestas. Si el lógico es \texttt{TRUE}, devuelve el valor en el segundo argumento y, si es \texttt{FALSE}, devuelve el valor en el tercer argumento. Aquí tenemos un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{0}
\FunctionTok{ifelse}\NormalTok{(a }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\NormalTok{a, }\ConstantTok{NA}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] NA}
\end{Highlighting}
\end{Shaded}

Esta función es particularmente útil porque sirve para vectores. Examina cada entrada del vector lógico y devuelve elementos del vector proporcionado en el segundo argumento, si la entrada es \texttt{TRUE}, o elementos del vector proporcionado en el tercer argumento, si la entrada es \texttt{FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{result }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(a }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\NormalTok{a, }\ConstantTok{NA}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Esta tabla nos ayuda a ver qué sucedió:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{rlrlr}
\toprule
a & is\_a\_positive & answer1 & answer2 & result\\
\midrule
0 & FALSE & Inf & NA & NA\\
1 & TRUE & 1.00 & NA & 1.0\\
2 & TRUE & 0.50 & NA & 0.5\\
-4 & FALSE & -0.25 & NA & NA\\
5 & TRUE & 0.20 & NA & 0.2\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Aquí hay un ejemplo de cómo esta función se puede usar fácilmente para reemplazar todos los valores faltantes en un vector con ceros:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(na\_example)}
\NormalTok{no\_nas }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(na\_example), }\DecValTok{0}\NormalTok{, na\_example)}
\FunctionTok{sum}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(no\_nas))}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

Otras dos funciones útiles son \texttt{any} y \texttt{all}. La función \texttt{any} toma un vector de lógicos y devuelve \texttt{TRUE} si alguna de las entradas es \texttt{TRUE}. La función \texttt{all} toma un vector de lógicos y devuelve \texttt{TRUE} si todas las entradas son \texttt{TRUE}. Aquí ofrecemos un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{any}\NormalTok{(z)}
\CommentTok{\#\textgreater{} [1] TRUE}
\FunctionTok{all}\NormalTok{(z)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-definir-funciones}{%
\section{Cómo definir funciones}\label{cuxf3mo-definir-funciones}}

A medida que adquieran más experiencia, necesitarán realizar las mismas operaciones una y otra vez. Un ejemplo sencillo es el cálculo de promedios. Podemos calcular el promedio de un vector \texttt{x} utilizando las funciones \texttt{sum} y \texttt{length}: \texttt{sum(x)/length(x)}. Debido a que hacemos esto repetidas veces, es mucho más eficiente escribir una función que realice esta operación. Esta operación particular es tan común que alguien ya escribió la función \texttt{mean} y se incluye en la base R. Sin embargo, se encontrarán con situaciones en las que la función aún no existe, por lo que R les permite escribir una. Se puede definir una versión sencilla de una función que calcula el promedio así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  s}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ahora \texttt{avg} es una función que calcula el promedio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}
\FunctionTok{identical}\NormalTok{(}\FunctionTok{mean}\NormalTok{(x), }\FunctionTok{avg}\NormalTok{(x))}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

Observen que las variables definidas dentro de una función no se guardan en el espacio de trabajo. Por lo tanto, mientras usamos \texttt{s} y \texttt{n} cuando llamamos (\emph{call} en inglés) \texttt{avg}, los valores se crean y cambian solo durante la llamada. Aquí podemos ver un ejemplo ilustrativo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \DecValTok{3}
\FunctionTok{avg}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 5.5}
\NormalTok{s}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Noten como \texttt{s} todavía es 3 después de que llamamos \texttt{avg}.

En general, las funciones son objetos, por lo que les asignamos nombres de variables con \texttt{\textless{}-}. La función \texttt{function} le dice a R que están a punto de definir una función. La forma general de la definición de una función es así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_function }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(VARIABLE\_NAME)\{}
\NormalTok{  perform operations on VARIABLE\_NAME and calculate VALUE}
\NormalTok{  VALUE}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Las funciones que definen pueden tener múltiples argumentos, así como valores predeterminados. Por ejemplo, podemos definir una función que calcule el promedio aritmético o geométrico dependiendo de una variable definida por usuarios como esta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{arithmetic =} \ConstantTok{TRUE}\NormalTok{)\{}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
  \FunctionTok{ifelse}\NormalTok{(arithmetic, }\FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/}\NormalTok{n, }\FunctionTok{prod}\NormalTok{(x)}\SpecialCharTok{\^{}}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{n))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aprenderemos más sobre cómo crear funciones a través de la experiencia a medida que nos enfrentemos a tareas más complejas.

\hypertarget{namespaces}{%
\section{\texorpdfstring{\emph{Namespaces}}{Namespaces}}\label{namespaces}}

Una vez que comiencen a convertirse en usuarios expertos de R, es probable que necesiten cargar varios complementos de paquetes (\emph{add-ons} en inglés) para algunos de sus análisis. Tan pronto hagan eso, es probable que descubran que dos paquetes a veces usan el mismo nombre para dos funciones diferentes. Y a menudo estas funciones hacen cosas completamente diferentes. De hecho, ya hemos visto esto porque ambos paquetes de base R \textbf{dplyr} y \textbf{stats} definen una función \texttt{filter}. Hay otros cinco ejemplos en \textbf{dplyr}. Sabemos esto porque cuando cargamos \textbf{dplyr} por primera vez, vemos el siguiente mensaje:

\begin{verbatim}
The following objects are masked from ‘package:stats’:

filter, lag

The following objects are masked from ‘package:base’:

intersect, setdiff, setequal, union
\end{verbatim}

Entonces, ¿qué hace R cuando escribimos \texttt{filter}? ¿Utiliza la función \textbf{dplyr} o la función \textbf{stats}? De nuestro trabajo anterior sabemos que usa \textbf{dplyr}. Pero, ¿qué pasa si queremos usar \textbf{stats}?

Estas funciones viven en diferentes \emph{namespaces}. R seguirá un cierto orden cuando busque una función en estos \emph{namespaces}. Pueden ver el orden escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{search}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

La primera entrada en esta lista es el ambiente global que incluye todos los objetos que definen.

Entonces, ¿qué pasa si queremos usar el \texttt{filter} \textbf{stats} en lugar del \texttt{filter} \textbf{dplyr} pero \textbf{dplyr} aparece primero en la lista de búsqueda? Pueden forzar el uso de un \emph{namespace} específico utilizando dos puntos dobles ( \texttt{::}) así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stats}\SpecialCharTok{::}\NormalTok{filter}
\end{Highlighting}
\end{Shaded}

Si queremos estar absolutamente seguros de que usamos el \texttt{filter} de \textbf{dplyr}, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\SpecialCharTok{::}\NormalTok{filter}
\end{Highlighting}
\end{Shaded}

Recuerden que si queremos usar una función en un paquete sin cargar el paquete completo, también podemos usar los dos puntos dobles.

Para más información sobre este tema más avanzado, recomendamos el libro de paquetes R\footnote{\url{http://r-pkgs.had.co.nz/namespace.html}}.

\hypertarget{bucles-for}{%
\section{Bucles-for}\label{bucles-for}}

La fórmula para la suma de la serie \(1+2+\dots+n\) es \(n(n+1)/2\). ¿Qué pasaría si no estuviéramos seguros de que esa era la función correcta? ¿Cómo podríamos verificar? Usando lo que aprendimos sobre las funciones, podemos crear una que calcule \(S_n\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compute\_s\_n }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n}
  \FunctionTok{sum}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

¿Cómo podemos calcular \(S_n\) para varios valores de \(n\), digamos \(n=1,\dots,25\)? ¿Escribimos 25 líneas de código llamando \texttt{compute\_s\_n}? No.~Para eso están los bucles-for (\emph{for-loops} en inglés) en la programación. En este caso, estamos realizando exactamente la misma tarea una y otra vez, y lo único que está cambiando es el valor de \(n\). Los bucles-for nos permiten definir el rango que toma nuestra variable (en nuestro ejemplo \(n=1,\dots,10\)), luego cambiar el valor y evaluar la expresión a medida que realice un \emph{bucle}.

Quizás el ejemplo más sencillo de un bucle-for es este código inútil:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)\{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] 1}
\CommentTok{\#\textgreater{} [1] 2}
\CommentTok{\#\textgreater{} [1] 3}
\CommentTok{\#\textgreater{} [1] 4}
\CommentTok{\#\textgreater{} [1] 5}
\end{Highlighting}
\end{Shaded}

Aquí está el bucle-for que escribiríamos para nuestro ejemplo \(S_n\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \DecValTok{25}
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\AttributeTok{length =}\NormalTok{ m) }\CommentTok{\# create an empty vector}
\ControlFlowTok{for}\NormalTok{(n }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{m)\{}
\NormalTok{  s\_n[n] }\OtherTok{\textless{}{-}} \FunctionTok{compute\_s\_n}\NormalTok{(n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En cada iteración \(n=1\), \(n=2\), etc \ldots, calculamos \(S_n\) y lo guardamos en la entrada \(n\) de \texttt{s\_n}.

Ahora podemos crear un gráfico para buscar un patrón:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{m}
\FunctionTok{plot}\NormalTok{(n, s\_n)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/sum-of-consecutive-squares-1} \end{center}

Si notaron que parece ser cuadrático, van por buen camino porque la fórmula es \(n(n+1)/2\).

\hypertarget{vectorization}{%
\section{Vectorización y funcionales}\label{vectorization}}

Aunque los bucles-for son un concepto importante para entender, no se usan mucho en R. A medida que aprendan más R, se darán cuenta de que la \emph{vectorización} es preferible a los bucles-for puesto que resulta en un código más corto y claro. Ya vimos ejemplos en la sección de aritmética de vectores. Una función \emph{vectorizada} es una función que aplicará la misma operación en cada uno de los vectores.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\FunctionTok{sqrt}\NormalTok{(x)}
\CommentTok{\#\textgreater{}  [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\NormalTok{x}\SpecialCharTok{*}\NormalTok{y}
\CommentTok{\#\textgreater{}  [1]   1   4   9  16  25  36  49  64  81 100}
\end{Highlighting}
\end{Shaded}

Para hacer este cálculo, no necesitamos los bucles-for. Sin embargo, no todas las funciones funcionan de esta manera. Por ejemplo, la función que acabamos de escribir, \texttt{compute\_s\_n}, no funciona elemento por elemento ya que espera un escalar. Este fragmento de código no ejecuta la función en cada entrada de \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{25}
\FunctionTok{compute\_s\_n}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

Los \emph{funcionales} son funciones que nos ayudan a aplicar la misma función a cada entrada en un vector, matriz, \emph{data frame} o lista. Aquí cubrimos el funcional que opera en vectores numéricos, lógicos y de caracteres: \texttt{sapply}.

La función \texttt{sapply} nos permite realizar operaciones basadas en elementos (\emph{element-wise} en inglés) en cualquier función. Aquí podemos ver como funciona:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\FunctionTok{sapply}\NormalTok{(x, sqrt)}
\CommentTok{\#\textgreater{}  [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16}
\end{Highlighting}
\end{Shaded}

Cada elemento de \texttt{x} se pasa a la función \texttt{sqrt} y devuelve el resultado. Estos resultados se concatenan. En este caso, el resultado es un vector de la misma longitud que el original, \texttt{x}. Esto implica que el bucle-for anterior puede escribirse de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{25}
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(n, compute\_s\_n)}
\end{Highlighting}
\end{Shaded}

Otros funcionales son \texttt{apply}, \texttt{lapply}, \texttt{tapply}, \texttt{mapply}, \texttt{vapply} y \texttt{replicate}. Usamos principalmente \texttt{sapply}, \texttt{apply} y \texttt{replicate} en este libro, pero recomendamos familiarizarse con los demás ya que pueden ser muy útiles.

\hypertarget{ejercicios-7}{%
\section{Ejercicios}\label{ejercicios-7}}

1. ¿Qué devolverá esta expresión condicional?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{(}\FunctionTok{all}\NormalTok{(x}\SpecialCharTok{\textgreater{}}\DecValTok{0}\NormalTok{))\{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"All Postives"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{\{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"Not all positives"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

2. ¿Cuál de las siguientes expresiones es siempre \texttt{FALSE} cuando al menos una entrada de un vector lógico \texttt{x} es TRUE?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{all(x)}
\item
  \texttt{any(x)}
\item
  \texttt{any(!x)}
\item
  \texttt{all(!x)}
\end{enumerate}

3. La función \texttt{nchar} le dice cuántos caracteres tiene un vector de caracteres. Escriba una línea de código que le asigne al objeto \texttt{new\_names} la abreviatura del estado cuando el nombre del estado tiene más de 8 caracteres.

4. Cree una función \texttt{sum\_n} que para cualquier valor dado, digamos \(n\), calcula la suma de los enteros de 1 a n (inclusivo). Use la función para determinar la suma de los enteros de 1 a 5,000.

5. Cree una función \texttt{altman\_plot} que toma dos argumentos, \texttt{x} y \texttt{y}, y grafica la diferencia contra la suma.

6. Después de ejecutar el siguiente código, ¿cuál es el valor de \texttt{x}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{my\_func }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(y)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{  y}\SpecialCharTok{+}\DecValTok{5}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

7. Escriba una función \texttt{compute\_s\_n} que para cualquier \(n\) calcula la suma \(S_n = 1^2 + 2^2 + 3^2 + \dots n^2\). Indique el valor de la suma cuando \(n=10\).

8. Defina un vector numérico vacío \texttt{s\_n} de tamaño 25 usando \texttt{s\_n\ \textless{}-\ vector("numeric",\ 25)} y almacene los resultados de \(S_1, S_2, \dots S_{25}\) usando un bucle-for.

9. Repita el ejercicio 8, pero esta vez use \texttt{sapply}.

10. Repita el ejercicio 8, pero esta vez use \texttt{map\_dbl}.

11. Grafique \(S_n\) versus \(n\). Use puntos definidos por \(n=1,\dots,25\).

12. Confirme que la fórmula para esta suma es \(S_n= n(n+1)(2n+1)/6\).

\hypertarget{tidyverse}{%
\chapter{\texorpdfstring{\emph{tidyverse}}{tidyverse}}\label{tidyverse}}

Hasta ahora hemos estado manipulando vectores reordenándolos y creando subconjuntos mediante la indexación. Sin embargo, una vez comencemos los análisis más avanzados, la unidad preferida para el almacenamiento de datos no es el vector sino el \emph{data frame}. En este capítulo aprenderemos a trabajar directamente con \emph{data frames}, que facilitan enormemente la organización de información. Utilizaremos \emph{data frames} para la mayoría de este libro. Nos enfocaremos en un formato de datos específico denominado \emph{tidy} y en una colección específica de paquetes que son particularmente útiles para trabajar con data \emph{tidy} y que se denomina el \emph{tidyverse}.

Podemos cargar todos los paquetes del \emph{tidyverse} a la vez al instalar y cargar el paquete \textbf{tidyverse}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

Aprenderemos cómo implementar el enfoque \emph{tidyverse} a lo largo del libro, pero antes de profundizar en los detalles, en este capítulo presentamos algunos de los aspectos más utilizadas del \emph{tidyverse}, comenzando con el paquete \textbf{dplyr} para manipular los \emph{data frames} y el paquete \textbf{purrr} para trabajar con las funciones. Tengan en cuenta que el \emph{tidyverse} también incluye un paquete para graficar, \textbf{ggplot2}, que presentaremos más adelante en el Capítulo \ref{ggplot2} en la parte de visualización de datos del libro, el paquete \textbf{readr} discutido en el Capítulo \ref{importing-data} y muchos otros. En este capítulo, primero presentamos el concepto de datos \emph{tidy} y luego demostramos cómo usamos el \emph{tidyverse} para trabajar con \emph{data frames} en este formato.

\hypertarget{tidy-data}{%
\section{\texorpdfstring{Datos \emph{tidy}}{Datos tidy}}\label{tidy-data}}

Decimos que una tabla de datos está en formato \emph{tidy} si cada fila representa una observación y las columnas representan las diferentes variables disponibles para cada una de estas observaciones. El set de datos \texttt{murders} es un ejemplo de un \emph{data frame tidy}.

\begin{verbatim}
#>        state abb region population total
#> 1    Alabama  AL  South    4779736   135
#> 2     Alaska  AK   West     710231    19
#> 3    Arizona  AZ   West    6392017   232
#> 4   Arkansas  AR  South    2915918    93
#> 5 California  CA   West   37253956  1257
#> 6   Colorado  CO   West    5029196    65
\end{verbatim}

Cada fila representa un estado con cada una de las cinco columnas proveyendo una variable diferente relacionada con estos estados: nombre, abreviatura, región, población y total de asesinatos.

Para ver cómo se puede proveer la misma información en diferentes formatos, consideren el siguiente ejemplo:

\begin{verbatim}
#>       country year fertility
#> 1     Germany 1960      2.41
#> 2 South Korea 1960      6.16
#> 3     Germany 1961      2.44
#> 4 South Korea 1961      5.99
#> 5     Germany 1962      2.47
#> 6 South Korea 1962      5.79
\end{verbatim}

Este set de datos \emph{tidy} ofrece tasas de fertilidad para dos países a lo largo de los años. Se considera un set de datos \emph{tidy} porque cada fila presenta una observación con las tres variables: país, año y tasa de fecundidad. Sin embargo, este set de datos originalmente vino en otro formato y le cambiamos la forma para distribuir a través del paquete \textbf{dslabs}. Originalmente, los datos estaban en el siguiente formato:

\begin{verbatim}
#>       country 1960 1961 1962
#> 1     Germany 2.41 2.44 2.47
#> 2 South Korea 6.16 5.99 5.79
\end{verbatim}

Se provee la misma información, pero hay dos diferencias importantes en el formato: 1) cada fila incluye varias observaciones y 2) una de las variables, año, se almacena en el encabezado. Para que los paquetes del \emph{tidyverse} se utilicen de manera óptima, le tenemos que cambiar la forma a los datos para que estén en formato \emph{tidy}, que aprenderán a hacer en la sección ``\emph{Wrangling} de datos'' del libro. Hasta entonces, utilizaremos ejemplos de sets de datos que ya están en formato \emph{tidy}.

Aunque no es inmediatamente obvio, a medida que avancen en el libro comenzarán a apreciar las ventajas de trabajar usando un acercamiento en el que las funciones usan formatos \emph{tidy} tanto para \emph{inputs} como para \emph{outputs}. Verán cómo esto permite que los analistas de datos se enfoquen en los aspectos más importantes del análisis en lugar del formato de los datos.

\hypertarget{ejercicios-8}{%
\section{Ejercicios}\label{ejercicios-8}}

1. Examine el set de datos \texttt{co2} incluidos en base R. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{co2} son datos \emph{tidy}: tiene un año para cada fila.
\item
  \texttt{co2} no es \emph{tidy}: necesitamos al menos una columna con un vector de caracteres.
\item
  \texttt{co2} no es \emph{tidy}: es una matriz en lugar de un \emph{data frame}.
\item
  \texttt{co2} no es \emph{tidy}: para ser \emph{tidy} tendríamos que cambiarle la forma (\emph{wrangle it} en inglés) para tener tres columnas (año, mes y valor), y entonces cada observación de CO2 tendría una fila.
\end{enumerate}

2. Examine el set de datos \texttt{ChickWeight} incluidos en base R. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{ChickWeight} no es \emph{tidy}: cada pollito tiene más de una fila.
\item
  \texttt{ChickWeight} es \emph{tidy}: cada observación (un peso) está representada por una fila. El pollito de donde provino esta medida es una de las variables.
\item
  \texttt{ChickWeight} no es \emph{tidy}: nos falta la columna del año.
\item
  \texttt{ChickWeight} es \emph{tidy}: se almacena en un \emph{data frame}.
\end{enumerate}

3. Examine el set de datos predefinido \texttt{BOD}. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{BOD} no es \emph{tidy}: solo tiene seis filas.
\item
  \texttt{BOD} no es \emph{tidy}: la primera columna es solo un índice.
\item
  \texttt{BOD} es \emph{tidy}: cada fila es una observación con dos valores (tiempo y demanda)
\item
  \texttt{BOD} es \emph{tidy}: todos los sets de datos pequeños son \emph{tidy} por definición.
\end{enumerate}

4. ¿Cuál de los siguientes sets de datos integrados es \emph{tidy}? Puede elegir más de uno.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{BJsales}
\item
  \texttt{EuStockMarkets}
\item
  \texttt{DNase}
\item
  \texttt{Formaldehyde}
\item
  \texttt{Orange}
\item
  \texttt{UCBAdmissions}
\end{enumerate}

\hypertarget{cuxf3mo-manipular-los-data-frames}{%
\section{\texorpdfstring{Cómo manipular los \emph{data frames}}{Cómo manipular los data frames}}\label{cuxf3mo-manipular-los-data-frames}}

El paquete \textbf{dplyr} del \emph{tidyverse} ofrece funciones que realizan algunas de las operaciones más comunes cuando se trabaja con \emph{data frames} y usa nombres para estas funciones que son relativamente fáciles de recordar. Por ejemplo, para cambiar la tabla de datos agregando una nueva columna, utilizamos \texttt{mutate}. Para filtrar la tabla de datos a un subconjunto de filas, utilizamos \texttt{filter}. Finalmente, para subdividir los datos seleccionando columnas específicas, usamos \texttt{select}.

\hypertarget{cuxf3mo-auxf1adir-una-columna-con-mutate}{%
\subsection{\texorpdfstring{Cómo añadir una columna con \texttt{mutate}}{Cómo añadir una columna con mutate}}\label{cuxf3mo-auxf1adir-una-columna-con-mutate}}

Queremos que toda la información necesaria para nuestro análisis se incluya en la tabla de datos. Entonces, la primera tarea es añadir las tasas de asesinatos a nuestro \emph{data frame} de asesinatos. La función \texttt{mutate} toma el \emph{data frame} como primer argumento y el nombre y los valores de la variable como segundo argumento usando la convención \texttt{name\ =\ values}. Entonces, para añadir tasas de asesinatos, usamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(murders, }\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Recuerden que aquí usamos \texttt{total} y \texttt{population} dentro de la función, que son objetos \textbf{no} definidos en nuestro espacio de trabajo. Pero, ¿por qué no recibimos un error?

Esta es una de las principales características de \textbf{dplyr}. Las funciones en este paquete, como \texttt{mutate}, saben buscar variables en el \emph{data frame} que el primer argumento les provee. En la llamada a \texttt{mutate} que vemos arriba, \texttt{total} tendrá los valores de \texttt{murders\$total}. Este enfoque hace que el código sea mucho más legible.

Podemos ver que se agrega la nueva columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(murders)}
\CommentTok{\#\textgreater{}        state abb region population total rate}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135 2.82}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19 2.68}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232 3.63}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93 3.19}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257 3.37}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65 1.29}
\end{Highlighting}
\end{Shaded}

Aunque hemos sobrescrito el objeto original \texttt{murders}, esto no cambia el objeto que se cargó con \texttt{data(murders)}. Si cargamos los datos \texttt{murders} nuevamente, el original sobrescribirá nuestra versión mutada.

\hypertarget{cuxf3mo-crear-subconjuntos-con-filter}{%
\subsection{\texorpdfstring{Cómo crear subconjuntos con \texttt{filter}}{Cómo crear subconjuntos con filter}}\label{cuxf3mo-crear-subconjuntos-con-filter}}

Ahora supongan que queremos filtrar la tabla de datos para mostrar solo las entradas para las cuales la tasa de asesinatos es inferior a 0.71. Para hacer esto, usamos la función \texttt{filter}, que toma la tabla de datos como primer argumento y luego la declaración condicional como el segundo. Igual que con \texttt{mutate}, podemos usar los nombres de variables sin comillas de \texttt{murders} dentro de la función y esta sabrá que nos referimos a las columnas y no a los objetos en el espacio de trabajo.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(murders, rate }\SpecialCharTok{\textless{}=} \FloatTok{0.71}\NormalTok{)}
\CommentTok{\#\textgreater{}           state abb        region population total  rate}
\CommentTok{\#\textgreater{} 1        Hawaii  HI          West    1360301     7 0.515}
\CommentTok{\#\textgreater{} 2          Iowa  IA North Central    3046355    21 0.689}
\CommentTok{\#\textgreater{} 3 New Hampshire  NH     Northeast    1316470     5 0.380}
\CommentTok{\#\textgreater{} 4  North Dakota  ND North Central     672591     4 0.595}
\CommentTok{\#\textgreater{} 5       Vermont  VT     Northeast     625741     2 0.320}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-seleccionar-columnas-con-select}{%
\subsection{\texorpdfstring{Cómo seleccionar columnas con \texttt{select}}{Cómo seleccionar columnas con select}}\label{cuxf3mo-seleccionar-columnas-con-select}}

Aunque nuestra tabla de datos solo tiene seis columnas, algunas tablas de datos incluyen cientos. Si queremos ver solo algunas columnas, podemos usar la función \texttt{select} de \textbf{dplyr}. En el siguiente código, seleccionamos tres columnas, asignamos el resultado a un nuevo objeto y luego filtramos este nuevo objeto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_table }\OtherTok{\textless{}{-}} \FunctionTok{select}\NormalTok{(murders, state, region, rate)}
\FunctionTok{filter}\NormalTok{(new\_table, rate }\SpecialCharTok{\textless{}=} \FloatTok{0.71}\NormalTok{)}
\CommentTok{\#\textgreater{}           state        region  rate}
\CommentTok{\#\textgreater{} 1        Hawaii          West 0.515}
\CommentTok{\#\textgreater{} 2          Iowa North Central 0.689}
\CommentTok{\#\textgreater{} 3 New Hampshire     Northeast 0.380}
\CommentTok{\#\textgreater{} 4  North Dakota North Central 0.595}
\CommentTok{\#\textgreater{} 5       Vermont     Northeast 0.320}
\end{Highlighting}
\end{Shaded}

En la llamada a \texttt{select}, el primer argumento \texttt{murders} es un objeto, pero \texttt{state}, \texttt{region} y \texttt{rate} son nombres de variables.

\hypertarget{ejercicios-9}{%
\section{Ejercicios}\label{ejercicios-9}}

1. Cargue el paquete \textbf{dplyr} y el set de datos de asesinatos de EE.UU.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

Puede añadir columnas usando la función \texttt{mutate} de \textbf{dplyr}. Esta función reconoce los nombres de la columnas y dentro de la función puede llamarlos sin comillas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(murders, }\AttributeTok{population\_in\_millions =}\NormalTok{ population}\SpecialCharTok{/} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos escribir \texttt{population} en vez de \texttt{murders\$population}. La función \texttt{mutate} sabe que estamos agarrando columnas de \texttt{murders}.

Use la función \texttt{mutate} para añadir una columna de asesinatos llamada \texttt{rate} con la tasa de asesinatos por 100,000 como en el código del ejemplo anterior. Asegúrese de redefinir \texttt{murders} como se hizo en el código del ejemplo anterior (murders \textless- {[}su código{]}) para que podamos seguir usando esta variable.

2. Si \texttt{rank(x)} le da el rango de las entradas de \texttt{x} de menor a mayor, \texttt{rank(-x)} le da los rangos de mayor a menor. Use la función \texttt{mutate} para añadir una columna \texttt{rank} que contiene el rango de la tasa de asesinatos de mayor a menor. Asegúrese de redefinir \texttt{murders} para poder seguir usando esta variable.

3. Con \textbf{dplyr}, podemos usar \texttt{select} para mostrar solo ciertas columnas. Por ejemplo, con este código solo mostraríamos los estados y los tamaños de población:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{select}\NormalTok{(murders, state, population) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Utilice \texttt{select} para mostrar los nombres de los estados y las abreviaturas en \texttt{murders}. No redefina \texttt{murders}, solo muestre los resultados.

4. La función \texttt{filter} de \textbf{dplyr} se utiliza para elegir filas específicas del \emph{data frame} para guardar. A diferencia de \texttt{select} que es para columnas, \texttt{filter} es para filas. Por ejemplo, puede mostrar solo la fila de Nueva York así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(murders, state }\SpecialCharTok{==} \StringTok{"New York"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Puede usar otros vectores lógicos para filtrar filas.

Utilice \texttt{filter} para mostrar los cinco estados con las tasas de asesinatos más altas. Después de añadir la tasa y el rango de asesinatos, no cambie el set de datos de asesinatos de EE. UU., solo muestre el resultado. Recuerde que puede filtrar basándose en la columna \texttt{rank}.

5. Podemos eliminar filas usando el operador \texttt{!=}. Por ejemplo, para eliminar Florida, haríamos esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{no\_florida }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(murders, state }\SpecialCharTok{!=} \StringTok{"Florida"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Cree un nuevo \emph{data frame} con el nombre \texttt{no\_south} que elimina los estados del sur. ¿Cuántos estados hay en esta categoría? Puede usar la función \texttt{nrow} para esto.

6. También podemos usar \texttt{\%in\%} para filtrar con \textbf{dplyr}. Por lo tanto, puede ver los datos de Nueva York y Texas de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(murders, state }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Texas"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Cree un nuevo \emph{data frame} llamado \texttt{murders\_nw} con solo los estados del noreste y oeste. ¿Cuántos estados hay en esta categoría?

7. Suponga que desea vivir en el noreste u oeste \textbf{y} desea que la tasa de asesinatos sea inferior a 1. Queremos ver los datos de los estados que satisfacen estas opciones. Tenga en cuenta que puede usar operadores lógicos con \texttt{filter}. Aquí hay un ejemplo en el que filtramos para mantener solo estados pequeños en la región noreste.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(murders, population }\SpecialCharTok{\textless{}} \DecValTok{5000000} \SpecialCharTok{\&}\NormalTok{ region }\SpecialCharTok{==} \StringTok{"Northeast"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Asegúrese que \texttt{murders} ha sido definido con \texttt{rate} y \texttt{rank} y todavía tiene todos los estados. Cree una tabla llamada \texttt{my\_states} que contiene filas para los estados que satisfacen ambas condiciones: está localizado en el noreste u oeste y la tasa de asesinatos es inferior a 1. Use \texttt{select} para mostrar solo el nombre del estado, la tasa y el rango.

\hypertarget{el-pipe}{%
\section{\texorpdfstring{El \emph{pipe}: \texttt{\%\textgreater{}\%}}{El pipe: \%\textgreater\%}}\label{el-pipe}}

Con \textbf{dplyr}, podemos realizar una serie de operaciones, por ejemplo \texttt{select} y entonces \texttt{filter}, enviando los resultados de una función a otra usando lo que se llama el \emph{pipe operator}: \texttt{\%\textgreater{}\%}. Algunos detalles se incluyen a continuación.

Escribimos el código anterior para mostrar tres variables (estado, región, tasa) para los estados que tienen tasas de asesinatos por debajo de 0.71. Para hacer esto, definimos el objeto intermedio \texttt{new\_table}. En \textbf{dplyr}, podemos escribir código que se parece más a una descripción de lo que queremos hacer sin objetos intermedios:

\[ \mbox {original data }
\rightarrow \mbox { select }
\rightarrow \mbox { filter } \]

Para tal operación, podemos usar el \emph{pipe} \texttt{\%\textgreater{}\%}. El código se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(state, region, rate) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(rate }\SpecialCharTok{\textless{}=} \FloatTok{0.71}\NormalTok{)}
\CommentTok{\#\textgreater{}           state        region  rate}
\CommentTok{\#\textgreater{} 1        Hawaii          West 0.515}
\CommentTok{\#\textgreater{} 2          Iowa North Central 0.689}
\CommentTok{\#\textgreater{} 3 New Hampshire     Northeast 0.380}
\CommentTok{\#\textgreater{} 4  North Dakota North Central 0.595}
\CommentTok{\#\textgreater{} 5       Vermont     Northeast 0.320}
\end{Highlighting}
\end{Shaded}

Esta línea de código es equivalente a las dos líneas de código anteriores. ¿Qué está pasando aquí?

En general, el \emph{pipe} envía el resultado que se encuentra en el lado izquierdo del \emph{pipe} para ser el primer argumento de la función en el lado derecho del \emph{pipe}. Aquí vemos un ejemplo sencillo:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{16} \SpecialCharTok{\%\textgreater{}\%} \FunctionTok{sqrt}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

Podemos continuar canalizando (\emph{piping} en inglés) valores a lo largo de:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{16} \SpecialCharTok{\%\textgreater{}\%} \FunctionTok{sqrt}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{log2}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 2}
\end{Highlighting}
\end{Shaded}

La declaración anterior es equivalente a \texttt{log2(sqrt(16))}.

Recuerden que el \emph{pipe} envía valores al primer argumento, por lo que podemos definir otros argumentos como si el primer argumento ya estuviera definido:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{16} \SpecialCharTok{\%\textgreater{}\%} \FunctionTok{sqrt}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{log}\NormalTok{(}\AttributeTok{base =} \DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2}
\end{Highlighting}
\end{Shaded}

Por lo tanto, al usar el \emph{pipe} con \emph{data frames} y \textbf{dplyr}, ya no necesitamos especificar el primer argumento requerido puesto que las funciones \textbf{dplyr} que hemos descrito toman todos los datos como el primer argumento. En el código que escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(state, region, rate) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(rate }\SpecialCharTok{\textless{}=} \FloatTok{0.71}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{murders} es el primer argumento de la función \texttt{select} y el nuevo \emph{data frame} (anteriormente \texttt{new\_table}) es el primer argumento de la función \texttt{filter}.

Tengan en cuenta que el \emph{pipe} funciona bien con las funciones donde el primer argumento son los datos de entrada. Las funciones en los paquetes \textbf{tidyverse} y \textbf{dplyr} tienen este formato y se pueden usar fácilmente con el \emph{pipe}.

\hypertarget{ejercicios-10}{%
\section{Ejercicios}\label{ejercicios-10}}

1. El \emph{pipe} \texttt{\%\textgreater{}\%} se puede usar para realizar operaciones secuencialmente sin tener que definir objetos intermedios. Comience redefiniendo \emph{murders} para incluir la tasa y el rango.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(murders, }\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{,}
                  \AttributeTok{rank =} \FunctionTok{rank}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{rate))}
\end{Highlighting}
\end{Shaded}

En la solución al ejercicio anterior, hicimos lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_states }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(murders, region }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Northeast"}\NormalTok{, }\StringTok{"West"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{                      rate }\SpecialCharTok{\textless{}} \DecValTok{1}\NormalTok{)}

\FunctionTok{select}\NormalTok{(my\_states, state, rate, rank)}
\end{Highlighting}
\end{Shaded}

El \emph{pipe} \texttt{\%\textgreater{}\%} nos permite realizar ambas operaciones secuencialmente sin tener que definir una variable intermedia \texttt{my\_states}. Por lo tanto, podríamos haber mutado y seleccionado en la misma línea de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mutate}\NormalTok{(murders, }\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{,}
       \AttributeTok{rank =} \FunctionTok{rank}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{rate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(state, rate, rank)}
\end{Highlighting}
\end{Shaded}

Note que \texttt{select} ya no tiene un \emph{data frame} como primer argumento. Se supone que el primer argumento sea el resultado de la operación realizada justo antes de \texttt{\%\textgreater{}\%}.

Repita el ejercicio anterior, pero ahora, en lugar de crear un nuevo objeto, muestre el resultado y solo incluya las columnas de estado, velocidad y rango. Use un \emph{pipe} \texttt{\%\textgreater{}\%} para hacer esto en una sola línea.

2. Reinicie \texttt{murders} a la tabla original usando \texttt{data(murders)}. Use un \emph{pipe} para crear un nuevo \emph{data frame} llamado \texttt{my\_states} que considera solo los estados del noreste u oeste que tienen una tasa de asesinatos inferior a 1 y contiene solo las columnas de estado, tasa y rango. El \emph{pipe} también debe tener cuatro componentes separados por tres \texttt{\%\textgreater{}\%}. El código debería verse algo similar a lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_states }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  mutate SOMETHING }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  filter SOMETHING }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  select SOMETHING}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-resumir-datos}{%
\section{Cómo resumir datos}\label{cuxf3mo-resumir-datos}}

Una parte importante del análisis exploratorio de datos es resumir los datos. El promedio y la desviación estándar son dos ejemplos de estadísticas de resumen ampliamente utilizadas. A menudo se pueden obtener resúmenes más informativos dividiendo primero los datos en grupos. En esta sección, cubrimos dos nuevos verbos de \textbf{dplyr} que facilitan estos cálculos: \texttt{summarize} y \texttt{group\_by}. Aprendemos a acceder a los valores resultantes utilizando la función \texttt{pull}.

\hypertarget{summarize}{%
\subsection{\texorpdfstring{\texttt{summarize}}{summarize}}\label{summarize}}

La función \texttt{summarize} de \textbf{dplyr} ofrece una forma de calcular estadísticas de resumen con código intuitivo y legible. Comenzamos con un ejemplo sencillo basado en alturas. El set de datos \texttt{heights} incluye las alturas y el sexo reportado por los estudiantes en una encuesta en clase.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\end{Highlighting}
\end{Shaded}

El siguiente código calcula el promedio y la desviación estándar para las hembras:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{average =} \FunctionTok{mean}\NormalTok{(height), }\AttributeTok{standard\_deviation =} \FunctionTok{sd}\NormalTok{(height))}
\NormalTok{s}
\CommentTok{\#\textgreater{}   average standard\_deviation}
\CommentTok{\#\textgreater{} 1    64.9               3.76}
\end{Highlighting}
\end{Shaded}

Esto toma nuestra tabla de datos original como entrada, la filtra para incluir solo a las filas representando hembras y luego produce una nueva tabla resumida con solo el promedio y la desviación estándar de las alturas. Podemos elegir los nombres de las columnas de la tabla resultante. Por ejemplo, arriba decidimos usar \texttt{average} y \texttt{standard\_deviation}, pero podríamos haber usado otros nombres de la misma manera.

Como la tabla resultante almacenada en \texttt{s} es un \emph{data frame}, podemos acceder a los componentes con el operador de acceso \texttt{\$}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s}\SpecialCharTok{$}\NormalTok{average}
\CommentTok{\#\textgreater{} [1] 64.9}
\NormalTok{s}\SpecialCharTok{$}\NormalTok{standard\_deviation}
\CommentTok{\#\textgreater{} [1] 3.76}
\end{Highlighting}
\end{Shaded}

Igual que con la mayoría de las otras funciones de \textbf{dplyr}, \texttt{summarize} conoce los nombres de las variables y podemos usarlos directamente. Entonces, cuando escribimos \texttt{mean(height)} dentro de la llamada a la función \texttt{summarize}, la función accede a la columna con el nombre ``height'', o altura, y luego calcula el promedio del vector numérico resultante. Podemos calcular cualquier otro resumen que opera en vectores y devuelve un solo valor.

Para otro ejemplo de cómo podemos usar la función \texttt{summarize}, calculemos la tasa promedio de asesinatos en Estados Unidos. Recuerden que nuestra tabla de datos incluye los asesinatos totales y el tamaño de la población para cada estado y ya hemos usado \textbf{dplyr} para añadir una columna de índice de asesinatos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{population}\SpecialCharTok{*}\DecValTok{100000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Recuerden que la tasa de asesinatos en EE. UU. \textbf{no} es el promedio de las tasas de asesinatos estatales:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarize}\NormalTok{(murders, }\FunctionTok{mean}\NormalTok{(rate))}
\CommentTok{\#\textgreater{}   mean(rate)}
\CommentTok{\#\textgreater{} 1       2.78}
\end{Highlighting}
\end{Shaded}

Esto se debe a que en el cálculo anterior, los estados pequeños tienen el mismo peso que los grandes. La tasa de asesinatos de Estados Unidos es el número total de asesinatos en Estados Unidos dividido por la población total. Entonces el cálculo correcto es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{us\_murder\_rate }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{rate =} \FunctionTok{sum}\NormalTok{(total)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(population) }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{)}
\NormalTok{us\_murder\_rate}
\CommentTok{\#\textgreater{}   rate}
\CommentTok{\#\textgreater{} 1 3.03}
\end{Highlighting}
\end{Shaded}

Este cálculo cuenta estados más grandes proporcionalmente a su tamaño, lo que da como resultado un valor mayor.

\hypertarget{resuxfamenes-muxfaltiples}{%
\subsection{Resúmenes múltiples}\label{resuxfamenes-muxfaltiples}}

Supongan que queremos tres resúmenes de una variable, como por ejemplo la mediana, el mínimo y el máximo. Podemos usar \texttt{summarize} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{median =} \FunctionTok{median}\NormalTok{(height), }\AttributeTok{minimum =} \FunctionTok{min}\NormalTok{(height), }
            \AttributeTok{maximum =} \FunctionTok{max}\NormalTok{(height))}
\CommentTok{\#\textgreater{}   median minimum maximum}
\CommentTok{\#\textgreater{} 1     65      51      79}
\end{Highlighting}
\end{Shaded}

Pero podemos obtener estos tres valores con una sola línea de código usando la función \texttt{quantile}: \texttt{quantile(x,\ c(0.5,\ 0,\ 1))} devuelve la mediana (percentil 50), el mínimo (percentil 0), y el máximo (percentil 100). Podemos usar la función con \texttt{summarize} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{median\_min\_max =} \FunctionTok{quantile}\NormalTok{(height, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\CommentTok{\#\textgreater{}   median\_min\_max}
\CommentTok{\#\textgreater{} 1             65}
\CommentTok{\#\textgreater{} 2             51}
\CommentTok{\#\textgreater{} 3             79}
\end{Highlighting}
\end{Shaded}

Ahora noten que los resúmenes se devuelven en filas separadas. Para obtenerlos en columnas, tenemos que definir una función que devuelve un \emph{data frame} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{median\_min\_max }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  qs }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(x, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
  \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{median =}\NormalTok{ qs[}\DecValTok{1}\NormalTok{], }\AttributeTok{minimum =}\NormalTok{ qs[}\DecValTok{2}\NormalTok{], }\AttributeTok{maximum =}\NormalTok{ qs[}\DecValTok{3}\NormalTok{])}
\NormalTok{\}}
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{median\_min\_max}\NormalTok{(height))}
\CommentTok{\#\textgreater{}   median minimum maximum}
\CommentTok{\#\textgreater{} 1     65      51      79}
\end{Highlighting}
\end{Shaded}

En la próxima sección veremos lo útil que esto puede ser cuando resumimos por grupo.

\hypertarget{group-by}{%
\subsection{\texorpdfstring{Cómo agrupar y luego resumir con \texttt{group\_by}}{Cómo agrupar y luego resumir con group\_by}}\label{group-by}}

Una operación común en la exploración de datos es dividir primero los datos en grupos y luego calcular resúmenes para cada grupo. Por ejemplo, podemos querer calcular el promedio y la desviación estándar para las alturas de hombres y mujeres por separado. La función \texttt{group\_by} nos ayuda a hacer esto.

Si escribimos esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(sex)}
\CommentTok{\#\textgreater{} \# A tibble: 1,050 x 2}
\CommentTok{\#\textgreater{} \# Groups:   sex [2]}
\CommentTok{\#\textgreater{}   sex   height}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}  \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Male      75}
\CommentTok{\#\textgreater{} 2 Male      70}
\CommentTok{\#\textgreater{} 3 Male      68}
\CommentTok{\#\textgreater{} 4 Male      74}
\CommentTok{\#\textgreater{} 5 Male      61}
\CommentTok{\#\textgreater{} \# ... with 1,045 more rows}
\end{Highlighting}
\end{Shaded}

El resultado no se ve muy diferente de \texttt{heights}, excepto que vemos \texttt{Groups:\ sex\ {[}2{]}} cuando imprimimos el objeto. Aunque no es inmediatamente obvio por su apariencia, esto ahora es un \emph{data frame} especial llamado un \emph{grouped data frame} y las funciones de \textbf{dplyr}, en particular \texttt{summarize}, se comportarán de manera diferente cuando actúan sobre este objeto. Conceptualmente, pueden pensar en esta tabla como muchas tablas, con las mismas columnas pero no necesariamente el mismo número de filas, apiladas juntas en un objeto. Cuando resumimos los datos después de la agrupación, esto es lo que sucede:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(sex) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{average =} \FunctionTok{mean}\NormalTok{(height), }\AttributeTok{standard\_deviation =} \FunctionTok{sd}\NormalTok{(height))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 3}
\CommentTok{\#\textgreater{}   sex    average standard\_deviation}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}    \textless{}dbl\textgreater{}              \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Female    64.9               3.76}
\CommentTok{\#\textgreater{} 2 Male      69.3               3.61}
\end{Highlighting}
\end{Shaded}

La función \texttt{summarize} aplica el resumen a cada grupo por separado.

Para ver otro ejemplo, calculemos la mediana, el mínimo y máximo de la tasa de asesinatos en las cuatro regiones del país usando la función \texttt{median\_min\_max} definida anteriormente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(region) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{median\_min\_max}\NormalTok{(rate))}
\CommentTok{\#\textgreater{} \# A tibble: 4 x 4}
\CommentTok{\#\textgreater{}   region        median minimum maximum}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}          \textless{}dbl\textgreater{}   \textless{}dbl\textgreater{}   \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Northeast       1.80   0.320    3.60}
\CommentTok{\#\textgreater{} 2 South           3.40   1.46    16.5 }
\CommentTok{\#\textgreater{} 3 North Central   1.97   0.595    5.36}
\CommentTok{\#\textgreater{} 4 West            1.29   0.515    3.63}
\end{Highlighting}
\end{Shaded}

\hypertarget{pull}{%
\section{\texorpdfstring{\texttt{pull}}{pull}}\label{pull}}

El objeto \texttt{us\_murder\_rate} definido anteriormente representa solo un número. Sin embargo, lo estamos almacenando en un \emph{data frame}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(us\_murder\_rate)}
\CommentTok{\#\textgreater{} [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

ya que, como la mayoría de las funciones de \textbf{dplyr}, \texttt{summarize} siempre devuelve un \emph{data frame}.

Esto podría ser problemático si queremos usar este resultado con funciones que requieren un valor numérico. Aquí mostramos un truco útil para acceder a los valores almacenados en los datos cuando usamos \emph{pipes}: cuando un objeto de datos se canaliza (\emph{is piped} en inglés), ese objeto y sus columnas se pueden acceder usando la función \texttt{pull}. Para entender lo que queremos decir, miren esta línea de código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{us\_murder\_rate }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(rate)}
\CommentTok{\#\textgreater{} [1] 3.03}
\end{Highlighting}
\end{Shaded}

Esto devuelve el valor en la columna \texttt{rate} de \texttt{us\_murder\_rate} haciéndolo equivalente a \texttt{us\_murder\_rate\$rate}.

Para obtener un número de la tabla de datos original con una línea de código, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{us\_murder\_rate }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{rate =} \FunctionTok{sum}\NormalTok{(total)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(population) }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(rate)}

\NormalTok{us\_murder\_rate}
\CommentTok{\#\textgreater{} [1] 3.03}
\end{Highlighting}
\end{Shaded}

que ahora es numérico:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(us\_murder\_rate)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-ordenar-los-data-frames}{%
\section{\texorpdfstring{Cómo ordenar los \emph{data frames}}{Cómo ordenar los data frames}}\label{cuxf3mo-ordenar-los-data-frames}}

Al examinar un set de datos, a menudo es conveniente ordenar, numérica o alfabéticamente, basado en una o más de las columnas de la tabla. Conocemos las funciones \texttt{order} y \texttt{sort}, pero para ordenar tablas enteras, la función \texttt{arrange} de \textbf{dplyr} es útil. Por ejemplo, aquí ordenamos los estados según el tamaño de la población:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(population) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}                  state abb        region population total   rate}
\CommentTok{\#\textgreater{} 1              Wyoming  WY          West     563626     5  0.887}
\CommentTok{\#\textgreater{} 2 District of Columbia  DC         South     601723    99 16.453}
\CommentTok{\#\textgreater{} 3              Vermont  VT     Northeast     625741     2  0.320}
\CommentTok{\#\textgreater{} 4         North Dakota  ND North Central     672591     4  0.595}
\CommentTok{\#\textgreater{} 5               Alaska  AK          West     710231    19  2.675}
\CommentTok{\#\textgreater{} 6         South Dakota  SD North Central     814180     8  0.983}
\end{Highlighting}
\end{Shaded}

Con \texttt{arrange} podemos decidir cuál columna usar para ordenar. Para ver los estados por tasa de asesinatos, desde menor a mayor, organizamos por el \texttt{rate} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(rate) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}           state abb        region population total  rate}
\CommentTok{\#\textgreater{} 1       Vermont  VT     Northeast     625741     2 0.320}
\CommentTok{\#\textgreater{} 2 New Hampshire  NH     Northeast    1316470     5 0.380}
\CommentTok{\#\textgreater{} 3        Hawaii  HI          West    1360301     7 0.515}
\CommentTok{\#\textgreater{} 4  North Dakota  ND North Central     672591     4 0.595}
\CommentTok{\#\textgreater{} 5          Iowa  IA North Central    3046355    21 0.689}
\CommentTok{\#\textgreater{} 6         Idaho  ID          West    1567582    12 0.766}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que el comportamiento por defecto es ordenar en orden ascendente. En \textbf{dplyr}, la función \texttt{desc} transforma un vector para que esté en orden descendente. Para ordenar la tabla en orden descendente, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(rate))}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-ordenar-anidadamente}{%
\subsection{Cómo ordenar anidadamente}\label{cuxf3mo-ordenar-anidadamente}}

Si estamos ordenando una columna cuando hay empates, podemos usar una segunda columna para romper el empate. Del mismo modo, se puede usar una tercera columna para romper empates entre la primera y la segunda, y así sucesivamente. Aquí ordenamos por \texttt{region} y entonces, dentro de la región, ordenamos por tasa de asesinatos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(region, rate) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}           state abb    region population total  rate}
\CommentTok{\#\textgreater{} 1       Vermont  VT Northeast     625741     2 0.320}
\CommentTok{\#\textgreater{} 2 New Hampshire  NH Northeast    1316470     5 0.380}
\CommentTok{\#\textgreater{} 3         Maine  ME Northeast    1328361    11 0.828}
\CommentTok{\#\textgreater{} 4  Rhode Island  RI Northeast    1052567    16 1.520}
\CommentTok{\#\textgreater{} 5 Massachusetts  MA Northeast    6547629   118 1.802}
\CommentTok{\#\textgreater{} 6      New York  NY Northeast   19378102   517 2.668}
\end{Highlighting}
\end{Shaded}

\hypertarget{los-primeros-n}{%
\subsection{\texorpdfstring{Los primeros \(n\)}{Los primeros n}}\label{los-primeros-n}}

En el código anterior, usamos la función \texttt{head} para evitar que la página se llene con todo el set de datos. Si queremos ver una mayor proporción, podemos usar la función \texttt{top\_n}. Esta función toma un \emph{data frame} como primer argumento, el número de filas para mostrar en el segundo y la variable para filtrar en el tercero. Aquí hay un ejemplo de cómo ver las 5 filas superiores:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{top\_n}\NormalTok{(}\DecValTok{5}\NormalTok{, rate)}
\CommentTok{\#\textgreater{}                  state abb        region population total  rate}
\CommentTok{\#\textgreater{} 1 District of Columbia  DC         South     601723    99 16.45}
\CommentTok{\#\textgreater{} 2            Louisiana  LA         South    4533372   351  7.74}
\CommentTok{\#\textgreater{} 3             Maryland  MD         South    5773552   293  5.07}
\CommentTok{\#\textgreater{} 4             Missouri  MO North Central    5988927   321  5.36}
\CommentTok{\#\textgreater{} 5       South Carolina  SC         South    4625364   207  4.48}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que las filas no están ordenadas por \texttt{rate}, solo filtradas. Si queremos ordenar, necesitamos usar \texttt{arrange}. Recuerden que si el tercer argumento se deja en blanco, \texttt{top\_n} filtra por la última columna.

\hypertarget{ejercicios-11}{%
\section{Ejercicios}\label{ejercicios-11}}

Para estos ejercicios, utilizaremos los datos de la encuesta recopilada por el Centro Nacional de Estadísticas de Salud de Estados Unidos (NCHS por sus siglas en inglés). Este centro ha realizado una serie de encuestas de salud y nutrición desde la década de 1960. A partir de 1999, alrededor de 5,000 individuos de todas las edades han sido entrevistados cada año y completan el componente de examen de salud de la encuesta. Parte de los datos está disponible a través del paquete \textbf{NHANES}. Una vez que instale el paquete \textbf{NHANES}, puede cargar los datos así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(NHANES)}
\FunctionTok{data}\NormalTok{(NHANES)}
\end{Highlighting}
\end{Shaded}

Los datos \textbf{NHANES} tienen muchos valores faltantes. Las funciones \texttt{mean} y \texttt{sd} devolverán \texttt{NA} si alguna de las entradas del vector de entrada es un \texttt{NA}. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(na\_example)}
\FunctionTok{mean}\NormalTok{(na\_example)}
\CommentTok{\#\textgreater{} [1] NA}
\FunctionTok{sd}\NormalTok{(na\_example)}
\CommentTok{\#\textgreater{} [1] NA}
\end{Highlighting}
\end{Shaded}

Para ignorar los \texttt{NA}s, podemos usar el argumento \texttt{na.rm}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(na\_example, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2.3}
\FunctionTok{sd}\NormalTok{(na\_example, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1.22}
\end{Highlighting}
\end{Shaded}

Exploremos ahora los datos de \textbf{NHANES}.

1. Le ofrecemos algunos datos básicos sobre la presión arterial. Primero, seleccionemos un grupo para establecer el estándar. Utilizaremos hembras de 20 a 29 años. \texttt{AgeDecade} es una variable categórica con estas edades. Tenga en cuenta que la categoría está codificada como " 20-29", ¡con un espacio al frente! ¿Cuál es el promedio y la desviación estándar de la presión arterial sistólica según se guarda en la variable \texttt{BPSysAve}? Guárdela en una variable llamada \texttt{ref}.

Sugerencia: use \texttt{filter} y \texttt{summarize} y use el argumento \texttt{na.rm\ =\ TRUE} al calcular el promedio y la desviación estándar. También puede filtrar los valores de NA utilizando \texttt{filter}.

2. Usando un \emph{pipe}, asigne el promedio a una variable numérica \texttt{ref\_avg}. Sugerencia: use el código similar al anterior y luego \texttt{pull}.

3. Ahora indique los valores mínimo y máximo para el mismo grupo.

4. Calcule el promedio y la desviación estándar para las hembras, pero para cada grupo de edad por separado en lugar de una década seleccionada como en la pregunta 1. Tenga en cuenta que los grupos de edad se definen por \texttt{AgeDecade}. Sugerencia: en lugar de filtrar por edad y género, filtre por \texttt{Gender} y luego use \texttt{group\_by}.

5. Repita el ejercicio 4 para los varones.

6. Podemos combinar ambos resúmenes para los ejercicios 4 y 5 en una línea de código. Esto es porque \texttt{group\_by} nos permite agrupar por más de una variable. Obtenga una gran tabla de resumen usando \texttt{group\_by(AgeDecade,\ Gender)}.

7. Para los varones entre las edades de 40-49, compare la presión arterial sistólica según raza, como aparece en la variable \texttt{Race1}. Ordene la tabla resultante según la presión arterial sistólica promedio de más baja a más alta.

\hypertarget{tibbles}{%
\section{\texorpdfstring{\emph{Tibbles}}{Tibbles}}\label{tibbles}}

Los datos \emph{tidy} deben almacenarse en \emph{data frames}. Discutimos el \emph{data frame} en la Sección \ref{data-frames} y hemos estado usando el \emph{data frame} \texttt{murders} en todo el libro. En la sección \ref{group-by}, presentamos la función \texttt{group\_by}, que permite estratificar los datos antes de calcular las estadísticas de resumen. Pero, ¿dónde se almacena la información del grupo en el \emph{data frame}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(region)}
\CommentTok{\#\textgreater{} \# A tibble: 51 x 6}
\CommentTok{\#\textgreater{} \# Groups:   region [4]}
\CommentTok{\#\textgreater{}   state      abb   region population total  rate}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}      \textless{}chr\textgreater{} \textless{}fct\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Alabama    AL    South     4779736   135  2.82}
\CommentTok{\#\textgreater{} 2 Alaska     AK    West       710231    19  2.68}
\CommentTok{\#\textgreater{} 3 Arizona    AZ    West      6392017   232  3.63}
\CommentTok{\#\textgreater{} 4 Arkansas   AR    South     2915918    93  3.19}
\CommentTok{\#\textgreater{} 5 California CA    West     37253956  1257  3.37}
\CommentTok{\#\textgreater{} \# ... with 46 more rows}
\end{Highlighting}
\end{Shaded}

Observen que no hay columnas con esta información. Pero si miran el \emph{output} anterior, verán la línea \texttt{A\ tibble} seguida por unas dimensiones. Podemos aprender la clase del objeto devuelto usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(region) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{class}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "grouped\_df" "tbl\_df"     "tbl"        "data.frame"}
\end{Highlighting}
\end{Shaded}

El \texttt{tbl} es un tipo especial de \emph{data frame}. Las funciones \texttt{group\_by} y \texttt{summarize} siempre devuelven este tipo de \emph{data frame}. La función \texttt{group\_by} devuelve un tipo especial de \texttt{tbl}, el \texttt{grouped\_df}. Discutiremos esto más adelante. Por coherencia, los verbos de manipulación \textbf{dplyr} ( \texttt{select}, \texttt{filter}, \texttt{mutate} y \texttt{arrange}) preservan la clase del \emph{input}: si reciben un \emph{data frame} regular, devuelven un \emph{data frame} regular, mientras que si reciben un \emph{tibble}, devuelven un \emph{tibble}. Pero los \emph{tibbles} son el formato preferido por el \emph{tidyverse} y, como resultado, las funciones \emph{tidyverse} que producen un \emph{data frame} desde cero devuelven un \emph{tibble}. Por ejemplo, en el Capítulo \ref{importing-data}, veremos que las funciones del \emph{tidyverse} que se usan para importar datos crean \emph{tibbles}.

Los \emph{tibbles} son muy similares a los \emph{data frames}. De hecho, pueden pensar en ellos como una versión moderna de \emph{data frames}. Sin embargo, hay tres diferencias importantes que describiremos a continuación.

\hypertarget{los-tibbles-se-ven-mejor}{%
\subsection{\texorpdfstring{Los \emph{tibbles} se ven mejor}{Los tibbles se ven mejor}}\label{los-tibbles-se-ven-mejor}}

El método de impresión para \emph{tibbles} es más legible que el de un \emph{data frame}. Para ver esto, comparen el \emph{output} de escribir \texttt{murders} y el \emph{output} de asesinatos si los convertimos en un \emph{tibble}. Podemos hacer esto usando \texttt{as\_tibble(murders)}. Si usan RStudio, el \emph{output} para un \emph{tibble} se ajusta al tamaño de sus ventanas. Para ver esto, cambien el ancho de su consola R y observen cómo se muestran más/menos columnas.

\hypertarget{los-subconjuntos-de-tibbles-son-tibbles}{%
\subsection{\texorpdfstring{Los subconjuntos de \emph{tibbles} son \emph{tibbles}}{Los subconjuntos de tibbles son tibbles}}\label{los-subconjuntos-de-tibbles-son-tibbles}}

Si creamos subconjuntos de las columnas de un \emph{data frame}, le pueden devolver un objeto que no es un \emph{data frame}, como un vector o escalar. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(murders[,}\DecValTok{4}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

no es un \emph{data frame}. Con \emph{tibbles}, esto no sucede:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\FunctionTok{as\_tibble}\NormalTok{(murders)[,}\DecValTok{4}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] "tbl\_df"     "tbl"        "data.frame"}
\end{Highlighting}
\end{Shaded}

Esto es útil en el \emph{tidyverse} ya que las funciones requieren \emph{data frames} como \emph{input}.

Con \emph{tibbles}, si desean acceder al vector que define una columna y no recuperar un \emph{data frame}, deben usar el operador de acceso \texttt{\$}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\FunctionTok{as\_tibble}\NormalTok{(murders)}\SpecialCharTok{$}\NormalTok{population)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

Una característica relacionada es que \emph{tibbles} les dará una advertencia si intentan acceder a una columna que no existe. Por ejemplo, si escribimos accidentalmente \texttt{Population} en lugar de \texttt{population} vemos que:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders}\SpecialCharTok{$}\NormalTok{Population}
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

devuelve un \texttt{NULL} sin advertencia, lo que puede dificultar la depuración. Por el contrario, si intentamos esto con un \emph{tibble}, obtenemos una advertencia informativa:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as\_tibble}\NormalTok{(murders)}\SpecialCharTok{$}\NormalTok{Population}
\CommentTok{\#\textgreater{} Warning: Unknown or uninitialised column: \textasciigrave{}Population\textasciigrave{}.}
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

\hypertarget{los-tibbles-pueden-tener-entradas-complejas}{%
\subsection{\texorpdfstring{Los \emph{tibbles} pueden tener entradas complejas}{Los tibbles pueden tener entradas complejas}}\label{los-tibbles-pueden-tener-entradas-complejas}}

Si bien las columnas del \emph{data frame} deben ser vectores de números, cadenas o valores lógicos, los \emph{tibbles} pueden tener objetos más complejos, como listas o funciones. Además, podemos crear \emph{tibbles} con funciones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{id =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), }\AttributeTok{func =} \FunctionTok{c}\NormalTok{(mean, median, sd))}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 2}
\CommentTok{\#\textgreater{}      id func  }
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}list\textgreater{}}
\CommentTok{\#\textgreater{} 1     1 \textless{}fn\textgreater{}  }
\CommentTok{\#\textgreater{} 2     2 \textless{}fn\textgreater{}  }
\CommentTok{\#\textgreater{} 3     3 \textless{}fn\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{los-tibbles-se-pueden-agrupar}{%
\subsection{\texorpdfstring{Los \emph{tibbles} se pueden agrupar}{Los tibbles se pueden agrupar}}\label{los-tibbles-se-pueden-agrupar}}

La función \texttt{group\_by} devuelve un tipo especial de \emph{tibble}: un \emph{tibble} agrupado. Esta clase almacena información que les permite saber qué filas están en qué grupos. Las funciones \emph{tidyverse}, en particular \texttt{summarize}, están al tanto de la información del grupo.

\hypertarget{cuxf3mo-crear-un-tibble-usando-tibble-en-lugar-de-data.frame}{%
\subsection{\texorpdfstring{Cómo crear un \emph{tibble} usando \texttt{tibble} en lugar de \texttt{data.frame}}{Cómo crear un tibble usando tibble en lugar de data.frame}}\label{cuxf3mo-crear-un-tibble-usando-tibble-en-lugar-de-data.frame}}

A veces es útil para nosotros crear nuestros propios \emph{data frames}. Para crear un \emph{data frame} en formato \emph{tibble}, pueden utilizar la función \texttt{tibble}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grades }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\AttributeTok{names =} \FunctionTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Juan"}\NormalTok{, }\StringTok{"Jean"}\NormalTok{, }\StringTok{"Yao"}\NormalTok{),}
                 \AttributeTok{exam\_1 =} \FunctionTok{c}\NormalTok{(}\DecValTok{95}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{),}
                 \AttributeTok{exam\_2 =} \FunctionTok{c}\NormalTok{(}\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{90}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Noten que la base R (sin paquetes cargados) tiene una función con un nombre muy similar, \texttt{data.frame}, que se puede usar para crear un \emph{data frame} regular en vez de un \emph{tibble}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grades }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{names =} \FunctionTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Juan"}\NormalTok{, }\StringTok{"Jean"}\NormalTok{, }\StringTok{"Yao"}\NormalTok{),}
                     \AttributeTok{exam\_1 =} \FunctionTok{c}\NormalTok{(}\DecValTok{95}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{),}
                     \AttributeTok{exam\_2 =} \FunctionTok{c}\NormalTok{(}\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{90}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Para convertir un \emph{data frame} normal en un \emph{tibble}, pueden usar la función \texttt{as\_tibble}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as\_tibble}\NormalTok{(grades) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{class}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "tbl\_df"     "tbl"        "data.frame"}
\end{Highlighting}
\end{Shaded}

\hypertarget{el-operador-punto}{%
\section{El operador punto}\label{el-operador-punto}}

Una de las ventajas de utilizar el \emph{pipe} \texttt{\%\textgreater{}\%} es que no tenemos que seguir nombrando nuevos objetos mientras manipulamos el \emph{data frame}. Recuerden que si queremos calcular la tasa de asesinatos promedio para los estados del sur, en lugar de escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(murders, region }\SpecialCharTok{==} \StringTok{"South"}\NormalTok{)}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(tab\_1, }\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{5}\NormalTok{)}
\NormalTok{rates }\OtherTok{\textless{}{-}}\NormalTok{ tab\_2}\SpecialCharTok{$}\NormalTok{rate}
\FunctionTok{median}\NormalTok{(rates)}
\CommentTok{\#\textgreater{} [1] 3.4}
\end{Highlighting}
\end{Shaded}

podemos evitar definir nuevos objetos intermedios escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(murders, region }\SpecialCharTok{==} \StringTok{"South"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{5}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{median =} \FunctionTok{median}\NormalTok{(rate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(median)}
\CommentTok{\#\textgreater{} [1] 3.4}
\end{Highlighting}
\end{Shaded}

Podemos hacer esto porque cada una de estas funciones toma un \emph{data frame} como primer argumento. Pero, ¿qué pasa si queremos acceder a un componente del \emph{data frame}? Por ejemplo, ¿qué pasa si la función \texttt{pull} no está disponible y queremos acceder \texttt{tab\_2\$rate}? ¿Qué nombre de \emph{data frame} usamos? La respuesta es el operador punto (\emph{dot operator} en inglés).

Por ejemplo, para acceder al vector de velocidad sin la función \texttt{pull}, podríamos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rates }\OtherTok{\textless{}{-}}\FunctionTok{filter}\NormalTok{(murders, region }\SpecialCharTok{==} \StringTok{"South"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{5}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  .}\SpecialCharTok{$}\NormalTok{rate}
\FunctionTok{median}\NormalTok{(rates)}
\CommentTok{\#\textgreater{} [1] 3.4}
\end{Highlighting}
\end{Shaded}

\hypertarget{el-paquete-purrr}{%
\section{\texorpdfstring{El paquete \textbf{purrr}}{El paquete purrr}}\label{el-paquete-purrr}}

En la Sección \ref{vectorization}, aprendimos sobre la función \texttt{sapply}, que nos permitió aplicar la misma función a cada elemento de un vector. Construimos una función y utilizamos \texttt{sapply} para calcular la suma de los primeros \texttt{n} enteros para varios valores de \texttt{n} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compute\_s\_n }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n}
  \FunctionTok{sum}\NormalTok{(x)}
\NormalTok{\}}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{25}
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(n, compute\_s\_n)}
\end{Highlighting}
\end{Shaded}

Este tipo de operación, que aplica la misma función o procedimiento a elementos de un objeto, es bastante común en el análisis de datos. El paquete \textbf{purrr} incluye funciones similares a \texttt{sapply}, pero que interactúan mejor con otras funciones del \emph{tidyverse}. La principal ventaja es que podemos controlar mejor el tipo de resultado de las funciones. En cambio, \texttt{sapply} puede devolver varios tipos de objetos diferentes, convirtiéndolos cuando sea conveniente. Las funciones de \textbf{purrr} nunca harán esto: devolverán objetos de un tipo específico o devolverán un error si esto no es posible.

La primera función de \textbf{purrr} que aprenderemos es \texttt{map}, que funciona muy similar a \texttt{sapply} pero siempre, sin excepción, devuelve una lista:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(purrr)}
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{map}\NormalTok{(n, compute\_s\_n)}
\FunctionTok{class}\NormalTok{(s\_n)}
\CommentTok{\#\textgreater{} [1] "list"}
\end{Highlighting}
\end{Shaded}

Si queremos un vector numérico, podemos usar \texttt{map\_dbl} que siempre devuelve un vector de valores numéricos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{map\_dbl}\NormalTok{(n, compute\_s\_n)}
\FunctionTok{class}\NormalTok{(s\_n)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\end{Highlighting}
\end{Shaded}

Esto produce los mismos resultados que la llamada \texttt{sapply} que vemos arriba.

Una función de \textbf{purrr} particularmente útil para interactuar con el resto del \emph{tidyverse} es \texttt{map\_df}, que siempre devuelve un \emph{tibble data frame}. Sin embargo, la función que llamamos debe devolver un vector o una lista con nombres. Por esta razón, el siguiente código daría como resultado un error \texttt{Argument\ 1\ must\ have\ names}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(n, compute\_s\_n)}
\end{Highlighting}
\end{Shaded}

Necesitamos cambiar la función para arreglar esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compute\_s\_n }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n}
  \FunctionTok{tibble}\NormalTok{(}\AttributeTok{sum =} \FunctionTok{sum}\NormalTok{(x))}
\NormalTok{\}}
\NormalTok{s\_n }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(n, compute\_s\_n)}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{purrr} ofrece mucha más funcionalidad no discutida aquí. Para obtener más detalles, pueden consultar recursos en línea\footnote{\url{https://jennybc.github.io/purrr-tutorial/}}.

\hypertarget{los-condicionales-de-tidyverse}{%
\section{\texorpdfstring{Los condicionales de \emph{tidyverse}}{Los condicionales de tidyverse}}\label{los-condicionales-de-tidyverse}}

Un análisis de datos típicos frecuentemente implicará una o más operaciones condicionales. En la Sección \ref{conditionals}, describimos la función \texttt{ifelse}, que utilizaremos ampliamente en este libro. Ahora presentamos dos funciones de \textbf{dplyr} que ofrecen una funcionalidad adicional para realizar operaciones condicionales.

\hypertarget{case_when}{%
\subsection{\texorpdfstring{\texttt{case\_when}}{case\_when}}\label{case_when}}

La función \texttt{case\_when} es útil para vectorizar declaraciones condicionales. Esto es similar a \texttt{ifelse}, pero puede generar cualquier cantidad de valores, en lugar de solo \texttt{TRUE} o \texttt{FALSE}. Aquí hay un ejemplo que divide los números en negativo, positivo y 0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\FunctionTok{case\_when}\NormalTok{(x }\SpecialCharTok{\textless{}} \DecValTok{0} \SpecialCharTok{\textasciitilde{}} \StringTok{"Negative"}\NormalTok{,}
\NormalTok{          x }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\textasciitilde{}} \StringTok{"Positive"}\NormalTok{,}
          \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}} \StringTok{"Zero"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "Negative" "Negative" "Zero"     "Positive" "Positive"}
\end{Highlighting}
\end{Shaded}

Un uso común de esta función es definir unas variables categóricas basadas en variables existentes. Por ejemplo, supongan que queremos comparar las tasas de asesinatos en cuatro grupos de estados: \emph{New England}, \emph{West Coast}, \emph{South} y \emph{Other}. Para cada estado, primero preguntamos si está en \emph{New England}. Si la respuesta es no, entonces preguntamos si está en el \emph{West Coast}, y si no, preguntamos si está en el \emph{South} y, si no, entonces asignamos ninguna de las anteriores (\emph{Other}). Aquí vemos como usamos \texttt{case\_when} para hacer esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{group =} \FunctionTok{case\_when}\NormalTok{(}
\NormalTok{    abb }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"ME"}\NormalTok{, }\StringTok{"NH"}\NormalTok{, }\StringTok{"VT"}\NormalTok{, }\StringTok{"MA"}\NormalTok{, }\StringTok{"RI"}\NormalTok{, }\StringTok{"CT"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"New England"}\NormalTok{,}
\NormalTok{    abb }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"WA"}\NormalTok{, }\StringTok{"OR"}\NormalTok{, }\StringTok{"CA"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"West Coast"}\NormalTok{,}
\NormalTok{    region }\SpecialCharTok{==} \StringTok{"South"} \SpecialCharTok{\textasciitilde{}} \StringTok{"South"}\NormalTok{,}
    \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}} \StringTok{"Other"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(group) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{rate =} \FunctionTok{sum}\NormalTok{(total)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(population) }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 4 x 2}
\CommentTok{\#\textgreater{}   group        rate}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 New England  1.72}
\CommentTok{\#\textgreater{} 2 Other        2.71}
\CommentTok{\#\textgreater{} 3 South        3.63}
\CommentTok{\#\textgreater{} 4 West Coast   2.90}
\end{Highlighting}
\end{Shaded}

\hypertarget{between}{%
\subsection{\texorpdfstring{\texttt{between}}{between}}\label{between}}

Una operación común en el análisis de datos es determinar si un valor cae dentro de un intervalo. Podemos verificar esto usando condicionales. Por ejemplo, para verificar si los elementos de un vector \texttt{x} están entre \texttt{a} y \texttt{b}, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\textgreater{}=}\NormalTok{ a }\SpecialCharTok{\&}\NormalTok{ x }\SpecialCharTok{\textless{}=}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

Sin embargo, esto puede volverse complicado, especialmente dentro del enfoque \emph{tidyverse}. La función \texttt{between} realiza la misma operación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{between}\NormalTok{(x, a, b)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-12}{%
\section{Ejercicios}\label{ejercicios-12}}

1. Cargue el set de datos \texttt{murders}. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{murders} está en formato \emph{tidy} y se almacena en un \emph{tibble}.
\item
  \texttt{murders} está en formato \emph{tidy} y se almacena en un \emph{data frame}.
\item
  \texttt{murders} no está en formato \emph{tidy} y se almacena en un \emph{tibble}.
\item
  \texttt{murders} no está en formato \emph{tidy} y se almacena en un \emph{data frame}.
\end{enumerate}

2. Utilice \texttt{as\_tibble} para convertir la tabla de datos \texttt{murders} en un \emph{tibble} y guárdelo en un objeto llamado \texttt{murders\_tibble}.

3. Utilice la función \texttt{group\_by} para convertir \texttt{murders} en un \emph{tibble} que se agrupa por región.

4. Escriba el código \emph{tidyverse} que es equivalente a este código:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\FunctionTok{mean}\NormalTok{(}\FunctionTok{log}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{population)))}
\end{Highlighting}
\end{Shaded}

Escríbalo usando el \emph{pipe} para que cada función se llame sin argumentos. Use el operador punto para acceder a la población. Sugerencia: el código debe comenzar con \texttt{murders\ \%\textgreater{}\%}.

5. Utilice el \texttt{map\_df} para crear un \emph{data frame} con tres columnas que se denominan \texttt{n}, \texttt{s\_n} y \texttt{s\_n\_2}. La primera columna debe contener los números del 1 al 100. La segunda y la tercera columna deben contener la suma del 1 al 100 \(n\) con \(n\) representando el número de fila.

\hypertarget{importing-data}{%
\chapter{Importando datos}\label{importing-data}}

Hemos estado usando sets de datos ya almacenados como objetos R. Los científicos de datos rara vez tendrán tanta suerte y frecuentemente tendrán que importar datos a R desde un archivo, una base de datos u otras fuentes. Actualmente, una de las formas más comunes de almacenar y compartir datos para el análisis es a través de hojas de cálculo electrónicas. Una hoja de cálculo almacena datos en filas y columnas. Básicamente es una versión de archivo de un \emph{data frame}. Al guardar dicha tabla en un archivo de computadora, uno necesita una manera de definir cuándo termina una nueva fila o columna y cuando comienza la otra. Esto a su vez define las celdas en las que se almacenan los valores individuales.

Al crear hojas de cálculo con archivos de texto, como esas creadas con un editor sencillo de texto, se define una nueva fila con \emph{return} y se separan las columnas con un carácter especial predefinido. Los caracteres más comunes son coma (\texttt{,}), punto y coma (\texttt{;}), espacio ( ) y el \emph{tab} (un número predeterminado de espacios o \texttt{\textbackslash{}t}). Aquí tenemos un ejemplo de cómo se ve un archivo separado por comas si lo abrimos con un editor básico de texto:

\begin{center}\includegraphics[width=0.7\linewidth]{R/img/csv-file} \end{center}

La primera fila contiene nombres de columnas en lugar de datos. Nos referimos a esto como un \emph{encabezado} (\emph{header} en inglés), y cuando leemos (\emph{read-in} en inglés) datos de una hoja de cálculo es importante saber si el archivo tiene un encabezado o no. La mayoría de las funciones de lectura suponen que hay un encabezado. Para saber si el archivo tiene un encabezado, miren el archivo antes de intentar leerlo. Esto se puede hacer con un editor de texto o con RStudio. En RStudio, podemos hacerlo abriendo el archivo en el editor o navegando a la ubicación del archivo, haciendo doble clic en el archivo y presionando \emph{View File}.

Sin embargo, no todos los archivos de hojas de cálculo están en formato de texto. Las hojas de cálculo de Google (\emph{Google Sheets} en inglés), por ejemplo, se acceden con un navegador. Otro ejemplo es el formato propietario utilizado por Microsoft Excel, que no se puede ver con un editor de texto. A pesar de esto y debido a la popularidad del software Microsoft Excel, este formato se utiliza ampliamente.

Comenzamos este capítulo describiendo las diferencias entre archivos de texto (ASCII), Unicode y binarios y cómo estas afectan la forma en que los importamos. Entonces, explicamos los conceptos de rutas de archivos y directorios de trabajo, que son esenciales para comprender cómo importar datos de manera efectiva. Luego, presentamos los paquetes \textbf{readr} y \textbf{readxl} y las funciones disponibles para importar hojas de cálculo en R. Finalmente, ofrecemos algunas recomendaciones sobre cómo almacenar y organizar datos en archivos. Los desafíos más complejos, sin embargo, como la extracción de datos de páginas web o de documentos PDF, se discutirán en la parte del libro ``\emph{Wrangling} de datos''.

\hypertarget{las-rutas-y-el-directorio-de-trabajo}{%
\section{Las rutas y el directorio de trabajo}\label{las-rutas-y-el-directorio-de-trabajo}}

El primer paso para importar datos desde una hoja de cálculo es ubicar el archivo que contiene los datos. Aunque no lo recomendamos, pueden utilizar un enfoque similar al que usan para abrir archivos en Microsoft Excel: haciendo clic en el menú de \emph{File} de RStudio, haciendo clic en \emph{Import Dataset} y luego haciendo clic en las carpetas hasta encontrar el archivo. Queremos poder escribir código en lugar de estar apuntando y haciendo clic. Las claves y los conceptos que necesitamos para aprender a hacer esto se describen en detalle en la parte del libro ``Herramientas de productividad''. Aquí ofrecemos una descripción general de los conceptos básicos.

El principal reto de este primer paso es permitir que las funciones de R que realizan la importación sepan dónde buscar el archivo que contiene los datos. La forma más sencilla de hacer esto es tener una copia del archivo en la carpeta donde las funciones de importación buscan por defecto. Una vez que hagamos esto, solo tenemos que proveerle el nombre del archivo a la función de importación.

El paquete \textbf{dslabs} incluye una hoja de cálculo que contiene los datos de los asesinatos de EE. UU. Encontrar este archivo no es obvio, pero las siguientes líneas de código copian el archivo a la carpeta en la que R busca por defecto. A continuación explicamos cómo funcionan estas líneas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filename }\OtherTok{\textless{}{-}} \StringTok{"murders.csv"}
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{fullpath }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(dir, filename)}
\FunctionTok{file.copy}\NormalTok{(fullpath, }\StringTok{"murders.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Este código no lee los datos en R, solo copia un archivo. Pero una vez copie el archivo, podemos importar los datos con solo una línea de código. Aquí usamos la función \texttt{read\_csv} del paquete \textbf{readr}, que forma parte del \textbf{tidyverse}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(filename)}
\end{Highlighting}
\end{Shaded}

Los datos se importan y almacenan en \texttt{dat}. El resto de esta sección define algunos conceptos importantes y ofrece una visión general de cómo escribimos código para que R pueda encontrar los archivos que queremos importar. Capítulo \ref{unix} ofrece más detalles sobre este tema.

\hypertarget{el-sistema-de-archivos}{%
\subsection{El sistema de archivos}\label{el-sistema-de-archivos}}

Pueden pensar en el sistema de archivos (\emph{filesystem} en inglés) de su computadora como una serie de carpetas anidadas, cada una con otras carpetas y archivos. Los científicos de datos se refieren a las carpetas como \emph{directorios} y a la carpeta que contiene todas las demás carpetas como el \emph{directorio raíz} (\emph{root directory} en inglés). El directorio en el que estamos ubicados actualmente se llama el \emph{directorio de trabajo} (\emph{working directory} en inglés). Por lo tanto, el directorio de trabajo cambia a medida que se muevan por las carpetas: considérenlo como su ubicación actual.

\hypertarget{las-rutas-relativas-y-completas}{%
\subsection{Las rutas relativas y completas}\label{las-rutas-relativas-y-completas}}

La \emph{ruta} (\emph{path} en inglés) de un archivo es una lista de nombres de directorios que se pueden considerar instrucciones sobre en qué carpetas hacer clic y en qué orden encontrar el archivo. Si estas instrucciones son para encontrar el archivo desde el directorio raíz, nos referiremos a ellas como la \emph{ruta completa} (\emph{full path} en inglés). Si las instrucciones son para encontrar el archivo desde el directorio de trabajo, nos referimos a ellas como una \emph{ruta relativa} (\emph{relative path} en inglés). Sección \ref{filesystem} ofrece más detalles sobre este tema.

Para ver un ejemplo de una ruta completa en su sistema, escriban lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.file}\NormalTok{(}\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Las cadenas separadas por barras son los nombres de los directorios. La primera barra diagonal representa el directorio raíz y sabemos que esta es una ruta completa porque comienza con una barra diagonal. Si el primer nombre del directorio aparece sin una barra diagonal en el comienzo, entonces R supone que la ruta es relativa. Podemos usar la función \texttt{list.files} para ver ejemplos de rutas relativas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\FunctionTok{list.files}\NormalTok{(}\AttributeTok{path =}\NormalTok{ dir)}
\CommentTok{\#\textgreater{}  [1] "data"        "DESCRIPTION" "extdata"     "help"       }
\CommentTok{\#\textgreater{}  [5] "html"        "INDEX"       "Meta"        "NAMESPACE"  }
\CommentTok{\#\textgreater{}  [9] "R"           "script"}
\end{Highlighting}
\end{Shaded}

Estas rutas relativas nos dan la localización de los archivos o directorios si comenzamos en el directorio con la ruta completa. Por ejemplo, la ruta completa al directorio \texttt{help} en el ejemplo anterior es: \texttt{/Library/Frameworks/R.framework/Versions/3.5/Resources/library/dslabs/help}.

\textbf{Nota}: Probablemente no harán mucho uso de la función \texttt{system.file} en su trabajo diario de análisis de datos. Lo presentamos en esta sección porque facilita el intercambio de hojas de cálculo al incluirlas en el paquete \textbf{dslabs}. Raras veces tendrán el lujo de tener datos incluidos en paquetes que ya han instalado. Sin embargo, con frecuencia necesitarán navegar por rutas completas y relativas e importar datos con formato de hoja de cálculo.

\hypertarget{el-directorio-de-trabajo}{%
\subsection{El directorio de trabajo}\label{el-directorio-de-trabajo}}

Recomendamos escribir solo rutas relativas en su código ya que las rutas completas son exclusivas de sus computadoras y es preferible que su código sea portátil. Pueden obtener la ruta completa de su directorio de trabajo sin escribirla explícitamente utilizando la función \texttt{getwd}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wd }\OtherTok{\textless{}{-}} \FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Si necesitan cambiar su directorio de trabajo, pueden usar la función \texttt{setwd} o pueden cambiarlo a través de RStudio haciendo clic en \emph{Session}.

\hypertarget{cuxf3mo-generar-los-nombres-de-ruta}{%
\subsection{Cómo generar los nombres de ruta}\label{cuxf3mo-generar-los-nombres-de-ruta}}

Otro ejemplo de cómo obtener una ruta completa sin escribirla explícitamente se ofreció arriba cuando creamos el objeto \texttt{fullpath} de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filename }\OtherTok{\textless{}{-}} \StringTok{"murders.csv"}
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{fullpath }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(dir, filename)}
\end{Highlighting}
\end{Shaded}

La función \texttt{system.file} provee la ruta completa de la carpeta que contiene todos los archivos y directorios relevantes para el paquete especificado por el argumento \texttt{package}. Al explorar los directorios en \texttt{dir}, nos encontramos con que \texttt{extdata} contiene el archivo que queremos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{filename }\SpecialCharTok{\%in\%} \FunctionTok{list.files}\NormalTok{(}\FunctionTok{file.path}\NormalTok{(dir, }\StringTok{"extdata"}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

La función \texttt{system.file} nos permite proveer un subdirectorio como primer argumento, para que podamos obtener la ruta completa del directorio \texttt{extdata} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La función \texttt{file.path} se usa para combinar los nombres de directorios para producir la ruta completa del archivo que queremos importar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fullpath }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(dir, filename)}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-copiar-los-archivos-usando-rutas}{%
\subsection{Cómo copiar los archivos usando rutas}\label{cuxf3mo-copiar-los-archivos-usando-rutas}}

La última línea de código que usamos para copiar el archivo en nuestro directorio de inicio usó la función \texttt{file.copy}. Esta toma dos argumentos: el nombre del archivo para copiar y el nombre que se usará en el nuevo directorio.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{file.copy}\NormalTok{(fullpath, }\StringTok{"murders.csv"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

Si un archivo se copia exitosamente, la función \texttt{file.copy} devuelve \texttt{TRUE}. Tengan en cuenta que le estamos dando al archivo el mismo nombre, \texttt{murders.csv}, pero podríamos haberle dado cualquier nombre. También recuerden que al no iniciar la cadena con una barra diagonal, R supone que esta es una ruta relativa y copia el archivo al directorio de trabajo.

Deberían poder ver el archivo en su directorio de trabajo usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{list.files}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{los-paquetes-readr-y-readxl}{%
\section{Los paquetes readr y readxl}\label{los-paquetes-readr-y-readxl}}

En esta sección presentamos las principales funciones de importación del \emph{tidyverse}. Utilizaremos el archivo \texttt{murders.csv} del paquete \textbf{dslabs} como ejemplo. Para simplificar la ilustración, copiaremos el archivo a nuestro directorio de trabajo usando el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filename }\OtherTok{\textless{}{-}} \StringTok{"murders.csv"}
\NormalTok{dir }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{fullpath }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(dir, filename)}
\FunctionTok{file.copy}\NormalTok{(fullpath, }\StringTok{"murders.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{readr}{%
\subsection{readr}\label{readr}}

El paquete \textbf{readr} incluye funciones para leer datos almacenados en hojas de cálculo. \textbf{readr} es parte del paquete \textbf{tidyverse}, o pueden cargarlo directamente así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(readr)}
\end{Highlighting}
\end{Shaded}

Las siguientes funciones están disponibles para leer hojas de cálculo:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.14}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.65}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.21}}@{}}
\toprule
Función & Formato & Sufijo típico \\
\midrule
\endhead
read\_table & valores separados por espacios en blanco & txt \\
read\_csv & valores separados por comas & csv \\
read\_csv2 & valores separados por punto y coma & csv \\
read\_tsv & valores separados delimitados por tab & tsv \\
read\_delim & formato de archivo de texto general, debe definir delimitador & txt \\
\bottomrule
\end{longtable}

Aunque el sufijo generalmente nos indica qué tipo de archivo es, no hay garantía de que estos siempre coincidan. Podemos abrir el archivo para echar un vistazo o usar la función \texttt{read\_lines} para ver algunas líneas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read\_lines}\NormalTok{(}\StringTok{"murders.csv"}\NormalTok{, }\AttributeTok{n\_max =} \DecValTok{3}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "state,abb,region,population,total"}
\CommentTok{\#\textgreater{} [2] "Alabama,AL,South,4779736,135"     }
\CommentTok{\#\textgreater{} [3] "Alaska,AK,West,710231,19"}
\end{Highlighting}
\end{Shaded}

Esto también muestra que hay un encabezado. Ahora estamos listos para leer los datos en R. Del sufijo .csv y del vistazo al archivo, sabemos que tenemos que usar \texttt{read\_csv}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(filename)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que recibimos un mensaje informándonos qué tipos de datos se utilizaron para cada columna. También observen que \texttt{dat} es un \texttt{tibble}, no solo un \emph{data frame}. Esto es porque \texttt{read\_csv} es un leedor (\emph{parser} en inglés) del \emph{tidyverse}. Podemos confirmar que los datos se han leído de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{View}\NormalTok{(dat)}
\end{Highlighting}
\end{Shaded}

Finalmente, recuerden que también podemos usar la ruta completa para el archivo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(fullpath)}
\end{Highlighting}
\end{Shaded}

\hypertarget{readxl}{%
\subsection{readxl}\label{readxl}}

Pueden cargar el paquete \textbf{readxl} usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(readxl)}
\end{Highlighting}
\end{Shaded}

El paquete ofrece funciones para leer formatos de Microsoft Excel:

\begin{longtable}[]{@{}lll@{}}
\toprule
Función & Formato & Sufijo típico \\
\midrule
\endhead
read\_excel & detectar automáticamente el formato & xls, xlsx \\
read\_xls & formato original & xls \\
read\_xlsx & nuevo formato & xlsx \\
\bottomrule
\end{longtable}

Los formatos de Microsoft Excel le permiten tener más de una hoja de cálculo en un archivo. Estos se conocen como \emph{hojas} (\emph{sheets} en inglés). Las funciones enumeradas anteriormente leen la primera hoja por defecto, pero también podemos leer las otras. La función \texttt{excel\_sheets} nos da los nombres de todas las hojas en un archivo de Excel. Estos nombres entonces se pueden pasar al argumento \texttt{sheet} en las tres funciones anteriores para leer hojas distintas a la primera.

\hypertarget{ejercicios-13}{%
\section{Ejercicios}\label{ejercicios-13}}

1. Utilice la función \texttt{read\_csv} para leer cada uno de los archivos que el siguiente código guarda en el objeto \texttt{files}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{files }\OtherTok{\textless{}{-}} \FunctionTok{list.files}\NormalTok{(path)}
\NormalTok{files}
\end{Highlighting}
\end{Shaded}

2. Observe que el último, el archivo \texttt{olive}, nos da una advertencia. Esto se debe a que a la primera línea del archivo le falta el encabezado de la primera columna.

Lea la página de ayuda para \texttt{read\_csv} para aprender cómo leer el archivo sin leer este encabezado. Si omite el encabezado, no debería recibir esta advertencia. Guarde el resultado en un objeto llamado \texttt{dat}.

3. Un problema con el enfoque anterior es que no sabemos qué representan las columnas. Escriba:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(dat)}
\end{Highlighting}
\end{Shaded}

para confirmar que los nombres no son informativos.

Utilice la función \texttt{readLines} para leer solo la primera línea (luego aprenderemos cómo extraer valores del \emph{output}).

\hypertarget{cuxf3mo-descargar-archivos}{%
\section{Cómo descargar archivos}\label{cuxf3mo-descargar-archivos}}

Otro lugar común donde residen los datos es en el internet. Cuando estos datos están en archivos, podemos descargarlos y luego importarlos, o incluso leerlos directamente de la web. Por ejemplo, notamos que como nuestro paquete \textbf{dslabs} está en GitHub, el archivo que descargamos con el paquete tiene una URL:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url }\OtherTok{\textless{}{-}} \StringTok{"https://raw.githubusercontent.com/rafalab/dslabs/master/inst/}
\StringTok{extdata/murders.csv"}
\end{Highlighting}
\end{Shaded}

El archivo \texttt{read\_csv} puede leer estos archivos directamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(url)}
\end{Highlighting}
\end{Shaded}

Si quieren tener una copia local del archivo, pueden usar la función \texttt{download.file}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{download.file}\NormalTok{(url, }\StringTok{"murders.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Esto descargará el archivo y lo guardará en su sistema con el nombre \texttt{murders.csv}. Pueden usar cualquier nombre aquí, no necesariamente \texttt{murders.csv}. Recuerden que al usar \texttt{download.file} deben tener cuidado ya que \textbf{sobrescribirá los archivos existentes sin previo aviso}.

Dos funciones que a veces son útiles al descargar datos del internet son \texttt{tempdir} y \texttt{tempfile}. La primera crea un directorio con un nombre aleatorio que es muy probable que sea único. Igualmente, \texttt{tempfile} crea una cadena de caracteres, no un archivo, que probablemente sea un nombre de archivo único. Entonces pueden ejecutar un comando, como el siguiente, que borra el archivo temporero una vez que importe los datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp\_filename }\OtherTok{\textless{}{-}} \FunctionTok{tempfile}\NormalTok{()}
\FunctionTok{download.file}\NormalTok{(url, tmp\_filename)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(tmp\_filename)}
\FunctionTok{file.remove}\NormalTok{(tmp\_filename)}
\end{Highlighting}
\end{Shaded}

\hypertarget{las-funciones-de-importaciuxf3n-de-base-r}{%
\section{Las funciones de importación de base R}\label{las-funciones-de-importaciuxf3n-de-base-r}}

La base R también provee funciones de importación. Estos tienen nombres similares a esas del \emph{tidyverse}, por ejemplo \texttt{read.table}, \texttt{read.csv} y \texttt{read.delim}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat2 }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(filename)}
\end{Highlighting}
\end{Shaded}

\hypertarget{scan}{%
\subsection{\texorpdfstring{\texttt{scan}}{scan}}\label{scan}}

Al leer hojas de cálculo, muchas cosas pueden salir mal. El archivo puede tener un encabezado multilíneal, pueden faltar celdas, o puede usar una codificación inesperada\footnote{\url{https://en.wikipedia.org/wiki/Character_encoding}}. Les recomendamos que lean esta publicación sobre problemas comunes\footnote{\url{https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/}}.

Con experiencia, aprenderán a manejar los diferentes retos. Además, les ayudará leer detenidamente los archivos de ayuda para las funciones que discutimos aquí. Con \texttt{scan} pueden leer cada celda de un archivo, como vemos aquí:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{filename }\OtherTok{\textless{}{-}} \StringTok{"murders.csv"}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\FunctionTok{file.path}\NormalTok{(path, filename), }\AttributeTok{sep=}\StringTok{","}\NormalTok{, }\AttributeTok{what =} \StringTok{"c"}\NormalTok{)}
\NormalTok{x[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\CommentTok{\#\textgreater{}  [1] "state"      "abb"        "region"     "population" "total"     }
\CommentTok{\#\textgreater{}  [6] "Alabama"    "AL"         "South"      "4779736"    "135"}
\end{Highlighting}
\end{Shaded}

Noten que el \emph{tidyverse} incluye \texttt{read\_lines}, una función igualmente útil.

\hypertarget{archivos-de-texto-versus-archivos-binarios}{%
\section{Archivos de texto versus archivos binarios}\label{archivos-de-texto-versus-archivos-binarios}}

En la ciencia de datos, los archivos generalmente se pueden clasificar en dos categorías: archivos de texto (también conocidos como archivos ASCII) y archivos binarios. Ya han trabajado con archivos de texto. Todos sus \emph{scripts} de R son archivos de texto igual que los archivos de R markdown utilizados para crear este libro. Las tablas csv que han leído también son archivos de texto. Una gran ventaja de estos archivos es que podemos ``mirarlos'' fácilmente sin tener que comprar ningún tipo de software especial o seguir instrucciones complicadas. Se puede usar cualquier editor de texto para examinar un archivo de texto, incluyendo los editores disponibles gratuitamente como RStudio, Notepad, textEdit, vi, emacs, nano y pico. Para ver esto, intenten abrir un archivo csv con la herramienta de RStudio \emph{Open file}. Deberían poder ver el contenido directamente en su editor. Sin embargo, si intentan abrir, digamos, un archivo Excel xls, jpg o png, no podrán ver nada inmediatamente útil. Estos son archivos binarios. Los archivos de Excel son carpetas comprimidas con varios archivos de texto dentro de ellas. Pero la principal distinción aquí es que los archivos de texto se pueden examinar fácilmente.

Aunque R incluye herramientas para leer archivos binarios ampliamente utilizados, como archivos xls, en general es mejor encontrar sets de datos almacenados en archivos de texto. Del mismo modo, al compartir datos, es mejor que estén disponibles como archivos de texto siempre que el almacenamiento no sea un problema (los archivos binarios son mucho más eficientes para ahorrar espacio en su disco). En general, los formatos de texto facilitan el intercambio de datos, ya que no requieren software comercial para trabajar con los datos.

Extraer datos de una hoja de cálculo almacenada como un archivo de texto es quizás la forma más fácil de llevar datos de un archivo a una sesión R. Desafortunadamente, las hojas de cálculo no siempre están disponibles y el hecho de que puedan ver los archivos de texto no necesariamente implica que extraer datos de ellos sea sencillo. En la parte del libro ``\emph{Wrangling} de datos'', aprendemos a extraer datos de archivos de texto más complejos, como los archivos HTML.

\hypertarget{unicode-versus-ascii}{%
\section{Unicode versus ASCII}\label{unicode-versus-ascii}}

Un problema en la ciencia de datos es suponer que un archivo es un archivo de texto ASCII cuando en actualidad es otra cosa que puede parecerse mucho a un archivo de texto ASCII: un archivo de texto Unicode.

Para entender la diferencia entre estos, recuerden que todo en una computadora necesita convertirse eventualmente en 0s y 1s. ASCII es una \emph{codificación} (\emph{encoding} en inglés) que define una correspondencia entre caracteres y números. ASCII usa 7 \emph{bits} (0s y 1s) que resulta en \(2^7 = 128\) elementos únicos, suficientes para codificar todos los caracteres en un teclado en inglés. Sin embargo, otros idiomas, como el español, usan caracteres no incluidos en esta codificación. Por ejemplo, las tildes no están codificadas por ASCII. Por esta razón, se definió una nueva codificación que utiliza más de 7 \emph{bits}: Unicode. Cuando se utiliza Unicode, se puede elegir entre 8, 16 y 32 \emph{bits} abreviados UTF-8, UTF-16 y UTF-32 respectivamente. RStudio usa la codificación UTF-8 por defecto.

Aunque no entraremos en detalles sobre cómo lidiar con las diferentes codificaciones aquí, es importante que sepan que existen diferentes codificaciones para que pueden diagnosticar bien un problema si lo encuentran. Una forma en que se manifiestan los problemas es cuando surjen caracteres de ``aspecto extraño'' que no esperaban. Esta discusión de StackOverflow es un ejemplo: \url{https://stackoverflow.com/questions/18789330/r-on-windows-character-encoding-hell}.

\hypertarget{cuxf3mo-organizar-datos-con-hojas-de-cuxe1lculo}{%
\section{Cómo organizar datos con hojas de cálculo}\label{cuxf3mo-organizar-datos-con-hojas-de-cuxe1lculo}}

Aunque este libro se enfoca casi exclusivamente en el análisis de datos, el manejo de datos también es una parte importante de la ciencia de datos. Como explicamos en la introducción, no cubrimos este tema. Sin embargo, los analistas de datos frecuentemente necesitan recopilar datos, o trabajar con otros que recopilan datos, de manera que la forma más conveniente de almacenarlos es en una hoja de cálculo. Aunque completar una hoja de cálculo a mano es una práctica que no recomendamos y preferimos que el proceso se automatice lo más posible, a veces no queda otro remedio. Por lo tanto, en esta sección, ofrecemos recomendaciones sobre cómo organizar los datos en una hoja de cálculo. Aunque hay paquetes R diseñados para
leer hojas de cálculo de Microsoft Excel, generalmente queremos evitar este formato. Recomendamos \emph{Google Sheets} como una herramienta de software gratuita. Abajo resumimos las recomendaciones hechas en una publicación de Karl Broman y Kara Woo\footnote{\url{https://www.tandfonline.com/doi/abs/10.1080/00031305.2017.1375989}}.
Favor de leer el artículo completo para más detalles importantes.

\begin{itemize}
\tightlist
\item
  \textbf{Sea coherente} - Antes de empezar a ingresar datos, tenga un plan. Una vez lo tenga, sea consistente y sígalo.
\item
  \textbf{Elija buenos nombres para las cosas}: Los nombres que elije para los objetos, los archivos y los directorios deben ser memorables, fáciles de deletrear y descriptivos. Este es un equilibrio difícil de lograr y requiere tiempo y reflexión. Una regla importante a seguir es \textbf{no usar espacios}; en su lugar, usen guiones bajos \texttt{\_} o guiones \texttt{-}. Además, evite los símbolos; es mejor utilizar las letras y los números.
\item
  \textbf{Escriba fechas como AAAA-MM-DD} - Para evitar confusión, recomendamos utilizar el estándar global ISO 8601.
\item
  \textbf{Evite las celdas vacías} - Llene todas las celdas y use un código común para los datos faltantes.
\item
  \textbf{Ponga solo una cosa en cada celda} - Es mejor añadir columnas para almacenar la información adicional en vez de tener más de una pieza de información en una celda.
\item
  \textbf{Hazlo un rectángulo} - La hoja de cálculo debe ser un rectángulo.
\item
  \textbf{Cree un diccionario de datos} - Si necesita explicar cosas, por ejemplo cuáles son las columnas o cuáles son las etiquetas utilizadas para las variables categóricas, hágalo en un archivo separado.
\item
  \textbf{No haga cálculos en los archivos de datos sin procesar} - Excel le permite realizar cálculos. No haga esto parte de su hoja de cálculo. El código para los cálculos debe estar en un \emph{script}.
\item
  \textbf{No use color o resaltado como datos} - La mayoría de funciones de importación no pueden importar esta información. En cambio, codifique esta información como una variable.
\item
  \textbf{Respalde su información}: Respalde sus datos frecuentemente.
\item
  \textbf{Utilice la validación de datos para evitar errores} - Aproveche las herramientas en su software de hoja de cálculo para que el proceso sea lo más libre posible de errores y de lesiones por estrés repetitivo.
\item
  \textbf{Guarde los datos como archivos de texto} - Guarde los archivos para compartir en formato delimitado por comas o \emph{tabs}.
\end{itemize}

\hypertarget{ejercicios-14}{%
\section{Ejercicios}\label{ejercicios-14}}

1. Elija una medida que pueda tomar regularmente. Por ejemplo, su peso diario o cuánto tiempo le toma correr 8 kilometros. Mantenga una hoja de cálculo que incluya la fecha, la hora, la medición y cualquier otra variable informativa que considere valiosa. Haga esto por 2 semanas. Luego haga un gráfico.

\hypertarget{part-visualizaciuxf3n-de-datos}{%
\part{Visualización de datos}\label{part-visualizaciuxf3n-de-datos}}

\hypertarget{introducciuxf3n-a-la-visualizaciuxf3n-de-datos}{%
\chapter{Introducción a la visualización de datos}\label{introducciuxf3n-a-la-visualizaciuxf3n-de-datos}}

Raras veces es útil mirar los números y las cadenas de caracteres que definen un set de datos. Para confirmar esto, impriman y miren la tabla de datos de asesinatos de Estados Unidos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\FunctionTok{head}\NormalTok{(murders)}
\CommentTok{\#\textgreater{}        state abb region population total}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65}
\end{Highlighting}
\end{Shaded}

¿Qué aprenden de ver esta tabla? ¿Cuán rápido pueden determinar qué estados tienen las poblaciones más grandes? ¿Qué estados tienen las más pequeñas? ¿Cuán grande es un estado típico? ¿Existe una relación entre el tamaño de la población y el total de asesinatos? ¿Cómo varían las tasas de asesinatos entre las regiones del país? Para la mayoría de cerebros humanos, es bastante difícil extraer esta información simplemente mirando los números. En cambio, las respuestas a todas las preguntas anteriores están fácilmente disponibles al examinar este gráfico:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-plot-0-1} \end{center}

Esto nos recuerda del dicho ``una imagen vale más que mil palabras''. La visualización de datos ofrece una forma muy efectiva de comunicar hallazgos basados en datos. En algunos casos, la visualización es tan convincente que no requiere un análisis de seguimiento.

La creciente disponibilidad de sets de datos informativos y de herramientas de software ha conducido a una mayor dependencia de la visualizacion de datos en muchas industrias, academias y gobiernos. Un ejemplo destacado son las organizaciones de noticias, que están adoptando cada vez más el \emph{periodismo de datos} e incluyendo \emph{infografías} eficaces como parte de sus informes.

Un ejemplo particularmente efectivo es un artículo del Wall Street Journal\footnote{\url{http://graphics.wsj.com/infectious-diseases-and-vaccines/?mc_cid=711ddeb86e}} que muestra datos relacionados con el impacto de las vacunas en la lucha contra las enfermedades infecciosas. Uno de los gráficos muestra los casos de sarampión por estado de EE. UU. a lo largo de los años con una línea vertical que indica cuándo se introdujo la vacuna.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/wsj-vaccines-example-1} \end{center}

Otro ejemplo notable proviene de un gráfico del New York Times\footnote{\url{http://graphics8.nytimes.com/images/2011/02/19/nyregion/19schoolsch/19schoolsch-popup.gif}} que resume los resultados de los exámenes de los Regentes de la ciudad de Nueva York. Según el artículo\footnote{\url{https://www.nytimes.com/2011/02/19/nyregion/19schools.html}}, estas puntuaciones se recopilan por varias razones, incluso para determinar si un estudiante se gradúa de escuela secundaria. En la ciudad de Nueva York, se necesita una puntuación mínima de 65 para aprobar. La distribución de las puntuaciones de las pruebas nos obliga a notar algo un poco problemático:

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/regents-exams-example-1} \end{center}

La puntuación de prueba más común es la calificación mínima para aprobar, con muy pocas puntuaciones justo por debajo del umbral. Este resultado inesperado es consistente con el aumento de la puntuación de los estudiantes cerca de aprobar, pero sin obtener el mínimo de 65.

Este es un ejemplo de cómo la visualización de datos puede conducir a descubrimientos que de otro modo se perderían si simplemente sometiéramos los datos a una serie de herramientas o procedimientos de análisis de datos. La visualización de datos es la herramienta más efectiva de lo que llamamos el \emph{análisis exploratorio de datos} (EDA por sus siglas en inglés). John W. Tukey\footnote{\url{https://en.wikipedia.org/wiki/John_Tukey}}, considerado el padre de EDA, una vez dijo:

\begin{quote}
\begin{quote}
``El mayor valor de una imagen es cuando nos obliga a notar lo que nunca esperábamos ver.''
\end{quote}
\end{quote}

Muchas de las herramientas de análisis de datos más ampliamente utilizadas fueron inicialmente desarolladas gracias al EDA. Este es quizás la parte más importante del análisis de datos, pero a menudo se ignora.

La visualización de datos ahora también es omnipresente en organizaciones filantrópicas y educativas. En las conferencias ``New Insights on Poverty''\footnote{\url{https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en}} y ``The Best Stats You've Never Seen''\footnote{\url{https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen}}, Hans Rosling nos obliga a notar lo inesperado con una serie de gráficos relacionados con la salud y la economía mundial. En sus videos, Rosling usa unos gráficos animados para demostrar cómo el mundo está cambiando y cómo las viejas narrativas ya no son ciertas.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/gampnider-example-plot-1} \end{center}

También es importante recordar que las equivocaciones, los prejuicios, los errores sistemáticos y otros problemas inesperados a menudo conducen a datos que se deben analizar con cuidado. No descubrir estos problemas puede dar lugar a análisis defectuosos y descubrimientos falsos. Como ejemplo, consideren que los instrumentos de medición a veces fallan y que la mayoría de los procedimientos de análisis de datos no están diseñados para detectarlos.
Sin embargo, estos procedimientos aún le darán una respuesta. El hecho de que puede ser difícil, o hasta imposible, notar un error solo a partir de los resultados que se reportan hace que la visualización de datos sea particularmente importante.

En esta parte del libro aprenderemos los conceptos básicos de la visualización de datos y del análisis exploratorio de datos mediante el uso de tres ejemplos motivantes. Usaremos el paquete \textbf{ggplot2} para codificar. Para aprender los conceptos básicos, utilizaremos un ejemplo algo artificial: alturas reportadas por estudiantes. Entonces discutiremos dos ejemplos mencionados anteriormente: 1) la salud y economía mundial y 2) las tendencias de enfermedades infecciosas en Estados Unidos.

Por supuesto, la visualización de datos es mucho más de lo que cubrimos aquí. A continuación ofrecemos unas referencias para los que quieran aprender más:

\begin{itemize}
\tightlist
\item
  ER Tufte (1983) The visual display of quantitative information. Graphics Press.
\item
  ER Tufte (1990) Envisioning information. Graphics Press.
\item
  ER Tufte (1997) Visual explanations. Graphics Press.
\item
  WS Cleveland (1993) Visualizing data. Hobart Press.
\item
  WS Cleveland (1994) The elements of graphing data. CRC Press.
\item
  A Gelman, C Pasarica, R Dodhia (2002) Let's practice what we preach: Turning tables into graphs. The American Statistician 56:121-130.
\item
  NB Robbins (2004) Creating more effective graphs. Wiley.
\item
  A Cairo (2013) The functional art: An introduction to information graphics and visualization. New Riders.
\item
  N Yau (2013) Data points: Visualization that means something. Wiley.
\end{itemize}

Finalmente, no discutiremos gráficos interactivos, un tema demasiado avanzado para este libro. Abajo incluímos algunos recursos útiles para aquellos interesados en aprender más sobre ese tema:

\begin{itemize}
\tightlist
\item
  \href{https://shiny.rstudio.com/}{https://shiny.rstudio.com}
\item
  \href{https://d3js.org/}{https://d3js.org}
\end{itemize}

\hypertarget{ggplot2}{%
\chapter{ggplot2}\label{ggplot2}}

La visualización de datos exploratorios es quizás la mayor ventaja de R. Uno puede pasar rápidamente de la idea a los datos al gráfico con un equilibrio único de flexibilidad y facilidad. Por ejemplo, Excel puede ser más fácil que R para algunos gráficos, pero no es tan flexible. D3.js puede ser más flexible y poderoso que R, pero se tarda mucho más en generar una gráfico.

A lo largo del libro, crearemos gráficos usando el paquete \textbf{ggplot2}\footnote{\url{https://ggplot2.tidyverse.org/}}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\FunctionTok{library}\NormalTok{(ggplot2)}
\end{Highlighting}
\end{Shaded}

Hay muchas opciones para graficar disponibles en R. De hecho, las capacidades para graficar que vienen con una instalación básica de R ya son bastante útiles. También hay otros paquetes para crear gráficos como \textbf{grid} y \textbf{lattice}. En este libro decidimos usar \textbf{ggplot2} porque divide los gráficos en componentes de una manera que le permite a los principiantes crear gráficos relativamente complejos y estéticamente agradables utilizando una sintaxis intuitiva y relativamente fácil de recordar.

Una razón por la cual \textbf{ggplot2} es generalmente más intuitiva para los principiantes es porque usa una gramática de gráficos\footnote{\url{http://www.springer.com/us/book/9780387245447}}, el \emph{gg} de \textbf{ggplot2}. Esto es análogo a la forma en que aprender gramática puede ayudar a un estudiante construir cientos de oraciones diferentes al aprender solo una pequeña cantidad de verbos, sustantivos y adjetivos, en vez de memorizar cada oración específica. Del mismo modo, al aprender una pequeña cantidad de los componentes básicos de \textbf{ggplot2} y de su gramática, podrán crear cientos de gráficos diferentes.

Otra razón por la cual \textbf{ggplot2} es fácil para los principiantes es que su comportamiento por defecto se ha elegido cuidadosamente para satisfacer la gran mayoría de los casos y, además, es visualmente agradable. Como resultado, es posible crear gráficos informativos y elegantes con un código relativamente sencillo y legible.

Una limitación de \textbf{ggplot2} es que está diseñado para trabajar exclusivamente con tablas de datos en formato \emph{tidy} (donde las filas son observaciones y las columnas son variables). Sin embargo, un porcentaje sustancial de sets de datos con los que los principiantes trabajan están en este formato o pueden convertirse a tal. Una ventaja de este enfoque es que, con tal que nuestros datos estén \emph{tidy}, \textbf{ggplot2} simplifica el código de graficar y el aprendizaje de gramática para una variedad de gráficos.

Para usar \textbf{ggplot2}, tendrán que aprender varias funciones y argumentos. Estos son difíciles de memorizar, por lo que les recomendamos que tengan a mano la hoja de referencia de ggplot2. Pueden obtener una copia en línea\footnote{\url{https://github.com/rstudio/cheatsheets/raw/master/translations/spanish/ggplot2.pdf}} o simplemente realizar una búsqueda en internet de ``ggplot2 cheat sheet''.

\hypertarget{los-componentes-de-un-gruxe1fico}{%
\section{Los componentes de un gráfico}\label{los-componentes-de-un-gruxe1fico}}

Construiremos un gráfico como el siguiente, que resume el set de datos de asesinatos con armas de fuego en Estados Unidos:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-plot-1} \end{center}

Podemos ver claramente cuánto varían los estados según el tamaño de la población y el número total de asesinatos. No es sorprendente que también se observe una relación clara entre los totales de asesinatos y el tamaño de la población. Un estado que cae en la línea discontinua gris tiene la misma tasa de asesinatos que el promedio de EE. UU. Las cuatro regiones geográficas se denotan con color, que señala cómo la mayoría de los estados del sur tienen tasas de asesinatos por encima del promedio.

Esta visualización de datos nos muestra prácticamente toda la información de la tabla de datos. El código necesario para hacer el gráfico es relativamente sencillo. Aprenderemos a crearlo parte por parte.

El primer paso para aprender \textbf{ggplot2} es poder separar un gráfico en componentes. Empezaremos analizando el gráfico anterior e introduciendo algo de la terminología de \textbf{ggplot2}. Los tres componentes principales para considerar son:

\begin{itemize}
\tightlist
\item
  \textbf{Data}: Se está resumiendo el set de datos de asesinatos con armas de Estados Unidos. Nos referimos a esto como el componente \textbf{data}.
\item
  \textbf{Geometría}: El gráfico anterior es un diagrama de dispersión. Esto se denomina el componente de \textbf{geometría}. Otras posibles geometrías son diagrama de barras, histograma, densidades suaves (\emph{smooth densities} en inglés), gráfico Q-Q y diagrama de cajas.
\item
  \textbf{Mapeo estético}: El gráfico usa varias señales visuales para representar la información proveída por el set de datos. Las dos señales más importantes en este gráfico son las posiciones de los puntos en el eje-x y el eje-y, que representan el tamaño de la población y el número total de asesinatos, respectivamente. Cada punto representa una observación diferente, y \emph{mapeamos} los datos de estas observaciones y las señales visuales a las escalas x e y. El color es otra señal visual que asignamos a la región. Nos referimos a esto como el componente de \textbf{mapeo estético}. La forma en que definimos el mapeo depende de qué \textbf{geometría} estamos usando.
\end{itemize}

También observamos que:

\begin{itemize}
\tightlist
\item
  Los puntos están etiquetados con las abreviaturas de los estados.
\item
  El rango del eje-x y el eje-y parece estar definido por el rango de los datos. Ambos están en escalas logarítmicas.
\item
  Hay etiquetas, un título, una leyenda y utilizamos el estilo de la revista ``The Economist''.
\end{itemize}

Ahora construiremos el gráfico parte por parte. Comenzemos cargando el set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\hypertarget{objetos-ggplot}{%
\section{\texorpdfstring{Objetos \texttt{ggplot}}{Objetos ggplot}}\label{objetos-ggplot}}

El primer paso para crear un gráfico \textbf{ggplot2} es definir un objeto \texttt{ggplot}. Hacemos esto con la función \texttt{ggplot}, que inicializa el gráfico. Si leemos la página de ayuda para esta función, vemos que el primer argumento se usa para especificar qué datos están asociados con este objeto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(}\AttributeTok{data =}\NormalTok{ murders)}
\end{Highlighting}
\end{Shaded}

También podemos \emph{pipe} los datos como primer argumento. Entonces, esta línea de código es equivalente a la anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-2-1} \end{center}

El código crea un gráfico, en este caso una pizarra en blanco ya que no se ha definido la geometría. La única opción de estilo que vemos es un fondo gris.

Lo que sucedió es que el objeto fue creado y, debido a que no fue asignado, se evaluó automáticamente. Pero podemos asignar nuestro gráfico a un objeto, por ejemplo así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(}\AttributeTok{data =}\NormalTok{ murders)}
\FunctionTok{class}\NormalTok{(p)}
\CommentTok{\#\textgreater{} [1] "gg"     "ggplot"}
\end{Highlighting}
\end{Shaded}

Para representar el gráfico asociado con este objeto, simplemente imprimimos el objeto \texttt{p}. Cada una de las siguientes dos líneas de código produce el mismo gráfico que vemos arriba:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(p)}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\hypertarget{geometruxedas}{%
\section{Geometrías}\label{geometruxedas}}

En \texttt{ggplot2} creamos gráficos agregando \emph{capas} (\emph{layers} en inglés). Las capas pueden definir geometrías, calcular estadísticas de resumen, definir qué escalas (\emph{scales} en inglés) usar o incluso cambiar estilos. Para añadir capas, usamos el símbolo \texttt{+}. En general, una línea de código se verá así:

\begin{quote}
\begin{quote}
DATOS\%\textgreater\% \texttt{ggplot()} + CAPA 1 + CAPA 2 + \ldots{} + CAPA N
\end{quote}
\end{quote}

Usualmente, la primera capa que agregamos define la geometría. Queremos hacer un diagrama de dispersión. ¿Qué geometría debemos utilizar?

Echando un vistazo rápido a la hoja de referencia, vemos que la función utilizada para crear gráficos con esta geometría es \texttt{geom\_point}.

\begin{center}\includegraphics[width=0.45\linewidth]{R/img/ggplot2-cheatsheeta} \includegraphics[width=0.45\linewidth]{R/img/ggplot2-cheatsheetb} \end{center}

(Imagen cortesía de RStudio\footnote{\url{https://github.com/rstudio/cheatsheets}}. Licencia CC-BY-4.0\footnote{\url{https://github.com/rstudio/cheatsheets/blob/master/LICENSE}}.)

Los nombres de las funciones de geometría siguen el patrón: \texttt{geom\_X} donde X es el nombre de la geometría. Algunos ejemplos incluyen \texttt{geom\_point}, \texttt{geom\_bar} y \texttt{geom\_histogram}.

Para que \texttt{geom\_point} funcione bien, necesitamos proveer datos y una correspondencia. Ya hemos conectado el objeto \texttt{p} con la tabla de datos \texttt{murders} y si agregamos la capa \texttt{geom\_point}, esta por defecto usa los datos de asesinatos. Para saber qué correspondencias se esperan, lean la Sección \textbf{Aesthetics} de la página de ayuda de \texttt{geom\_point}:

\begin{verbatim}
> Aesthetics
>
> geom_point understands the following aesthetics (required aesthetics are in bold):
>
> x
>
> y
>
> alpha
>
> colour
\end{verbatim}

y, como se esperaba, vemos que se requieren al menos dos argumentos: \texttt{x} e \texttt{y}.

\hypertarget{mapeos-estuxe9ticos}{%
\section{Mapeos estéticos}\label{mapeos-estuxe9ticos}}

Los \textbf{mapeos estéticos} (\emph{aesthetic mappings} en inglés) describen cómo las propiedades de los datos se conectan con las características del gráfico, como la distancia a lo largo de un eje, el tamaño o el color. La función \texttt{aes} conecta los datos con lo que vemos en el gráfico mediante la definición de asignaciones estéticas y, por eso, será una de las funciones que más utilizarán al graficar. El resultado de la función \texttt{aes} a menudo se utiliza como argumento de una función de geometría. Este ejemplo produce un diagrama de dispersión de asesinatos totales versus población en millones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, }\AttributeTok{y =}\NormalTok{ total))}
\end{Highlighting}
\end{Shaded}

Podemos quitar el \texttt{x\ =} e \texttt{y\ =} si quisiéramos ya que estos son el primer y el segundo argumento esperado, como se ve en la página de ayuda.

En lugar de definir nuestro gráfico desde cero, podemos añadir una capa al objeto \texttt{p} que se definió anteriormente como \texttt{p\ \textless{}-\ ggplot(data\ =\ murders)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-3-1} \end{center}

La escala y las etiquetas se definen por defecto al agregar esta capa. Al igual que las funciones de \textbf{dplyr}, \texttt{aes} también usa los nombres de variables del componente objeto: podemos usar \texttt{population} y \texttt{total} sin tener que llamarlos como \texttt{murders\$population} and \texttt{murders\$total}. El comportamiento de reconocer las variables del componente de datos es específico a \texttt{aes}. Con la mayoría de las funciones, si intentan acceder a los valores de \texttt{population} o \texttt{total} fuera de \texttt{aes}, recibirán un error.

\hypertarget{capas}{%
\section{Capas}\label{capas}}

Una segunda capa en el gráfico que queremos hacer implica añadir una etiqueta a cada punto para identificar el estado. Las funciones \texttt{geom\_label} y \texttt{geom\_text} nos permiten añadir texto al gráfico con o sin un rectángulo detrás del texto, respectivamente.

Debido a que cada punto (cada estado en este caso) tiene una etiqueta, necesitamos un mapeo estético para hacer la conexión entre los puntos y las etiquetas. Al leer la página de ayuda, aprendemos que el mapeo entre el punto y la etiqueta se provee a través del argumento \texttt{label} de \texttt{aes}. Entonces el código se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total)) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-4-1} \end{center}

Hemos agregado exitosamente una segunda capa al gráfico.

Como ejemplo del comportamiento único de \texttt{aes} mencionado anteriormente, observen que esta llamada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_test }\OtherTok{\textless{}{-}}\NormalTok{ p }\SpecialCharTok{+} \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb))}
\end{Highlighting}
\end{Shaded}

está bien, mientras que esta llamada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_test }\OtherTok{\textless{}{-}}\NormalTok{ p }\SpecialCharTok{+} \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total), }\AttributeTok{label =}\NormalTok{ abb)}
\end{Highlighting}
\end{Shaded}

les dará un error ya que \texttt{abb} no se encuentra porque está fuera de la función \texttt{aes}. La capa \texttt{geom\_text} no sabe dónde encontrar \texttt{abb} porque es un nombre de columna y no una variable global.

\hypertarget{cuxf3mo-probar-varios-argumentos}{%
\subsection{Cómo probar varios argumentos}\label{cuxf3mo-probar-varios-argumentos}}

Cada función de geometría tiene muchos otros argumentos además de \texttt{aes} y \texttt{data}. Estos suelen ser específicos de la función. Por ejemplo, en el gráfico que queremos hacer, los puntos son más grandes que el tamaño predeterminado. En el archivo de ayuda vemos que \texttt{size} es una estética y se puede cambiar así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total), }\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-5-1} \end{center}

\texttt{size} \textbf{no} es un mapeo: mientras los mapeos usan datos de observaciones específicas y necesitan estar dentro de \texttt{aes()}, las operaciones que queremos que afecten a todos los puntos de la misma manera no necesitan ser incluidas dentro \texttt{aes}.

Ahora, debido a que los puntos son más grandes, es difícil ver las etiquetas. Si leemos la página de ayuda para \texttt{geom\_text}, vemos que el argumento \texttt{nudge\_x} mueve el texto ligeramente hacia la derecha o hacia la izquierda:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total), }\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb), }\AttributeTok{nudge\_x =} \FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-6-1} \end{center}

Esto es preferible puesto que facilita la lectura del texto. En la Sección \ref{add-on-packages}, aprenderemos una mejor manera de asegurarnos de que podemos ver los puntos y las etiquetas.

\hypertarget{mapeos-estuxe9ticos-globales-versus-locales}{%
\section{Mapeos estéticos globales versus locales}\label{mapeos-estuxe9ticos-globales-versus-locales}}

En la línea anterior de código, definimos el mapeo \texttt{aes(population/10\^{}6,\ total)} dos veces, una vez en cada geometría. Podemos evitar esto usando un mapeo estético \emph{global} cuando definimos la pizarra en blanco que nos da el objeto \texttt{ggplot}. Recuerden que la función \texttt{ggplot} contiene un argumento que nos permite definir mapeos estéticos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(ggplot)}
\CommentTok{\#\textgreater{} function (data = NULL, mapping = aes(), ..., environment = parent.frame()) }
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

Si definimos un mapeo en \texttt{ggplot}, todas las geometrías que se agregan como capas se asignarán por defecto a este mapeo. Redefinimos \texttt{p}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb))}
\end{Highlighting}
\end{Shaded}

y entonces podemos simplemente escribir el siguiente código para producir el gráfico anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x =} \FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Mantenemos los argumentos \texttt{size} y \texttt{nudge\_x} en \texttt{geom\_point} y \texttt{geom\_text}, respectivamente, porque solo queremos aumentar el tamaño de los puntos y ajustar la posición (\emph{nudge} en inglés) de las etiquetas. Si ponemos esos argumentos en \texttt{aes}, entonces se aplicarán a ambos gráficos. También tengan en cuenta que la función \texttt{geom\_point} no necesita un argumento \texttt{label} y por lo tanto ignora esa estética.

Si es necesario, podemos anular el mapeo global definiendo un nuevo mapeo dentro de cada capa. Estas definiciones \emph{locales} reemplazan a las \emph{globales}. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =} \DecValTok{10}\NormalTok{, }\AttributeTok{y =} \DecValTok{800}\NormalTok{, }\AttributeTok{label =} \StringTok{"Hello there!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-8-1} \end{center}

Claramente, la segunda llamada a \texttt{geom\_text} no usa \texttt{population} y \texttt{total}.

\hypertarget{escalas}{%
\section{Escalas}\label{escalas}}

Primero, las escalas que queremos están en escala logarítmica. Este no es el valor predeterminado, por lo que este cambio debe añadirse a través de una capa de \emph{escalas}. Una mirada rápida a la hoja de referencia revela que la función \texttt{scale\_x\_continuous} nos permite controlar el comportamiento de las escalas. La usamos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x =} \FloatTok{0.05}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log10"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log10"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-9-1} \end{center}

Debido a que ahora estamos en la escala logarítmica, el ajuste a la posición debe hacerse más pequeño.

Esta transformación particular es tan común que \textbf{ggplot2} ofrece dos funciones especializadas \texttt{scale\_x\_log10} y \texttt{scale\_y\_log10}, que podemos usar para reescribir el código de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x =} \FloatTok{0.05}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_log10}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{etiquetas-y-tuxedtulos}{%
\section{Etiquetas y títulos}\label{etiquetas-y-tuxedtulos}}

Del mismo modo, la hoja de referencia revela que para cambiar las etiquetas y añadir un título, utilizamos las siguientes funciones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x =} \FloatTok{0.05}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Populations in millions (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Total number of murders (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"US Gun Murders in 2010"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-10-1} \end{center}

¡Casi terminamos! Lo único que nos falta es añadir color, leyenda y cambios opcionales al estilo.

\hypertarget{categoruxedas-como-colores}{%
\section{Categorías como colores}\label{categoruxedas-como-colores}}

Podemos cambiar el color de los puntos usando el argumento \texttt{col} en la función \texttt{geom\_point}. Para facilitar la demostración de características nuevas, redefiniremos \texttt{p} para ser todo excepto la capa de puntos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb)) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x =} \FloatTok{0.05}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Populations in millions (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Total number of murders (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"US Gun Murders in 2010"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y luego probaremos lo que sucede cuando agregamos diferentes llamadas a \texttt{geom\_point}. Por ejemplo, podemos hacer que todos los puntos sean azules agregando el argumento \texttt{color}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{color =}\StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-11-1} \end{center}

Sin embargo, no queremos esto. Queremos asignar color según la región geográfica. Un buen comportamiento por defecto de \textbf{ggplot2} es que si asignamos una variable categórica al color, automáticamente asigna un color diferente a cada categoría, además de una leyenda.

Dado que la elección del color está determinada por una característica de cada observación, este es un mapeo estético. Para asignar un color a cada punto, necesitamos usar \texttt{aes}. Usamos el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{col=}\NormalTok{region), }\AttributeTok{size =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-12-1} \end{center}

Los mapeos \texttt{x} e \texttt{y} se heredan de esos ya definidos en \texttt{p}, así que no los redefinimos. También movemos \texttt{aes} al primer argumento, dado que ahí es donde se esperan los mapeos en esta llamada.

Aquí vemos otro comportamiento útil por defecto: \textbf{ggplot2} automáticamente agrega una leyenda que asigna el color a la región. Si no quieren añadir esta leyenda, establecemos el argumento \texttt{geom\_point} como \texttt{show.legend\ =\ FALSE}.

\hypertarget{anotaciuxf3n-formas-y-ajustes}{%
\section{Anotación, formas y ajustes}\label{anotaciuxf3n-formas-y-ajustes}}

A menudo queremos añadir formas o anotaciones a las figuras que no se derivan directamente del mapeo estético; algunos ejemplos incluyen etiquetas, cuadros, áreas sombreadas y líneas.

Aquí queremos añadir una línea que represente la tasa promedio de asesinatos en todo el país. Una vez que determinemos la tasa por millón a ser \(r\), esta línea se define por la fórmula: \(y = r x\), con \(y\) y \(x\) nuestros ejes: asesinatos totales y población en millones, respectivamente. En la escala logarítmica, esta línea se convierte en: \(\log(y) = \log(r) + \log(x)\). Entonces, en nuestro gráfico, es una línea con pendiente 1 e intercepto \(\log(r)\). Para calcular este valor, utilizamos nuestros conocimientos de \textbf{dplyr}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{rate =} \FunctionTok{sum}\NormalTok{(total)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(population) }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(rate)}
\end{Highlighting}
\end{Shaded}

Para añadir una línea, usamos la función \texttt{geom\_abline}. \textbf{ggplot2} utiliza \texttt{ab} en el nombre para recordarnos que estamos suministrando el intercepto (\texttt{a}) y el pendiente (\texttt{b}). La línea predeterminada tiene pendiente 1 e intercepto 0, por lo que solo tenemos que definir el intercepto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{col=}\NormalTok{region), }\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \FunctionTok{log10}\NormalTok{(r))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-example-13-1} \end{center}

Aquí \texttt{geom\_abline} no utiliza ninguna información del objeto de datos.

Podemos cambiar el tipo de línea y el color de las líneas usando argumentos. Además, la dibujamos primero para que no tape nuestros puntos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ p }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \FunctionTok{log10}\NormalTok{(r), }\AttributeTok{lty =} \DecValTok{2}\NormalTok{, }\AttributeTok{color =} \StringTok{"darkgrey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{col=}\NormalTok{region), }\AttributeTok{size =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Noten que hemos redefinido \texttt{p} y usaremos esta nueva \texttt{p} a continuación y en la siguiente sección.

Los gráficos por defecto creados por \textbf{ggplot2} ya son muy útiles. Sin embargo, con frecuencia necesitamos hacer pequeños ajustes al comportamiento predeterminado. Aunque no siempre es obvio cómo hacer esto aun con la hoja de referencia, \textbf{ggplot2} es muy flexible.

Por ejemplo, podemos hacer cambios a la leyenda a través de la función \texttt{scale\_color\_discrete}. En nuestro gráfico original, la palabra \emph{region} está en mayúscula y podemos cambiarla así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ p }\SpecialCharTok{+} \FunctionTok{scale\_color\_discrete}\NormalTok{(}\AttributeTok{name =} \StringTok{"Region"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-on-packages}{%
\section{Paquetes complementarios}\label{add-on-packages}}

El poder de \textbf{ggplot2} se incrementa aún más debido a la disponibilidad de paquetes adicionales. Los cambios restantes necesarios para darle los toques finales a nuestro gráfico requieren los paquetes \textbf{ggthemes} y \textbf{ggrepel}.

El estilo de un gráfico \textbf{ggplot2} se puede cambiar usando las funciones de \texttt{theme}. Se incluyen varios temas (\emph{themes} en inglés) como parte del paquete \textbf{ggplot2}. De hecho, para la mayoría de los gráficos de este libro, utilizamos una función del paquete \textbf{dslabs} que automáticamente establece un tema por defecto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ds\_theme\_set}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{ggthemes} añade muchos otros temas, incluso el tema \texttt{theme\_economist} que escogimos. Después de instalar el paquete, pueden cambiar el estilo agregando una capa como la siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggthemes)}
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{theme\_economist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Pueden ver cómo se ven algunos de los otros temas simplemente cambiando la función. Por ejemplo, pueden probar el tema \texttt{theme\_fivethirtyeight()} en vez del anterior.

La diferencia final tiene que ver con la posición de las etiquetas. En nuestro gráfico, algunas de las etiquetas se superponen. El paquete de complementos \textbf{ggrepel} incluye una geometría que añade etiquetas a la vez que garantiza que no se superpongan entre sí. Para utilizarla, simplemente cambiamos \texttt{geom\_text} a \texttt{geom\_text\_repel}.

\hypertarget{cuxf3mo-combinarlo-todo}{%
\section{Cómo combinarlo todo}\label{cuxf3mo-combinarlo-todo}}

Ahora que hemos terminado las pruebas, podemos escribir un código que produzca nuestro gráfico deseado partiendo de cero.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggthemes)}
\FunctionTok{library}\NormalTok{(ggrepel)}

\NormalTok{r }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{rate =} \FunctionTok{sum}\NormalTok{(total)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(population) }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(rate)}

\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, total, }\AttributeTok{label =}\NormalTok{ abb)) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \FunctionTok{log10}\NormalTok{(r), }\AttributeTok{lty =} \DecValTok{2}\NormalTok{, }\AttributeTok{color =} \StringTok{"darkgrey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{col=}\NormalTok{region), }\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text\_repel}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_log10}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Populations in millions (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Total number of murders (log scale)"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"US Gun Murders in 2010"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_color\_discrete}\NormalTok{(}\AttributeTok{name =} \StringTok{"Region"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme\_economist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/final-ggplot-example-1} \end{center}

\hypertarget{qplot}{%
\section{\texorpdfstring{Gráficos rápidos con \texttt{qplot}}{Gráficos rápidos con qplot}}\label{qplot}}

Hemos aprendido las técnicas eficaces \textbf{ggplot2} para generar visualizaciones. Sin embargo, hay casos en que sólo necesitamos un gráfico rápido de, por ejemplo, un histograma de los valores en un vector, un diagrama de dispersión de los valores en dos vectores o un diagrama de caja usando vectores categóricos y numéricos. Ya hemos demostrado cómo generar estos gráficos con \texttt{hist}, \texttt{plot} y \texttt{boxplot}. Sin embargo, si queremos ser consistentes con el estilo de ggplot, podemos usar la función \texttt{qplot}.

Si tenemos valores en dos vectores como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(murders)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{log10}\NormalTok{(murders}\SpecialCharTok{$}\NormalTok{population)}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ murders}\SpecialCharTok{$}\NormalTok{total}
\end{Highlighting}
\end{Shaded}

y queremos hacer un diagrama de dispersión con \textbf{ggplot2}, tendríamos que escribir algo como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x, }\AttributeTok{y =}\NormalTok{ y) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Esto parece ser demasiado código para una gráfico tan sencillo. La función \texttt{qplot} sacrifica la flexibilidad ofrecida por el enfoque de \textbf{ggplot2}, pero nos permite rápidamente generar un gráfico.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

Aprenderemos más sobre \texttt{qplot} en la Sección \ref{other-geometries}

\hypertarget{cuadruxedculas-de-gruxe1ficos}{%
\section{Cuadrículas de gráficos}\label{cuadruxedculas-de-gruxe1ficos}}

A menudo tenemos que poner gráficos uno al lado del de otro. El paquete \textbf{gridExtra} nos permite hacer eso:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(gridExtra)}
\NormalTok{p1 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(x)}
\NormalTok{p2 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(x,y)}
\FunctionTok{grid.arrange}\NormalTok{(p1, p2, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/gridExtra-example-1} \end{center}

\hypertarget{ejercicios-15}{%
\section{Ejercicios}\label{ejercicios-15}}

Comience cargando los paquetes \textbf{dplyr} y \textbf{ggplot2}, así como los datos \texttt{murders} y \texttt{heights}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\FunctionTok{library}\NormalTok{(ggplot2)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

1. Con \textbf{ggplot2}, los gráficos se pueden guardar como objetos. Por ejemplo, podemos asociar un set de datos con un objeto de gráfico así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(}\AttributeTok{data =}\NormalTok{ murders)}
\end{Highlighting}
\end{Shaded}

Como \texttt{data} es el primer argumento, no necesitamos explicarlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

y también podemos usar el \emph{pipe}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

¿Cuál es la clase del objeto \texttt{p}?

2. Recuerde que para imprimir un objeto puede usar el comando \texttt{print} o simplemente escribir el objeto. Imprima el objeto \texttt{p} definido en el ejercicio uno y describa lo que ve.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  No pasa nada.
\item
  Una gráfico de pizarra en blanco.
\item
  Un diagrama de dispersión.
\item
  Un histograma.
\end{enumerate}

3. Usando el \emph{pipe} \texttt{\%\textgreater{}\%}, cree un objeto \texttt{p} pero esta vez asociado con el set de datos \texttt{heights} en lugar del set de datos \texttt{murders}.

4. ¿Cuál es la clase del objeto \texttt{p} que acaba de crear?

5. Ahora vamos a añadir una capa y las mapeos estéticos correspondientes. Para los datos de asesinatos, graficamos asesinatos totales versus tamaños de población. Explore el set de datos \texttt{murders} para recordar cuáles son los nombres de estas dos variables y escoja la respuesta correcta. \textbf{Sugerencia}: Mire \texttt{?murders}.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{state} y \texttt{abb}
\item
  \texttt{total\_murders} y \texttt{population\_size}
\item
  \texttt{total} y \texttt{population}
\item
  \texttt{murders} y \texttt{size}
\end{enumerate}

6. Para crear el diagrama de dispersión, agregamos una capa con \texttt{geom\_point}. Los mapeos estéticos requieren que definamos las variables del eje-x y del eje-y, respectivamente. Entonces el código se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ , }\AttributeTok{y =}\NormalTok{ )) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

excepto que tenemos que definir las dos variables \texttt{x} e \texttt{y}. Llene el espacio con los nombres correctos de las variables.

7. Recuerde que si no usamos nombres de argumentos, podemos obtener el mismo gráfico si ingresamos los nombres de las variables en el orden correcto de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population, total)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Vuelva a hacer el gráfico pero ahora con total en el eje-x y población en el eje-y.

8. Si en lugar de puntos queremos añadir texto, podemos usar las geometrías \texttt{geom\_text()} o \texttt{geom\_label()}. El siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population, total)) }\SpecialCharTok{+} \FunctionTok{geom\_label}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

nos dará el mensaje de error: \texttt{Error:\ geom\_label\ requires\ the\ following\ missing\ aesthetics:\ label}

¿Por qué ocurre esto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Necesitamos mapear un carácter a cada punto a través del argumento de etiqueta en \texttt{aes}.
\item
  Necesitamos dejar que \texttt{geom\_label} sepa qué carácter usar en el gráfico.
\item
  La geometría \texttt{geom\_label} no requiere valores del eje-x y del eje-y.
\item
  \texttt{geom\_label} no es un comando de \textbf{ggplot2}.
\end{enumerate}

9. Reescriba el código anterior para que use abreviaturas como el \texttt{label} (la etiqueta) a través de \texttt{aes}.

10. Cambie el color de las etiquetas a azul. ¿Cómo se hace?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Agregando una columna llamada \texttt{blue} a \texttt{murders}.
\item
  Debido a que cada etiqueta necesita un color diferente, mapeamos los colores a través de \texttt{aes}.
\item
  Utilizando el argumento \texttt{color} en \texttt{ggplot}.
\item
  Como queremos que todos los colores sean azules, no necesitamos asignar colores, solo usar el argumento de color en \texttt{geom\_label}.
\end{enumerate}

11. Reescriba el código anterior para que las etiquetas sean azules.

12. Ahora suponga que queremos usar color para representar las diferentes regiones. En este caso, ¿cuál de los siguientes es el más apropiado?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Añadir una columna llamada \texttt{color} a \texttt{murders} con el color que queremos usar.
\item
  Como cada etiqueta necesita un color diferente, mapear los colores a través del argumento de color de \texttt{aes}.
\item
  Utilizar el argumento \texttt{color} en \texttt{ggplot}.
\item
  Como queremos que todos los colores sean azules, no necesitamos asignar colores, solo usar el argumento de color en \texttt{geom\_label}.
\end{enumerate}

13. Reescriba el código anterior para que el color de las etiquetas sea determinado por la región del estado.

14. Ahora vamos a cambiar el eje-x a una escala logarítmica para tomar en cuenta el hecho de que la distribución de la población es asimétrica. Comencemos definiendo un objeto \texttt{p} guardando el gráfico que hemos hecho hasta ahora:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population, total, }\AttributeTok{label =}\NormalTok{ abb, }\AttributeTok{color =}\NormalTok{ region)) }\SpecialCharTok{+}
  \FunctionTok{geom\_label}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Para cambiar el eje-y a una escala logarítmica, aprendimos sobre la función \texttt{scale\_x\_log10()}. Agregue esta capa al objeto \texttt{p} para cambiar la escala y crear el gráfico.

15. Repita el ejercicio anterior pero ahora cambie ambos ejes para que estén en la escala logarítmica.

16. Ahora edite el código anterior para añadir el título ``Gun murder data'' al argumento. Sugerencia: use la función \texttt{ggtitle}.

\hypertarget{distributions}{%
\chapter{Cómo visualizar distribuciones de datos}\label{distributions}}

Los datos numéricos a menudo se resumen con el valor \emph{promedio}. Por ejemplo, la calidad de una escuela secundaria a veces se resume con un solo número: la puntuación promedio en una prueba estandarizada. Ocasionalmente, se incluye un segundo número: la \emph{desviación estándar}. Por ejemplo, pueden leer un informe que indique que las puntuaciones fueron 680 más o menos 50 (la desviación estándar). El informe ha resumido un vector completo de puntuaciones con solo dos números. ¿Es esto apropiado? ¿Hay alguna información importante que no estamos considerando al ver este resumen en lugar de la lista completa?

Nuestro primer componente básico de visualización de datos es aprender a resumir listas de factores o vectores numéricos. Generalmente, la mejor manera de compartir o explorar este resumen es a través de la visualización de datos. El resumen estadístico más básico de una lista de objetos o números es su distribución. Una vez que un vector se haya resumido como una distribución, existen varias técnicas de visualización de datos para transmitir esta información de manera efectiva.

En este capítulo, primero discutiremos las propiedades de una variedad de distribuciones y cómo visualizar las distribuciones usando un ejemplo motivante de alturas de estudiantes. Luego, en la Sección \ref{other-geometries}, discutiremos las geometrías de \textbf{ggplot2} para estas visualizaciones.

\hypertarget{tipos-de-variables}{%
\section{Tipos de variables}\label{tipos-de-variables}}

Trabajaremos con dos tipos de variables: categóricas y numéricas. Cada uno puede dividirse en otros dos grupos: las variables categóricas pueden ser ordinales o no, mientras que las numéricas pueden ser discretas o continuas.

Cuando cada entrada en un vector proviene de uno de un pequeño número de grupos, nos referimos a los datos como \emph{datos categóricos}. Dos ejemplos sencillos son el sexo (masculino o femenino) y las regiones (noreste, sur, norte central, oeste). Algunos datos categóricos se pueden ordenar aunque no sean números, por ejemplo cuán picante es una comida (poco, medio, muy). En los libros de texto de estadísticas, los datos categóricos ordenados se denominan datos \emph{ordinales}.

Ejemplos de datos numéricos son el tamaño de la población, las tasas de asesinatos y las alturas. Algunos datos numéricos se pueden tratar como ordenados categóricos. Podemos dividir aún más los datos numéricos en continuos y discretos. Las variables continuas son aquellas que pueden tomar cualquier valor, como las alturas, si se miden con suficiente precisión. Por ejemplo, un par de gemelos pueden medir 68.12 y 68.11 pulgadas, respectivamente. Los conteos, como el tamaño de la población, son discretos porque tienen que ser números redondos.

Tengan en cuenta que los datos numéricos discretos pueden considerarse ordinales. Aunque esto es técnicamente cierto, generalmente reservamos el término datos ordinales para variables que pertenecen a un pequeño número de grupos diferentes, y cada grupo tiene muchos miembros. En cambio, cuando tenemos muchos grupos con pocos casos en cada grupo, generalmente nos referimos a ellos como variables numéricas discretas. Entonces, por ejemplo, el número de paquetes de cigarrillos que una persona fuma al día, redondeado al paquete más cercano, se consideraría ordinal, mientras que el número real de cigarrillos se consideraría una variable numérica. Sin embargo, hay ejemplos que pueden considerarse tanto numéricos como ordinales cuando se trata de visualizar datos.

\hypertarget{estudio-de-caso-describiendo-alturas-de-estudiantes}{%
\section{Estudio de caso: describiendo alturas de estudiantes}\label{estudio-de-caso-describiendo-alturas-de-estudiantes}}

Aquí presentamos un nuevo problema motivante. Es artificial, pero nos ayudará ilustrar los conceptos necesarios para comprender las distribuciones.

Imaginen que tenemos que describir las alturas de nuestros compañeros de clase a ET, un extraterrestre que nunca ha visto humanos. Como primer paso, necesitamos recopilar datos. Para hacer esto, les pedimos a los estudiantes que indiquen sus alturas en pulgadas. Les pedimos que nos provean información sobre su sexo biológico porque sabemos que hay dos distribuciones diferentes por sexo. Recopilamos los datos y los guardamos en el set de datos \texttt{heights}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\end{Highlighting}
\end{Shaded}

Una forma de transmitir las alturas a ET es simplemente enviarle esta lista de 1,050 alturas. Sin embargo, hay formas mucho más efectivas de transmitir la información y, para lograr esto, nos ayudará a entender el concepto de distribuciones. Para simplificar la explicación, primero nos enfocamos en las alturas masculinas. Examinamos los datos de altura femenina en la Sección \ref{student-height-cont}.

\hypertarget{la-funciuxf3n-de-distribuciuxf3n}{%
\section{La función de distribución}\label{la-funciuxf3n-de-distribuciuxf3n}}

Resulta que, en algunos casos, el promedio y la desviación estándar son prácticamente todo lo que necesitamos para comprender los datos. Aprenderemos técnicas de visualización de datos que nos ayudarán a determinar cuándo este resumen de dos números es apropiado. Estas mismas técnicas servirán como una alternativa para cuando dos números no son suficientes.

El resumen estadístico más básico de una lista de objetos o números es su distribución. La forma más sencilla de pensar en una distribución es como una descripción compacta de una lista con muchas entradas. Este concepto no debería ser nuevo para los lectores de este libro. Por ejemplo, con datos categóricos, la distribución simplemente describe la proporción de cada categoría única. El sexo representado en el set de datos de alturas es:

\begin{verbatim}
#> 
#> Female   Male 
#>  0.227  0.773
\end{verbatim}

Esta \emph{tabla de frecuencia} de dos categorías es la forma más sencilla de una distribución. Realmente no necesitamos visualizarla ya que un número describe todo lo que necesitamos saber: 23\% son mujeres y el resto son hombres. Cuando hay más categorías, un diagrama de barras sencillo describe la distribución. Aquí hay un ejemplo con las regiones estatales de EE. UU.:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/state-region-distribution-1} \end{center}

Este gráfico simplemente nos muestra cuatro números, uno para cada categoría. Usualmente usamos diagramas de barras cuando tenemos pocos números. Aunque este gráfico en particular no ofrece mucha más información que una tabla de frecuencias en sí, es un primer ejemplo de cómo convertimos un vector en un gráfico que resume de manera sucinta toda la información en el vector. Cuando los datos son numéricos, la tarea de mostrar distribuciones es más retante.

\hypertarget{cdf-intro}{%
\section{Funciones de distribución acumulada}\label{cdf-intro}}

Los datos numéricos que no son categóricos también tienen distribuciones. En general, cuando los datos no son categóricos, indicar la frecuencia de cada entrada no es un resumen efectivo, ya que la mayoría de las entradas son únicas. En nuestro estudio de caso, por ejemplo, mientras varios estudiantes reportaron una altura de 68 pulgadas, un estudiante indicó una altura de \texttt{68.503937007874} pulgadas y otro una altura \texttt{68.8976377952756} pulgadas. Suponemos que convirtieron sus alturas de 174 y 175 centímetros, respectivamente.

Los libros de texto de estadísticas nos enseñan que una forma más útil de definir una distribución de datos numéricos es definir una función que indique la proporción de los datos a continuación \(a\) para todos los valores posibles de \(a\). Esta función se llama la \emph{función de distribución acumulada} (\emph{cumulative distribution function} o CDF por sus siglas en inglés). En estadística, se usa la siguiente notación:

\[ F(a) = \mbox{Pr}(x \leq a) \]

Aquí vemos un gráfico de \(F\) para los datos de altura masculina:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ecdf-1} \end{center}

Similar a lo que hace la tabla de frecuencias para datos categóricos, la CDF define la distribución de datos numéricos. En el gráfico, podemos ver que 16\% de los valores son menos de 65, ya que \(F(66)=\) 0.164, o que 84\% de los valores son menos de 72, ya que \(F(72)=\) 0.841,
y así. De hecho, podemos informar la proporción de valores entre dos alturas, digamos \(a\) y \(b\), al calcular \(F(b) - F(a)\). Esto significa que si enviamos este diagrama a ET, tendrá toda la información necesaria para reconstruir la lista completa. Parafraseando la expresión ``una imagen vale más que mil palabras'', en este caso una imagen es tan informativa como 812 números.

Una nota final: debido a que las CDF pueden definirse matemáticamente, la palabra \emph{empírica} se añade para distinguir cuando se usan los datos. Por lo tanto, utilizamos el término CDF empírico (o eCDF por sus siglas en inglés).

\hypertarget{histogramas}{%
\section{Histogramas}\label{histogramas}}

Aunque el concepto de CDF se discute ampliamente en los libros de texto de estadística, el gráfico no es muy popular en la práctica. La razón principal es que no transmite fácilmente características de interés como: ¿en qué valor se centra la distribución? ¿La distribución es simétrica? ¿Qué rangos contienen el 95\% de los valores? Los histogramas son preferidos porque facilitan enormemente la respuesta a tales preguntas. Los histogramas sacrifican solo un poco de información para producir gráficos que son mucho más fáciles de interpretar.

La forma más sencilla de hacer un histograma es dividir el \emph{span} de nuestros datos en \emph{compartimientos} (\emph{bins} en inglés) no superpuestos del mismo tamaño. Entonces para cada compartimiento, contamos el número de valores que se encuentran en ese intervalo. El histograma grafica estos conteos como barras con la base de la barra definida por los intervalos. A continuación tenemos el histograma para los datos de altura que dividen el rango de valores en intervalos de una pulgada: \([49.5, 50.5], [51.5,52.5],(53.5,54.5],...,(82.5,83.5]\).

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/height-histogram-1} \end{center}

Como pueden ver en la figura de arriba, un histograma es similar a un diagrama de barras, pero difiere en que el eje-x es numérico, no categórico.

Si le enviamos este diagrama a ET, inmediatamente aprenderá algunos detalles importantes sobre nuestros datos. Primero, el rango de datos es de 50 a 84 con la mayoría (más del 95\%) entre 63 y 75 pulgadas. Además, las alturas son casi simétricas alrededor de 69 pulgadas. Por último, al sumar conteos, ET puede obtener una muy buena aproximación de la proporción de los datos en cualquier intervalo. Por lo tanto, el histograma anterior no solo es fácil de interpretar, sino que también ofrece casi toda la información contenida en la lista cruda de 812 alturas con aproximadamente 30 conteos, uno por cada compartimiento.

¿Qué información perdemos? Recuerden que todos los valores en cada intervalo se tratan de la misma manera cuando se calculan las alturas del compartimiento. Entonces, por ejemplo, el histograma no distingue entre 64, 64.1 y 64.2 pulgadas. Dado que estas diferencias son casi imperceptibles a la vista, las implicaciones prácticas son insignificantes y pudimos resumir los datos en solo 23 números.

Discutimos cómo codificar histogramas en la Sección \ref{other-geometries}.

\hypertarget{densidad-suave}{%
\section{Densidad suave}\label{densidad-suave}}

Los gráficos de densidad suave son estéticamente más atractivos que los histogramas. A continuación vemos un gráfico de densidad suave para nuestros datos de altura:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/example-of-smoothed-density-1} \end{center}

En este gráfico, ya no tenemos bordes afilados en los límites de intervalo y se han eliminado muchos de los picos locales. Además, la escala del eje-y cambió de conteos a \emph{densidad}.

Para entender las densidades suaves, tenemos que entender \emph{estimadores}, un tema que no abordamos hasta más tarde. Sin embargo, ofrecemos una explicación heurística para ayudarles a entender los conceptos básicos y así poder utilizar esta herramienta útil de visualización de datos.

El nuevo concepto principal que deben entender es que suponemos que nuestra lista de valores observados es un subconjunto de una lista mucho más grande de valores no observados. En el caso de las alturas, pueden imaginar que nuestra lista de 812 estudiantes varones proviene de una lista hipotética que contiene todas las alturas de todos los estudiantes varones en todo el mundo, medidos todos con mucha precisión. Digamos que hay 1,000,000 de estas medidas. Esta lista de valores tiene una distribución, como cualquier lista de valores, y esta distribución considerable es realmente lo que queremos transmitir a ET, ya que es mucho más general. Desafortunadamente, no podemos ver esa lista grandísima.

Sin embargo, podemos hacer una suposición que quizás nos ayude a aproximarla. Si tuviéramos 1,000,000 valores, medidos con mucha precisión, podríamos hacer un histograma con compartimientos muy, muy pequeños. La suposición es que si mostramos esto, la altura de los compartimientos consecutivos será similar. Esto es lo que queremos decir con suave: no tenemos grandes saltos en las alturas de los compartimientos consecutivos. A continuación tenemos un histograma hipotético con compartimientos de tamaño 1:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-data-histogram-1-1} \end{center}

Entre más pequeños hacemos los compartimientos, más suave se vuelve el histograma. Aquí están los histogramas con ancho de compartimiento de 1, 0.5 y 0.1:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/simulated-data-histogram-2-1} \end{center}

La densidad suave es básicamente la curva que atraviesa la parte superior de las barras del histograma cuando los compartimientos son muy, muy pequeños. Para que la curva no dependa del tamaño hipotético de la lista hipotética, calculamos la curva usando frecuencias en lugar de conteos:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-density-1-1} \end{center}

Ahora, de vuelta a la realidad. No tenemos millones de medidas. En cambio, tenemos 812 y no podemos hacer un histograma con compartimientos muy pequeños.

Por lo tanto, hacemos un histograma utilizando tamaños de compartimiento apropiados para nuestros datos y frecuencias de cómputo en lugar de conteos. Además, dibujamos una curva suave que pasa por la parte superior de las barras del histograma. Los siguientes gráficos muestran los pasos que conducen a una densidad suave:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/smooth-density-2-1} \end{center}

Sin embargo, recuerden que \emph{suave} (\emph{smooth} en inglés) es un término relativo. De hecho, podemos controlar la \emph{suavidad} de la curva cambiando el número de puntos en los compartimientos. Esta opción se conoce como \emph{bandwidth}, \emph{span}, \emph{window size} o, en español, \emph{ventana de suavizado} o \emph{parámetro de suavizado}, y se puede ajustar en la función que calcula la curva de densidad suave. Aquí hay dos ejemplos que usan diferentes niveles de suavidad en el mismo histograma:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/densities-different-smoothness-1} \end{center}

Necesitamos tomar esta decisión con cuidado ya que las visualizaciones que resultan pueden cambiar nuestra interpretación de los datos. Debemos seleccionar un grado de suavidad que podamos defender como representativo de los datos subyacentes. En el caso de la altura, realmente tenemos razones para creer que la proporción de personas con alturas similares debería ser la misma. Por ejemplo, la proporción que es 72 pulgadas debería ser más similar a la proporción que es 71 que a la proporción que es 78 o 65. Esto implica que la curva debe ser bastante suave; es decir, la curva debería parecerse más al ejemplo de la derecha que al de la izquierda.

Si bien el histograma es un resumen sin supuestos, la densidad suavizada se basa en algunos supuestos.

\hypertarget{cuxf3mo-interpretar-el-eje-y}{%
\subsection{Cómo interpretar el eje-y}\label{cuxf3mo-interpretar-el-eje-y}}

Tengan en cuenta que interpretar el eje-y de un gráfico de densidad suave no es obvio. Se escala para que el área bajo la curva de densidad se sume a 1. Si imaginan que formamos un compartimiento con una base de 1 unidad de longitud, el valor del eje-y nos indica la proporción de valores en ese compartimiento. Sin embargo, esto solo es cierto para compartimientos de tamaño 1. Para intervalos de otro tamaño, la mejor manera de determinar la proporción de datos en ese intervalo es calculando la proporción del área total contenida en ese intervalo. Por ejemplo, aquí vemos la proporción de valores entre 65 y 68:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/area-under-curve-1} \end{center}

La proporción de esta área es aproximadamente
0.3,
lo que significa que aproximadamente 30\% de las alturas masculinas están entre 65 y 68 pulgadas.

Al comprender esto, estamos listos para usar la densidad suave como resumen. Para este set de datos, nos sentimos bastante cómodos suponiendo suavidad y, por ende, compartiendo esta figura estéticamente agradable con ET, que puede usarla para comprender nuestros datos de alturas masculinas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/example-of-smoothed-density-2-1} \end{center}

\hypertarget{densidades-permiten-estratificaciuxf3n}{%
\subsection{Densidades permiten estratificación}\label{densidades-permiten-estratificaciuxf3n}}

Como nota final, señalamos que una ventaja de las densidades suaves sobre los histogramas para fines de visualización es que las densidades facilitan la comparación de dos distribuciones. Esto se debe en gran parte a que los bordes irregulares del histograma añaden desorden. Aquí hay un ejemplo que compara las alturas masculinas y las femeninas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/two-densities-one-plot-1} \end{center}

Con el argumento correcto, \texttt{ggplot} automáticamente sombrea la región de intersección con un color diferente. Mostraremos ejemplos de código de \textbf{ggplot2} para densidades en la Sección \ref{gapminder} así como en la Sección \ref{other-geometries}.

\hypertarget{ejercicios-16}{%
\section{Ejercicios}\label{ejercicios-16}}

1. En el set de datos \texttt{murders}, la región es una variable categórica y la siguiente es su distribución:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-exercise-1} \end{center}

Redondeando al 5\% más cercano, ¿qué proporción de los estados se encuentran en la región ``North Central''?

2. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  El gráfico anterior es un histograma.
\item
  El gráfico anterior muestra solo cuatro números con un diagrama de barras.
\item
  Las categorías no son números, por lo que no tiene sentido graficar la distribución.
\item
  Los colores, no la altura de las barras, describen la distribución.
\end{enumerate}

3. El siguiente gráfico muestra el eCDF para las alturas masculinas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ecdf-exercise-1} \end{center}

Según el gráfico, ¿qué porcentaje de hombres son más bajos que 75 pulgadas?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  100\%
\item
  95\%
\item
  80\%
\item
  72 pulgadas
\end{enumerate}

4. A la pulgada más cercana, ¿qué altura \texttt{m} tiene la propiedad de que la mitad de los estudiantes varones son más altos que \texttt{m} y la mitad son más bajos?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  61 pulgadas
\item
  64 pulgadas
\item
  69 pulgadas
\item
  74 pulgadas
\end{enumerate}

5. Aquí hay un eCDF de las tasas de asesinatos en todos los estados:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ecdf-exercise-2-1} \end{center}

Sabiendo que hay 51 estados (contando DC) y basado en este gráfico, ¿cuántos estados tienen tasas de homicidio superiores a 10 por cada 100,000 personas?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  1
\item
  5
\item
  10
\item
  50
\end{enumerate}

6. Según el eCDF anterior, ¿cuál de las siguientes afirmaciones es cierta?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Alrededor de la mitad de los estados tienen tasas de homicidios superiores a 7 por 100,000 y la otra mitad por debajo.
\item
  La mayoría de los estados tienen tasas de homicidio de menos de 2 por 100,000.
\item
  Todos los estados tienen tasas de asesinatos superiores a 2 por 100,000.
\item
  Con la excepción de 4 estados, las tasas de asesinatos son inferiores a 5 por cada 100,000.
\end{enumerate}

7. A continuación mostramos el histograma de alturas masculinas de nuestro set de datos \texttt{heights}:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/height-histogram-exercise-1} \end{center}

Según este gráfico, ¿cuántos hombres hay entre 63.5 y 65.5?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  10
\item
  24
\item
  34
\item
  100
\end{enumerate}

8. ¿Aproximadamente qué \textbf{porcentaje} son más bajos que 60 pulgadas?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  1\%
\item
  10\%
\item
  25\%
\item
  50\%
\end{enumerate}

9. Según el siguiente gráfico de densidad, ¿aproximadamente qué proporción de estados de EE. UU. tiene poblaciones con más de 10 millones de personas?

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/density-exercise-1} \end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  0.02
\item
  0.15
\item
  0.50
\item
  0.55
\end{enumerate}

10. A continuación hay tres gráficos de densidad. ¿Es posible que sean del mismo set de datos?

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/density-exercise-2-1} \end{center}

¿Cuál de las siguientes afirmaciones es cierta?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Es imposible que sean del mismo set de datos.
\item
  Son del mismo set de datos, pero los gráficos son diferentes debido a errores de código.
\item
  Son del mismo set de datos, pero el primer y el segundo gráfico suavizan de menos y el tercero sobresuaviza.
\item
  Son del mismo set de datos, pero el primero no está en la escala logarítmica, el segundo suaviza de menos y el tercero sobresuaviza.
\end{enumerate}

\hypertarget{normal-distribution}{%
\section{La distribución normal}\label{normal-distribution}}

Los histogramas y los gráficos de densidad proveen excelentes resúmenes de una distribución. ¿Pero podemos resumir aún más? A menudo vemos el promedio y la desviación estándar utilizada como resumen estadístico: ¡un resumen de dos números! Para comprender cuáles son estos resúmenes y por qué se usan tanto, necesitamos comprender la distribución normal.

La distribución normal, también conocida como curva de campana y distribución Gausiana, es uno de los conceptos matemáticos más famosos de la historia. Una razón para esto es que se producen distribuciones aproximadamente normales en muchas situaciones, incluyendo las ganancias de juego, las alturas, los pesos, la presión arterial, las puntuaciones en las pruebas estandarizadas y los errores de medición experimentales. Hay explicaciones para esto y las describiremos más adelante. Aquí nos enfocamos en cómo la distribución normal nos ayuda a resumir los datos.

En vez de usar datos, la distribución normal se define con una fórmula matemática. Para cualquier intervalo \((a,b)\), la proporción de valores en ese intervalo se puede calcular utilizando esta fórmula:

\[\mbox{Pr}(a < x < b) = \int_a^b \frac{1}{\sqrt{2\pi}s} e^{-\frac{1}{2}\left( \frac{x-m}{s} \right)^2} \, dx\]

No necesitan memorizar o comprender los detalles de la fórmula. Sin embargo, recuerden que está completamente definida por solo dos parámetros: \(m\) y \(s\). El resto de los símbolos en la fórmula representan los extremos del intervalo que determinamos \(a\) y \(b\) y las conocidas constantes matemáticas \(\pi\) y \(e\). Estos dos parámetros, \(m\) y \(s\), se conocen respectivamente como el \emph{promedio} (o \emph{la media}) y \emph{la desviación estándar} (SD por sus siglas en inglés) de la distribución.

La distribución es simétrica, centrada en el promedio, y la mayoría de los valores (alrededor del 95\%) están dentro de 2 SD del promedio. Así es como se ve la distribución normal cuando el promedio es 0 y la SD es 1:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/normal-distribution-density-1} \end{center}

El hecho de que la distribución está definida por solo dos parámetros implica que si la distribución de un set de datos se puede aproximar con una distribución normal, toda la información necesaria para describir la distribución se puede codificar en solo dos números: el promedio y la desviación estándar. Ahora vamos a definir estos valores para una lista arbitraria de números.

Para una lista de números contenidos en un vector \texttt{x}, el promedio se define como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/} \FunctionTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

y la SD se define como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{((x}\SpecialCharTok{{-}}\NormalTok{mu)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/} \FunctionTok{length}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

que puede interpretarse como la distancia promedio entre los valores y su promedio.

Calculemos los valores para la altura de los varones que almacenaremos en el objeto \(x\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{index }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{==} \StringTok{"Male"}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height[index]}
\end{Highlighting}
\end{Shaded}

Se pueden usar las funciones predefinidas \texttt{mean} y \texttt{sd} (tengan en cuenta que por razones que se explican en la Sección \ref{data-driven-model}, \texttt{sd} divide por \texttt{length(x)-1} en vez de \texttt{length(x)}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x)}
\FunctionTok{c}\NormalTok{(}\AttributeTok{average =}\NormalTok{ m, }\AttributeTok{sd =}\NormalTok{ s)}
\CommentTok{\#\textgreater{} average      sd }
\CommentTok{\#\textgreater{}   69.31    3.61}
\end{Highlighting}
\end{Shaded}

A continuación tenemos un gráfico de la densidad suave de nuestras alturas de estudiantes en azul y la distribución normal con media = 69.3 y SD = 3.6 trazado como una línea negra:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/data-and-normal-densities-1} \end{center}

La distribución normal parece ser una buena aproximación aquí. Ahora veremos cuán bien funciona esta aproximación para predecir la proporción de valores dentro de los intervalos.

\hypertarget{unidades-estuxe1ndar}{%
\section{Unidades estándar}\label{unidades-estuxe1ndar}}

Para los datos que se distribuyen aproximadamente normalmente, es conveniente pensar en términos de \emph{unidades estándar}. La unidad estándar de un valor nos dice cuántas desviaciones estándar se alejan del promedio. Específicamente, para un valor \texttt{x} de un vector \texttt{X}, definimos el valor de \texttt{x} en unidades estándar como \texttt{z\ =\ (x\ -\ m)/s} con \texttt{m} y \texttt{s} el promedio y la desviación estándar de \texttt{X}, respectivamente. ¿Por qué es conveniente hacer esto?

Primero, repasen la fórmula para la distribución normal y observen que lo que se está exponiendo es \(-z^2/2\) con \(z\) equivalente a \(x\) en unidades estándar. El hecho de que el máximo de \(e^{-z^2/2}\) es cuando \(z=0\) explica por qué la distribución ocurre en el promedio. También explica la simetría ya que \(- z^2/2\) es simétrico alrededor de 0. Además, noten que si convertimos los datos distribuidos normalmente a unidades estándar, podemos saber rápidamente si, por ejemplo, una persona es aproximadamente promedio (\(z=0\)), entre los más altos (\(z \approx 2\)), entre los más bajos (\(z \approx -2\)), o una ocurrencia extremadamente rara (\(z > 3\) o \(z < -3\)). Recuerden que no importa cuáles sean las unidades originales, estas reglas aplican a cualquier dato que es aproximadamente normal.

En R, podemos obtener unidades estándar usando la función \texttt{scale}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Ahora para ver cuántos hombres hay dentro de 2 SD del promedio, simplemente escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(}\FunctionTok{abs}\NormalTok{(z) }\SpecialCharTok{\textless{}} \DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.95}
\end{Highlighting}
\end{Shaded}

¡La proporción es aproximadamente 95\%, que es lo que predice la distribución normal! Para tener hasta más confirmación de que la aproximación es precisa, podemos usar gráficos Q-Q (\emph{quantile-quantile} plots en inglés).

\hypertarget{gruxe1ficos-q-q}{%
\section{Gráficos Q-Q}\label{gruxe1ficos-q-q}}

Una manera sistemática de evaluar cuán bien se ajusta la distribución normal a los datos es verificar si las proporciones observadas y predecidas coinciden. En general, este es el acercamiento del gráfico Q-Q.

Primero, definimos los cuantiles teóricos para la distribución normal. En los libros de estadísticas usamos el símbolo \(\Phi(x)\) para definir la función que nos da la probabilidad de que una distribución normal estándar sea menos que \(x\). Entonces, por ejemplo, \(\Phi(-1.96) = 0.025\) y \(\Phi(1.96) = 0.975\). En R, podemos evaluar \(\Phi\) utilizando la función \texttt{pnorm}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.96}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.025}
\end{Highlighting}
\end{Shaded}

La función inversa \(\Phi^{-1}(x)\) nos da los \emph{cuantiles teóricos} para la distribución normal. Así, por ejemplo, \(\Phi^{-1}(0.975) = 1.96\). En R, podemos evaluar el inverso de \(\Phi\) utilizando la función \texttt{qnorm}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1.96}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que estos cálculos son para la distribución normal estándar por defecto (media = 0, desviación estándar = 1), pero también podemos definirlos para cualquier distribución normal. Podemos hacer esto usando los argumentos \texttt{mean} y \texttt{sd} en las funciones \texttt{pnorm} y \texttt{qnorm}. Por ejemplo, podemos usar \texttt{qnorm} para determinar cuantiles de una distribución con promedio y desviación estándar específicos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{, }\AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 8.92}
\end{Highlighting}
\end{Shaded}

Para la distribución normal, todos los cálculos relacionados con los cuantiles se realizan sin datos, de ahí el nombre de \emph{cuantiles teóricos}. Pero los cuantiles se pueden definir para cualquier distribución, incluso una empírica. Entonces si tenemos datos en un vector \(x\), podemos definir el cuantil asociado con cualquier proporción \(p\) como el \(q\) para el cual la proporción de valores por debajo de \(q\) es \(p\). Usando el código R, podemos definir \texttt{q} como el valor para el cual \texttt{mean(x\ \textless{}=\ q)\ =\ p}. Observen que no todo \(p\) tiene un \(q\) para el cual la proporción es exactamente \(p\). Hay varias maneras de definir el mejor \(q\) como se discute en la página de ayuda para la función \texttt{quantile}.

Como ejemplo rápido, para los datos de alturas masculinas, vemos que:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{69.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.515}
\end{Highlighting}
\end{Shaded}

Alrededor del 50\% son más bajos o iguales a 69 pulgadas. Esto implica que si \(p=0.50\), entonces \(q=69.5\).

La idea de un gráfico Q-Q es que si sus datos están bien aproximados por la distribución normal, los cuantiles de sus datos deberían ser similares a los cuantiles de una distribución normal. Para construir un gráfico Q-Q, hacemos lo siguiente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definimos un vector de \(m\) dimensiones \(p_1, p_2, \dots, p_m\).
\item
  Definimos un vector de cuantiles \(q_1, \dots, q_m\) para las proporciones \(p_1, \dots, p_m\) usando sus datos. Nos referimos a estos como los \emph{cuantiles muestrales} (\emph{sample quantiles} en inglés).
\item
  Definimos un vector de cuantiles teóricos para las proporciones \(p_1, \dots, p_m\) para una distribución normal con el mismo promedio y desviación estándar que los datos.
\item
  Graficamos los cuantiles muestrales versus los cuantiles teóricos.
\end{enumerate}

Construyamos un gráfico Q-Q usando el código R. Comiencen definiendo el vector de proporciones.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\FloatTok{0.05}\NormalTok{, }\FloatTok{0.95}\NormalTok{, }\FloatTok{0.05}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para obtener los cuantiles de los datos, podemos usar la función \texttt{quantile} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sample\_quantiles }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(x, p)}
\end{Highlighting}
\end{Shaded}

Para obtener los cuantiles teóricos de distribución normal con promedio y desviación estándar (SD) correspondiente, utilizamos la función \texttt{qnorm}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{theoretical\_quantiles }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(p, }\AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(x), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

Para ver si coinciden o no, los graficamos uno contra el otro y dibujamos la línea de identidad:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(theoretical\_quantiles, sample\_quantiles) }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/qqplot-original-1} \end{center}

Noten que este código es mucho más sencillo si usamos unidades estándar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sample\_quantiles }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(z, p)}
\NormalTok{theoretical\_quantiles }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(p)}
\FunctionTok{qplot}\NormalTok{(theoretical\_quantiles, sample\_quantiles) }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

El código anterior se incluye para ayudar a describir los gráficos Q-Q. Sin embargo, en la práctica es más fácil usar el código \textbf{ggplot2} descrito en la Sección \ref{other-geometries}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =} \FunctionTok{scale}\NormalTok{(height))) }\SpecialCharTok{+}
  \FunctionTok{geom\_qq}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Mientras que para la ilustración anterior usamos 20 cuantiles, el valor por defecto de la función \texttt{geom\_qq} es utilizar la misma cantidad de cuantiles como datos.

\hypertarget{percentiles}{%
\section{Percentiles}\label{percentiles}}

Antes de continuar, definamos algunos términos que se usan comúnmente en el análisis exploratorio de datos.

\emph{Percentiles} son casos especiales de \emph{cuantiles} que se usan comúnmente. Los percentiles son los cuantiles que se obtienen al configurar el \(p\) a \(0.01, 0.02, ..., 0.99\). Denominamos, por ejemplo, el caso de \(p=0.25\) el cuartilo inferior, ya que nos da un número para el cual el 25\% de los datos están por debajo. El percentil más famoso es el 50, también conocido como la \emph{mediana}.

Para la distribución normal, la mediana y el promedio son los mismos, pero generalmente este no es el caso.

Otro caso especial que recibe un nombre son los \emph{cuartiles}, que se obtienen al configurar \(p=0.25,0.50\) y \(0.75\).

\hypertarget{diagramas-de-caja}{%
\section{Diagramas de caja}\label{diagramas-de-caja}}

Para presentar los diagramas de caja (\emph{boxplots} en inglés), volveremos a los datos de asesinatos de EE. UU. Supongan que queremos resumir la distribución de la tasa de asesinatos. Usando la técnica de visualización de datos que hemos aprendido, podemos ver que la aproximación normal no aplica aquí:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/hist-qqplot-non-normal-data-1} \end{center}

En este caso, el histograma anterior o un gráfico de densidad suave serviría como un resumen relativamente sucinto.

Ahora supongan que los que están acostumbrados a recibir solo dos números como resúmenes nos piden un resumen numérico más compacto.

Aquí Tukey ofreció algunos consejos. Primero, recomendó proveer un resumen de cinco números compuestos por el rango junto con los cuartiles (los percentiles 25, 50 y 75). Además, Tukey sugirió ignorar los \emph{valores atípicos} (\emph{outliers} en inglés) al calcular el rango y, en su lugar, graficarlos como puntos independientes. Ofreceremos una explicación detallada de los valores atípicos más adelante. Finalmente, recomendó que graficáramos estos números como una ``caja'' con ``bigotes'' así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/first-boxplot-1} \end{center}

con el cuadro definido por los percentiles 25\% y 75\% y los bigotes mostrando el rango. La distancia entre estos dos se llama el rango \emph{intercuartil}. Los dos puntos son valores atípicos según la definición de Tukey. La mediana se muestra con una línea horizontal.

A partir de este gráfico sencillo, hoy conocido como un \emph{diagrama de caja}, sabemos que la mediana es de aproximadamente 2.5, que la distribución no es simétrica y que el rango es de 0 a 5 para la gran mayoría de los estados con dos excepciones.

Discutimos cómo crear diagramas de caja en la Sección \ref{other-geometries}.

\hypertarget{stratification}{%
\section{Estratificación}\label{stratification}}

En el análisis de datos, a menudo dividimos las observaciones en grupos según los valores de una o más variables asociadas con esas observaciones. Por ejemplo, en la siguiente sección dividimos los valores de altura en grupos según una variable de sexo: hembras y varones. Llamamos a este procedimiento \emph{estratificación} y nos referimos a los grupos resultantes como \emph{estratos}.

La estratificación es común en la visualización de datos porque a menudo estamos interesados en cómo la distribución de variables difiere entre los diferentes subgrupos. Veremos varios ejemplos a lo largo de esta parte del libro. Revisaremos el concepto de estratificación cuando aprendamos regresión en el Capítulo \ref{regression} y en la parte de \emph{machine learning} del libro.

\hypertarget{student-height-cont}{%
\section{Estudio de caso: describiendo alturas de estudiantes (continuación)}\label{student-height-cont}}

Usando el histograma, los gráficos de densidad y los gráficos Q-Q, nos hemos convencido de que los datos de altura masculina se aproximan bien con una distribución normal. En este caso, le damos a ET un resumen muy sucinto: las alturas masculinas siguen una distribución normal con un promedio de 69.3 pulgadas y una SD de 3.6 pulgadas. Con esta información, ET tendrá una buena idea de qué esperar cuando conozca a nuestros estudiantes varones. Sin embargo, para proporcionar una imagen completa, también debemos proveer un resumen de las alturas femeninas.

Aprendimos que los diagramas de caja son útiles cuando queremos comparar rápidamente dos o más distribuciones. Aquí vemos las alturas para varones y hembras:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/female-male-boxplots-1} \end{center}

El diagrama inmediatamente demuestra que los varones son, en promedio, más altos que las hembras. Las desviaciones estándar parecen ser similares. Pero, ¿la aproximación normal también funciona para los datos de altura femenina recopilados por la encuesta? Esperamos que sigan una distribución normal, al igual que los varones. Sin embargo, los gráficos exploratorios revelan que la aproximación no es tan útil:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/histogram-qqplot-female-heights-1} \end{center}

Vemos algo que no observamos para los varones: el gráfico de densidad tiene una segunda protuberancia. Además, el gráfico Q-Q muestra que los puntos más altos tienden a ser más altos de lo esperado por la distribución normal. Finalmente, también vemos cinco puntos en el gráfico Q-Q que sugieren alturas más bajas de lo esperado para una distribución normal. Al nuevamente informar a ET, es posible que necesitemos proveer un histograma en lugar de solo el promedio y la desviación estándar para las alturas femeninas.

Sin embargo, releemos la cita de Tukey y nos damos cuenta de que hemos notado lo que no esperábamos ver. Si observamos otras distribuciones de altura femenina, encontramos que están bien aproximadas con una distribución normal. Entonces, ¿por qué son diferentes nuestras alumnas? ¿Es nuestra clase un requisito para el equipo femenino de baloncesto? ¿Hay una proporción pequeña de mujeres que dicen ser más altas de lo que son? Otra explicación, quizás más probable, es que en el formulario en que los estudiantes ingresaron sus alturas, \texttt{FEMALE} era el sexo predeterminado y algunos varones ingresaron sus alturas, pero olvidaron cambiar la variable de sexo. En cualquier caso, la visualización de datos ha ayudado a descubrir una posible falla en nuestros datos.

Con respecto a los cinco valores más pequeños, noten que estos valores son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{top\_n}\NormalTok{(}\DecValTok{5}\NormalTok{, }\FunctionTok{desc}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(height)}
\CommentTok{\#\textgreater{} [1] 51 53 55 52 52}
\end{Highlighting}
\end{Shaded}

Debido a que estas son alturas autoreportadas, una posibilidad es que las estudiantes quisieron ingresar \texttt{5\textquotesingle{}1"}, \texttt{5\textquotesingle{}2"}, \texttt{5\textquotesingle{}3"} o \texttt{5\textquotesingle{}5"}.

\hypertarget{ejercicios-17}{%
\section{Ejercicios}\label{ejercicios-17}}

1. Defina variables que contengan las alturas de varones y hembras de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\NormalTok{male }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height[heights}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{==} \StringTok{"Male"}\NormalTok{]}
\NormalTok{female }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height[heights}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

¿Cuántas medidas tenemos para cada una?

2. Supongan que no podemos hacer un gráfico y queremos comparar las distribuciones una al lado de otra. No podemos simplemente enumerar todos los números. En cambio, veremos los percentiles. Cree una tabla de cinco filas que muestre \texttt{female\_percentiles} y \texttt{male\_percentiles} con los percentiles 10, 30, 50, \ldots, 90 para cada sexo. Luego, cree un \emph{data frame} con estas dos como columnas.

3. Estudie los siguientes diagramas de caja que muestran los tamaños de población por país:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplot-exercise-1} \end{center}

¿Qué continente tiene el país con el mayor tamaño de población?

4. ¿Qué continente tiene la mediana de tamaño poblacional más grande?

5. ¿Cuál es la mediana del tamaño poblacional de África al millón más cercano?

6. ¿Qué proporción de países en Europa tiene poblaciones menos de 14 millones?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  0.99
\item
  0.75
\item
  0.50
\item
  0.25
\end{enumerate}

7. Si utilizamos una transformación logarítmica, ¿qué continente de los anteriores tiene el mayor rango intercuartil?

8. Cargue el set de datos de altura y cree un vector \texttt{x} con solo las alturas masculinas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height[heights}\SpecialCharTok{$}\NormalTok{sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

¿Qué proporción de los datos está entre 69 y 72 pulgadas (más alto que 69, pero más bajo o igual a 72)? Sugerencia: use un operador lógico y \texttt{mean}.

9. Supongan que lo único que sabe sobre los datos es el promedio y la desviación estándar. Use la aproximación normal para estimar la proporción que acaba de calcular. Sugerencia: comience calculando el promedio y la desviación estándar. Luego use la función \texttt{pnorm} para predecir las proporciones.

10. Note que la aproximación calculada en la pregunta nueve está muy cerca del cálculo exacto en la primera pregunta. Ahora realice la misma tarea para valores más atípicos. Compare el cálculo exacto y la aproximación normal para el intervalo (79,81{]}. ¿Cuántas veces mayor es la proporción real que la aproximación?

11. Aproxime la distribución de hombres adultos en el mundo como distribución normal con un promedio de 69 pulgadas y una desviación estándar de 3 pulgadas. Usando esta aproximación, calcule la proporción de hombres adultos que miden 7 pies de alto o más, conocidos como \emph{seven footers}. Sugerencia: use la función \texttt{pnorm}.

12. Hay alrededor de mil millones de hombres entre las edades de 18 y 40 en el mundo. Use su respuesta a la pregunta anterior para estimar cuántos de estos hombres (de 18 a 40 años) miden siete pies de altura o más en el mundo.

13. Hay alrededor de 10 jugadores de la Asociación Nacional de Baloncesto (NBA) que miden 7 pies de altura o más. Usando la respuesta a las dos preguntas anteriores, ¿qué proporción de los \emph{seven footers} del mundo, entre 18 a 40 años, están en la NBA?

14. Repita los cálculos realizados en la pregunta anterior para la altura del baloncelista Lebron James: 6 pies y 8 pulgadas. Hay alrededor de 150 jugadores que son al menos tan altos.

15. Al responder a las preguntas anteriores, descubrimos que no es raro que un jugador de siete pies se convierta en jugador de la NBA. Entonces, ¿que sería una crítica justa de nuestros cálculos?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  La práctica y el talento son lo que hacen a un gran jugador de baloncesto, no la altura.
\item
  La aproximación normal no es apropiada para alturas.
\item
  Como se observa en la pregunta 10, la aproximación normal tiende a subestimar los valores atípicos. Es posible que haya más \emph{seven footers} de lo que predijimos.
\item
  Como se observa en la pregunta 10, la aproximación normal tiende a sobreestimar los valores atípicos. Es posible que haya menos \emph{seven footers} de lo que predijimos.
\end{enumerate}

\hypertarget{other-geometries}{%
\section{Geometrías ggplot2}\label{other-geometries}}

En el Capitulo \ref{ggplot2}, presentamos el paquete \textbf{ggplot2} para la visualización de datos. Aquí demostramos cómo generar gráficos relacionados con distribuciones, específicamente los gráficos que se muestran anteriormente en este capítulo.

\hypertarget{diagramas-de-barras}{%
\subsection{Diagramas de barras}\label{diagramas-de-barras}}

Para generar un diagrama de barras (\emph{barplots} en inglés), podemos usar la geometría \texttt{geom\_bar}. Por defecto, R cuenta los casos en cada categoría y dibuja una barra. Aquí vemos el diagrama de barras para las regiones de Estados Unidos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(region)) }\SpecialCharTok{+} \FunctionTok{geom\_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-geom-1} \end{center}

A menudo ya tenemos una tabla con una distribución que queremos presentar como diagrama de barras. Aquí tenemos un ejemplo de tal tabla:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(murders)}
\NormalTok{tab }\OtherTok{\textless{}{-}}\NormalTok{ murders }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(region) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{proportion =}\NormalTok{ n}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(n))}
\NormalTok{tab}
\CommentTok{\#\textgreater{}          region  n proportion}
\CommentTok{\#\textgreater{} 1     Northeast  9      0.176}
\CommentTok{\#\textgreater{} 2         South 17      0.333}
\CommentTok{\#\textgreater{} 3 North Central 12      0.235}
\CommentTok{\#\textgreater{} 4          West 13      0.255}
\end{Highlighting}
\end{Shaded}

Ya no queremos que \texttt{geom\_bar} cuente, sino que simplemente grafique una barra a la altura proporcionada por la variable \texttt{proportion}. Para esto necesitamos proveer \texttt{x} (las categorías) e \texttt{y} (los valores) y usar la opción \texttt{stat="identity"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(region, proportion)) }\SpecialCharTok{+} \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/region-freq-barplot-1} \end{center}

\hypertarget{histogramas-1}{%
\subsection{Histogramas}\label{histogramas-1}}

Para generar histogramas, utilizamos \texttt{geom\_histogram}. Al revisar la página de ayuda para esta función, vemos que el único argumento requerido es \texttt{x}, la variable para la cual construiremos un histograma. No usamos la \texttt{x} porque sabemos que es el primer argumento.
El código se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Si ejecutamos el código anterior, nos da un mensaje:

\begin{quote}
\texttt{stat\_bin()} utilizando \texttt{bins\ =\ 30}. Elija un mejor valor con
\texttt{binwidth}.
\end{quote}

Anteriormente utilizamos un tamaño de compartimiento de 1 pulgada, por lo que el código se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Finalmente, si por razones estéticas queremos añadir color, usamos los argumentos descritos en la página de ayuda. También añadimos etiquetas y un título:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{fill =} \StringTok{"blue"}\NormalTok{, }\AttributeTok{col =} \StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Male heights in inches"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Histogram"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/height-histogram-geom-1} \end{center}

\hypertarget{gruxe1ficos-de-densidad}{%
\subsection{Gráficos de densidad}\label{gruxe1ficos-de-densidad}}

Para crear una densidad suave, usamos \texttt{geom\_density}. Para hacer un gráfico de densidad suave con los datos que anteriormente visualizamos como un histograma, podemos usar este código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Para rellenar con color, podemos usar el argumento \texttt{fill}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{fill=}\StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-density-1} \end{center}

Para cambiar la suavidad de la densidad, utilizamos el argumento \texttt{adjust} para multiplicar el valor por defecto por ese \texttt{adjust}. Por ejemplo, si queremos que el parámetro de suavizado sea el doble de grande, usamos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{fill=}\StringTok{"blue"}\NormalTok{, }\AttributeTok{adjust =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{diagramas-de-caja-1}{%
\subsection{Diagramas de caja}\label{diagramas-de-caja-1}}

La geometría para crear diagramas de caja es \texttt{geom\_boxplot}. Como ya hemos discutido, los diagramas de caja son útiles para comparar distribuciones. Por ejemplo, a continuación vemos las alturas mostradas anteriormente para las mujeres, pero aquí en comparación con los hombres. Para esta geometría, necesitamos los argumentos \texttt{x} como las categorías y los argumentos \texttt{y} como los valores:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/female-male-boxplots-geom-1} \end{center}

\hypertarget{gruxe1ficos-q-q-1}{%
\subsection{Gráficos Q-Q}\label{gruxe1ficos-q-q-1}}

Para gráficos Q-Q, usamos la geometría \texttt{geom\_qq}. De la página de ayuda, aprendemos que necesitamos especificar el \texttt{sample} (aprenderemos sobre \emph{samples} en un capítulo posterior). Aquí tenemos el gráfico Q-Q para alturas de varones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_qq}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-qq-1} \end{center}

Por defecto, la variable muestral se compara con una distribución normal con un promedio de 0 y una desviación estándar de 1. Para cambiar esto, utilizamos el argumento \texttt{dparams} según la página de ayuda. Para añadir una línea de identidad, simplemente asignen otra capa. Para líneas rectas, usamos la función \texttt{geom\_abline}. La línea por defecto es la línea de identidad (pendiente = 1, intercepto = 0).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{params }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(height), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(height))}

\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_qq}\NormalTok{(}\AttributeTok{dparams =}\NormalTok{ params) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Otra opción aquí es escalar los datos primero y luego hacer un gráfico Q-Q contra la distribución normal estándar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =} \FunctionTok{scale}\NormalTok{(height))) }\SpecialCharTok{+}
  \FunctionTok{geom\_qq}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{imuxe1genes}{%
\subsection{Imágenes}\label{imuxe1genes}}

No hemos tenido que usar imágenes para los conceptos descritos en este capítulo, pero los usaremos en la Sección \ref{vaccines}, así que presentamos las dos geometrías utilizadas para crear imágenes: \textbf{geom\_tile} y \textbf{geom\_raster}. Se comportan de manera similar; para ver cómo difieren, consulten la página de ayuda. Para crear una imagen en \textbf{ggplot2}, necesitamos un \emph{data frame} con las coordenadas x e y, así como los valores asociados con cada uno de estos. Aquí tenemos un \emph{data frame}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{12}\NormalTok{, }\AttributeTok{y =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{z =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{120}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que esta es la versión \emph{tidy} de una matriz, \texttt{matrix(1:120,\ 12,\ 10)}. Para graficar la imagen, usamos el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y, }\AttributeTok{fill =}\NormalTok{ z)) }\SpecialCharTok{+}
  \FunctionTok{geom\_raster}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Con estas imágenes, a menudo querrán cambiar la escala de color. Esto se puede hacer a través de la capa \texttt{scale\_fill\_gradientn}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y, }\AttributeTok{fill =}\NormalTok{ z)) }\SpecialCharTok{+}
  \FunctionTok{geom\_raster}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_gradientn}\NormalTok{(}\AttributeTok{colors =} \FunctionTok{terrain.colors}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot2-image-new-colors-1} \end{center}

\hypertarget{gruxe1ficos-ruxe1pidos}{%
\subsection{Gráficos rápidos}\label{gruxe1ficos-ruxe1pidos}}

En la Sección \ref{qplot}, presentamos \texttt{qplot} como una función útil cuando necesitamos hacer un diagrama de dispersión rápido. También podemos usar \texttt{qplot} para hacer histogramas, diagramas de densidad, diagramas de caja, gráficos Q-Q y más. Aunque no provee el nivel de control de \texttt{ggplot}, \texttt{qplot} es definitivamente útil, ya que nos permite hacer un gráfico con un pequeño fragmento de código.

Supongan que tenemos las alturas femeninas en un objeto \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(height)}
\end{Highlighting}
\end{Shaded}

Para hacer un histograma rápido podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

La función adivina que queremos hacer un histograma porque solo proveemos una variable. En la Sección \ref{qplot}, vimos que si le damos dos variables a \texttt{qplot}, automáticamente crea un diagrama de dispersión.

Para hacer un gráfico Q-Q rápido, tienen que usar el argumento \texttt{sample}. Recuerden que podemos añadir capas tal como lo hacemos con \texttt{ggplot}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(}\AttributeTok{sample =} \FunctionTok{scale}\NormalTok{(x)) }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Si proveemos un factor y un vector numérico, obtenemos un gráfico como el que vemos abajo. Tengan en cuenta que en el código estamos utilizando el argumento \texttt{data}. Como el \emph{data frame} no es el primer argumento en \texttt{qplot}, tenemos que usar el operador de punto.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{qplot}\NormalTok{(sex, height, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

También podemos seleccionar una geometría específica mediante el uso del argumento \texttt{geom}. Entonces, para convertir el diagrama anterior en un diagrama de caja, usamos el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{qplot}\NormalTok{(sex, height, }\AttributeTok{data =}\NormalTok{ ., }\AttributeTok{geom =} \StringTok{"boxplot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

También podemos usar el argumento \texttt{geom} para generar un gráfico de densidad en lugar de un histograma:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x, }\AttributeTok{geom =} \StringTok{"density"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Aunque no tanto como con \texttt{ggplot}, tenemos cierta flexibilidad para mejorar los resultados de \texttt{qplot}. Mirando la página de ayuda, vemos varias formas en que podemos mejorar el aspecto del histograma anterior. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x, }\AttributeTok{bins=}\DecValTok{15}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{), }\AttributeTok{xlab =} \StringTok{"Population"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/qplot-example-6-1} \end{center}

\textbf{Nota técnica}: La razón por la que usamos \texttt{I("black")} es porque queremos que \texttt{qplot} trate \texttt{"black"} como un carácter en lugar de convertirlo en un factor. Este es el comportamiento por defecto dentro de \texttt{aes}, que se llama internamente aquí. En general, la función \texttt{I} se usa en R para decir ``manténgalo como está''.

\hypertarget{ejercicios-18}{%
\section{Ejercicios}\label{ejercicios-18}}

1. Ahora vamos a usar la función \texttt{geom\_histogram} para hacer un histograma de las alturas en el set de datos \texttt{height}. Al leer la documentación para esta función, vemos que requiere solo una asignación, los valores que se utilizarán para el histograma. Haga un histograma de todos los gráficos.

¿Cuál es la variable que contiene las alturas?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{sex}
\item
  \texttt{heights}
\item
  \texttt{height}
\item
  \texttt{heights\$height}
\end{enumerate}

2. Ahora cree un objeto \texttt{ggplot} usando el \emph{pipe} para asignar los datos de altura a un objeto \texttt{ggplot}. Asigne \texttt{height} a los valores de x a través de la función \texttt{aes}.

3. Ahora estamos listos para añadir una capa para hacer el histograma. Utilice el objeto creado en el ejercicio anterior y la función \texttt{geom\_histogram} para hacer el histograma.

4. Cuando ejecutamos el código en el ejercicio anterior, recibimos la advertencia:
\texttt{stat\_bin()} utilizando \texttt{bins\ =\ 30}. Elija un mejor valor con \texttt{binwidth}.

Utilice el argumento \texttt{binwidth} para cambiar el histograma creado en el ejercicio anterior para usar compartimientos de tamaño de 1 pulgada.

5. En lugar de un histograma, vamos a hacer un gráfico de densidad suave. En este caso, no crearemos un objeto, sino haremos y mostraremos el gráfico con una línea de código. Cambie la geometría en el código utilizado anteriormente para hacer una densidad suave en lugar de un histograma.

6. Ahora vamos a hacer un gráfico de densidad para varones y hembras por separado. Podemos hacer esto usando el argumento \texttt{group}. Asignamos grupos a través del mapeo estético, ya que cada punto necesita un grupo antes de hacer los cálculos necesarios para estimar una densidad.

7. También podemos asignar grupos a través del argumento \texttt{color}. Esto tiene el beneficio adicional de que utiliza el color para distinguir los grupos. Cambie el código anterior para usar color.

8. Además, podemos asignar grupos a través del argumento \texttt{fill}. Esto tiene el beneficio adicional de que usa colores para distinguir los grupos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height, }\AttributeTok{fill =}\NormalTok{ sex)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Sin embargo, aquí la segunda densidad se traza sobre la primera. Podemos hacer que las curvas sean más visibles mediante el uso de \emph{alpha blending} para añadir transparencia. Establezca el parámetro alfa a 0.2 en la función \texttt{geom\_density} para hacer este cambio.

\hypertarget{gapminder}{%
\chapter{Visualización de datos en la práctica}\label{gapminder}}

En este capítulo, demostraremos cómo el código relativamente sencillo de \textbf{ggplot2} puede crear gráficos esclarecedores y estéticamente agradables. Como motivación, crearemos gráficos que nos ayudarán a comprender mejor las tendencias de la salud y la economía mundial. Implementaremos lo que aprendimos en los Capítulos \ref{ggplot2} y \ref{other-geometries} y aprenderemos a expandir el código para perfeccionar los gráficos. A medida que avancemos en nuestro estudio de caso, describiremos los principios generales más relevantes a la visualización de datos y aprenderemos conceptos como \emph{facetas}, \emph{gráficos de series de tiempo}, \emph{transformaciones} y \emph{gráficos ridge}.

\hypertarget{estudio-de-caso-nuevas-ideas-sobre-la-pobreza}{%
\section{Estudio de caso: nuevas ideas sobre la pobreza}\label{estudio-de-caso-nuevas-ideas-sobre-la-pobreza}}

Hans Rosling\footnote{\url{https://en.wikipedia.org/wiki/Hans_Rosling}} era el cofundador de la Fundación Gapminder\footnote{\url{http://www.gapminder.org/}}, una organización dedicada a educar al público mediante datos para disipar mitos comunes sobre el llamado mundo en desarrollo. La organización utiliza datos para mostrar cómo las tendencias actuales en los campos de salud y economía contradicen las narrativas que emanan de la cobertura sensacionalista de los medios de catástrofes, tragedias y otros eventos desafortunados. Como se indica en el sitio web de la Fundación Gapminder:

\begin{quote}
\begin{quote}
\begin{quote}
Los periodistas y cabilderos cuentan historias dramáticas. Ese es su trabajo. Cuentan historias sobre eventos extraordinarios y personas inusuales. Las historias dramáticas se acumulan en las mentes de las personas en una visión del mundo demasiado dramática y con fuertes sentimientos de estrés negativo: ``¡El mundo está empeorando!'', ``¡Somos nosotros contra ellos!'', ``¡Las demás personas son extrañas!'', ``¡La población sigue creciendo!'' y ``¡A nadie le importa!''
\end{quote}
\end{quote}
\end{quote}

Hans Rosling se dedicó, en su propia manera dramática, a educar al público sobre tendencias basadas en datos utilizando visualizaciones de datos eficaces. Esta sección se basa en dos charlas que ejemplifican esta perspectiva educativa: \emph{New Insights on Poverty}\footnote{\url{https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en}} y \emph{The Best Stats You've Ever Seen}\footnote{\url{https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen}}. Específicamente, en esta sección usamos datos para intentar responder a las siguientes dos preguntas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ¿Es una caracterización justa del mundo actual decir que está dividido en naciones ricas occidentales y el mundo en desarrollo compuesto por África, Asia y América Latina?
\item
  ¿Ha empeorado la desigualdad de ingresos en todos los países durante los últimos 40 años?
\end{enumerate}

Para responder a estas preguntas, utilizaremos el set de datos \texttt{gapminder} proveído por \textbf{dslabs}. Este set de datos se creó utilizando varias hojas de cálculo disponibles de la Fundación Gapminder. Pueden acceder a la tabla de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(gapminder)}
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\CommentTok{\#\textgreater{} \# A tibble: 10,545 x 9}
\CommentTok{\#\textgreater{}   country     year infant\_mortality life\_expectancy fertility population}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}      \textless{}int\textgreater{}            \textless{}dbl\textgreater{}           \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}      \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Albania     1960            115.             62.9      6.19    1636054}
\CommentTok{\#\textgreater{} 2 Algeria     1960            148.             47.5      7.65   11124892}
\CommentTok{\#\textgreater{} 3 Angola      1960            208              36.0      7.32    5270844}
\CommentTok{\#\textgreater{} 4 Antigua a\textasciitilde{}  1960             NA              63.0      4.43      54681}
\CommentTok{\#\textgreater{} 5 Argentina   1960             59.9            65.4      3.11   20619075}
\CommentTok{\#\textgreater{} \# ... with 10,540 more rows, and 3 more variables: gdp \textless{}dbl\textgreater{},}
\CommentTok{\#\textgreater{} \#   continent \textless{}fct\textgreater{}, region \textless{}fct\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-prueba-de-hans-rosling}{%
\subsection{La prueba de Hans Rosling}\label{la-prueba-de-hans-rosling}}

Igual que en el video \emph{New Insights on Poverty}, comenzamos examinando nuestros conocimientos sobre las diferencias en la mortalidad infantil en diferentes países. Para cada uno de los cinco pares de países a continuación, ¿qué países creen que tuvieron las tasas de mortalidad infantil más altas en 2015? ¿Qué pares creen que son más similares?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sri Lanka o Turquía
\item
  Polonia o Corea del Sur
\item
  Malasia o Rusia
\item
  Pakistán o Vietnam
\item
  Tailandia o Sudáfrica
\end{enumerate}

Al responder a estas preguntas sin datos, los países no europeos suelen ser elegidos como los que tienen tasas de mortalidad infantil más altas: Sri Lanka sobre Turquía, Corea del Sur sobre Polonia y Malasia sobre Rusia. También es común suponer que los países considerados como parte del mundo en desarrollo: Pakistán, Vietnam, Tailandia y Sudáfrica, tienen tasas de mortalidad igualmente altas.

Para responder a estas preguntas \textbf{con datos}, podemos usar \textbf{dplyr}. Por ejemplo, para la primera comparación vemos que:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==} \DecValTok{2015} \SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Sri Lanka"}\NormalTok{,}\StringTok{"Turkey"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(country, infant\_mortality)}
\CommentTok{\#\textgreater{}     country infant\_mortality}
\CommentTok{\#\textgreater{} 1 Sri Lanka              8.4}
\CommentTok{\#\textgreater{} 2    Turkey             11.6}
\end{Highlighting}
\end{Shaded}

Turquía tiene la mayor tasa de mortalidad infantil.

Podemos usar este código en todas las comparaciones y descubrimos lo siguiente:

\begin{verbatim}
#> New names:
#> * country -> country...1
#> * infant_mortality -> infant_mortality...2
#> * country -> country...3
#> * infant_mortality -> infant_mortality...4
\end{verbatim}

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lrlr}
\toprule
country & infant mortality & country & infant mortality\\
\midrule
Sri Lanka & 8.4 & Turkey & 11.6\\
Poland & 4.5 & South Korea & 2.9\\
Malaysia & 6.0 & Russia & 8.2\\
Pakistan & 65.8 & Vietnam & 17.3\\
Thailand & 10.5 & South Africa & 33.6\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Vemos que los países europeos en esta lista tienen tasas de mortalidad infantil más altas: Polonia tiene una tasa más alta que Corea del Sur y Rusia tiene una tasa más alta que Malasia. También vemos que Pakistán tiene una tasa mucho más alta que Vietnam y Sudáfrica tiene una tasa mucho más alta que Tailandia. Resulta que cuando Hans Rosling le dio este cuestionario a grupos de personas educadas, la puntuación promedio fue menos de 2.5 de 5, peor de lo que hubieran obtenido si hubieran adivinado. Esto implica que más que ignorantes, estamos mal informados. En este capítulo, vemos cómo la visualización de datos nos ayuda a informarnos.

\hypertarget{diagramas-de-dispersiuxf3n}{%
\section{Diagramas de dispersión}\label{diagramas-de-dispersiuxf3n}}

La razón por las bajas puntuaciones se deriva de la noción preconcebida de que el mundo está dividido en dos grupos: el mundo occidental (Europa occidental y América del Norte), caracterizado por una larga vida y familias pequeñas, versus el mundo en desarrollo (África, Asia y América Latina), caracterizados por cortos períodos de vida y familias numerosas. ¿Pero los datos respaldan esta visión dicotómica?

Los datos necesarios para responder a esta pregunta también están disponibles en nuestra tabla \texttt{gapminder}. Usando nuestras recién aprendidas habilidades de visualización de datos, podemos enfrentar este desafío.

Para analizar esta visión del mundo, nuestro primer gráfico es un diagrama de dispersión de la esperanza de vida versus las tasas de fertilidad (número promedio de hijos por mujer). Comenzamos mirando los datos de hace unos 50 años, cuando quizás esta visión se consolidó por primera vez en nuestras mentes.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year }\SpecialCharTok{==} \DecValTok{1962}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/fertility-versus-life-expectancy-1962-1} \end{center}

La mayoría de puntos se dividen en dos categorías distintas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Esperanza de vida alrededor de 70 años y 3 o menos hijos por familia.
\item
  Esperanza de vida inferior a 65 años y más de 5 niños por familia.
\end{enumerate}

Para confirmar que estos países son de las regiones que esperamos, podemos usar un color para representar un continente.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year }\SpecialCharTok{==} \DecValTok{1962}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{( }\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy, }\AttributeTok{color =}\NormalTok{ continent)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/fertility-versus-life-expectancy-1962-with-color-1} \end{center}

En 1962, la visión del ``Oeste versus el mundo en desarrollo'' se basaba en cierta realidad. ¿Sigue siendo así 50 años después?

\hypertarget{separar-en-facetas}{%
\section{Separar en facetas}\label{separar-en-facetas}}

Podemos graficar fácilmente los datos de 2012 de la misma manera que lo hicimos para 1962. Sin embargo, para hacer comparaciones, es preferible graficar lado a lado. En \textbf{ggplot2}, logramos esto separando las variables en \emph{facetas} (\emph{faceting} en inglés): estratificamos los datos por alguna variable y hacemos el mismo gráfico para cada estrato.

Para separar en facetas, añadimos una capa con la función \texttt{facet\_grid}, que automáticamente separa los gráficos. Esta función les permite separar hasta dos variables en facetas usando columnas para representar una variable y filas para representar la otra. La función espera que las variables de fila y de columna estén separadas por un \texttt{\textasciitilde{}}. Aquí vemos un ejemplo de un diagrama de dispersión donde añadimos \texttt{facet\_grid} como la última capa:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\DecValTok{1962}\NormalTok{, }\DecValTok{2012}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy, }\AttributeTok{col =}\NormalTok{ continent)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(continent}\SpecialCharTok{\textasciitilde{}}\NormalTok{year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/fertility-versus-life-expectancy-facet-1} \end{center}

Arriba vemos un gráfico para cada combinación de continente/año. Sin embargo, esto es solo un ejemplo y más de lo que queremos, que es simplemente comparar dos años: 1962 y 2012. En este caso, solo hay una variable y usamos \texttt{.} para que \texttt{facet\_grid} sepa que no estamos usando una de las variables:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\DecValTok{1962}\NormalTok{, }\DecValTok{2012}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy, }\AttributeTok{col =}\NormalTok{ continent)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(. }\SpecialCharTok{\textasciitilde{}}\NormalTok{ year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/fertility-versus-life-expectancy-two-years-1} \end{center}

Este gráfico muestra claramente que la mayoría de los países se han mudado del conjunto \emph{mundo en desarrollo} al conjunto \emph{mundo occidental}. En 2012, la visión del mundo occidental versus el mundo en desarrollo ya no tiene sentido. Esto es particularmente evidente cuando se compara Europa con Asia, este último ahora con varios países que han realizado grandes mejoras.

\hypertarget{facet_wrap}{%
\subsection{\texorpdfstring{\texttt{facet\_wrap}}{facet\_wrap}}\label{facet_wrap}}

Para explorar cómo sucedió esta transformación a través de los años, podemos hacer el gráfico para varios años. Por ejemplo, podemos añadir los años 1970, 1980, 1990 y 2000. Sin embargo, si hacemos esto, no queremos a todos los gráficos en la misma fila, que es lo que hace \texttt{facet\_grid} por defecto, ya que aparecerán demasiado estrechos para mostrar los datos. En cambio, queremos usar múltiples filas y columnas. La función \texttt{facet\_wrap} nos permite hacer esto automáticamente acomodando la serie de gráficos para que cada imagen tenga dimensiones visibles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{years }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1962}\NormalTok{, }\DecValTok{1980}\NormalTok{, }\DecValTok{1990}\NormalTok{, }\DecValTok{2000}\NormalTok{, }\DecValTok{2012}\NormalTok{)}
\NormalTok{continents }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Europe"}\NormalTok{, }\StringTok{"Asia"}\NormalTok{)}
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ continent }\SpecialCharTok{\%in\%}\NormalTok{ continents) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{( }\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy, }\AttributeTok{col =}\NormalTok{ continent)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/fertility-versus-life-expectancy-five-years-1} \end{center}

Este gráfico muestra claramente cómo la mayoría de los países asiáticos han mejorado a un ritmo mucho más rápido que los europeos.

\hypertarget{escalas-fijas-para-mejores-comparaciones}{%
\subsection{Escalas fijas para mejores comparaciones}\label{escalas-fijas-para-mejores-comparaciones}}

La elección por defecto del rango de los ejes es importante. Cuando no se usa \texttt{facet}, este rango está determinado por los datos que se muestran en el gráfico. Cuando usan \texttt{facet}, este rango está determinado por los datos que se muestran en todos los gráficos y, por lo tanto, se mantienen fijos en todos los gráficos. Esto hace que las comparaciones entre gráficos sean mucho más fáciles. Por ejemplo, en el gráfico anterior, podemos ver que la esperanza de vida ha aumentado y la fertilidad ha disminuido en la mayoría de los países. Vemos esto porque la nube de puntos se mueve. Este no es el caso si ajustamos las escalas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\DecValTok{1962}\NormalTok{, }\DecValTok{2012}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(fertility, life\_expectancy, }\AttributeTok{col =}\NormalTok{ continent)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(. }\SpecialCharTok{\textasciitilde{}}\NormalTok{ year, }\AttributeTok{scales =} \StringTok{"free"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/facet-without-fixed-scales-1} \end{center}

En el gráfico anterior, debemos prestar atención particular al rango para notar que el gráfico de la derecha tiene una mayor esperanza de vida.

\hypertarget{gruxe1ficos-de-series-de-tiempo}{%
\section{Gráficos de series de tiempo}\label{gruxe1ficos-de-series-de-tiempo}}

Las visualizaciones anteriores ilustran efectivamente que los datos ya no son compatibles con la visión del mundo occidental frente al mundo en desarrollo. Al ver estos gráficos, surgen nuevas preguntas. Por ejemplo, ¿qué países están mejorando más y cuáles menos? ¿La mejora fue constante durante los últimos 50 años o se aceleró más durante ciertos períodos? Para una mirada más detenida que pueda ayudar a responder a estas preguntas, presentamos \emph{gráficos de series de tiempo} (\emph{time series plots} en inglés).

Los gráficos de series de tiempo tienen tiempo en el eje-x y un resultado o medida de interés en el eje-y. Por ejemplo, aquí vemos un gráfico de la tendencia de las tasas de fertilidad de Estados Unidos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{==} \StringTok{"United States"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, fertility)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/fertility-time-series-plot-points-1} \end{center}

Observamos que la tendencia no es lineal en absoluto, sino que durante los años sesenta y setenta se produce una fuerte caída por debajo de 2. Entonces la tendencia vuelve a 2 y se estabiliza durante los años noventa.

Cuando los puntos están regular y densamente espaciados, como vemos arriba, creamos una curva que une los puntos con líneas, para transmitir que estos datos provienen de una sola serie, aquí un país. Para hacer esto, usamos la función \texttt{geom\_line} en vez de \texttt{geom\_point}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{==} \StringTok{"United States"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, fertility)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/fertility-time-series-plot-curve-1} \end{center}

Esto es particularmente útil cuando comparamos dos países. Si creamos un subconjunto de los datos para incluir dos países, uno de Europa y uno de Asia, entonces adaptamos el código anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countries }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"South Korea"}\NormalTok{,}\StringTok{"Germany"}\NormalTok{)}

\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{\%in\%}\NormalTok{ countries) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year,fertility)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/wrong-time-series-plot-1} \end{center}

Claramente, este \textbf{no} es el gráfico que queremos. En lugar de una línea para cada país, se unen los puntos para ambos países porque no le hemos dicho a \texttt{ggplot} que queremos dos líneas independientes. Para que \texttt{ggplot} entienda que hay dos curvas que se deben hacer por separado, asignamos cada punto a un \texttt{group}, uno para cada país:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countries }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"South Korea"}\NormalTok{,}\StringTok{"Germany"}\NormalTok{)}

\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{\%in\%}\NormalTok{ countries }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(fertility)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, fertility, }\AttributeTok{group =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/time-series-two-curves-1} \end{center}

¿Pero qué línea va con qué país? Podemos asignar colores para hacer esta distinción.
Un efecto secundario útil de usar el argumento \texttt{color} para asignar diferentes colores a los diferentes países es que los datos se agrupan automáticamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countries }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"South Korea"}\NormalTok{,}\StringTok{"Germany"}\NormalTok{)}

\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{\%in\%}\NormalTok{ countries }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(fertility)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year,fertility, }\AttributeTok{col =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/fertility-time-series-plot-1} \end{center}

El gráfico muestra claramente cómo la tasa de fertilidad de Corea del Sur cayó drásticamente durante los años sesenta y setenta, y en 1990 tuvo una tasa similar a la de Alemania.

\hypertarget{etiquetas-en-lugar-de-leyendas}{%
\subsection{Etiquetas en lugar de leyendas}\label{etiquetas-en-lugar-de-leyendas}}

Para los gráficos de tendencias, recomendamos etiquetar las líneas en lugar de usar leyendas, ya que el espectador puede ver rápidamente qué línea representa qué país. Esta sugerencia aplica a la mayoría de los gráficos: las etiquetas generalmente se prefieren a las leyendas.

Demostramos cómo hacer esto usando los datos de esperanza de vida. Definimos una tabla de datos con las ubicaciones de las etiquetas y luego usamos una segunda asignación solo para estas etiquetas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{labels }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{country =}\NormalTok{ countries, }\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{1975}\NormalTok{,}\DecValTok{1965}\NormalTok{), }\AttributeTok{y =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{,}\DecValTok{72}\NormalTok{))}

\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{\%in\%}\NormalTok{ countries) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, life\_expectancy, }\AttributeTok{col =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{data =}\NormalTok{ labels, }\FunctionTok{aes}\NormalTok{(x, y, }\AttributeTok{label =}\NormalTok{ country), }\AttributeTok{size =} \DecValTok{5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/labels-better-than-legends-1} \end{center}

El gráfico muestra claramente cómo una mejora en la esperanza de vida siguió a caídas en las tasas de fertilidad. En 1960, los alemanes vivieron 15 años más que los surcoreanos, aunque para 2010 la brecha está completamente cerrada. Ejemplifica la mejora que muchos países no occidentales han logrado en los últimos 40 años.

\hypertarget{transformaciones-de-datos}{%
\section{Transformaciones de datos}\label{transformaciones-de-datos}}

Ahora cambiamos nuestra atención a la segunda pregunta relacionada con la idea común de que la distribución de la riqueza en todo el mundo ha empeorado durante las últimas décadas. Cuando se le pregunta al público en general si los países pobres se han vuelto más pobres y los países ricos se han vuelto más ricos, la mayoría responde que sí. Mediante el uso de estratificación, histogramas, densidades suaves y diagramas de caja, podremos ver si este realmente es el caso. Primero, aprenderemos cómo las transformaciones a veces pueden ayudar a proporcionar resúmenes y gráficos más informativos.

La tabla de datos \texttt{gapminder} incluye una columna con el producto interno bruto de los países (GDP por sus siglas en inglés). El GDP mide el valor de mercado de los bienes y servicios producidos por un país en un año. El GDP por persona a menudo se usa como un resumen aproximado de la riqueza de un país. Aquí dividimos esta cantidad por 365 para obtener la medida más interpretable de \emph{dólares por día}. Utilizando los dólares estadounidenses actuales como una unidad, una persona que sobrevive con un ingreso de menos de \$2 por día se define como viviendo en la ``pobreza absoluta''. Añadimos esta variable a la tabla de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{dollars\_per\_day =}\NormalTok{ gdp}\SpecialCharTok{/}\NormalTok{population}\SpecialCharTok{/}\DecValTok{365}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Los valores del GDP se ajustan a la inflación y representan dólares estadounidenses actuales, por lo que estos valores deben ser comparables a lo largo de los años. Por supuesto, estos son promedios de país y dentro de cada país hay mucha variabilidad. Todos los gráficos y las ideas que se describen a continuación se refieren a los promedios de los países y no a los individuos dentro de estos.

\hypertarget{transformaciuxf3n-logaruxedtmica}{%
\subsection{Transformación logarítmica}\label{transformaciuxf3n-logaruxedtmica}}

Abajo tenemos un histograma de ingresos diarios desde 1970:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{past\_year }\OtherTok{\textless{}{-}} \DecValTok{1970}
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dollars-per-day-distribution-1} \end{center}

Utilizamos el argumento \texttt{color\ =\ "black"} para dibujar un límite y distinguir claramente los compartimientos.

En este gráfico, vemos que para la mayoría de los países, los promedios están por debajo de \$10 por día. Sin embargo, la mayoría del eje-x está dedicado a 35 países con promedio de menos de \$10. Por lo tanto, el gráfico no es muy informativo con respecto a países con valores inferiores a \$10 por día.

Sería más informativo poder ver rápidamente cuántos países tienen ingresos diarios promedio de aproximadamente \$1 (extremadamente pobre), \$2 (muy pobre), \$4 (pobre), \$8 (promedio), \$16 (acomodado), \$32 (rico), \$64 (muy rico) por día. Estos cambios son multiplicativos y las transformaciones logarítmicas convierten los cambios multiplicativos en aditivos: cuando se usa la base 2, la duplicación de un valor se convierte en un aumento de 1.

Aquí tenemos la distribución si aplicamos una transformación logarítmica base 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\FunctionTok{log2}\NormalTok{(dollars\_per\_day))) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dollars-per-day-distribution-log-1} \end{center}

Así logramos ver de cerca a los países de ingresos medios a ingresos bajos.

\hypertarget{quuxe9-base}{%
\subsection{¿Qué base?}\label{quuxe9-base}}

En el caso anterior, utilizamos la base 2 en las transformaciones logarítmicas. Otras opciones comunes son base \(\mathrm{e}\) (el logaritmo natural) y base 10.

En general, no recomendamos utilizar el logaritmo natural para la exploración y visualización de datos. La razón es porque mientras \(2^2, 2^3, 2^4, \dots\) o \(10^2, 10^3, \dots\) son fáciles de calcular en nuestras cabezas, lo mismo no es cierto para \(\mathrm{e}^2, \mathrm{e}^3, \dots\), por lo que la escala no es intuitiva ni fácil de interpretar.

En el ejemplo de dólares por día, utilizamos la base 2 en lugar de la base 10 porque el rango resultante es más fácil de interpretar. El rango de los valores que se trazan es 0.327, 48.885.

En la base 10, esto se convierte en un rango que incluye muy pocos enteros: solo 0 y 1. Con la base dos, nuestro rango incluye -2, -1, 0, 1, 2, 3, 4 y 5. Es más fácil calcular \(2^x\) y \(10^x\) cuando \(x\) es un entero y entre -10 y 10, por lo que preferimos tener enteros más pequeños en la escala. Otra consecuencia de un rango limitado es que elegir el ancho del compartimiento (\emph{binwidth} en inglés) es más difícil. Con logaritmo base 2, sabemos que un ancho de compartimiento de 1 se convertirá en un compartimiento con rango \(x\) a \(2x\).

Para un ejemplo en el que la base 10 tiene más sentido, consideren los tamaños de poblaciones. Un logaritmo base 10 es preferible ya que el rango para estos es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(gapminder, year }\SpecialCharTok{==}\NormalTok{ past\_year) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{min =} \FunctionTok{min}\NormalTok{(population), }\AttributeTok{max =} \FunctionTok{max}\NormalTok{(population))}
\CommentTok{\#\textgreater{}     min      max}
\CommentTok{\#\textgreater{} 1 46075 8.09e+08}
\end{Highlighting}
\end{Shaded}

Abajo tenemos el histograma de los valores transformados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\FunctionTok{log10}\NormalTok{(population))) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/population-histogram-log10-1} \end{center}

En el gráfico anterior, rápidamente vemos que las poblaciones de los países oscilan entre diez mil y diez mil millones.

\hypertarget{transformar-los-valores-o-la-escala}{%
\subsection{¿Transformar los valores o la escala?}\label{transformar-los-valores-o-la-escala}}

Hay dos formas en que podemos usar las transformaciones logarítmicas en los gráficos. Podemos tomar el logaritmo de los valores antes de graficarlos o usar escalas logarítmicas en los ejes. Ambos enfoques son útiles y tienen diferentes ventajas. Si tomamos el logaritmo de los datos, podemos interpretar más fácilmente los valores intermedios en la escala. Por ejemplo, si vemos:

\texttt{-\/-\/-\/-1-\/-\/-\/-x-\/-\/-\/-2-\/-\/-\/-\/-\/-\/-\/-3-\/-\/-\/-}

para datos transformados con el logaritmo, sabemos que el valor de \(x\) es de aproximadamente 1.5. Si usamos escalas logarítmicas:

\texttt{-\/-\/-\/-10-\/-\/-x-\/-\/-100-\/-\/-\/-\/-\/-1000-\/-\/-}

entonces, para determinar \texttt{x}, necesitamos calcular \(10^{1.5}\), que no es fácil de hacer mentalmente. La ventaja de usar escalas logarítmicas es que vemos los valores originales en los ejes. Sin embargo, la ventaja de mostrar escalas logarítmicas es que los valores originales se muestran en el gráfico y son más fáciles de interpretar. Por ejemplo, veríamos ``32 dólares por día'' en lugar de ``5 log base 2 dólares por día''.

Como aprendimos anteriormente, si queremos escalar el eje con logaritmos, podemos usar la función \texttt{scale\_x\_continuous}. En vez de primero tomar el logaritmo de los valores, aplicamos esta capa:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dollars-per-day-log-scale-1} \end{center}

Tengan en cuenta que la transformación logarítmica base 10 tiene su propia función: \texttt{scale\_x\_log10()}, pero actualmente la base 2 no tiene, aunque fácilmente podríamos definir una.

Hay otras transformaciones disponibles a través del argumento \texttt{trans}. Como aprenderemos más adelante, la transformación de raíz cuadrada (\texttt{sqrt}) es útil cuando se consideran conteos. La transformación logística (\texttt{logit}) es útil cuando se grafican proporciones entre 0 y 1. La transformación \texttt{reverse} es útil cuando queremos que los valores más pequeños estén a la derecha o arriba.

\hypertarget{cuxf3mo-visualizar-distribuciones-multimodales}{%
\section{Cómo visualizar distribuciones multimodales}\label{cuxf3mo-visualizar-distribuciones-multimodales}}

En el histograma anterior vemos dos protuberancias: una aproximadamente en 4 y otra aproximadamente en 32. En estadística, estas protuberancias a veces se denominan \emph{modas} (\emph{modes} en inglés). La moda de una distribución es el valor con la frecuencia más alta. La moda de distribución normal es el promedio. Cuando una distribución, como la anterior, no disminuye monotónicamente de la moda, llamamos a los lugares donde sube y baja de nuevo \emph{modas locales} y decimos que la distribución tiene \emph{modas múltiples}.

El histograma anterior sugiere que la distribución de ingreso de los países en 1970 tiene dos modas: una de aproximadamente 2 dólares por día (1 en la escala log 2) y la otra de aproximadamente 32 dólares por día (5 en la escala log 2). Esta \emph{bimodalidad} es consistente con un mundo dicotómico compuesto por países con ingresos promedio inferiores a \$8 (3 en la escala log 2) por día y países por encima de eso.

\hypertarget{cuxf3mo-comparar-muxfaltiples-distribuciones-con-diagramas-de-caja-y-gruxe1ficos-ridge}{%
\section{\texorpdfstring{Cómo comparar múltiples distribuciones con diagramas de caja y gráficos \emph{ridge}}{Cómo comparar múltiples distribuciones con diagramas de caja y gráficos ridge}}\label{cuxf3mo-comparar-muxfaltiples-distribuciones-con-diagramas-de-caja-y-gruxe1ficos-ridge}}

De acuerdo con el histograma, los valores de distribución del ingreso de 1970 muestran una dicotomía. Sin embargo, el histograma no nos muestra si los dos grupos de países están en el \emph{oeste} o forman parte del mundo \emph{en desarrollo}.

Comencemos examinando rápidamente los datos por región. Reordenamos las regiones por la mediana y usamos una escala logarítmica.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{region =} \FunctionTok{reorder}\NormalTok{(region, dollars\_per\_day, }\AttributeTok{FUN =}\NormalTok{ median)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, region)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/unnamed-chunk-360-1} \end{center}

Ya podemos ver que efectivamente existe una dicotomía ``el Oeste versus el Resto'': hay dos grupos claros, con el grupo rico compuesto por Norteamérica, Europa del Norte y Occidental, Nueva Zelanda y Australia. Definimos grupos basados en esta observación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{group =} \FunctionTok{case\_when}\NormalTok{(}
\NormalTok{    region }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Western Europe"}\NormalTok{, }\StringTok{"Northern Europe"}\NormalTok{,}\StringTok{"Southern Europe"}\NormalTok{,}
                  \StringTok{"Northern America"}\NormalTok{,}
                  \StringTok{"Australia and New Zealand"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"West"}\NormalTok{,}
\NormalTok{    region }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Eastern Asia"}\NormalTok{, }\StringTok{"South{-}Eastern Asia"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"East Asia"}\NormalTok{,}
\NormalTok{    region }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Caribbean"}\NormalTok{, }\StringTok{"Central America"}\NormalTok{,}
                  \StringTok{"South America"}\NormalTok{) }\SpecialCharTok{\textasciitilde{}} \StringTok{"Latin America"}\NormalTok{,}
\NormalTok{    continent }\SpecialCharTok{==} \StringTok{"Africa"} \SpecialCharTok{\&}
\NormalTok{      region }\SpecialCharTok{!=} \StringTok{"Northern Africa"} \SpecialCharTok{\textasciitilde{}} \StringTok{"Sub{-}Saharan"}\NormalTok{,}
    \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}} \StringTok{"Others"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Convertimos esta variable \texttt{group} en un factor para controlar el orden de los niveles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{group =} \FunctionTok{factor}\NormalTok{(group, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Others"}\NormalTok{, }\StringTok{"Latin America"}\NormalTok{,}
                                          \StringTok{"East Asia"}\NormalTok{, }\StringTok{"Sub{-}Saharan"}\NormalTok{,}
                                          \StringTok{"West"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

En la siguiente sección mostramos cómo visualizar y comparar distribuciones entre grupos.

\hypertarget{diagramas-de-caja-2}{%
\subsection{Diagramas de caja}\label{diagramas-de-caja-2}}

El anterior análisis exploratorio de datos reveló dos características sobre la distribución de ingreso promedio en 1970. Usando un histograma, encontramos una distribución bimodal con los modos relacionados con los países pobres y ricos. Ahora queremos comparar la distribución entre estos cinco grupos para confirmar la dicotomía ``el Oeste versus el Resto''. El número de puntos en cada categoría es lo suficientemente grande como para que un gráfico de resumen pueda ser útil. Podríamos generar cinco histogramas o cinco gráficos de densidad, pero puede ser más práctico tener todos los resúmenes visuales en un gráfico. Por lo tanto, comenzamos apilando diagramas de caja uno al lado del otro. Tengan en cuenta que añadimos la capa \texttt{theme(axis.text.x\ =\ element\_text(angle\ =\ 90,\ hjust\ =\ 1))} para que las etiquetas de grupo sean verticales, ya que no encajan si las mostramos horizontalmente, y para quitar la etiqueta del eje a fin de hacer espacio.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(group, dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{angle =} \DecValTok{90}\NormalTok{, }\AttributeTok{hjust =} \DecValTok{1}\NormalTok{))}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dollars-per-day-boxplot-1} \end{center}

Los diagramas de caja tienen la limitación de que al resumir los datos en cinco números, se pueden perder características importantes de los datos. Una forma de evitar esto es mostrando los datos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dollars-per-day-boxplot-with-data-1} \end{center}

\hypertarget{gruxe1ficos-ridge}{%
\subsection{\texorpdfstring{Gráficos \emph{ridge}}{Gráficos ridge}}\label{gruxe1ficos-ridge}}

Mostrar cada punto individual no siempre revela características importantes de la distribución. Aunque no es el caso aquí, cuando el número de puntos de datos es demasiado grande acabamos sobregraficando y mostrar los datos puede ser contraproducente. Los diagramas de caja ayudan con esto al proveer un resumen de cinco números, pero esto también tiene limitaciones. Por ejemplo, los diagramas de caja no revelan distribuciones bimodales. Para ver esto, miren los dos gráficos abajo que resumen el mismo set de datos:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/boxplot-dont-show-bimodal-1} \end{center}

En los casos en que nos preocupa que el resumen del diagrama de caja sea demasiado simplista, podemos mostrar densidades suaves o histogramas apilados utilizando \emph{gráficos ridge}. Como estamos acostumbrados a visualizar densidades con valores en el eje-x, las apilamos verticalmente. Además, debido a que necesitamos más espacio en este enfoque, es conveniente superponerlos. El paquete \textbf{ggridges} incluye una función conveniente para hacer esto. Abajo vemos los datos de ingresos, que mostramos arriba con diagramas de caja, pero ahora visualizados con un \emph{gráfico ridge}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggridges)}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, group)) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{)}
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_density\_ridges}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ridge-plot-1} \end{center}

Tengan en cuenta que tenemos que invertir el \texttt{x} e \texttt{y} que se usaron para el diagrama de caja. Un parametro útil de \texttt{geom\_density\_ridges} es \texttt{scale}, que les permite determinar cuánto superponer; por ejemplo, \texttt{scale\ =\ 1} significa que no hay superposición. Valores mayores que 1 resultan en mayor superposición.

Si el número de puntos de datos es lo suficientemente pequeño, podemos añadirlos al gráfico \emph{ridge} usando el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_density\_ridges}\NormalTok{(}\AttributeTok{jittered\_points =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ridge-plot-with-points-1} \end{center}

Por defecto, la altura de los puntos está \emph{jittered} y no se debe interpretar de ninguna manera. Para mostrar puntos de datos, pero sin usar \emph{jitter}, podemos usar el siguiente código para agregar lo que se conoce como una representación \emph{rug} de los datos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_density\_ridges}\NormalTok{(}\AttributeTok{jittered\_points =} \ConstantTok{TRUE}\NormalTok{,}
                        \AttributeTok{position =} \FunctionTok{position\_points\_jitter}\NormalTok{(}\AttributeTok{height =} \DecValTok{0}\NormalTok{),}
                        \AttributeTok{point\_shape =} \StringTok{\textquotesingle{}|\textquotesingle{}}\NormalTok{, }\AttributeTok{point\_size =} \DecValTok{3}\NormalTok{,}
                        \AttributeTok{point\_alpha =} \DecValTok{1}\NormalTok{, }\AttributeTok{alpha =} \FloatTok{0.7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ridge-plot-with-rug-1} \end{center}

\hypertarget{ejemplo-distribuciones-de-ingresos-de-1970-versus-2010}{%
\subsection{Ejemplo: distribuciones de ingresos de 1970 versus 2010}\label{ejemplo-distribuciones-de-ingresos-de-1970-versus-2010}}

La exploración de datos muestra claramente que en 1970 hubo una dicotomía del ``Oeste versus el Resto''. ¿Pero persiste esta dicotomía? Vamos a usar \texttt{facet\_grid} para ver cómo han cambiado las distribuciones. Para comenzar, nos enfocamos en dos grupos: el Oeste y el Resto. Hacemos cuatro histogramas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{past\_year }\OtherTok{\textless{}{-}} \DecValTok{1970}
\NormalTok{present\_year }\OtherTok{\textless{}{-}} \DecValTok{2010}
\NormalTok{years }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(past\_year, present\_year)}
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(gdp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{west =} \FunctionTok{ifelse}\NormalTok{(group }\SpecialCharTok{==} \StringTok{"West"}\NormalTok{, }\StringTok{"West"}\NormalTok{, }\StringTok{"Developing"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(year }\SpecialCharTok{\textasciitilde{}}\NormalTok{ west)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-hist-west-v-developing-two-years-1} \end{center}

Antes de interpretar los hallazgos de este gráfico, notamos que hay más países representados en los histogramas de 2010 que en 1970: los conteos totales son mayores. Una razón para esto es que varios países se fundaron después de 1970. Por ejemplo, la Unión Soviética se dividió en diferentes países durante la década de 1990. Otra razón es que hay mas datos disponibles para más países en 2010.

Rehacemos los gráficos utilizando solo países con datos disponibles para ambos años. En la parte sobre \emph{wrangling} de datos de este libro, aprenderemos a usar herramientas de \textbf{tidyverse} que nos permitará escribir código eficiente para esto, pero aquí podemos usar un código sencillo usando la función \texttt{intersect}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{country\_list\_1 }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ past\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(country)}

\NormalTok{country\_list\_2 }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==}\NormalTok{ present\_year }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(country)}

\NormalTok{country\_list }\OtherTok{\textless{}{-}} \FunctionTok{intersect}\NormalTok{(country\_list\_1, country\_list\_2)}
\end{Highlighting}
\end{Shaded}

Estos 108 constituyen
86\% de la población mundial, por lo que este subconjunto debe ser representativo.

Vamos a rehacer el gráfico, pero solo para este subconjunto simplemente agregando \texttt{country\ \%in\%\ country\_list} a la función \texttt{filter}:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-histogram-west-v-devel-1} \end{center}

Ahora vemos que los países ricos se han vuelto un poco más ricos, pero en términos de porcentaje, los países pobres parecen haber mejorado más. En particular, vemos que la proporción de países \emph{en desarrollo} que ganan más de \$16 por día aumentó sustancialmente.

Para ver qué regiones específicas mejoraron más, podemos rehacer los diagramas de caja que hicimos anteriormente, pero ahora añadimos el año 2010 y luego usamos \emph{facet} para comparar los dos años.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(group, dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{angle =} \DecValTok{90}\NormalTok{, }\AttributeTok{hjust =} \DecValTok{1}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(. }\SpecialCharTok{\textasciitilde{}}\NormalTok{ year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/income-histogram-by-region-1} \end{center}

Aquí pausamos para presentar otra importante característica de \textbf{ggplot2}. Como queremos comparar cada región antes y después, sería conveniente tener el diagrama de caja de 1970 al lado del de 2010 para cada región. En general, las comparaciones son más fáciles cuando los datos se grafican uno al lado del otro.

Entonces, en lugar de separar en facetas, mantenemos los datos de cada año juntos y pedimos colorearlos (o rellenarlos) según el año. Tengan en cuenta que los grupos se separan automáticamente por año y cada par de diagramas de caja se dibujan uno al lado del otro. Como el año es un número, lo convertimos en un factor ya que \textbf{ggplot2} asigna automáticamente un color a cada categoría de un factor. Recuerden que tenemos que convertir la columnas \texttt{year} de numérica a factor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \FunctionTok{factor}\NormalTok{(year)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(group, dollars\_per\_day, }\AttributeTok{fill =}\NormalTok{ year)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{angle =} \DecValTok{90}\NormalTok{, }\AttributeTok{hjust =} \DecValTok{1}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-histogram-west-v-devel-by-year-1} \end{center}

Finalmente, señalamos que si lo más que nos interesa es comparar los valores de antes y después, podría tener más sentido graficar los aumentos porcentuales. Todavía no estamos listos para aprender a codificar esto, pero así es como se vería el gráfico:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-west-v-devel-before-after-ratio-1} \end{center}

La exploración de datos previa sugiere que la brecha de ingresos entre países ricos y pobres se ha reducido considerablemente durante los últimos 40 años. Usamos una serie de histogramas y diagramas de caja para ver esto. Sugerimos una forma sucinta de transmitir este mensaje con solo un gráfico.

Empecemos observando que los gráficos de densidad para la distribución del ingreso en 1970 y 2010 transmiten el mensaje de que la brecha se está cerrando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{fill =} \StringTok{"grey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(. }\SpecialCharTok{\textasciitilde{}}\NormalTok{ year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/income-smooth-density-by-year-1} \end{center}

En el gráfico de 1970, vemos dos modas claras: países pobres y ricos. En 2010, parece que algunos de los países pobres se han desplazado hacia la derecha, cerrando la brecha.

El próximo mensaje que debemos transmitir es que la razón de este cambio en distribución es que varios países pobres se hicieron más ricos, en lugar de que algunos países ricos se hicieron más pobres. Para hacer esto, podemos asignar un color a los grupos que identificamos durante la exploración de datos.

Sin embargo, primero tenemos que aprender a hacer estas densidades suaves de una manera que conserve la información sobre el número de países en cada grupo. Para entender por qué necesitamos esto, recuerden la discrepancia en el tamaño de cada grupo:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{rr}
\toprule
Developing & West\\
\midrule
87 & 21\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Pero cuando superponemos dos densidades, el comportamiento por defecto es que el área representada por cada distribución sume a 1, independientemente del tamaño de cada grupo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{group =} \FunctionTok{ifelse}\NormalTok{(group }\SpecialCharTok{==} \StringTok{"West"}\NormalTok{, }\StringTok{"West"}\NormalTok{, }\StringTok{"Developing"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, }\AttributeTok{fill =}\NormalTok{ group)) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(year }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-smooth-density-by-year-west-v-developing-1} \end{center}

El gráfico de arriba hace que parezca que hay el mismo número de países en cada grupo. Para cambiar esto, necesitaremos aprender a acceder a las variables calculadas con la función \texttt{geom\_density}.

\hypertarget{cuxf3mo-obtener-acceso-a-variables-calculadas}{%
\subsection{Cómo obtener acceso a variables calculadas}\label{cuxf3mo-obtener-acceso-a-variables-calculadas}}

Para que las áreas de estas densidades sean proporcionales al tamaño de los grupos, simplemente multiplicamos los valores del eje-y por el tamaño del grupo. En el archivo de ayuda de \texttt{geom\_density}, vemos que las funciones calculan una variable denominada \texttt{count} que hace exactamente esto. Queremos que esta variable, y no la densidad, esté en el eje-y.

En \textbf{ggplot2}, obtenemos acceso a estas variables rodeando el nombre con dos puntos. Por lo tanto, utilizaremos el siguiente mapeo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ dollars\_per\_day, }\AttributeTok{y =}\NormalTok{ ..count..)}
\end{Highlighting}
\end{Shaded}

Ahora podemos crear el diagrama deseado simplemente cambiando el mapeo en el fragmento del código anterior. También ampliaremos los límites del eje-x.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{group =} \FunctionTok{ifelse}\NormalTok{(group }\SpecialCharTok{==} \StringTok{"West"}\NormalTok{, }\StringTok{"West"}\NormalTok{, }\StringTok{"Developing"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, }\AttributeTok{y =}\NormalTok{ ..count.., }\AttributeTok{fill =}\NormalTok{ group)) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{, }\AttributeTok{limit =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.125}\NormalTok{, }\DecValTok{300}\NormalTok{))}

\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(year }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-smooth-density-counts-1} \end{center}

Si queremos que las densidades sean más suaves, usamos el argumento \texttt{bw} para que se use el mismo parámetro de suavizado en cada densidad. Seleccionamos 0.75 después de probar varios valores.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{bw =} \FloatTok{0.75}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{facet\_grid}\NormalTok{(year }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-smooth-density-counts-by-year-1} \end{center}

Este gráfico ahora muestra lo que está sucediendo muy claramente. La distribución del mundo en desarrollo está cambiando. Aparece una tercera moda formada por los países que más redujeron la brecha.

Para visualizar si alguno de los grupos definidos anteriormente son la causa principal de estos cambios, rápidamente podemos hacer un gráfico \emph{ridge}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(dollars\_per\_day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, group)) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_density\_ridges}\NormalTok{(}\AttributeTok{adjust =} \FloatTok{1.5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(. }\SpecialCharTok{\textasciitilde{}}\NormalTok{ year)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ridge-plot-income-five-regions-1} \end{center}

Otra forma de lograr esto es apilando las densidades una encima de otra:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{\%in\%}\NormalTok{ years }\SpecialCharTok{\&}\NormalTok{ country }\SpecialCharTok{\%in\%}\NormalTok{ country\_list) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(year) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{weight =}\NormalTok{ population}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(population)}\SpecialCharTok{*}\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(dollars\_per\_day, }\AttributeTok{fill =}\NormalTok{ group)) }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{, }\AttributeTok{limit =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.125}\NormalTok{, }\DecValTok{300}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{bw =} \FloatTok{0.75}\NormalTok{, }\AttributeTok{position =} \StringTok{"stack"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(year }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-smooth-density-counts-by-region-and-year-1} \end{center}

Aquí podemos ver claramente cómo las distribuciones para Asia Oriental, América Latina y otros se desplazan notablemente hacia la derecha. Mientras que África subsahariana permanece estancada.

Noten que ordenamos los niveles del grupo para que la densidad del Occidente se grafique primero, luego África subsahariana. Tener los dos extremos graficados primero nos permite ver mejor la bimodalidad restante.

\hypertarget{densidades-ponderadas}{%
\subsection{Densidades ponderadas}\label{densidades-ponderadas}}

Como punto final, notamos que estas distribuciones ponderan cada país igual. Entonces si la mayoría de la población está mejorando, pero viviendo en un país muy grande, como China, podríamos no apreciar esto. De hecho, podemos ponderar las densidades suaves usando el argumento de mapeo \texttt{weight}. El gráfico entonces se ve así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-smooth-density-counts-by-region-year-weighted-1} \end{center}

Esta figura en particular muestra muy claramente cómo se está cerrando la brecha de distribución de ingresos y que la mayoría de paises que siguen en la pobreza están en África subsahariana.

\hypertarget{la-falacia-ecoluxf3gica-y-la-importancia-de-mostrar-los-datos}{%
\section{La falacia ecológica y la importancia de mostrar los datos}\label{la-falacia-ecoluxf3gica-y-la-importancia-de-mostrar-los-datos}}

A lo largo de esta sección, hemos estado comparando regiones del mundo. Hemos visto que, en promedio, algunas regiones obtienen mejores resultados que otras. En esta sección, nos enfocamos en describir la importancia de la variabilidad dentro de los grupos al examinar la relación entre las tasas de mortalidad infantil de un país y el ingreso promedio.

Definimos algunas regiones más y comparamos los promedios entre regiones:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ecological-fallacy-averages-1} \end{center}

La relación entre estas dos variables es casi perfectamente lineal y el gráfico muestra una diferencia dramática. Mientras que en el Occidente mueren menos del 0.5\% de los bebés, ¡en África subsahariana la tasa es superior al 6\%!

Observen que el gráfico utiliza una nueva transformación, la transformación logística.

\hypertarget{logit}{%
\subsection{Transformación logística}\label{logit}}

La transformación logística o \emph{logit} para una proporción o tasa \(p\) se define como:

\[f(p) = \log \left( \frac{p}{1-p} \right)\]

Cuando \(p\) es una proporción o probabilidad, la cantidad que transformamos con el logaritmo, \(p/(1-p)\), se llama \emph{odds}. En este caso \(p\) es la proporción de bebés que sobrevivieron. Los \emph{odds} nos dicen cuántos más bebés se espera que sobrevivan a que mueran. La transformación logarítmica lo hace simétrico. Si las tasas son iguales, entonces el \emph{log odds} es 0. Los aumentos multiplicativos se convierten en incrementos positivos o negativos, respectivamente.

Esta escala es útil cuando queremos resaltar diferencias cercanas a 0 o 1. Para las tasas de supervivencia, esto es importante porque una tasa de supervivencia del 90\% es inaceptable, mientras que una supervivencia del 99\% es relativamente buena. Preferiríamos mucho una tasa de supervivencia más cercana al 99.9\%. Queremos que nuestra escala resalte estas diferencias y el \emph{logit} lo hace. Recuerden que 99.9/0.1 es aproximadamente 10 veces más grande que 99/1, que es aproximadamente 10 veces más grande que 90/10. Al usar el logaritmo, estos incrementos multiplicativos se convierten en aumentos constantes.

\hypertarget{mostrar-los-datos}{%
\subsection{Mostrar los datos}\label{mostrar-los-datos}}

Ahora, regresamos a nuestro gráfico. Basado en el gráfico anterior, ¿concluimos que un país con ingresos bajos está destinado a tener una tasa de supervivencia baja? Además, ¿concluímos que las tasas de supervivencia en el África subsahariana son más bajas que en el sur de Asia, que a su vez son más bajas que en las islas del Pacífico y así sucesivamente?

Llegar a esta conclusión basada en un gráfico que muestra promedios se denomina una \emph{falacia ecológica}. La relación casi perfecta entre las tasas de supervivencia y los ingresos solo se observa para los promedios a nivel regional. Cuando mostramos todos los datos, vemos una historia más complicada:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ecological-fallacy-all-data-1} \end{center}

Específicamente, vemos que hay una gran cantidad de variabilidad. Vemos que los países de las mismas regiones pueden ser bastante diferentes y que los países con los mismos ingresos pueden tener diferentes tasas de supervivencia. Por ejemplo, mientras que, en promedio, África subsahariana tuvo los peores resultados económicos y de salud, existe una gran variabilidad dentro de ese grupo. Mauricio y Botswana están mejores que Angola y Sierra Leona, con Mauricio comparable a países occidentales.

\hypertarget{principios-de-visualizaciuxf3n-de-datos}{%
\chapter{Principios de visualización de datos}\label{principios-de-visualizaciuxf3n-de-datos}}

Ya hemos presentado algunas reglas a seguir mientras creamos gráficos para nuestros ejemplos. Aquí nuestro objetivo es ofrecer algunos principios generales que podemos usar como guía para una visualización de datos efectiva. Gran parte de esta sección se basa en una charla de Karl Broman\footnote{\url{http://kbroman.org/}} titulada ``Creating Effective Figures and Tables''\footnote{\url{https://www.biostat.wisc.edu/~kbroman/presentations/graphs2017.pdf}} e incluye algunas de las figuras que se hicieron con el código que Karl pone a disposición en su repositorio de GitHub\footnote{\url{https://github.com/kbroman/Talk_Graphs}}, así como las notas de la clase ``Introduction to Data Visualization'' de Peter Aldhous\footnote{\url{http://paldhous.github.io/ucb/2016/dataviz/index.html}}. Siguiendo el enfoque de Karl, mostramos algunos ejemplos de estilos de gráficos que debemos evitar, explicamos cómo mejorarlos y entonces los usamos como motivación para una lista de principios. Además, comparamos y contrastamos los gráficos que siguen estos principios con otros que los ignoran.

Los principios se basan principalmente en investigaciones relacionadas a la manera en que los humanos detectan patrones y hacen comparaciones visuales. Los enfoques preferidos son aquellos que mejor se adaptan a la forma en que nuestros cerebros procesan la información visual. Al escoger las herramientas de visualización, es importante tener en cuenta nuestro objetivo. Podemos estar comparando una cantidad de números suficientemente pequeña que se pueden distinguir, describiendo distribuciones de datos categóricos o valores numéricos, comparando los datos de dos grupos o describiendo la relación entre dos variables. Todo esto afecta la presentación que escojeremos. Como nota final, queremos enfatizar que para los científicos de datos es importante adaptar y optimizar los gráficos para la audiencia. Por ejemplo, un gráfico exploratorio hecho para nosotros será diferente a una tabla destinada a comunicar un hallazgo a una audiencia general.

Utilizaremos estos paquetes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{library}\NormalTok{(gridExtra)}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-codificar-datos-utilizando-seuxf1ales-visuales}{%
\section{Cómo codificar datos utilizando señales visuales}\label{cuxf3mo-codificar-datos-utilizando-seuxf1ales-visuales}}

Comenzamos describiendo algunos principios para codificar datos. Hay varios acercamientos a nuestra disposición que incluyen posición, largo, ángulos, área, brillo y tono de color.

Para ilustrar cómo se comparan algunas de estas estrategias, supongan que queremos informar los resultados de dos encuestas hipotéticas, tomadas en 2000 y luego en 2015, con respecto a la preferencia de navegador. Para cada año, simplemente estamos comparando cinco cantidades: los cinco porcentajes. Una representación gráfica de porcentajes ampliamente utilizada y popularizada por Microsoft Excel, es el gráfico circular:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/piechart-1} \end{center}

Aquí estamos representando cantidades con áreas y ángulos, ya que tanto el ángulo como el área de cada sección del gráfico son proporcionales a la cantidad que representa el sector. Esto resulta ser una opción subóptima dado que, como lo demuestran los estudios de percepción, los humanos no son buenos para cuantificar ángulos con precisión y son aún peores cuando el área es la única señal visual disponible. El gráfico de anillo es un ejemplo de un gráfico que usa solo área:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/donutchart-1} \end{center}

Para ver cuán difícil es cuantificar los ángulos y el área, recuerden que las clasificaciones y todos los porcentajes en los gráficos anteriores cambiaron de 2000 a 2015. ¿Pueden determinar los porcentajes reales y clasificar la popularidad de los navegadores? ¿Pueden ver cómo los porcentajes cambiaron de 2000 a 2015? No es fácil distinguirlo del gráfico. De hecho, la función \texttt{pie} de la página de ayuda de R señala que:

\begin{quote}
Los gráficos circulares son una forma muy mala de mostrar información. El ojo es bueno juzgando medidas lineales y malo juzagando áreas relativas. Un diagrama de barras o de puntos es una forma preferible de mostrar este tipo de datos.
\end{quote}

En este caso, simplemente mostrar los números no solo es más claro, sino que también ahorraría costos de impresión si imprimen una copia en papel:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lrr}
\toprule
Browser & 2000 & 2015\\
\midrule
Opera & 3 & 2\\
Safari & 21 & 22\\
Firefox & 23 & 21\\
Chrome & 26 & 29\\
IE & 28 & 27\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

La forma preferida de graficar estas cantidades es usar la longitud y la posición como señales visuales, ya que los humanos son mucho mejores juzgando medidas lineales. El diagrama de barras usa este enfoque al usar barras de longitud proporcionales a las cantidades de interés. Al añadir líneas horizontales a valores estratégicamente elegidos, en este caso en cada múltiplo de 10, aliviamos la carga visual de cuantificar a través de la posición de la parte superior de las barras. Comparen y contrasten la información que podemos extraer de los siguientes dos pares de gráficos.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/two-barplots-1} \end{center}

Observen lo fácil que es ver las diferencias en el diagrama de barras. De hecho, ahora podemos determinar los porcentajes reales siguiendo una línea horizontal hasta el eje-x.

Si por alguna razón tienen que hacer un gráfico circular, etiqueten cada sección del círculo con su porcentaje respectivo para que la audiencia no tenga que inferirlos de los ángulos o del área:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/excel-barplot-1} \end{center}

En general, cuando se muestran cantidades, se prefieren la posición y la longitud sobre los ángulos y/o el área. El brillo y el color son aún más difíciles de cuantificar que los ángulos. Pero, como veremos más adelante, a veces son útiles cuando se deben mostrar más de dos dimensiones a la vez.

\hypertarget{cuuxe1ndo-incluir-0}{%
\section{Cuándo incluir 0}\label{cuuxe1ndo-incluir-0}}

Cuando se usan diagramas de barras, es erróneo no comenzar las barras en 0. Esto se debe a que, al usar un diagrama de barras, estamos implicando que la longitud es proporcional a las cantidades que se muestran. Al evitar 0, se pueden hacer diferencias relativamente pequeñas verse mucho más grandes de lo que realmente son. Este acercamiento a menudo es utilizado por políticos o medios de comunicación que intentan exagerar la diferencia. A continuación se muestra un ejemplo ilustrativo utilizado por Peter Aldhous en su conferencia\footnote{\url{http://paldhous.github.io/ucb/2016/dataviz/week2.html}}.

\begin{center}\includegraphics[width=0.7\linewidth]{dataviz/img/class2_8} \end{center}

(Fuente: Fox News, vía Media Matters\footnote{\url{http://mediamatters.org/blog/2013/04/05/fox-news-newest-dishonest-chart-immigration-enf/193507}}.)

En el gráfico anterior, las detenciones parecen haber casi triplicado cuando, de hecho, solo han aumentado aproximadamente un 16\%. Comenzar el gráfico en 0 ilustra esto claramente:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-from-zero-1-1} \end{center}

Abajo vemos otro ejemplo, que se describe en detalle en un artículo del blog ``Flowing Data'':

\begin{center}\includegraphics[width=0.7\linewidth]{dataviz/img/Bush-cuts} \end{center}

(Fuente: Fox News, a través de Flowing Data\footnote{\url{http://flowingdata.com/2012/08/06/fox-news-continues-charting-excellence/}}.)

Este gráfico hace que un aumento del 13\% parezca cinco veces más grande. Aquí tenemos el gráfico apropiado:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-from-zero-2-1} \end{center}

Finalmente, aquí tenemos un ejemplo extremo que hace que una diferencia muy pequeña, de menos de 2\%, parezca 10 a 100 veces más grande:

\begin{center}\includegraphics[width=0.7\linewidth]{dataviz/img/venezuela-election} \end{center}

(Fuente:
El Mundo\footnote{\url{https://www.elmundo.es/america/2013/04/15/venezuela/1366029653.html}} y Diego Mariano.)

Aquí está el gráfico apropiado:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-from-zero-3-1} \end{center}

Cuando se usa posición en lugar de longitud, no es necesario incluir 0. Este es el caso en particular cuando queremos comparar las diferencias entre los grupos en relación con la variabilidad dentro de un grupo. Aquí tenemos un ejemplo ilustrativo que muestra la esperanza de vida promedio de cada país estratificada por continente en 2012:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/points-plot-not-from-zero-1} \end{center}

Tengan en cuenta que en el gráfico de la izquierda, que incluye 0, el espacio entre 0 y 43 no añade información y hace que sea más difícil comparar la variabilidad entre y dentro del grupo.

\hypertarget{no-distorsionar-cantidades}{%
\section{No distorsionar cantidades}\label{no-distorsionar-cantidades}}

Durante el discurso del Estado de la Unión de 2011 del Presidente Barack Obama, se utilizó el siguiente gráfico para comparar el PIB de EE. UU. con el PIB de cuatro naciones competidoras:

\begin{center}\includegraphics[width=0.7\linewidth]{dataviz/img/state-of-the-union} \end{center}

(Fuente: The 2011 State of the Union Address\footnote{\url{https://www.youtube.com/watch?v=kl2g40GoRxg}}.)

Si juzgamos por el área de los círculos, Estados Unidos parece tener una economía cinco veces más grande que la de China y más de 30 veces más grande que la de Francia. Sin embargo, si nos fijamos en los números actuales, vemos que este no es el caso. Las proporciones son 2.6 y 5.8 veces mayores que las de China y Francia, respectivamente. La razón de esta distorsión es que el radio del círculo, en lugar del área, se hizo proporcional a la cantidad, lo que implica que la proporción entre las áreas es cuadrada: 2.6 se convierte en 6.5 y 5.8 se convierte en 34.1. Aquí hay una comparación de los círculos que obtenemos si hacemos que el valor sea proporcional al radio y al área:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/area-not-radius-1} \end{center}

No sorprende entonces que por defecto \textbf{ggplot2} use el área en lugar del radio. Sin embargo, en este caso, realmente no deberíamos usar el área, ya que podemos usar la posición y la longitud:

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/barplot-better-than-area-1} \end{center}

\hypertarget{ordenar-categoruxedas-por-un-valor-significativo}{%
\section{Ordenar categorías por un valor significativo}\label{ordenar-categoruxedas-por-un-valor-significativo}}

Cuando uno de los ejes se usa para mostrar categorías, como se hace en los diagramas de barras, el comportamiento por defecto de \textbf{ggplot2} es ordenar las categorías alfabéticamente cuando se definen por cadenas de caracteres. Si están definidas por factores, se ordenan según los niveles de factores. Raras veces queremos usar el orden alfabético. En cambio, debemos ordenar por una cantidad significativa. En todos los casos anteriores, los diagramas de barras se ordenaron según los valores que mostraban. La excepción fueron los diagramas de barras comparando navegadores. En ese caso, mantuvimos el orden igual en todos los diagramas de barras para facilitar la comparación. Específicamente, en vez de ordenar los navegadores por separado en los dos años, ordenamos ambos años por el valor promedio de 2000 y 2015.

Anteriormente aprendimos a usar la función \texttt{reorder}, que nos ayuda a lograr este objetivo. Para apreciar cómo el orden correcto puede ayudar a transmitir un mensaje, supongan que queremos crear un gráfico para comparar la tasa de homicidios en todos los estados de EE.UU. Estamos particularmente interesados en los estados más peligrosos y los más seguros. Tengan en cuenta la diferencia cuando ordenamos alfabéticamente, la accion por defecto, versus cuando ordenamos por la tasa real:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/do-not-order-alphabetically-1} \end{center}

Podemos hacer el segundo gráfico así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(murders)}
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{murder\_rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{100000}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{state =} \FunctionTok{reorder}\NormalTok{(state, murder\_rate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(state, murder\_rate)) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat=}\StringTok{"identity"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{coord\_flip}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.y =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{6}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La función \texttt{reorder} también nos permite reordenar grupos. Anteriormente vimos un ejemplo relacionado con la distribución de ingresos entre regiones. Aquí vemos las dos versiones graficadas una contra la otra:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/reorder-boxplot-example-1} \end{center}

El primer gráfico ordena las regiones alfabéticamente, mientras que el segundo las ordena por la mediana del grupo.

\hypertarget{mostrar-los-datos-1}{%
\section{Mostrar los datos}\label{mostrar-los-datos-1}}

Nos hemos enfocado en mostrar cantidades únicas en todas las categorías. Ahora cambiamos nuestra atención a la visualización de datos con un enfoque en la comparación de grupos.

Para motivar nuestro primer principio, ``mostrar los datos'', volvemos a nuestro ejemplo artificial de describir alturas a ET, un extraterrestre. Esta vez supongan que ET está interesado en la diferencia de alturas entre hombres y mujeres. Un gráfico comúnmente utilizado para comparaciones entre grupos y popularizado por software como Microsoft Excel, es el \emph{dynamite plot}, que muestra el promedio y los errores estándar (los errores estándar se definen en un capítulo posterior, pero no los confundan con la desviación estándar de los datos). El gráfico se ve así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/show-data-1-1} \end{center}

El promedio de cada grupo está representado por la parte superior de cada barra y las antenas se extienden desde el promedio al promedio más dos errores estándar. Si todo lo que ET recibe es este gráfico, tendrá poca información sobre qué esperar si se encuentra con un grupo de hombres y mujeres. Las barras van a 0: ¿esto significa que hay humanos pequeños que miden menos de un pie? ¿Todos los varones son más altos que las hembras más altas? ¿Hay una rango de alturas? ET no puede responder a estas preguntas ya que casi no le hemos dado información sobre la distribución de altura.

Esto nos lleva a nuestro primer principio: mostrar los datos. Este código sencillo de \textbf{ggplot2} ya genera un gráfico más informativo que el diagrama de barras al simplemente mostrar todos los puntos de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(sex, height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/show-data-2-1} \end{center}

El gráfico anterior nos da una idea del rango de los datos. Sin embargo, este gráfico también tiene limitaciones, ya que realmente no podemos ver todos los 238 y 812 puntos graficados para hembras y varones, respectivamente, y muchos puntos están graficados uno encima del otro. Como hemos descrito anteriormente, visualizar la distribución es mucho más informativo. Pero antes de hacer esto, señalamos dos formas en que podemos mejorar un gráfico que muestra todos los puntos.

El primero es agregar \emph{jitter}, que añade un pequeño desplazamiento aleatorio a cada punto. En este caso, agregar \emph{jitter} horizontal no cambia la interpretación, ya que las alturas de los puntos no cambian, pero minimizamos el número de puntos que se superponen y, por lo tanto, tenemos una mejor idea visual de cómo se distribuyen los datos. Una segunda mejora proviene del uso de \emph{alpha blending}, que hace que los puntos sean algo transparentes. Entre más puntos se superponen, más oscuro será el gráfico, que también nos ayuda tener una idea de cómo se distribuyen los puntos. Aquí está el mismo gráfico con \emph{jitter} y \emph{alpha blending}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(sex, height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{width =} \FloatTok{0.1}\NormalTok{, }\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/show-points-with-jitter-1} \end{center}

Ahora comenzamos a sentir que, en promedio, los varones son más altos que las hembras. También observamos bandas horizontales oscuras de puntos, que demuestra que muchos estudiantes indican valores que se redondean al entero más cercano.

\hypertarget{cuxf3mo-facilitar-comparaciones}{%
\section{Cómo facilitar comparaciones}\label{cuxf3mo-facilitar-comparaciones}}

\hypertarget{usen-ejes-comunes}{%
\subsection{Usen ejes comunes}\label{usen-ejes-comunes}}

Como hay tantos puntos, es más efectivo mostrar distribuciones que puntos individuales. Por lo tanto, mostramos histogramas para cada grupo:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/common-axes-histograms-wrong-1} \end{center}

Sin embargo, mirando el gráfico arriba, no es inmediatamente obvio que los varones son, en promedio, más altos que las hembras. Tenemos que mirar cuidadosamente para notar que el eje-x tiene un rango más alto de valores en el histograma masculino. Un principio importante aquí es \textbf{mantener los ejes iguales} cuando se comparan datos en dos gráficos. A continuación, vemos cómo la comparación se vuelve más fácil:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/common-axes-histograms-right-1} \end{center}

\hypertarget{alineen-gruxe1ficos-verticalmente-para-ver-cambios-horizontales-y-horizontalmente-para-ver-cambios-verticales}{%
\subsection{Alineen gráficos verticalmente para ver cambios horizontales y horizontalmente para ver cambios verticales}\label{alineen-gruxe1ficos-verticalmente-para-ver-cambios-horizontales-y-horizontalmente-para-ver-cambios-verticales}}

En estos histogramas, la señal visual relacionada con las disminuciones o los aumentos de altura son los cambios hacia la izquierda o hacia la derecha, respectivamente: los cambios horizontales. Alinear los gráficos verticalmente nos ayuda a ver este cambio cuando los ejes son fijos:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/common-axes-histograms-right-2-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(height, ..density..)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{, }\AttributeTok{color=}\StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_grid}\NormalTok{(sex}\SpecialCharTok{\textasciitilde{}}\NormalTok{.)}
\end{Highlighting}
\end{Shaded}

El gráfico anterior hace que sea mucho más fácil notar que los varones son, en promedio, más altos.

Si queremos obtener el resumen compacto que ofrecen los diagramas de caja, tenemos que alinearlos horizontalmente ya que, por defecto, los diagramas de caja se mueven hacia arriba y hacia abajo según los cambios de altura. Siguiendo nuestro principio de ``mostrar los datos'', superponemos todos los puntos de datos:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplot-with-points-with-jitter-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(sex, height)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{(}\AttributeTok{coef=}\DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{width =} \FloatTok{0.1}\NormalTok{, }\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Height in inches"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora comparen y contrasten estos tres gráficos, basados en exactamente los mismos datos:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/show-the-data-comparison-1} \end{center}

Observen cuánto más aprendemos de los dos gráficos a la derecha. Los diagramas de barras son útiles para mostrar un número, pero no son muy útiles cuando queremos describir distribuciones.

\hypertarget{consideren-transformaciones}{%
\subsection{Consideren transformaciones}\label{consideren-transformaciones}}

Hemos motivado el uso de la transformación logarítmica en los casos en que los cambios son multiplicativos. El tamaño de la población fue un ejemplo en el que encontramos que una transformación logarítmica produjo una transformación más informativa.

La combinación de un diagrama de barras elegido incorrectamente y no usar una transformación logarítimica cuando sea necesario puede ser particularmente distorsionante. Como ejemplo, consideren este diagrama de barras que muestra los tamaños de población promedio para cada continente en 2015:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/no-transformations-wrong-use-of-barplot-1} \end{center}

Mirando el gráfico anterior, uno concluiría que los países de Asia son mucho más poblados que los de otros continentes. Siguiendo el principio de ``mostrar los datos'', notamos rápidamente que esto se debe a dos países muy grandes, que suponemos son India y China:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/no-transformation-1} \end{center}

El uso de una transformación logarítmica aquí produce un gráfico mucho más informativo. Comparamos el diagrama de barras original con un diagrama de caja usando la transformación de escala logarítmica para el eje-y:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/correct-transformation-1} \end{center}

Con el nuevo gráfico, nos damos cuenta de que los países de África tienen una población mediana mayor que los de Asia.

Otras transformaciones que deben considerar son la transformación logística (\texttt{logit}), que es útil para ver mejor los cambios en las probabilidades, y la transformación de la raíz cuadrada (\texttt{sqrt}), que es útil para conteos.

\hypertarget{seuxf1ales-visuales-comparadas-deben-estar-adyacentes}{%
\subsection{Señales visuales comparadas deben estar adyacentes}\label{seuxf1ales-visuales-comparadas-deben-estar-adyacentes}}

Para cada continente, comparemos los ingresos en 1970 versus 2010. Al comparar los datos de ingresos entre regiones entre 1970 y 2010, hicimos un gráfico similar al siguiente, pero esta vez investigamos continentes en lugar de regiones.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplots-not-adjacent-1} \end{center}

El comportamiento por defecto de \textbf{ggplot2} es ordenar las etiquetas alfabéticamente para que las etiquetas con 1970 aparezcan antes que las etiquetas con 2010. Esto dificulta las comparaciones porque la distribución de un continente en 1970 está visualmente lejos de su distribución en 2010. Es mucho más fácil hacer la comparación entre 1970 y 2010 para cada continente cuando los diagramas de caja para ese continente están uno al lado del otro:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplot-adjacent-comps-1} \end{center}

\hypertarget{usen-color}{%
\subsection{Usen color}\label{usen-color}}

La comparación se hace aún más fácil si usamos color para denotar las dos cosas que queremos comparar:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplot-adjacent-comps-with-color-1} \end{center}

\hypertarget{consideren-los-daltuxf3nicos}{%
\section{Consideren los daltónicos}\label{consideren-los-daltuxf3nicos}}

Alrededor de 10\% de la población es daltónica. Desafortunadamente, los colores por defecto utilizados en \textbf{ggplot2} no son óptimos para este grupo. Sin embargo, \textbf{ggplot2} hace fácil cambiar la paleta de colores utilizada en los gráficos. Existen ejemplos de paletas que consideran los daltónicos\footnote{\url{http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/\#a-colorblind-friendly-palettefont}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{color\_blind\_friendly\_cols }\OtherTok{\textless{}{-}}
  \FunctionTok{c}\NormalTok{(}\StringTok{"\#999999"}\NormalTok{, }\StringTok{"\#E69F00"}\NormalTok{, }\StringTok{"\#56B4E9"}\NormalTok{, }\StringTok{"\#009E73"}\NormalTok{,}
    \StringTok{"\#F0E442"}\NormalTok{, }\StringTok{"\#0072B2"}\NormalTok{, }\StringTok{"\#D55E00"}\NormalTok{, }\StringTok{"\#CC79A7"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Aquí están los colores:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/color-blind-friendly-colors-1} \end{center}

Además, hay varios recursos en linea que pueden ayudarlos a seleccionar colores\footnote{\url{http://bconnelly.net/2013/10/creating-colorblind-friendly-figures/}}.

\hypertarget{gruxe1ficos-para-dos-variables}{%
\section{Gráficos para dos variables}\label{gruxe1ficos-para-dos-variables}}

En general, deben usar diagramas de dispersión para visualizar la relación entre dos variables. Para cada caso en el que hemos examinado la relación entre dos variables, incluyendo asesinatos totales versus tamaño de población, esperanza de vida versus tasas de fertilidad y mortalidad infantil versus ingresos, hemos utilizado diagramas de dispersión y ese es el gráfico que generalmente recomendamos. Sin embargo, hay algunas excepciones y aquí describimos dos gráficos alternativos: el \emph{slope chart} y el \emph{gráfico Bland-Altman}.

\hypertarget{slope-charts}{%
\subsection{\texorpdfstring{\emph{Slope charts}}{Slope charts}}\label{slope-charts}}

Una excepción en la que otro tipo de gráfico puede ser más informativo es cuando se comparan variables del mismo tipo, pero en diferentes momentos y para un número relativamente pequeño de comparaciones. Por ejemplo, si estamos comparando la esperanza de vida entre 2010 y 2015. En ese caso, recomendaríamos un \emph{slope chart}.

No hay geometría para los \emph{slope charts} en \textbf{ggplot2}, pero podemos construir una usando \texttt{geom\_line}. Necesitamos hacer algunos ajustes para añadir etiquetas. A continuación, mostramos un ejemplo que compara 2010 a 2015 para los grandes países occidentales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{west }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Western Europe"}\NormalTok{,}\StringTok{"Northern Europe"}\NormalTok{,}\StringTok{"Southern Europe"}\NormalTok{,}
          \StringTok{"Northern America"}\NormalTok{,}\StringTok{"Australia and New Zealand"}\NormalTok{)}

\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year}\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{2010}\NormalTok{, }\DecValTok{2015}\NormalTok{) }\SpecialCharTok{\&}\NormalTok{ region }\SpecialCharTok{\%in\%}\NormalTok{ west }\SpecialCharTok{\&}
           \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(life\_expectancy) }\SpecialCharTok{\&}\NormalTok{ population }\SpecialCharTok{\textgreater{}} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{7}\NormalTok{)}

\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{location =} \FunctionTok{ifelse}\NormalTok{(year }\SpecialCharTok{==} \DecValTok{2010}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
         \AttributeTok{location =} \FunctionTok{ifelse}\NormalTok{(year }\SpecialCharTok{==} \DecValTok{2015} \SpecialCharTok{\&}
\NormalTok{                             country }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"United Kingdom"}\NormalTok{, }\StringTok{"Portugal"}\NormalTok{),}
\NormalTok{                           location}\FloatTok{+0.22}\NormalTok{, location),}
         \AttributeTok{hjust =} \FunctionTok{ifelse}\NormalTok{(year }\SpecialCharTok{==} \DecValTok{2010}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \FunctionTok{as.factor}\NormalTok{(year)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, life\_expectancy, }\AttributeTok{group =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{color =}\NormalTok{ country), }\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ location, }\AttributeTok{label =}\NormalTok{ country, }\AttributeTok{hjust =}\NormalTok{ hjust),}
            \AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{ylab}\NormalTok{(}\StringTok{"Life Expectancy"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/slope-plot-1} \end{center}

Una ventaja del \emph{slope chart} es que rápidamente nos permite tener una idea de los cambios basados en la pendiente de las líneas. Aunque estamos usando el ángulo como señal visual, también utilizamos la posición para determinar los valores exactos. Comparar las mejoras es un poco más difícil con un diagrama de dispersión:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/scatter-plot-instead-of-slope-1} \end{center}

En el diagrama de dispersión, hemos seguido el principio de \emph{usar ejes comunes} porque estamos comparando estos antes y después. Sin embargo, si tenemos muchos puntos, los \emph{slope charts} dejan de ser útiles ya que se hace difícil ver todas las líneas.

\hypertarget{gruxe1fico-bland-altman}{%
\subsection{Gráfico Bland-Altman}\label{gruxe1fico-bland-altman}}

Como estamos interesados principalmente en la diferencia, tiene sentido dedicarle uno de nuestros ejes. El gráfico Bland-Altman, también conocido como el gráfico de diferencia de medias de Tukey y como el \emph{MA plot}, muestra la diferencia versus el promedio:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggrepel)}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"life\_expectancy\_"}\NormalTok{, year)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(country, year, life\_expectancy) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_from=}\StringTok{"life\_expectancy"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{average =}\NormalTok{ (life\_expectancy\_2015 }\SpecialCharTok{+}\NormalTok{ life\_expectancy\_2010)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{,}
         \AttributeTok{difference =}\NormalTok{ life\_expectancy\_2015 }\SpecialCharTok{{-}}\NormalTok{ life\_expectancy\_2010) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(average, difference, }\AttributeTok{label =}\NormalTok{ country)) }\SpecialCharTok{+} 
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_text\_repel}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{lty =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Average of 2010 and 2015"}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Difference between 2015 and 2010"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/bland-altman-1} \end{center}

Aquí, al simplemente mirar el eje-y, rápidamente vemos qué países han mostrado la mayor mejora. También, obtenemos una idea del valor general del eje-x.

\hypertarget{cuxf3mo-codificar-una-tercera-variable}{%
\section{Cómo codificar una tercera variable}\label{cuxf3mo-codificar-una-tercera-variable}}

Un diagrama de dispersión anterior mostró la relación entre la supervivencia infantil y el ingreso promedio. A continuación se muestra una versión de este gráfico que codifica tres variables: pertenencia a OPEC, región y población.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/encoding-third-variable-1} \end{center}

Codificamos variables categóricas con color y forma. Estas formas se pueden controlar con el argumento \texttt{shape}. Abajo mostramos las formas disponibles para su uso en R. Para los últimos cinco, el color rellena la forma.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/available-shapes-1} \end{center}

Para variables continuas, podemos usar color, intensidad o tamaño. A continuación ofrecemos un ejemplo de cómo hacer esto con un estudio de caso.

Al seleccionar colores para cuantificar una variable numérica, elegimos entre dos opciones: secuenciales y divergentes. Los colores secuenciales son adecuados para datos que van de mayor a menor. Los valores altos se distinguen claramente de los valores bajos. Aquí tenemos algunos ejemplos ofrecidos por el paquete \texttt{RColorBrewer}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(RColorBrewer)}
\FunctionTok{display.brewer.all}\NormalTok{(}\AttributeTok{type=}\StringTok{"seq"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/r-color-brewer-seq-1} \end{center}

Los colores divergentes se utilizan para representar valores que divergen de un centro. Ponemos igual énfasis en ambos extremos del rango de datos: más altos que el centro y más bajos que el centro. Un ejemplo de cuándo usaríamos un patrón divergente sería cuando mostramos la altura en cuántas desviaciones estándar están del promedio. Aquí hay algunos ejemplos de patrones divergentes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(RColorBrewer)}
\FunctionTok{display.brewer.all}\NormalTok{(}\AttributeTok{type=}\StringTok{"div"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/r-color-brewer-div-1} \end{center}

\hypertarget{eviten-los-gruxe1ficos-pseudo-tridimensionales}{%
\section{Eviten los gráficos pseudo-tridimensionales}\label{eviten-los-gruxe1ficos-pseudo-tridimensionales}}

La siguiente figura, tomada de la literatura científica\footnote{\url{https://projecteuclid.org/download/pdf_1/euclid.ss/1177010488}},
muestra tres variables: dosis, tipo de fármaco y supervivencia. Aunque sus pantallas o páginas de libros son planas y bidimensionales, el gráfico intenta imitar tres dimensiones y asigna una dimensión a cada variable.

\begin{center}\includegraphics[width=0.7\linewidth]{dataviz/img/fig8b} \end{center}

(Imagen cortesía de Karl Broman.)

Los humanos no son buenos para ver en tres dimensiones (que explica por qué es difícil estacionar en paralelo) y nuestra limitación es aún peor con respecto a las pseudo-tres dimensiones. Para ver esto, intenten determinar los valores de la variable de supervivencia en el gráfico anterior. ¿Pueden identificar cuándo la cinta púrpura se cruza con la roja? Este es un ejemplo en el que podemos fácilmente usar color para representar la variable categórica en lugar de un pseudo-3D:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/colors-for-different-lines-1} \end{center}

Observen cuánto más fácil es determinar los valores de supervivencia.

Pseudo-3D a veces se usa de forma totalmente gratuita: los gráficos se hacen para que se vean en 3D incluso cuando la tercera dimensión no representa una cantidad. Esto solo añade confusión y hace que sea más difícil transmitir su mensaje. Aquí hay dos ejemplos:

\begin{center}\includegraphics[width=0.45\linewidth]{dataviz/img/fig1e} \includegraphics[width=0.45\linewidth]{dataviz/img/fig2d} \end{center}

(Imágenes cortesía de Karl Broman.)

\hypertarget{eviten-demasiados-duxedgitos-significativos}{%
\section{Eviten demasiados dígitos significativos}\label{eviten-demasiados-duxedgitos-significativos}}

Por defecto, el software estadístico como R devuelve muchos dígitos significativos. El comportamiento por defecto en R es mostrar 7 dígitos significativos. Esa cantidad de dígitos a menudo no añade información y el desorden visual agregado puede dificultar que se entienda el mensaje. Como ejemplo, aquí están las tasas de enfermedades por cada 10,000 para California en cinco décadas, calculadas de los totales y la población con R:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lrrrr}
\toprule
state & year & Measles & Pertussis & Polio\\
\midrule
California & 1940 & 37.8826320 & 18.3397861 & 0.8266512\\
California & 1950 & 13.9124205 & 4.7467350 & 1.9742639\\
California & 1960 & 14.1386471 & NA & 0.2640419\\
California & 1970 & 0.9767889 & NA & NA\\
California & 1980 & 0.3743467 & 0.0515466 & NA\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Estamos reportando precisión de hasta 0.00001 casos por 10,000, un valor muy pequeño en el contexto de los cambios que ocurren a través del tiempo. En este caso, dos cifras significativas son más que suficientes y claramente indican que las tasas están disminuyendo:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lrrrr}
\toprule
state & year & Measles & Pertussis & Polio\\
\midrule
California & 1940 & 37.9 & 18.3 & 0.8\\
California & 1950 & 13.9 & 4.7 & 2.0\\
California & 1960 & 14.1 & NA & 0.3\\
California & 1970 & 1.0 & NA & NA\\
California & 1980 & 0.4 & 0.1 & NA\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Para cambiar el número de dígitos significativos o redondear números usamos \texttt{signif} y \texttt{round}. Pueden definir el número de dígitos significativos a nivel mundial configurando opciones como esta: \texttt{options(digits\ =\ 3)}.

Otro principio relacionado con la visualización de tablas es colocar los valores que se comparan en columnas en lugar de filas. Observen que nuestra tabla anterior es más fácil de leer que esta:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llrrrrr}
\toprule
state & disease & 1940 & 1950 & 1960 & 1970 & 1980\\
\midrule
California & Measles & 37.9 & 13.9 & 14.1 & 1 & 0.4\\
California & Pertussis & 18.3 & 4.7 & NA & NA & 0.1\\
California & Polio & 0.8 & 2.0 & 0.3 & NA & NA\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

\hypertarget{consideren-a-su-audiencia}{%
\section{Consideren a su audiencia}\label{consideren-a-su-audiencia}}

Los gráficos se pueden usar para 1) nuestros propios análisis exploratorios de datos, 2) para transmitir un mensaje a los expertos o 3) para ayudar a contar una historia a una audiencia general. Asegúrense de que el público destinario comprenda cada elemento del gráfico.

Como un ejemplo sencillo, consideren que para su propia exploración puede ser más útil transformar logarítmicamente los datos y luego graficarlos. Sin embargo, para una audiencia general que no está familiarizada con la conversión de valores logarítmicos a las medidas originales, será mucho más fácil entender el uso de una escala logarítmica para el eje en lugar de los valores transformados logarítmicamente.

\hypertarget{ejercicios-19}{%
\section{Ejercicios}\label{ejercicios-19}}

Para estos ejercicios, utilizaremos los datos de vacunas en el paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(us\_contagious\_diseases)}
\end{Highlighting}
\end{Shaded}

1. Los gráficos circulares son apropiados:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Cuando queremos mostrar porcentajes.
\item
  Cuando \textbf{ggplot2} no está disponible.
\item
  Cuando estoy jugando frisbee.
\item
  Nunca. Los diagramas de barras y las tablas siempre son mejores.
\end{enumerate}

2. ¿Cuál es el problema con el siguiente gráfico?

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/baplot-not-from-zero-exercises-1} \end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Los valores están mal. La votación final fue de 306 a 232.
\item
  El eje no comienza en 0. Juzgando por la longitud, parece que Trump recibió 3 veces más votos cuando, de hecho, fue aproximadamente 30\% más.
\item
  Los colores deben ser iguales.
\item
  Los porcentajes deben mostrarse como un gráfico circular.
\end{enumerate}

3. Mire a los siguientes dos gráficos. Muestran la misma información: tasas de sarampión de 1928 en los 50 estados.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/measels-exercise-1} \end{center}

¿Qué gráfico es más fácil de leer si quiere determinar cuáles son los mejores y peores estados en términos de tasas, y por qué?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Dan la misma información, por lo que ambos son igual de buenos.
\item
  El gráfico de la izquierda es mejor porque ordena los estados alfabéticamente.
\item
  El gráfico de la derecha es mejor porque el orden alfabético no tiene nada que ver con la enfermedad y al ordenar según la tasa real, rápidamente vemos los estados con las tasas más altas y más bajas.
\item
  Ambos gráficos deben ser un gráfico circular.
\end{enumerate}

4. Para hacer el gráfico de la izquierda, tenemos que reordenar los niveles de las variables de los estados.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ us\_contagious\_diseases }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(year }\SpecialCharTok{==} \DecValTok{1967} \SpecialCharTok{\&}\NormalTok{ disease}\SpecialCharTok{==}\StringTok{"Measles"} \SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(population)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ count}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10000} \SpecialCharTok{*} \DecValTok{52}\SpecialCharTok{/}\NormalTok{ weeks\_reporting)}
\end{Highlighting}
\end{Shaded}

Recuerde lo que sucede cuando hacemos un diagrama de barras:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(state, rate)) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat=}\StringTok{"identity"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{coord\_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/barplot-plot-exercise-example-1} \end{center}

Defina estos objetos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{state }\OtherTok{\textless{}{-}}\NormalTok{ dat}\SpecialCharTok{$}\NormalTok{state}
\NormalTok{rate }\OtherTok{\textless{}{-}}\NormalTok{ dat}\SpecialCharTok{$}\NormalTok{count}\SpecialCharTok{/}\NormalTok{dat}\SpecialCharTok{$}\NormalTok{population}\SpecialCharTok{*}\DecValTok{10000}\SpecialCharTok{*}\DecValTok{52}\SpecialCharTok{/}\NormalTok{dat}\SpecialCharTok{$}\NormalTok{weeks\_reporting}
\end{Highlighting}
\end{Shaded}

Redefina el objeto \texttt{state} para que los niveles se reordenen. Imprima el nuevo objeto \texttt{state} y sus niveles para que pueda ver que los niveles no reordenan el vector.

5. Ahora edite el código de arriba para redefinir \texttt{dat} para que los niveles de la variable \texttt{state} se reordenen por la variable \texttt{rate}. Entonces haga un diagrama de barras usando el código anterior, pero para este nuevo \texttt{dat}.

6. Digamos que está interesado en comparar las tasas de homicidios con armas de fuego en todas las regiones de EE. UU. Ve este gráfico:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{population}\SpecialCharTok{*}\DecValTok{100000}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(region) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(rate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{region =} \FunctionTok{factor}\NormalTok{(region)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(region, avg)) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat=}\StringTok{"identity"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Murder Rate Average"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/us-murders-barplot-1} \end{center}

y decide mudarse a un estado en la región occidental. ¿Cuál es el problema principal con esta interpretación?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Las categorías están ordenadas alfabéticamente.
\item
  El gráfico no muestra errores estándar.
\item
  El gráfico no muestra todos los datos. No vemos la variabilidad dentro de una región y es posible que los estados más seguros no estén en el occidente.
\item
  El noreste tiene el promedio más bajo.
\end{enumerate}

7. Haga un diagrama de caja de las tasas de asesinatos que se definen como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{population}\SpecialCharTok{*}\DecValTok{100000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

por región, mostrando todos los puntos y ordenando las regiones por su tasa mediana.

8. Los gráficos a continuación muestran tres variables continuas.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pseudo-3d-exercise-1} \end{center}

La línea \(x=2\) parece separar los puntos. Pero realmente no es el caso, como vemos cuando graficamos los datos en un par de puntos bidimensionales.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pseud-3d-exercise-2-1} \end{center}

¿Por qué pasa esto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Los humanos no son buenos leyendo gráficos pseudo-3D.
\item
  Debe haber un error en el código.
\item
  Los colores nos confunden.
\item
  Los diagramas de dispersión no se deben usar para comparar dos variables cuando tenemos acceso a tres variables.
\end{enumerate}

9. Reproduzca el gráfico de imagen que hicimos anteriormente pero para la viruela. Para este gráfico, no incluya años en los que no se indicaron casos en 10 o más semanas.

10. Ahora reproduzca el gráfico de series de tiempo que hicimos anteriormente, pero esta vez siguiendo las instrucciones de la pregunta anterior.

11. Para el estado de California, haga gráficos de series de tiempo que muestren las tasas de todas las enfermedades. Incluya solo años en los cuales se proveen datos en 10 o más semanas. Use un color diferente para cada enfermedad.

12. Ahora haga lo mismo con las tasas para EE. UU. Sugerencia: calcule la tasa de EE. UU. usando \texttt{summarize}, el total de casos dividido por la población total.

\hypertarget{vaccines}{%
\section{Estudio de caso: las vacunas y las enfermedades infecciosas}\label{vaccines}}

Las vacunas han ayudado a salvar millones de vidas. En el siglo XIX, antes de que se lograra la inmunización de grupo a través de programas de vacunación, las muertes por enfermedades infecciosas, como la viruela y la poliomielitis, eran comunes. Sin embargo, hoy los programas de vacunación se han vuelto algo controversiales a pesar de toda la evidencia científica de su importancia.

La controversia comenzó con un artículo\footnote{\url{http://www.thelancet.com/journals/lancet/article/PIIS0140-6736(97)11096-0/abstract}} publicado en 1988 y liderado por Andrew Wakefield, que afirmó la existencia de un vínculo entre la administración de la vacuna contra el sarampión, las paperas y la rubéola, y el autismo y las enfermedades intestinales.
A pesar de la gran cantidad de evidencia científica que contradice este hallazgo, los informes sensacionalistas de los medios de comunicación y el alarmismo de los que creen en teorías de conspiración llevaron a partes del público a creer que las vacunas eran perjudiciales. Como resultado, muchos padres dejaron de vacunar a sus hijos. Esta práctica peligrosa puede ser potencialmente desastrosa dado que los Centros para el Control de Enfermedades de EE.UU. (CDC por sus siglas en inglés) estiman que las vacunas evitarán más de 21 millones de hospitalizaciones y 732,000 muertes entre los niños nacidos en los últimos 20 años (ver \emph{Benefits from Immunization during the Vaccines for Children Program Era --- United States, 1994-2013, MMWR}\footnote{\url{https://www.cdc.gov/mmwr/preview/mmwrhtml/mm6316a4.htm}}).
Desde entonces, ``The Lancet'' ha retractado el artículo y Andrew Wakefield finalmente fue ``excluido del registro médico en mayo de 2010 con una observación que indica la falsificación fraudulenta en que incurrió y se le revocó la licencia para ejercer la medicina en el Reino Unido''
(Fuente: Wikipedia\footnote{\url{https://es.wikipedia.org/wiki/Andrew_Wakefield}}). Sin embargo, los conceptos erróneos perduran, en parte debido a activistas autoproclamados que continúan diseminando información errónea sobre las vacunas.

La comunicación efectiva de datos es un fuerte antídoto contra la información errónea y el miedo. Anteriormente enseñamos un ejemplo de un artículo del Wall Street Journal\footnote{\url{http://graphics.wsj.com/infectious-diseases-and-vaccines/}} que muestra datos relacionados con el impacto de las vacunas en la lucha contra las enfermedades infecciosas. A continuación reconstruiremos ese ejemplo.

Los datos utilizados para estos gráficos fueron recopilados, organizados y distribuidos por el Proyecto Tycho\footnote{\url{http://www.tycho.pitt.edu/}} e incluyen conteos reportados semanalmente para siete enfermedades desde 1928 hasta 2011 en los cincuenta estados de EE.UU. Incluimos los totales anuales en el paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(RColorBrewer)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(us\_contagious\_diseases)}
\FunctionTok{names}\NormalTok{(us\_contagious\_diseases)}
\CommentTok{\#\textgreater{} [1] "disease"         "state"           "year"           }
\CommentTok{\#\textgreater{} [4] "weeks\_reporting" "count"           "population"}
\end{Highlighting}
\end{Shaded}

Creamos un objeto temporero \texttt{dat} que almacena solo los datos de sarampión, incluye la tasa por 100,000, ordena a los estados según el valor promedio de enfermedad y elimina Alaska y Hawai ya que estos dos se convirtieron en estados a fines de la década de 1950. Tengan en cuenta que hay una columna \texttt{weeks\_reporting} que nos dice cuántas semanas del año se reportaron datos. Tenemos que ajustar ese valor al calcular la tasa:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the\_disease }\OtherTok{\textless{}{-}} \StringTok{"Measles"}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ us\_contagious\_diseases }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{state}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\StringTok{"Hawaii"}\NormalTok{,}\StringTok{"Alaska"}\NormalTok{) }\SpecialCharTok{\&}\NormalTok{ disease }\SpecialCharTok{==}\NormalTok{ the\_disease) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{mutate}\NormalTok{(}\AttributeTok{rate =}\NormalTok{ count}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10000} \SpecialCharTok{*} \DecValTok{52}\SpecialCharTok{/}\NormalTok{ weeks\_reporting) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{mutate}\NormalTok{(}\AttributeTok{state =} \FunctionTok{reorder}\NormalTok{(state, rate))}
\end{Highlighting}
\end{Shaded}

Ahora podemos graficar fácilmente las tasas de enfermedad por año. Aquí están los datos de sarampión de California:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{==} \StringTok{"California"} \SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(rate)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, rate)) }\SpecialCharTok{+}
\FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
\FunctionTok{ylab}\NormalTok{(}\StringTok{"Cases per 10,000"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{geom\_vline}\NormalTok{(}\AttributeTok{xintercept=}\DecValTok{1963}\NormalTok{, }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/california-measles-time-series-1} \end{center}

Añadimos una línea vertical en 1963, ya que es cuando se introdujo la vacuna\footnote{Control, Centers for Disease; Prevention (2014). CDC health information for international travel 2014 (the yellow book). p.~250. ISBN 9780199948505}.

¿Ahora podemos mostrar datos para todos los estados en un gráfico? Tenemos tres variables para incluir: año, estado y tasa. En la figura del WSJ, usan el eje-x para el año, el eje-y para el estado y el tono de color para representar las tasas. Sin embargo, la escala de colores que utilizan, que va del amarillo al azul al verde al naranja al rojo, se puede mejorar.

En nuestro ejemplo queremos usar una paleta secuencial ya que no hay un centro significativo, solo tasas bajas y altas.

Usamos la geometría \texttt{geom\_tile} para tejar la región con colores que representan las tasas de enfermedad. Usamos una transformación de raíz cuadrada para evitar que los conteos particularmente altos dominen el gráfico. Observen que los valores faltantes se muestran en gris. Además, noten que tan pronto una enfermedad fue prácticamente erradicada, algunos estados dejaron de informar casos por completo. Es por esa razón que vemos tanto gris después de 1980.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, state, }\AttributeTok{fill =}\NormalTok{ rate)) }\SpecialCharTok{+}
\FunctionTok{geom\_tile}\NormalTok{(}\AttributeTok{color =} \StringTok{"grey50"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{expand=}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{)) }\SpecialCharTok{+}
\FunctionTok{scale\_fill\_gradientn}\NormalTok{(}\AttributeTok{colors =} \FunctionTok{brewer.pal}\NormalTok{(}\DecValTok{9}\NormalTok{, }\StringTok{"Reds"}\NormalTok{), }\AttributeTok{trans =} \StringTok{"sqrt"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{geom\_vline}\NormalTok{(}\AttributeTok{xintercept=}\DecValTok{1963}\NormalTok{, }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{theme\_minimal}\NormalTok{() }\SpecialCharTok{+}
\FunctionTok{theme}\NormalTok{(}\AttributeTok{panel.grid =} \FunctionTok{element\_blank}\NormalTok{(),}
\AttributeTok{legend.position=}\StringTok{"bottom"}\NormalTok{,}
\AttributeTok{text =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{8}\NormalTok{)) }\SpecialCharTok{+}
\FunctionTok{ggtitle}\NormalTok{(the\_disease) }\SpecialCharTok{+}
\FunctionTok{ylab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/vaccines-plot-1} \end{center}

Este gráfico ofrece evidencia preponderante a favor de la contribución de las vacunas. Sin embargo, una limitación es que usa el color para representar la cantidad, que, como explicamos anteriormente, dificulta saber exactamente cuán altos llegan los valores. La posición y la longitud son mejores señales. Si estamos dispuestos a perder información de estado, podemos hacer una versión del gráfico que muestre los valores con posición. También podemos mostrar el promedio de EE. UU., que calculamos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avg }\OtherTok{\textless{}{-}}\NormalTok{ us\_contagious\_diseases }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{filter}\NormalTok{(disease}\SpecialCharTok{==}\NormalTok{the\_disease) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(year) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{summarize}\NormalTok{(}\AttributeTok{us\_rate =} \FunctionTok{sum}\NormalTok{(count, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}\SpecialCharTok{/}
\FunctionTok{sum}\NormalTok{(population, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{*} \DecValTok{10000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora para hacer el gráfico simplemente usamos la geometría \texttt{geom\_line}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(rate)) }\SpecialCharTok{\%\textgreater{}\%}
\FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
\FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, rate, }\AttributeTok{group =}\NormalTok{ state), }\AttributeTok{color =} \StringTok{"grey50"}\NormalTok{,}
\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{size =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{geom\_line}\NormalTok{(}\AttributeTok{mapping =} \FunctionTok{aes}\NormalTok{(year, us\_rate), }\AttributeTok{data =}\NormalTok{ avg, }\AttributeTok{size =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"sqrt"}\NormalTok{, }\AttributeTok{breaks =} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{125}\NormalTok{, }\DecValTok{300}\NormalTok{)) }\SpecialCharTok{+}
\FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Cases per 10,000 by state"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{ylab}\NormalTok{(}\StringTok{""}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{data =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{1955}\NormalTok{, }\AttributeTok{y =} \DecValTok{50}\NormalTok{),}
\AttributeTok{mapping =} \FunctionTok{aes}\NormalTok{(x, y, }\AttributeTok{label=}\StringTok{"US average"}\NormalTok{),}
\AttributeTok{color=}\StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
\FunctionTok{geom\_vline}\NormalTok{(}\AttributeTok{xintercept=}\DecValTok{1963}\NormalTok{, }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/time-series-vaccines-plot-1} \end{center}

En teoría, podríamos usar el color para representar los estados, que son una variable categórica, pero es difícil elegir 50 colores distintos.

\hypertarget{ejercicios-20}{%
\section{Ejercicios}\label{ejercicios-20}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Reproduzca el mapa de matriz que hicimos anteriormente pero para la viruela. Para este gráfico, no incluya los años en que no se reportaron casos por 10 o más semanas.
\item
  Ahora reproduzca el gráfico de series de tiempo que hicimos anteriormente, pero esta vez siguiendo las instrucciones de la pregunta anterior para la viruela.
\item
  Para el estado de California, haga un gráfico de series de tiempo que muestre las tasas de todas las enfermedades. Incluya solo años con informes de 10 o más semanas. Use un color diferente para cada enfermedad.
\item
  Ahora haga lo mismo con las tasas para Estados Unidos. Sugerencia: calcule la tasa de EE. UU. usando \texttt{summarize}: total dividido por población total.
\end{enumerate}

\hypertarget{robust-summaries}{%
\chapter{Resúmenes robustos}\label{robust-summaries}}

\hypertarget{valores-atuxedpicos}{%
\section{Valores atípicos}\label{valores-atuxedpicos}}

Anteriormente describimos cómo los diagramas de caja muestran \emph{valores atípicos} (\emph{outliers} en inglés), pero no ofrecimos una definición precisa. Aquí discutimos los valores atípicos, los acercamientos que pueden ayudar para detectarlos y los resúmenes que toman en cuenta su presencia.

Los valores atípicos son muy comunes en la ciencia de datos. La recopilación de datos puede ser compleja y es común observar puntos de datos generados por error. Por ejemplo, un viejo dispositivo de monitoreo puede leer mediciones sin sentido antes de fallar por completo. El error humano también es una fuente de valores atípicos, en particular cuando la entrada de datos se realiza manualmente. Un individuo, por ejemplo, puede ingresar erróneamente su altura en centímetros en lugar de pulgadas o colocar el decimal en el lugar equivocado.

¿Cómo distinguimos un valor atípico de mediciones que son demasiado grandes o pequeñas simplemente debido a la variabilidad esperada? Esta no siempre es una pregunta fácil de contestar, pero intentaremos ofrecer alguna orientación. Comencemos con un caso sencillo.

Supongan que un colega se encarga de recopilar datos demográficos para un grupo de varones. Los datos indican la altura en pies y se almacenan en el objeto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(outlier\_example)}
\FunctionTok{str}\NormalTok{(outlier\_example)}
\CommentTok{\#\textgreater{}  num [1:500] 5.59 5.8 5.54 6.15 5.83 5.54 5.87 5.93 5.89 5.67 ...}
\end{Highlighting}
\end{Shaded}

Nuestro colega utiliza el hecho de que las alturas suelen estar bien aproximadas por una distribución normal y resume los datos con el promedio y la desviación estándar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(outlier\_example)}
\CommentTok{\#\textgreater{} [1] 6.1}
\FunctionTok{sd}\NormalTok{(outlier\_example)}
\CommentTok{\#\textgreater{} [1] 7.8}
\end{Highlighting}
\end{Shaded}

y escribe un informe sobre el hecho interesante de que este grupo de varones es mucho más alto de lo normal. ¡La altura promedio es más de seis pies! Sin embargo, al usar sus conocimientos de ciencia de datos, notan algo más que es inesperado: la desviación estándar es de más de 7 pies. Al sumar y restar dos desviaciones estándar, observan que el 95\% de esta población parece tener alturas entre -9.489, 21.697 pies, que no tiene sentido. Un gráfico rápido muestra el problema:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{boxplot}\NormalTok{(outlier\_example)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/boxplot-reveals-outliers-1} \end{center}

Parece que hay al menos un valor que no tiene sentido, ya que sabemos que una altura de 180 pies es imposible. El diagrama de caja detecta este punto como un valor atípico.

\hypertarget{mediana}{%
\section{Mediana}\label{mediana}}

Cuando tenemos un valor atípico como este, el promedio puede llegar a ser muy grande. Matemáticamente, podemos hacer que el promedio sea tan grande como queramos simplemente cambiando un número: con 500 puntos de datos, podemos aumentar el promedio en cualquier cantidad \(\Delta\) añadiendo \(\Delta \times\) 500 a un solo número. La mediana, definida como el valor para el cual la mitad de los valores son más pequeños y la otra mitad son más grandes, es robusta para tales valores atípicos. No importa cuán grande hagamos el punto más grande, la mediana sigue siendo la misma.

Con estos datos, la mediana es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{median}\NormalTok{(outlier\_example)}
\CommentTok{\#\textgreater{} [1] 5.74}
\end{Highlighting}
\end{Shaded}

lo cual es aproximadamente 5 pies y 9 pulgadas.

La mediana es lo que los diagramas de caja muestran como una línea horizontal.

\hypertarget{el-rango-intercuartil-iqr}{%
\section{El rango intercuartil (IQR)}\label{el-rango-intercuartil-iqr}}

La caja en un diagrama de caja se define por el primer y tercer cuartil. Estos están destinados a proveer una idea de la variabilidad en los datos: el 50\% de los datos están dentro de este rango. La diferencia entre el 3er y 1er cuartil (o los percentiles 75 y 25) se conoce como el rango intercuartil (IQR por sus siglas en inglés). Como sucede con la mediana, esta cantidad será robusta para los valores atípicos ya que los valores grandes no la afectan. Podemos hacer algunos cálculos y ver que para los datos que siguen la distribución normal, el IQR/1.349 se aproxima a la desviación estándar de los datos si un valor atípico no hubiera estado presente. Podemos ver que esto funciona bien en nuestro ejemplo, ya que obtenemos un estimado de la desviación estándar de:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{IQR}\NormalTok{(outlier\_example)}\SpecialCharTok{/} \FloatTok{1.349}
\CommentTok{\#\textgreater{} [1] 0.245}
\end{Highlighting}
\end{Shaded}

lo cual es cerca de 3 pulgadas.

\hypertarget{la-definiciuxf3n-de-tukey-de-un-valor-atuxedpico}{%
\section{La definición de Tukey de un valor atípico}\label{la-definiciuxf3n-de-tukey-de-un-valor-atuxedpico}}

En R, los puntos que caen fuera de los bigotes del diagrama de caja se denominan \emph{valores atípicos}, una definición que Tukey introdujo. El bigote superior termina en el percentil 75 más 1.5 \(\times\) IQR, mientras que el bigote inferior termina en el percentil 25 menos 1.5 \(\times\) IQR. Si definimos el primer y el tercer cuartil como \(Q_1\) y \(Q_3\), respectivamente, entonces un valor atípico es cualquier valor fuera del rango:

\[[Q_1 - 1.5 \times (Q_3 - Q1), Q_3 + 1.5 \times (Q_3 - Q1)].\]

Cuando los datos se distribuyen normalmente, las unidades estándar de estos valores son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q3 }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.75}\NormalTok{)}
\NormalTok{q1 }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.25}\NormalTok{)}
\NormalTok{iqr }\OtherTok{\textless{}{-}}\NormalTok{ q3 }\SpecialCharTok{{-}}\NormalTok{ q1}
\NormalTok{r }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(q1 }\SpecialCharTok{{-}} \FloatTok{1.5}\SpecialCharTok{*}\NormalTok{iqr, q3 }\SpecialCharTok{+} \FloatTok{1.5}\SpecialCharTok{*}\NormalTok{iqr)}
\NormalTok{r}
\CommentTok{\#\textgreater{} [1] {-}2.7  2.7}
\end{Highlighting}
\end{Shaded}

Utilizando la función \texttt{pnorm}, vemos que 99.3\% de los datos caen en este intervalo.

Tengan en cuenta que este no es un evento tan extremo: si tenemos 1000 puntos de datos que se distribuyen normalmente, esperamos ver unos 7 fuera de este rango. Pero estos no serían valores atípicos ya que esperamos verlos bajo la variación típica.

Si queremos que un valor atípico sea más raro, podemos cambiar el 1.5 a un número mas grande. Tukey también usó 3 y los denominó \emph{far out outliers} o \emph{valores atípicos extremos}. Con una distribución normal,
100\%
de los datos caen en este intervalo. Esto se traduce en aproximadamente 2 en un millón de posibilidades de estar fuera del rango. En la función \texttt{geom\_boxplot}, esto se puede controlar usando el argumento \texttt{outlier.size}, que por defecto es 1.5.

La medida de 180 pulgadas está más allá del rango de los datos de altura:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{max\_height }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(outlier\_example, }\FloatTok{0.75}\NormalTok{) }\SpecialCharTok{+} \DecValTok{3}\SpecialCharTok{*}\FunctionTok{IQR}\NormalTok{(outlier\_example)}
\NormalTok{max\_height}
\CommentTok{\#\textgreater{}  75\% }
\CommentTok{\#\textgreater{} 6.91}
\end{Highlighting}
\end{Shaded}

Si sacamos este valor, podemos ver que los datos se distribuyen normalmente como se espera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ outlier\_example[outlier\_example }\SpecialCharTok{\textless{}}\NormalTok{ max\_height]}
\FunctionTok{qqnorm}\NormalTok{(x)}
\FunctionTok{qqline}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/outlier-qqnorm-1} \end{center}

\hypertarget{desviaciuxf3n-absoluta-mediana}{%
\section{Desviación absoluta mediana}\label{desviaciuxf3n-absoluta-mediana}}

Otra opción para estimar la desviación estándar de manera robusta en presencia de valores atípicos es usar la desviación absoluta mediana (\emph{median absolute deviation} o MAD por sus siglas en inglés). Para calcular el MAD, primero calculamos la mediana y luego, para cada valor, calculamos la distancia entre ese valor y la mediana. El MAD se define como la mediana de estas distancias. Por razones técnicas que no discutimos aquí, esta cantidad debe multiplicarse por 1.4826 para asegurar que se aproxime a la desviación estándar real. La función \texttt{mad} ya incorpora esta corrección. Para los datos de altura, obtenemos una MAD de:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mad}\NormalTok{(outlier\_example)}
\CommentTok{\#\textgreater{} [1] 0.237}
\end{Highlighting}
\end{Shaded}

lo cual es cerca de 3 pulgadas.

\hypertarget{ejercicios-21}{%
\section{Ejercicios}\label{ejercicios-21}}

Vamos a usar el paquete \textbf{HistData}. Si no lo ha instalando, puede hacerlo así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"HistData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Cargue el set de datos de altura y cree un vector \texttt{x} que contiene solo las alturas masculinas de los datos de Galton de los padres y sus hijos de su investigación histórica sobre la herencia.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(HistData)}
\FunctionTok{data}\NormalTok{(Galton)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ Galton}\SpecialCharTok{$}\NormalTok{child}
\end{Highlighting}
\end{Shaded}

1. Calcule el promedio y la mediana de estos datos.

2. Calcule la mediana y el MAD de estos datos.

3. Ahora supongan que Galton cometió un error al ingresar el primer valor y olvidó usar el punto decimal. Puede imitar este error escribriendo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_with\_error }\OtherTok{\textless{}{-}}\NormalTok{ x}
\NormalTok{x\_with\_error[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ x\_with\_error[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{*}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

¿Cuántas pulgadas crece el promedio como resultado de este error?

4. ¿Cuántas pulgadas crece la SD como resultado de este error?

5. ¿Cuántas pulgadas crece la mediana como resultado de este error?

6. ¿Cuántas pulgadas crece el MAD como resultado de este error?

7. ¿Cómo podríamos utilizar el análisis exploratorio de datos para detectar que se cometió un error?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Dado que es solo un valor entre muchos, no se puede detectar esto.
\item
  Veríamos un cambio obvio en la distribución.
\item
  Un diagrama de caja, histograma o gráfico Q-Q revelarían un valor atípico obvio.
\item
  Un diagrama de dispersión mostraría altos niveles de error de medición.
\end{enumerate}

8. ¿Cuánto puede crecer accidentalmente el promedio con errores como este? Escribe una función llamada \texttt{error\_avg} que toma un valor \texttt{k} y devuelve el promedio del vector \texttt{x} después de que la primera entrada cambie a \texttt{k}. Muestre los resultados para \texttt{k=10000} y \texttt{k=-10000}.

\hypertarget{estudio-de-caso-alturas-autoreportadas-de-estudiantes}{%
\section{Estudio de caso: alturas autoreportadas de estudiantes}\label{estudio-de-caso-alturas-autoreportadas-de-estudiantes}}

Las alturas que hemos estado estudiando no son las alturas originales reportadas por los estudiantes. Las alturas originales también se incluyen en el paquete \textbf{dslabs} y se pueden cargar así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"reported\_heights"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La altura es un vector de caracteres, por lo que creamos una nueva columna con la versión numérica:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\OtherTok{\textless{}{-}}\NormalTok{ reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{original\_heights =}\NormalTok{ height, }\AttributeTok{height =} \FunctionTok{as.numeric}\NormalTok{(height))}
\CommentTok{\#\textgreater{} Warning in mask$eval\_all\_mutate(quo): NAs introducidos por coerción}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que recibimos una advertencia sobre los NAs. Esto se debe a que algunas de las alturas autoreportadas no eran números. Podemos ver por qué obtenemos estos NAs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}            time\_stamp    sex height original\_heights}
\CommentTok{\#\textgreater{} 1 2014{-}09{-}02 15:16:28   Male     NA            5\textquotesingle{} 4"}
\CommentTok{\#\textgreater{} 2 2014{-}09{-}02 15:16:37 Female     NA            165cm}
\CommentTok{\#\textgreater{} 3 2014{-}09{-}02 15:16:52   Male     NA              5\textquotesingle{}7}
\CommentTok{\#\textgreater{} 4 2014{-}09{-}02 15:16:56   Male     NA            \textgreater{}9000}
\CommentTok{\#\textgreater{} 5 2014{-}09{-}02 15:16:56   Male     NA             5\textquotesingle{}7"}
\CommentTok{\#\textgreater{} 6 2014{-}09{-}02 15:17:09 Female     NA             5\textquotesingle{}3"}
\end{Highlighting}
\end{Shaded}

Algunos estudiantes indicaron sus alturas usando pies y pulgadas en lugar de solo pulgadas. Otros usaron centímetros y otros solo estaban ``trolleando''. Por ahora eliminaremos estas entradas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(reported\_heights, }\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(height))}
\end{Highlighting}
\end{Shaded}

Si calculamos el promedio y la desviación estándar, observamos que obtenemos resultados extraños. El promedio y la desviación estándar son diferentes de la mediana y del MAD:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(sex) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{average =} \FunctionTok{mean}\NormalTok{(height), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(height),}
            \AttributeTok{median =} \FunctionTok{median}\NormalTok{(height), }\AttributeTok{MAD =} \FunctionTok{mad}\NormalTok{(height))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 5}
\CommentTok{\#\textgreater{}   sex    average    sd median   MAD}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}    \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Female    63.4  27.9   64.2  4.05}
\CommentTok{\#\textgreater{} 2 Male     103.  530.    70    4.45}
\end{Highlighting}
\end{Shaded}

Esto sugiere que tenemos valores atípicos, lo que se confirma creando un diagrama de caja:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/height-outlier-ggplot-1} \end{center}

Vemos algunos valores bastante extremos. Para ver cuáles son estos valores, podemos rápidamente mirar los valores más grandes utilizando la función \texttt{arrange}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{top\_n}\NormalTok{(}\DecValTok{10}\NormalTok{, height)}
\CommentTok{\#\textgreater{}             time\_stamp    sex height original\_heights}
\CommentTok{\#\textgreater{} 1  2014{-}09{-}03 23:55:37   Male  11111            11111}
\CommentTok{\#\textgreater{} 2  2016{-}04{-}10 22:45:49   Male  10000            10000}
\CommentTok{\#\textgreater{} 3  2015{-}08{-}10 03:10:01   Male    684              684}
\CommentTok{\#\textgreater{} 4  2015{-}02{-}27 18:05:06   Male    612              612}
\CommentTok{\#\textgreater{} 5  2014{-}09{-}02 15:16:41   Male    511              511}
\CommentTok{\#\textgreater{} 6  2014{-}09{-}07 20:53:43   Male    300              300}
\CommentTok{\#\textgreater{} 7  2014{-}11{-}28 12:18:40   Male    214              214}
\CommentTok{\#\textgreater{} 8  2017{-}04{-}03 16:16:57   Male    210              210}
\CommentTok{\#\textgreater{} 9  2015{-}11{-}24 10:39:45   Male    192              192}
\CommentTok{\#\textgreater{} 10 2014{-}12{-}26 10:00:12   Male    190              190}
\CommentTok{\#\textgreater{} 11 2016{-}11{-}06 10:21:02 Female    190              190}
\end{Highlighting}
\end{Shaded}

Las primeras siete entradas parecen errores extraños. Sin embargo, las siguientes entradas parecen haber sido ingresadas en centímetros en lugar de pulgadas. Dado que 184cm es equivalente a seis pies de altura, sospechamos que 184 realmente significa 72 pulgadas.

Podemos revisar todas las respuestas sin sentido examinando los datos que Tukey considera \emph{far out} o \emph{extremos}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{whisker }\OtherTok{\textless{}{-}} \DecValTok{3}\SpecialCharTok{*}\FunctionTok{IQR}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height)}
\NormalTok{max\_height }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height, .}\DecValTok{75}\NormalTok{) }\SpecialCharTok{+}\NormalTok{ whisker}
\NormalTok{min\_height }\OtherTok{\textless{}{-}} \FunctionTok{quantile}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height, .}\DecValTok{25}\NormalTok{) }\SpecialCharTok{{-}}\NormalTok{ whisker}
\NormalTok{reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{between}\NormalTok{(height, min\_height, max\_height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(original\_heights) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{(}\AttributeTok{n=}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(original\_heights)}
\CommentTok{\#\textgreater{}  [1] "6"     "5.3"   "511"   "6"     "2"     "5.25"  "5.5"   "11111"}
\CommentTok{\#\textgreater{}  [9] "6"     "6.5"}
\end{Highlighting}
\end{Shaded}

Al revisar estas alturas cuidadosamente, vemos dos errores comunes: entradas en centímetros, que resultan ser demasiado grandes, y entradas del tipo \texttt{x.y} con \texttt{x} e \texttt{y} representando pies y pulgadas respectivamente, que resultan ser demasiado pequeñas. Algunos de los valores aún más pequeños, como 1.6, podrían ser entradas en metros.

En la parte de \emph{wrangling} de datos de este libro, aprenderemos técnicas para corregir estos valores y convertirlos en pulgadas. Aquí pudimos detectar este problema mediante una cuidadosa exploración de los datos para descubrir problemas con ellos: el primer paso en la gran mayoría de los proyectos de ciencia de datos.

\hypertarget{part-estaduxedsticas-con-r}{%
\part{Estadísticas con R}\label{part-estaduxedsticas-con-r}}

\hypertarget{introducciuxf3n-a-las-estaduxedsticas-con-r}{%
\chapter{Introducción a las estadísticas con R}\label{introducciuxf3n-a-las-estaduxedsticas-con-r}}

El análisis de datos es uno de los enfoques principales de este libro. Si bien las herramientas informáticas que hemos presentado son desarrollos relativamente recientes, el análisis de datos ha existido durante más de un siglo. A lo largo de los años, los analistas de datos que trabajan en proyectos específicos han presentado ideas y conceptos que se generalizan a muchas otras aplicaciones. También han identificado maneras comunes en que nos pueden engañar patrones aparentes en los datos y realidades matemáticas importantes que no son inmediatamente obvias. La acumulación de estas ideas y perspectivas ha dado lugar a la disciplina de la estadística, que ofrece un marco matemático para facilitar la descripción y evaluación formal de estas ideas.

Para evitar repetir errores comunes y perder el tiempo reinventando la rueda, es importante que los analistas de datos tengan una comprensión profunda de las estadísticas. Debido a la madurez de la disciplina, hay docenas de libros excelentes ya publicados sobre este tema y, por lo tanto, no nos enfocamos en describir el marco matemático aquí. En cambio, presentamos conceptos brevemente y luego ofrecemos estudios de caso que demuestran cómo se utilizan las estadísticas en el análisis de datos junto con el código R que implementa estas ideas. También usamos el código R para ayudar a aclarar algunos de los principales conceptos estadísticos que generalmente se describen usando las matemáticas. Recomendamos complementar este capítulo con un libro de texto de estadísticas. Dos ejemplos son \emph{Statistics} de Freedman, Pisani y Purves y \emph{Statistical Inference} de Casella y Berger. Los conceptos específicos que discutimos en esta parte del libro son probabilidad, inferencia estadística, modelos estadísticos, regresión y modelos lineales, que son los principales temas abarcados en un curso de estadística. Los estudios de caso que presentamos se relacionan con la crisis financiera, el pronóstico de los resultados de las elecciones, cómo entender la herencia y cómo formar un equipo de béisbol.

\hypertarget{probabilidad}{%
\chapter{Probabilidad}\label{probabilidad}}

En los juegos de azar, la probabilidad tiene una definición muy intuitiva. Por ejemplo, sabemos lo que significa cuando decimos que la probabilidad de que un par de dados salga siete es 1 en 6. Sin embargo, este no es el caso en otros contextos. Hoy la teoría de probabilidad se utiliza de manera mucho más amplia con la palabra \emph{probabilidad} ya parte del lenguaje cotidiano. Si escribimos ``¿Cuáles son las probabilidades de'' en Google, la función de autocompletar nos da: ``tener mellizos'', ``tener gemelos'' y ``ganar la lotería''. Uno de los objetivos de esta parte del libro es ayudarles a comprender cómo la probabilidad es útil para entender y describir eventos del mundo real cuando realizamos análisis de datos.

Dado que saber cómo calcular las probabilidades ofrece una ventaja en los juegos de azar, a lo largo de la historia muchas personas inteligentes, incluyendo matemáticos famosos como Cardano, Fermat y Pascal, le han dedicado tiempo y energía a pensar en las matemáticas de estos juegos. Como resultado, nació la teoría de la probabilidad. La probabilidad sigue siendo muy útil en los juegos de azar modernos. Por ejemplo, en póker, podemos calcular la probabilidad de ganar una mano basado en las cartas en la mesa. Además, los casinos se basan en la teoría de la probabilidad para desarrollar juegos que casi siempre les garantizan ganancias.

La teoría de la probabilidad es útil en muchos otros contextos y, en particular, en áreas que de alguna manera dependen de los datos afectados por el azar. Todos los otros capítulos de esta parte se basan en la teoría de la probabilidad. El conocimiento de la probabilidad es, por consiguiente, indispensable para la ciencia de datos.

\hypertarget{probabilidad-discreta}{%
\section{Probabilidad discreta}\label{probabilidad-discreta}}

Comenzamos explorando algunos principios básicos relacionados con datos categóricos. Esta parte de la probabilidad se conoce como \emph{probabilidad discreta}. Luego, esto nos ayudará a comprender la teoría de la probabilidad que más tarde presentaremos para datos numéricos y continuos, los cuales son mucho más comunes en las aplicaciones de ciencia de datos. La probabilidad discreta es más útil en los juegos de cartas y, por ende, usamos estos como ejemplos.

\hypertarget{frecuencia-relativa}{%
\subsection{Frecuencia relativa}\label{frecuencia-relativa}}

Si bien la palabra probabilidad se usa en el lenguaje cotidiano, responder a preguntas sobre la probabilidad es difícil, si no imposible porque el concepto de ``probabilidad'' no está bien definido. Aquí discutimos una definición matemática de \emph{probabilidad} que nos permite dar respuestas precisas a ciertas preguntas.

Por ejemplo, si tengo 2 canicas rojas y 3 canicas azules dentro de una urna\footnote{\url{https://en.wikipedia.org/wiki/Urn_problem}} (muchos libros de probabilidad usan este término arcaico, así que nosotros también) y escojo una al azar, ¿cuál es la probabilidad de elegir una roja? Nuestra intuición nos dice que la respuesta es 2/5 o 40\%. Se puede dar una definición precisa al señalar que hay cinco resultados posibles de los cuales dos satisfacen la condición necesaria para el evento ``escoger una canica roja''. Dado que cada uno de los cinco resultados tiene la misma probabilidad de ocurrir, concluimos que la probabilidad es .4 para rojo y .6 para azul.

Una forma más tangible de pensar en la probabilidad de un evento es la proporción de veces que ocurre el evento cuando repetimos el experimento un número infinito de veces, independientemente y bajo las mismas condiciones.

\hypertarget{notaciuxf3n}{%
\subsection{Notación}\label{notaciuxf3n}}

Usamos la notación \(\mbox{Pr}(A)\) para denotar la probabilidad de que suceda evento \(A\). Usamos el término general \emph{evento} para referirnos a cosas que pueden suceder cuando algo ocurre por casualidad. En nuestro ejemplo anterior, el evento fue ``escoger una canica roja''. En una encuesta política en la que llamamos al azar a 100 probables votantes estadounidenses, un ejemplo de un evento es ``llamar a 48 demócratas y 52 republicanos''.

En las aplicaciones de ciencia de datos, frecuentemente trabajaremos con variables continuas. Estos eventos a menudo serán cosas como ``es esta persona más alta que 6 pies''. En ese caso, escribimos eventos en una forma más matemática: \(X \geq 6\). Veremos más de estos ejemplos a continuación. Aquí nos enfocamos en datos categóricos.

\hypertarget{distribuciones-de-probabilidad}{%
\subsection{Distribuciones de probabilidad}\label{distribuciones-de-probabilidad}}

Si conocemos la frecuencia relativa de las diferentes categorías, definir una distribución para resultados categóricos es relativamente sencillo. Simplemente asignamos una probabilidad a cada categoría. En los casos que pueden considerarse como canicas en una urna, para cada tipo de canica, su proporción define la distribución.

Si estamos llamando al azar a votantes probables de una población que es 44\% demócratas, 44\% republicanos, 10\% indecisos y 2\% del partido verde, estas proporciones definen la probabilidad para cada grupo. La distribución de probabilidad es:

\begin{longtable}[]{@{}lll@{}}
\toprule
& & \\
\midrule
\endhead
Pr (elegir un republicano) & = & 0.44 \\
Pr (elegir un demócrata) & = & 0.44 \\
Pr (elegir un indeciso) & = & 0.10 \\
Pr (elegir un verde) & = & 0.02 \\
\bottomrule
\end{longtable}

\hypertarget{simulaciones-monte-carlo-para-datos-categuxf3ricos}{%
\section{Simulaciones Monte Carlo para datos categóricos}\label{simulaciones-monte-carlo-para-datos-categuxf3ricos}}

Las computadoras ofrecen una forma de realizar el experimento aleatorio sencillo descrito anteriormente: elegir una canica al azar de una urna que contiene tres canicas azules y dos rojas. Los generadores de números aleatorios nos permiten imitar el proceso de escoger al azar.

Un ejemplo es la función \texttt{sample} en R. Demostramos su uso en el código a continuación. Primero, usamos la función \texttt{rep} para generar la urna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beads }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"blue"}\NormalTok{), }\AttributeTok{times =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{beads}
\CommentTok{\#\textgreater{} [1] "red"  "red"  "blue" "blue" "blue"}
\end{Highlighting}
\end{Shaded}

y luego usamos \texttt{sample} para escoger una canica al azar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "blue"}
\end{Highlighting}
\end{Shaded}

Esta línea de código produce un resultado aleatorio. Queremos repetir este experimento un número infinito de veces, pero es imposible repetirlo para siempre. Sin embargo, podemos repetir el experimento un número suficientemente grande de veces para que los resultados sean prácticamente equivalentes a repetirlo para siempre. \textbf{Este es un ejemplo de una simulación \emph{Monte Carlo}}.

Gran parte de lo que estudian los estadísticos matemáticos y teóricos, que no discutimos en este libro, se relaciona con proveer definiciones rigurosas de ``prácticamente equivalente'', así como estudiar cuán cerca nos llevan un gran número de experimentos a lo que sucede en el límite. Más adelante en esta sección, ofrecemos un acercamiento práctico para determinar qué es ``lo suficientemente grande''.

Para realizar nuestra primera simulación Monte Carlo, utilizamos la función \texttt{replicate}, que nos permite repetir la misma tarea varias veces. Aquí, repetimos el evento aleatorio \(B =\) 10,000 veces:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{events }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Ahora podemos ver si nuestra definición realmente está de acuerdo con esta aproximación de simulación Monte Carlo. Nosotros podemos usar \texttt{table} para ver la distribución:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(events)}
\NormalTok{tab}
\CommentTok{\#\textgreater{} events}
\CommentTok{\#\textgreater{} blue  red }
\CommentTok{\#\textgreater{} 5976 4024}
\end{Highlighting}
\end{Shaded}

y \texttt{prop.table} nos da las proporciones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prop.table}\NormalTok{(tab)}
\CommentTok{\#\textgreater{} events}
\CommentTok{\#\textgreater{}  blue   red }
\CommentTok{\#\textgreater{} 0.598 0.402}
\end{Highlighting}
\end{Shaded}

Los números anteriores son probabilidades estimadas proveídas por una simulación Monte Carlo. La teoría estadística, que no discutimos aquí, nos dice que en lo que \(B\) se hace más grande, las estimaciones se acercan a 3/5 = .6 y 2/5 = .4.

Aunque este es un ejemplo sencillo y no muy útil, luego utilizaremos simulaciones Monte Carlo para estimar probabilidades en casos en los cuales es difícil calcular cantidades exactas. Antes de profundizar en ejemplos más complejos, usaremos algunos sencillos para demostrar las herramientas informáticas disponibles en R.

\hypertarget{fijar-la-semilla-aleatoria}{%
\subsection{Fijar la semilla aleatoria}\label{fijar-la-semilla-aleatoria}}

Antes de continuar, explicaremos brevemente la siguiente línea importante de código:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1986}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A lo largo de este libro, utilizamos generadores de números aleatorios. Esto implica que muchos de los resultados que presentamos pueden cambiar por casualidad y una versión congelada del libro puede mostrar un resultado diferente al que obtienen cuando intenten codificar como observan en el libro. Esto no es un problema ya que los resultados son aleatorios y pueden cambiar. Sin embargo, si quieren asegurarse de que los resultados son exactamente los mismos cada vez que los ejecuten, pueden fijar la semilla (\emph{seed} en inglés) de generación de números aleatorios de R en un número específico. Arriba la fijamos en 1986. Queremos evitar usar la misma semilla cada vez. Una forma popular de escoger la semilla es restando el mes y el día del año. Por ejemplo, para el 20 de diciembre de 2018 fijamos la semilla en 1986: \(2018 - 12 - 20 = 1986\).

Pueden obtener más información sobre cómo fijar la semilla mirando la documentación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?set.seed}
\end{Highlighting}
\end{Shaded}

En los ejercicios, es posible que les pidamos que fijen la semilla para asegurar que sus resultados sean exactamente lo que esperamos.

\hypertarget{con-y-sin-reemplazo}{%
\subsection{Con y sin reemplazo}\label{con-y-sin-reemplazo}}

La función \texttt{sample} tiene un argumento que nos permite elegir más de un elemento de la urna. Sin embargo, por defecto, esta selección ocurre \emph{sin reemplazo}; es decir, después de seleccionar una canica, no se vuelve a colocar en la urna. Observen lo que sucede cuando pedimos seleccionar cinco canicas al azar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "red"  "blue" "blue" "blue" "red"}
\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "red"  "red"  "blue" "blue" "blue"}
\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "blue" "red"  "blue" "red"  "blue"}
\end{Highlighting}
\end{Shaded}

Esto resulta en reordenamientos que siempre tienen tres canicas azules y dos rojas. Si pedimos que se seleccionen seis canicas, obtenemos un error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{Error\ in\ sample.int(length(x),\ size,\ replace,\ prob)\ :\ cannot\ take\ a\ sample\ larger\ than\ the\ population\ when\ \textquotesingle{}replace\ =\ FALSE\textquotesingle{}}

Sin embargo, la función \texttt{sample} se puede usar directamente, sin el uso de \texttt{replicate}, para repetir el mismo experimento de elegir 1 de las 5 canicas, continuamente, en las mismas condiciones. Para hacer esto, muestreamos \emph{con reemplazo}; es decir, se devuelve la canica a la urna después de seleccionarla.
Podemos decirle a \texttt{sample} que haga esto cambiando el argumento \texttt{replace}, que por defecto es \texttt{FALSE}, a \texttt{replace\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{events }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(beads, B, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{prop.table}\NormalTok{(}\FunctionTok{table}\NormalTok{(events))}
\CommentTok{\#\textgreater{} events}
\CommentTok{\#\textgreater{}  blue   red }
\CommentTok{\#\textgreater{} 0.602 0.398}
\end{Highlighting}
\end{Shaded}

No sorprende que obtengamos resultados muy similares a los obtenidos previamente con \texttt{replicate}.

\hypertarget{independencia}{%
\section{Independencia}\label{independencia}}

Decimos que dos eventos son independientes si el resultado de uno no afecta al otro. El ejemplo clásico es el lanzamiento de monedas. Cada vez que lanzamos una moneda, la probabilidad de ver cara es 1/2, independientemente de los resultados de lanzamientos anteriores. Lo mismo es cierto cuando recogemos canicas de una urna con reemplazo. En el ejemplo anterior, la probabilidad de rojo es 0.40 independientemente de las selecciones anteriores.

Muchos ejemplos de eventos que no son independientes provienen de juegos de cartas. Cuando repartimos la primera carta, la probabilidad de obtener una K es 1/13 ya que hay trece posibilidades: Dos, Tres, \(\dots\), Diez, J, Q, K y As. Pero si repartimos una K como la primera carta y no la reemplazamos en la baraja, la probabilidad de que una segunda carta sea K es menor porque solo quedan tres Ks: la probabilidad es 3 de 51. Estos eventos, por lo tanto, \textbf{no son independientes}: el primer resultado afecta al siguiente.

Para ver un caso extremo de eventos no independientes, consideren nuestro ejemplo de escoger cinco canicas al azar \textbf{sin} reemplazo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(beads, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si tienen que adivinar el color de la primera canica, predecirán azul ya que azul tiene un 60\% de probabilidad. Pero si les mostramos el resultado de los últimos cuatro resultados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "blue" "blue" "blue" "red"}
\end{Highlighting}
\end{Shaded}

¿aún adivinarían azul? Por supuesto que no. Ahora saben que la probabilidad de rojo es 1 ya que la única canica que queda es roja. Los eventos no son independientes, por lo que las probabilidades cambian.

\hypertarget{probabilidades-condicionales}{%
\section{Probabilidades condicionales}\label{probabilidades-condicionales}}

Cuando los eventos no son independientes, las \emph{probabilidades condicionales} son útiles. Ya vimos un ejemplo de una probabilidad condicional: calculamos la probabilidad de que una segunda carta repartida sea K dado que la primera fue K. En la probabilidad, usamos la siguiente notación:

\[
\mbox{Pr}(\mbox{Card 2 is a king} \mid \mbox{Card 1 is a king}) = 3/51
\]

Utilizamos el \(\mid\) como abreviatura de ``dado eso'' o ``condicional en''.

Cuando dos eventos, digamos \(A\) y \(B\), son independientes, tenemos:

\[
\mbox{Pr}(A \mid B) = \mbox{Pr}(A)
\]

Esta es la forma matemática de decir: el hecho de que \(B\) sucedió no afecta la probabilidad de que \(A\) suceda. De hecho, esto puede considerarse la definición matemática de independencia.

\hypertarget{reglas-de-la-adiciuxf3n-y-de-la-multiplicaciuxf3n}{%
\section{Reglas de la adición y de la multiplicación}\label{reglas-de-la-adiciuxf3n-y-de-la-multiplicaciuxf3n}}

\hypertarget{regla-de-la-multiplicaciuxf3n}{%
\subsection{Regla de la multiplicación}\label{regla-de-la-multiplicaciuxf3n}}

Si queremos saber la probabilidad de que ocurran dos eventos, digamos \(A\) y \(B\), podemos usar la regla de la multiplicación:

\[
\mbox{Pr}(A \mbox{ and } B) = \mbox{Pr}(A)\mbox{Pr}(B \mid A)
\]
Usemos el juego de cartas Blackjack como ejemplo. En Blackjack, se les asignan dos cartas al azar. Después de ver lo que tienen, pueden pedir más cartas. El objetivo es acercarse más a 21 que el croupier, sin pasar. Las \emph{cartas con figuras} (\emph{face cards} en inglés) valen 10 puntos y las Ases valen 11 o 1 (uno elige).

Entonces, en Blackjack, para calcular las probablidades de obtener un 21 recibiendo un As y luego una carta de figura, calculamos la probabilidad de que la primera carta sea un As y multiplicamos por la probabilidad de sacar una carta de figura o un 10 dado que la primera fue un As: \(1/13 \times 16/51 \approx 0.025\).

La regla de la multiplicación también se aplica a más de dos eventos. Podemos usar la inducción para incluir más eventos:

\[
\mbox{Pr}(A \mbox{ and } B \mbox{ and } C) = \mbox{Pr}(A)\mbox{Pr}(B \mid A)\mbox{Pr}(C \mid A \mbox{ and } B)
\]

\hypertarget{regla-de-la-multiplicaciuxf3n-bajo-independencia}{%
\subsection{Regla de la multiplicación bajo independencia}\label{regla-de-la-multiplicaciuxf3n-bajo-independencia}}

Cuando tenemos eventos independientes, la regla de la multiplicación se hace más sencilla:

\[
\mbox{Pr}(A \mbox{ and } B \mbox{ and } C) = \mbox{Pr}(A)\mbox{Pr}(B)\mbox{Pr}(C)
\]

Pero debemos tener mucho cuidado antes de usar esto ya que suponer independencia cuando realmente no existe puede resultar en cálculos de probabilidad muy diferentes e incorrectos.

Como ejemplo, imaginen un caso judicial en el que se describe al sospechoso como teniendo bigote y barba. El acusado tiene bigote y barba y la fiscalía trae a un ``experto'' que testifica que 1/10 hombres tienen barba y 1/5 tienen bigote, así que usando la regla de la multiplicación concluimos que solo \(1/10 \times 1/5\) o 0.02 tienen ambos.

¡Pero para multiplicar así necesitamos suponer independencia! Digamos que la probabilidad condicional de que un hombre tenga un bigote condicionado en que tenga barba es .95. Entonces el cálculo correcto de la probabilidad resulta en un número mucho mayor: \(1/10 \times 95/100 = 0.095\).

La regla de la multiplicación también nos da una fórmula general para calcular probabilidades condicionales:

\[
\mbox{Pr}(B \mid A) = \frac{\mbox{Pr}(A \mbox{ and } B)}{ \mbox{Pr}(A)}
\]

Para ilustrar cómo usamos estas fórmulas y conceptos en la práctica, utilizaremos varios ejemplos relacionados con los juegos de cartas.

\hypertarget{regla-de-la-adiciuxf3n}{%
\subsection{Regla de la adición}\label{regla-de-la-adiciuxf3n}}

La regla de la adición nos dice que:

\[
\mbox{Pr}(A \mbox{ or } B) = \mbox{Pr}(A) + \mbox{Pr}(B) - \mbox{Pr}(A \mbox{ and } B)
\]

Esta regla es intuitiva: piense en un diagrama de Venn. Si simplemente sumamos las probabilidades, contamos la intersección dos veces, por lo que debemos restar una instancia.

\begin{center}\includegraphics[width=0.35\linewidth]{libro_files/figure-latex/venn-diagram-addition-rule-1} \end{center}

\hypertarget{combinaciones-y-permutaciones}{%
\section{Combinaciones y permutaciones}\label{combinaciones-y-permutaciones}}

En nuestro primer ejemplo, imaginamos una urna con cinco canicas. Recuerden que para calcular la distribución de probabilidad de un sorteo, simplemente enumeramos todas las probabilidades. Hubo 5 y entonces para cada evento contamos cuántas de estas probabilidades estaban asociadas con el evento. La probabilidad de elegir una canica azul es 3/5 porque de los cinco resultados posibles, tres fueron azules.

Para casos más complicados, los cálculos no son tan sencillos. Por ejemplo, ¿cuál es la probabilidad de que si escojo cinco cartas sin reemplazo, obtenga todas cartas del mismo palo (\emph{suit} en inglés), lo que se conoce como ``flush'' en el póker? En un curso de probabilidad discreta, se aprende la teoría sobre cómo hacer estos cálculos. Aquí nos enfocamos en cómo usar el código R para calcular las respuestas.

Primero, construyamos una baraja de cartas. Para esto, usaremos las funciones \texttt{expand.grid} y \texttt{paste}. Usamos \texttt{paste} para crear cadenas uniendo cadenas más pequeñas. Para hacer esto, tomamos el número y el palo de una carta y creamos el nombre de la carta de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number }\OtherTok{\textless{}{-}} \StringTok{"Three"}
\NormalTok{suit }\OtherTok{\textless{}{-}} \StringTok{"Hearts"}
\FunctionTok{paste}\NormalTok{(number, suit)}
\CommentTok{\#\textgreater{} [1] "Three Hearts"}
\end{Highlighting}
\end{Shaded}

\texttt{paste} también funciona en pares de vectores que realizan la operación elemento por elemento:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{paste}\NormalTok{(letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{], }\FunctionTok{as.character}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] "a 1" "b 2" "c 3" "d 4" "e 5"}
\end{Highlighting}
\end{Shaded}

La función \texttt{expand.grid} nos da todas las combinaciones de entradas de dos vectores. Por ejemplo, si tienen pantalones azules y negros y camisas blancas, grises y a cuadros (\emph{plaid} en inglés), todas sus combinaciones son:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{pants =} \FunctionTok{c}\NormalTok{(}\StringTok{"blue"}\NormalTok{, }\StringTok{"black"}\NormalTok{), }\AttributeTok{shirt =} \FunctionTok{c}\NormalTok{(}\StringTok{"white"}\NormalTok{, }\StringTok{"grey"}\NormalTok{, }\StringTok{"plaid"}\NormalTok{))}
\CommentTok{\#\textgreater{}   pants shirt}
\CommentTok{\#\textgreater{} 1  blue white}
\CommentTok{\#\textgreater{} 2 black white}
\CommentTok{\#\textgreater{} 3  blue  grey}
\CommentTok{\#\textgreater{} 4 black  grey}
\CommentTok{\#\textgreater{} 5  blue plaid}
\CommentTok{\#\textgreater{} 6 black plaid}
\end{Highlighting}
\end{Shaded}

Aquí es como generamos una baraja de cartas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suits }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Diamonds"}\NormalTok{, }\StringTok{"Clubs"}\NormalTok{, }\StringTok{"Hearts"}\NormalTok{, }\StringTok{"Spades"}\NormalTok{)}
\NormalTok{numbers }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Ace"}\NormalTok{, }\StringTok{"Deuce"}\NormalTok{, }\StringTok{"Three"}\NormalTok{, }\StringTok{"Four"}\NormalTok{, }\StringTok{"Five"}\NormalTok{, }\StringTok{"Six"}\NormalTok{, }\StringTok{"Seven"}\NormalTok{,}
             \StringTok{"Eight"}\NormalTok{, }\StringTok{"Nine"}\NormalTok{, }\StringTok{"Ten"}\NormalTok{, }\StringTok{"Jack"}\NormalTok{, }\StringTok{"Queen"}\NormalTok{, }\StringTok{"King"}\NormalTok{)}
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{number=}\NormalTok{numbers, }\AttributeTok{suit=}\NormalTok{suits)}
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(deck}\SpecialCharTok{$}\NormalTok{number, deck}\SpecialCharTok{$}\NormalTok{suit)}
\end{Highlighting}
\end{Shaded}

Con la baraja construida, podemos verificar que la probabilidad de que una K sea la primera carta es 1/13 calculando la proporción de posibles resultados que satisfagan nuestra condición:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kings }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{"King"}\NormalTok{, suits)}
\FunctionTok{mean}\NormalTok{(deck }\SpecialCharTok{\%in\%}\NormalTok{ kings)}
\CommentTok{\#\textgreater{} [1] 0.0769}
\end{Highlighting}
\end{Shaded}

Ahora, ¿qué tal la probabilidad condicional de que la segunda carta sea una K dado que la primera era una K? Anteriormente, dedujimos que si una K ya está fuera de la baraja y quedan 51 cartas, entonces la probabilidad es 3/51. Confirmemos enumerando todos los resultados posibles.

Para hacer esto, podemos usar la función \texttt{permutations} del paquete \textbf{gtools}. Para cualquier lista de tamaño \texttt{n}, esta función calcula todas las diferentes combinaciones que podemos obtener cuando seleccionamos \texttt{r} artículos. Aquí están todas las formas en que podemos elegir dos números de una lista que consiste en \texttt{1,2,3}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(gtools)}
\FunctionTok{permutations}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]    1    2}
\CommentTok{\#\textgreater{} [2,]    1    3}
\CommentTok{\#\textgreater{} [3,]    2    1}
\CommentTok{\#\textgreater{} [4,]    2    3}
\CommentTok{\#\textgreater{} [5,]    3    1}
\CommentTok{\#\textgreater{} [6,]    3    2}
\end{Highlighting}
\end{Shaded}

Observen que el orden importa aquí: 3,1 es diferente de 1,3. Además, tengan en cuenta que (1,1), (2,2) y (3,3) no aparecen porque una vez que elegimos un número, no puede volver a aparecer.

Opcionalmente, podemos añadir un vector. Si desean ver cinco números de teléfono aleatorios (de siete dígitos) de todos los números de teléfono posibles (sin repeticiones), pueden escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all\_phone\_numbers }\OtherTok{\textless{}{-}} \FunctionTok{permutations}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{7}\NormalTok{, }\AttributeTok{v =} \DecValTok{0}\SpecialCharTok{:}\DecValTok{9}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{nrow}\NormalTok{(all\_phone\_numbers)}
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(n, }\DecValTok{5}\NormalTok{)}
\NormalTok{all\_phone\_numbers[index,]}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5] [,6] [,7]}
\CommentTok{\#\textgreater{} [1,]    1    3    8    0    6    7    5}
\CommentTok{\#\textgreater{} [2,]    2    9    1    6    4    8    0}
\CommentTok{\#\textgreater{} [3,]    5    1    6    0    9    8    2}
\CommentTok{\#\textgreater{} [4,]    7    4    6    0    2    8    1}
\CommentTok{\#\textgreater{} [5,]    4    6    5    9    2    8    0}
\end{Highlighting}
\end{Shaded}

En lugar de usar los números del 1 al 10, el valor por defecto, R usa lo que proveemos a través de \texttt{v}: los dígitos de 0 a 9.

Para calcular todas las formas posibles en que podemos elegir dos cartas cuando el orden importa, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hands }\OtherTok{\textless{}{-}} \FunctionTok{permutations}\NormalTok{(}\DecValTok{52}\NormalTok{, }\DecValTok{2}\NormalTok{, }\AttributeTok{v =}\NormalTok{ deck)}
\end{Highlighting}
\end{Shaded}

Esta es una matriz con dos columnas y 2652 filas. Con una matriz podemos obtener la primera y segunda carta así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{first\_card }\OtherTok{\textless{}{-}}\NormalTok{ hands[,}\DecValTok{1}\NormalTok{]}
\NormalTok{second\_card }\OtherTok{\textless{}{-}}\NormalTok{ hands[,}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Ahora los casos para los cuales la primera carta es una K se pueden calcular así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kings }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{"King"}\NormalTok{, suits)}
\FunctionTok{sum}\NormalTok{(first\_card }\SpecialCharTok{\%in\%}\NormalTok{ kings)}
\CommentTok{\#\textgreater{} [1] 204}
\end{Highlighting}
\end{Shaded}

Para obtener la probabilidad condicional, calculamos qué fracción de estos tiene una K como la segunda carta:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(first\_card}\SpecialCharTok{\%in\%}\NormalTok{kings }\SpecialCharTok{\&}\NormalTok{ second\_card}\SpecialCharTok{\%in\%}\NormalTok{kings)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(first\_card}\SpecialCharTok{\%in\%}\NormalTok{kings)}
\CommentTok{\#\textgreater{} [1] 0.0588}
\end{Highlighting}
\end{Shaded}

que es exactamente 3/51, como ya habíamos deducido. Tengan en cuenta que el código anterior es equivalente a:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(first\_card}\SpecialCharTok{\%in\%}\NormalTok{kings }\SpecialCharTok{\&}\NormalTok{ second\_card}\SpecialCharTok{\%in\%}\NormalTok{kings)}\SpecialCharTok{/} \FunctionTok{mean}\NormalTok{(first\_card}\SpecialCharTok{\%in\%}\NormalTok{kings)}
\CommentTok{\#\textgreater{} [1] 0.0588}
\end{Highlighting}
\end{Shaded}

que usa \texttt{mean} en lugar de \texttt{sum} y es una versión R de:

\[
\frac{\mbox{Pr}(A \mbox{ and } B)}{ \mbox{Pr}(A)}
\]

¿Y qué tal si el orden no importa? Por ejemplo, en Blackjack, si le dan un As y una carta de figura como su primera mano, se llama un \emph{Natural 21} y ganan automáticamente. Si quisiéramos calcular la probabilidad de que esto suceda, enumeraríamos las \emph{combinaciones}, no las permutaciones, ya que el orden no importa.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{combinations}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]    1    2}
\CommentTok{\#\textgreater{} [2,]    1    3}
\CommentTok{\#\textgreater{} [3,]    2    3}
\end{Highlighting}
\end{Shaded}

En la segunda línea, el resultado no incluye (2,1) porque (1,2) ya se enumeró. Lo mismo aplica a (3,1) y (3,2).

Entonces, para calcular la probabilidad de un \emph{Natural 21}, podemos hacer esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{aces }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{"Ace"}\NormalTok{, suits)}

\NormalTok{facecard }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"King"}\NormalTok{, }\StringTok{"Queen"}\NormalTok{, }\StringTok{"Jack"}\NormalTok{, }\StringTok{"Ten"}\NormalTok{)}
\NormalTok{facecard }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{number =}\NormalTok{ facecard, }\AttributeTok{suit =}\NormalTok{ suits)}
\NormalTok{facecard }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(facecard}\SpecialCharTok{$}\NormalTok{number, facecard}\SpecialCharTok{$}\NormalTok{suit)}

\NormalTok{hands }\OtherTok{\textless{}{-}} \FunctionTok{combinations}\NormalTok{(}\DecValTok{52}\NormalTok{, }\DecValTok{2}\NormalTok{, }\AttributeTok{v =}\NormalTok{ deck)}
\FunctionTok{mean}\NormalTok{(hands[,}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hands[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard)}
\CommentTok{\#\textgreater{} [1] 0.0483}
\end{Highlighting}
\end{Shaded}

En la última línea, suponemos que el As es la primera carta que recibimos. Esto lo sabemos porque, sabiendo como \texttt{combination} enumera las probabilidades, entendemos que enumerará este caso primero. Pero para estar seguros, podríamos haber producido la misma respuesta al escribir lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{((hands[,}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hands[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard) }\SpecialCharTok{|}
\NormalTok{       (hands[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hands[,}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard))}
\CommentTok{\#\textgreater{} [1] 0.0483}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejemplo-monte-carlo}{%
\subsection{Ejemplo Monte Carlo}\label{ejemplo-monte-carlo}}

En lugar de usar \texttt{combinations} para deducir la probabilidad exacta de un \emph{Natural 21}, podemos usar una simulación Monte Carlo para estimar esta probabilidad. En este caso, escogemos dos cartas una y otra vez y notamos cuántos 21s tenemos. Podemos usar la función \texttt{sample} para escoger dos cartas sin reemplazos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hand }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(deck, }\DecValTok{2}\NormalTok{)}
\NormalTok{hand}
\CommentTok{\#\textgreater{} [1] "Queen Clubs"  "Seven Spades"}
\end{Highlighting}
\end{Shaded}

Y luego verificar si una carta es un As y la otra una carta de figura o un 10. De ahora en adelante, incluimos 10 cuando decimos \emph{carta de figura} o \emph{figura}. Ahora necesitamos verificar ambas probabilidades:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(hands[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hands[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard) }\SpecialCharTok{|}
\NormalTok{  (hands[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hands[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

Si repetimos esto 10,000 veces, obtenemos una muy buena aproximación de la probabilidad de un \emph{Natural 21}.

Comencemos escribiendo una función que escoje una mano y devuelve TRUE si obtenemos un 21. La función no necesita argumentos porque usa objetos definidos en el entorno global.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{blackjack }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  hand }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(deck, }\DecValTok{2}\NormalTok{)}
\NormalTok{  (hand[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hand[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard) }\SpecialCharTok{|}
\NormalTok{    (hand[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ aces }\SpecialCharTok{\&}\NormalTok{ hand[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%in\%}\NormalTok{ facecard)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aquí tenemos que verificar ambas probabilidades: As primero o As segundo porque no estamos usando la función \texttt{combinations}. La función devuelve \texttt{TRUE} si obtenemos un 21 y \texttt{FALSE} de otra manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{blackjack}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

Ahora podemos jugar este juego, digamos, 10,000 veces:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{results }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{blackjack}\NormalTok{())}
\FunctionTok{mean}\NormalTok{(results)}
\CommentTok{\#\textgreater{} [1] 0.0475}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejemplos}{%
\section{Ejemplos}\label{ejemplos}}

En esta sección, describimos dos ejemplos populares de probabilidad discreta: el problema Monty Hall y el problema del cumpleaños. Usamos R para ayudar a ilustrar los conceptos matemáticos.

\hypertarget{problema-monty-hall}{%
\subsection{Problema Monty Hall}\label{problema-monty-hall}}

En la década de 1970 en EE.UU, hubo un programa de concursos llamado ``Let's Make a Deal'' y Monty Hall era el anfitrión. En algún momento del juego, se le pedía al concursante que eligiera una de tres puertas. Detrás de una puerta había un premio, mientras que detrás de las otras puertas tenían una cabra que señalaba que el concursante había perdido. Después de que el concursante eligiera una puerta y antes de revelar si esa puerta contenía un premio, Monty Hall abría una de las otras dos puertas y le mostraba al concursante que no había ningún premio detrás de esa puerta. Luego le preguntaba al concursante: ``¿Quiere cambiar de puerta?'' ¿Qué harían Uds.?

Podemos usar la probabilidad para mostrar que si se quedan con la opción de la puerta original, sus probabilidades de ganar un premio siguen siendo 1 en 3. Sin embargo, si cambian a la otra puerta, ¡sus probabilidades de ganar duplican a 2 en 3! Esto parece contradictorio. Muchas personas piensan incorrectamente que ambas probabilidades son 1 en 2 ya que uno elige entre 2 opciones. Pueden ver una explicación matemática detallada en Khan Academy\footnote{\url{https://www.khanacademy.org/math/precalculus/prob-comb/dependent-events-precalc/v/monty-hall-problem}} o leer una en Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Monty_Hall_problem}}. A continuación, usamos una simulación Monte Carlo para ver qué estrategia es mejor. Tengan en cuenta que este código se escribe con más detalle de lo necesario para fines pedagógicos.

Comencemos con la estrategia de no cambiar de puerta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{monty\_hall }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(strategy)\{}
\NormalTok{  doors }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, }\StringTok{"goat"}\NormalTok{, }\StringTok{"goat"}\NormalTok{))}
\NormalTok{  prize\_door }\OtherTok{\textless{}{-}}\NormalTok{ doors[prize }\SpecialCharTok{==} \StringTok{"car"}\NormalTok{]}
\NormalTok{  my\_pick }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(doors, }\DecValTok{1}\NormalTok{)}
\NormalTok{  show }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(doors[}\SpecialCharTok{!}\NormalTok{doors }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(my\_pick, prize\_door)],}\DecValTok{1}\NormalTok{)}
\NormalTok{  stick }\OtherTok{\textless{}{-}}\NormalTok{ my\_pick}
\NormalTok{  stick }\SpecialCharTok{==}\NormalTok{ prize\_door}
  \ControlFlowTok{switch} \OtherTok{\textless{}{-}}\NormalTok{ doors[}\SpecialCharTok{!}\NormalTok{doors}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(my\_pick, show)]}
\NormalTok{  choice }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(strategy }\SpecialCharTok{==} \StringTok{"stick"}\NormalTok{, stick, }\ControlFlowTok{switch}\NormalTok{)}
\NormalTok{  choice }\SpecialCharTok{==}\NormalTok{ prize\_door}
\NormalTok{\}}
\NormalTok{stick }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{monty\_hall}\NormalTok{(}\StringTok{"stick"}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(stick)}
\CommentTok{\#\textgreater{} [1] 0.342}
\ControlFlowTok{switch} \OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{monty\_hall}\NormalTok{(}\StringTok{"switch"}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(}\ControlFlowTok{switch}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.668}
\end{Highlighting}
\end{Shaded}

Mientras escribimos el código, notamos que las líneas que comienzan con \texttt{my\_pick} y \texttt{show} no afectan la última operación lógica cuando nos atenemos a nuestra elección original. De esto, debemos darnos cuenta de que la probabilidad es de 1 en 3, la misma con la cual comenzamos. Cuando cambiamos, la estimación Monte Carlo confirma el cálculo de 2/3. Esto nos ayuda entender el problema mejor al mostrar que estamos quitando una puerta, \texttt{show}, que definitivamente no esconde un premio de nuestras opciones. También vemos que, a menos que lo hagamos bien cuando elegimos por primera vez, ustedes ganan: 1 - 1/3 = 2/3.

\hypertarget{problema-de-cumpleauxf1os}{%
\subsection{Problema de cumpleaños}\label{problema-de-cumpleauxf1os}}

Imagínense que están en un salón de clase con 50 personas. Si suponemos que este es un grupo de 50 personas seleccionadas al azar, ¿cuál es la probabilidad de que al menos dos personas tengan el mismo cumpleaños? Aunque es algo avanzado, podemos deducir esto matemáticamente. Haremos esto más tarde, pero aquí usamos una simulación Monte Carlo. Para simplificar, suponemos que nadie nació el 29 de febrero. Esto realmente no cambia mucho la respuesta.

Primero, tengan en cuenta que los cumpleaños se pueden representar como números entre 1 y 365, por lo que se puede obtener una muestra de 50 cumpleaños de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{bdays }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{365}\NormalTok{, n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para verificar si en este set particular de 50 personas tenemos al menos dos con el mismo cumpleaños, podemos usar la función \texttt{duplicated}, que devuelve \texttt{TRUE} siempre que un elemento de un vector sea un duplicado. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{duplicated}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

La segunda vez que aparecen 1 y 3, obtenemos un \texttt{TRUE}. Entonces, para verificar si dos cumpleaños son iguales, simplemente usamos las funciones \texttt{any} y \texttt{duplicated} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(}\FunctionTok{duplicated}\NormalTok{(bdays))}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

En este caso, vemos que sucedió. Al menos dos personas tuvieron el mismo cumpleaños.

Para estimar la probabilidad de un cumpleaños compartido en el grupo, repetimos este experimento muestreando sets de 50 cumpleaños una y otra vez:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{same\_birthday }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  bdays }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{365}\NormalTok{, n, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{any}\NormalTok{(}\FunctionTok{duplicated}\NormalTok{(bdays))}
\NormalTok{\}}
\NormalTok{results }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{same\_birthday}\NormalTok{(}\DecValTok{50}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(results)}
\CommentTok{\#\textgreater{} [1] 0.969}
\end{Highlighting}
\end{Shaded}

¿Esperaban que la probabilidad fuera tan alta?

Las personas tienden a subestimar estas probabilidades. Para tener una idea de por qué es tan alta, piensen en lo que sucede cuando el tamaño del grupo se acerca a 365. Con 365, se nos acaban los días y la probabilidad es una.

Digamos que queremos usar este conocimiento para apostar con amigos sobre si dos personas en un grupo tienen el mismo cumpleaños. ¿Con un grupo de qué tamaño son las probabilidades superiores a 50\%? ¿Superiores a 75\%?

Empecemos creando una tabla de consulta. Rápidamente podemos crear una función para calcular esto para cualquier tamaño de grupo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compute\_prob }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, }\AttributeTok{B=}\DecValTok{10000}\NormalTok{)\{}
\NormalTok{  results }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{same\_birthday}\NormalTok{(n))}
  \FunctionTok{mean}\NormalTok{(results)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Usando la función \texttt{sapply}, podemos realizar operaciones elemento por elemento en cualquier función:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{60}\NormalTok{)}
\NormalTok{prob }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(n, compute\_prob)}
\end{Highlighting}
\end{Shaded}

Ahora podemos hacer un gráfico de las probabilidades estimadas de dos personas tener el mismo cumpleaños en un grupo de tamaño \(n\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{prob }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(n, compute\_prob)}
\FunctionTok{qplot}\NormalTok{(n, prob)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/birthday-problem-mc-probabilities-1} \end{center}

Ahora calculemos las probabilidades exactas en lugar de usar simulaciones Monte Carlo. No solo obtenemos la respuesta exacta usando matemáticas, sino que los cálculos son mucho más rápidos ya que no tenemos que generar experimentos.

Para simplificar las matemáticas, en lugar de calcular la probabilidad de que ocurra, calcularemos la probabilidad de que no ocurra. Para esto, usamos la regla de la multiplicación.

Comencemos con la primera persona. La probabilidad de que persona 1 tenga un cumpleaños único es 1. La probabilidad de que persona 2 tenga un cumpleaños único, dado que ya se le asignó un día a persona 1, es 364/365. Luego, dado que las dos primeras personas tienen cumpleaños únicos, persona 3 tiene 363 días para elegir. Continuamos de esta manera y encontramos que las probabilidades de que todas las 50 personas tengan un cumpleaños único son:

\[
1 \times \frac{364}{365}\times\frac{363}{365} \dots \frac{365-n + 1}{365}
\]

Podemos escribir una función que haga esto para cualquier número:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exact\_prob }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  prob\_unique }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{365}\NormalTok{,}\DecValTok{365}\SpecialCharTok{{-}}\NormalTok{n}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}\SpecialCharTok{/}\DecValTok{365}
  \DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{prod}\NormalTok{( prob\_unique)}
\NormalTok{\}}
\NormalTok{eprob }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(n, exact\_prob)}
\FunctionTok{qplot}\NormalTok{(n, prob) }\SpecialCharTok{+} \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(n, eprob), }\AttributeTok{col =} \StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/birthday-problem-exact-probabilities-1} \end{center}

Este gráfico muestra que la simulación Monte Carlo ofrece una muy buena estimación de la probabilidad exacta. Si no hubiera sido posible calcular las probabilidades exactas, aún habríamos podido estimar con precisión las probabilidades.

\hypertarget{infinito-en-la-pruxe1ctica}{%
\section{Infinito en la práctica}\label{infinito-en-la-pruxe1ctica}}

La teoría descrita aquí requiere repetir experimentos una y otra vez para siempre. En la práctica no podemos hacer esto. En los ejemplos anteriores, utilizamos \(B=10,000\) experimentos Monte Carlo y resultó que esto nos dio estimados precisos. Cuanto mayor sea este número, más preciso será el estimado hasta que la aproximación sea tan buena que sus computadoras no podrán notar la diferencia. Pero en cálculos más complejos, 10,000 puede ser insuficiente. Además, para algunos cálculos, 10,000 experimentos podrían no ser computacionalmente factibles. En la práctica, no sabremos cuál es la respuesta, por lo que no sabremos si nuestra estimación Monte Carlo es precisa. Sabemos que entre más grande sea \(B\), mejor será la aproximación. ¿Pero cuán grande necesitamos que sea? Esta es realmente una pregunta desafiante y frecuentemente contestarla requiere una formación avanzada en estadística teórica.

Un enfoque práctico que describiremos aquí es verificar la estabilidad del estimado. A continuación ofrecemos un ejemplo con el problema de cumpleaños para un grupo de 25 personas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\AttributeTok{len =} \DecValTok{100}\NormalTok{)}
\NormalTok{compute\_prob }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(B, }\AttributeTok{n=}\DecValTok{25}\NormalTok{)\{}
\NormalTok{  same\_day }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{same\_birthday}\NormalTok{(n))}
  \FunctionTok{mean}\NormalTok{(same\_day)}
\NormalTok{\}}
\NormalTok{prob }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(B, compute\_prob)}
\FunctionTok{qplot}\NormalTok{(}\FunctionTok{log10}\NormalTok{(B), prob, }\AttributeTok{geom =} \StringTok{"line"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/monte-carlo-convergence-1} \end{center}

En este gráfico, podemos ver que los valores comienzan a estabilizarse (es decir, varían menos de .01) alrededor de 1000. Noten que la probabilidad exacta, que en este caso sabemos, es 0.569.

\hypertarget{ejercicios-22}{%
\section{Ejercicios}\label{ejercicios-22}}

1. Se escoge una canica al azar de una caja que contiene: 3 canicas cian, 5 canicas magenta y 7 canicas amarillas. ¿Cuál es la probabilidad de que la canica sea cian?

2. ¿Cuál es la probabilidad de que la canica no sea cian?

3. En lugar de escoger solo una canica, escoja dos canicas. Saque la primera canica sin devolverla a la caja. Este es un muestreo \textbf{sin} reemplazo. ¿Cuál es la probabilidad de que la primera canica sea cian y la segunda no sea cian?

4. Ahora repita el experimento, pero esta vez, después de sacar la primera canica y anotar el color, devuélvala a la caja y agite la caja. Este es un muestreo \textbf{con} reemplazo. ¿Cuál es la probabilidad de que la primera canica sea cian y la segunda canica no sea cian?

5. Dos eventos \(A\) y \(B\) son independientes si \(\mbox{Pr}(A \mbox{ and } B) = \mbox{Pr}(A) P(B)\). ¿Bajo qué situación son independientes la selección?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  No reemplaza el articulo seleccionado.
\item
  Reemplaza el articulo seleccionado.
\item
  Ninguna.
\item
  Ambas.
\end{enumerate}

6. Digamos que ha sacado 5 canicas de la caja, con reemplazo, y todas han sido amarillas. ¿Cuál es la probabilidad de que la próxima sea amarilla?

7. Si lanza un dado de 6 lados seis veces, ¿cuál es la probabilidad de no ver un 6?

8. Dos equipos de baloncesto, digamos los Celtics y los Cavs, están jugando una serie de siete juegos. Los Cavs son un mejor equipo y tienen un 60\% de probabilidad de ganar cada juego. ¿Cuál es la probabilidad de que los Celtics ganen \textbf{al menos} un juego?

9. Cree una simulación Monte Carlo para confirmar su respuesta al problema anterior. Utilizar \texttt{B\ \textless{}-\ 10000} simulaciones. Sugerencia: use el siguiente código para generar los resultados de los primeros cuatro juegos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{celtic\_wins }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\DecValTok{4}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.6}\NormalTok{, }\FloatTok{0.4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Los Celtics deben ganar uno de estos 4 juegos.

10. Dos equipos de baloncesto, digamos los Cavs y los Warriors, están jugando una serie de campeonato de siete juegos. El primero en ganar cuatro juegos, por consiguiente, gana la serie. Los equipos son igualmente buenos, por lo que cada uno tiene una probabilidad de 50-50 de ganar cada juego. Si los Cavs pierden el primer juego, ¿cuál es la probabilidad de que ganen la serie?

11. Confirme los resultados de la pregunta anterior con una simulación Monte Carlo.

12. Dos equipos, \(A\) y \(B\), están jugando una serie de siete juegos. Equipo \(A\) es mejor que equipo \(B\) y tiene un \(p>0.5\) probabilidad de ganar cada juego. Dado un valor-\(p\), la probabilidad de que el equipo no favorito \(B\) gane la serie se puede calcular con la siguiente función basada en una simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prob\_win }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(p)\{}
\NormalTok{  B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{    b\_win }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{), }\DecValTok{7}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
    \FunctionTok{sum}\NormalTok{(b\_win)}\SpecialCharTok{\textgreater{}=}\DecValTok{4}
\NormalTok{  \})}
  \FunctionTok{mean}\NormalTok{(result)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Use la función \texttt{sapply} para calcular la probabilidad, llámela \texttt{Pr}, de ganar para \texttt{p\ \textless{}-\ seq(0.5,\ 0.95,\ 0.025)}. Luego grafique el resultado.

13. Repita el ejercicio anterior, pero ahora mantenga la probabilidad fija en \texttt{p\ \textless{}-\ 0.75} y calcule la probabilidad para diferentes números de juegos necesarios para acabar la serie: ganar 1 juego, ganar 2 de 3 juegos, ganar 3 de 5 juegos, \ldots{} Específicamente, \texttt{N\ \textless{}-\ seq(1,\ 25,\ 2)}. Sugerencia: use esta función:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prob\_win }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(N, }\AttributeTok{p=}\FloatTok{0.75}\NormalTok{)\{}
\NormalTok{  B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{    b\_win }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{), N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
    \FunctionTok{sum}\NormalTok{(b\_win)}\SpecialCharTok{\textgreater{}=}\NormalTok{(N}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}\SpecialCharTok{/}\DecValTok{2}
\NormalTok{  \})}
  \FunctionTok{mean}\NormalTok{(result)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{probabilidad-continua}{%
\section{Probabilidad continua}\label{probabilidad-continua}}

En la Sección \ref{cdf-intro}, explicamos por qué al resumir una lista de valores numéricos, como las alturas, no es útil construir una distribución que defina una proporción para cada resultado posible. Por ejemplo, imagínemos que medimos a cada persona en una población grande, digamos de tamaño \(n\), con una precisión extremadamente alta. Como no hay dos personas con exactamente la misma altura, debemos asignar la proporción \(1/n\) a cada valor observado y como consecuencia no se obtiene ningún resumen útil. Del mismo modo, al definir distribuciones de probabilidad, no es útil asignar una probabilidad muy pequeña a cada altura.

Al igual que cuando se usan distribuciones para resumir datos numéricos, es mucho más práctico definir una función que opere en intervalos en lugar de valores individuales. La forma estándar de hacerlo es utilizando la \emph{función de distribución acumulada} (CDF por sus siglas en inglés).

Describimos la función de distribución acumulada empírica (eCDF) en la Sección \ref{cdf-intro} como un resumen básico de una lista de valores numéricos. Como ejemplo, anteriormente definimos la distribución de altura para los estudiantes varones adultos. Aquí definimos el vector \(x\) para contener estas alturas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(height)}
\end{Highlighting}
\end{Shaded}

Definimos la función de distribución acumulada empírica como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{F }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(a) }\FunctionTok{mean}\NormalTok{(x}\SpecialCharTok{\textless{}=}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

que, por cualquier valor \texttt{a}, da la proporción de valores en la lista \texttt{x} que son más pequeños o iguales que \texttt{a}.

Tengan en cuenta que todavía no hemos discutido la probabilidad en el contexto de la CDF. Hagamos esto preguntando lo siguiente: ¿si elijo a uno de los estudiantes varones al azar, cuál es la probabilidad de que sea más alto que 70.5 pulgadas? Debido a que cada estudiante tiene la misma probabilidad de ser elegido, la respuesta a esto es equivalente a la proporción de estudiantes que son más altos que 70.5 pulgadas. Usando la CDF obtenemos una respuesta escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{F}\NormalTok{(}\DecValTok{70}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.377}
\end{Highlighting}
\end{Shaded}

Una vez que se defina una CDF, podemos usar esto para calcular la probabilidad de cualquier subconjunto. Por ejemplo, la probabilidad de que un estudiante esté entre altura \texttt{a} y altura \texttt{b} es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{F}\NormalTok{(b)}\SpecialCharTok{{-}}\FunctionTok{F}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

Como podemos calcular la probabilidad de cualquier evento posible de esta manera, la función de probabilidad acumulada define la distribución de probabilidad para elegir una altura al azar de nuestro vector de alturas \texttt{x}.

\hypertarget{distribuciones-teuxf3ricas-continuas}{%
\section{Distribuciones teóricas continuas}\label{distribuciones-teuxf3ricas-continuas}}

En la Sección \ref{normal-distribution}, presentamos la distribución normal como una aproximación útil a muchas distribuciones naturales, incluyendo la altura. La distribución acumulada para la distribución normal se define mediante una fórmula matemática que en R se puede obtener con la función \texttt{pnorm}. Decimos que una cantidad aleatoria se distribuye normalmente con promedio \texttt{m} y desviación estándar \texttt{s} si su distribución de probabilidad se define por:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{F}\NormalTok{(a) }\OtherTok{=} \FunctionTok{pnorm}\NormalTok{(a, m, s)}
\end{Highlighting}
\end{Shaded}

Esto es útil porque si estamos dispuestos a usar la aproximación normal para, por ejemplo, la altura, no necesitamos todo el set de datos para responder a preguntas como: ¿cuál es la probabilidad de que un estudiante seleccionado al azar sea más alto que 70 pulgadas? Solo necesitamos la altura promedio y la desviación estándar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x)}
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\FloatTok{70.5}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.371}
\end{Highlighting}
\end{Shaded}

\hypertarget{distribuciones-teuxf3ricas-como-aproximaciones}{%
\subsection{Distribuciones teóricas como aproximaciones}\label{distribuciones-teuxf3ricas-como-aproximaciones}}

La distribución normal se deriva matemáticamente: no necesitamos datos para definirla. Para los científicos de datos, casi todo lo que hacemos en la práctica involucra datos. Los datos son siempre, desde un punto de vista técnico, discretos. Por ejemplo, podríamos considerar nuestros datos de altura categóricos con cada altura específica como una categoría única. La distribución de probabilidad se define por la proporción de estudiantes que indican cada altura. Aquí hay un gráfico de esa distribución de probabilidad:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/plot-of-height-frequencies-1} \end{center}

Mientras que la mayoría de los estudiantes redondearon sus alturas a la pulgada más cercana, otros indicaron valores con más precisión. Un estudiante indicó que su altura era 69.6850393700787 pulgadas, que equivale 177 centímetros. La probabilidad asignada a esta altura es 0.001 o 1 en 812. La probabilidad de 70 pulgadas es mucho mayor en 0.106, pero ¿tiene sentido pensar que la probabilidad de tener exactamente 70 pulgadas es diferente de 69.6850393700787? Claramente es mucho más útil para fines de análisis de datos tratar este resultado como una variable numérica continua, teniendo en cuenta que muy pocas personas, o tal vez ninguna, son exactamente 70 pulgadas y que la razón por la que obtenemos más valores en 70 es porque las personas redondean a la pulgada más cercana.

Con distribuciones continuas, la probabilidad de un valor singular no se define. Por ejemplo, no tiene sentido preguntar cuál es la probabilidad de que un valor distribuido normalmente sea 70. En cambio, definimos probabilidades para intervalos. Por lo tanto, podríamos preguntar cuál es la probabilidad de que alguien mida entre 69.5 y 70.5.

En casos como la altura, en los que los datos se redondean, la aproximación normal es particularmente útil si estamos trabajando con intervalos que incluyen exactamente un número redondo. Por ejemplo, la distribución normal es útil para aproximar la proporción de estudiantes que indican valores en intervalos como los tres siguientes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{68.5}\NormalTok{) }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{67.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.115}
\FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{69.5}\NormalTok{) }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{68.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.119}
\FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{70.5}\NormalTok{) }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{69.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.122}
\end{Highlighting}
\end{Shaded}

Observen lo mucho que nos acercamos con la aproximación normal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{68.5}\NormalTok{, m, s) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\FloatTok{67.5}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.103}
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{69.5}\NormalTok{, m, s) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\FloatTok{68.5}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.11}
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{70.5}\NormalTok{, m, s) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\FloatTok{69.5}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.108}
\end{Highlighting}
\end{Shaded}

Sin embargo, la aproximación no es tan útil para otros intervalos. Por ejemplo, observen cómo se descompone la aproximación cuando intentamos estimar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(x }\SpecialCharTok{\textless{}=} \FloatTok{70.9}\NormalTok{) }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(x}\SpecialCharTok{\textless{}=}\FloatTok{70.1}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0222}
\end{Highlighting}
\end{Shaded}

con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{70.9}\NormalTok{, m, s) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\FloatTok{70.1}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.0836}
\end{Highlighting}
\end{Shaded}

En general, llamamos a esta situación \emph{discretización}. Aunque la distribución de altura real es continua, las alturas reportadas tienden a ser más comunes en valores discretos, en este caso, debido al redondeo. Con tal que sepamos cómo lidiar con esta realidad, la aproximación normal puede ser una herramienta muy útil.

\hypertarget{la-densidad-de-probabilidad}{%
\subsection{La densidad de probabilidad}\label{la-densidad-de-probabilidad}}

Para distribuciones categóricas, podemos definir la probabilidad de una categoría. Por ejemplo, un lanzamiento de dado, llamémoslo \(X\), puede ser 1,2,3,4,5 o 6. La probabilidad de 4 se define como:

\[
\mbox{Pr}(X=4) = 1/6
\]

La CDF entonces se puede definir fácilmente:
\[
F(4) = \mbox{Pr}(X\leq 4) = \mbox{Pr}(X = 4) + \mbox{Pr}(X = 3) + \mbox{Pr}(X = 2) + \mbox{Pr}(X = 1)
\]

Aunque para distribuciones continuas la probabilidad de un solo valor \(\mbox{Pr}(X=x)\) no se define, hay una definición teórica que tiene una interpretación similar. La densidad de probabilidad en \(x\) se define como la función \(f(a)\) tal que:

\[
F(a) = \mbox{Pr}(X\leq a) = \int_{-\infty}^a f(x)\, dx
\]

Para aquellos que conocen el cálculo, recuerden que la integral está relacionada con una suma: es la suma de las barras con anchos que se aproximan a 0. Si no conocen el cálculo, pueden pensar en \(f(x)\) como una curva para la cual el área debajo de esa curva hasta el valor \(a\) les da la probabilidad \(\mbox{Pr}(X\leq a)\).

Por ejemplo, para usar la aproximación normal para estimar la probabilidad de que alguien sea más alto que 76 pulgadas, usamos:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\DecValTok{76}\NormalTok{, m, s)}
\CommentTok{\#\textgreater{} [1] 0.0321}
\end{Highlighting}
\end{Shaded}

que matemáticamente es el área gris a continuación:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/intergrals-1} \end{center}

La curva que ven es la densidad de probabilidad para la distribución normal. En R, obtenemos esto usando la función \texttt{dnorm}.

Aunque quizás no sea inmediatamente obvio por qué es útil conocer las densidades de probabilidad, comprender este concepto será esencial para aquellos que quieran ajustar modelos a datos para los que no hay funciones predefinidas disponibles.

\hypertarget{simulaciones-monte-carlo-para-variables-continuas}{%
\section{Simulaciones Monte Carlo para variables continuas}\label{simulaciones-monte-carlo-para-variables-continuas}}

R provee funciones para generar resultados normalmente distribuidos. Específicamente, la función \texttt{rnorm} toma tres argumentos: tamaño, promedio (predeterminado a 0) y desviación estándar (predeterminada a 1) y produce números aleatorios. Aquí tenemos un ejemplo de cómo podríamos generar datos que se parezcan a nuestras alturas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(x)}
\NormalTok{simulated\_heights }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(n, m, s)}
\end{Highlighting}
\end{Shaded}

No sorprende que la distribución se vea normal:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-heights-1} \end{center}

Esta es una de las funciones más útiles en R, ya que nos permite generar datos que imitan eventos naturales y responder a preguntas relacionadas con lo que podría suceder por casualidad al ejecutar simulaciones Monte Carlo.

Si, por ejemplo, elegimos 800 hombres al azar, ¿cuál es la distribución de la persona más alta? ¿Cuán raro es un hombre de 7 pies, un \emph{seven footer}, en un grupo de 800 hombres? La siguiente simulación Monte Carlo nos ayuda a responder esa pregunta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{tallest }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  simulated\_data }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{800}\NormalTok{, m, s)}
  \FunctionTok{max}\NormalTok{(simulated\_data)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Tener un \emph{seven footer} es bastante raro:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(tallest }\SpecialCharTok{\textgreater{}=} \DecValTok{7}\SpecialCharTok{*}\DecValTok{12}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0196}
\end{Highlighting}
\end{Shaded}

Aquí vemos la distribución resultante:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-tallest-height-1} \end{center}

Noten que no parece normal.

\hypertarget{distribuciones-continuas}{%
\section{Distribuciones continuas}\label{distribuciones-continuas}}

Presentamos la distribución normal en la Sección \ref{normal-distribution} y se usó como ejemplo anteriormente. La distribución normal no es la única distribución teórica útil. Otras distribuciones continuas que podemos encontrar son t de Student (\emph{Student t} en inglés), chi-cuadrada, exponencial, gamma, beta y beta-binomial. R provee funciones para calcular la densidad, los cuantiles, las funciones de distribución acumulada y para generar simulaciones Monte Carlo. R usa una convención que nos ayuda recordar los nombres: usa las letras \texttt{d}, \texttt{q}, \texttt{p} y \texttt{r} delante de una abreviatura del nombre de la distribución. Ya hemos visto las funciones \texttt{dnorm}, \texttt{pnorm} y \texttt{rnorm} para la distribución normal. La función \texttt{qnorm} nos da los cuantiles. Por lo tanto, podemos trazar una distribución así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{100}\NormalTok{)}
\FunctionTok{qplot}\NormalTok{(x, f, }\AttributeTok{geom =} \StringTok{"line"}\NormalTok{, }\AttributeTok{data =} \FunctionTok{data.frame}\NormalTok{(x, }\AttributeTok{f =} \FunctionTok{dnorm}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

Para la distribución t de Student, descrita más adelante en la Sección \ref{t-dist}, la abreviatura \texttt{t} se usa para que las funciones sean \texttt{dt} para la densidad, \texttt{qt} para los cuantiles, \texttt{pt} para la función de distribución acumulada y \texttt{rt} para la simulación Monte Carlo.

\hypertarget{ejercicios-23}{%
\section{Ejercicios}\label{ejercicios-23}}

1. Suponga que la distribución de las alturas femeninas se aproxima por una distribución normal con una media de 64 pulgadas y una desviación estándar de 3 pulgadas. Si elegimos una hembra al azar, ¿cuál es la probabilidad de que mida 5 pies o menos?

2. Suponga que la distribución de las alturas femeninas se aproxima por una distribución normal con una media de 64 pulgadas y una desviación estándar de 3 pulgadas. Si elegimos una hembra al azar, ¿cuál es la probabilidad de que mida 6 pies o más?

3. Suponga que la distribución de las alturas femeninas se aproxima por una distribución normal con una media de 64 pulgadas y una desviación estándar de 3 pulgadas. Si elegimos una hembra al azar, ¿cuál es la probabilidad de que mida entre 61 y 67 pulgadas?

4. Repita el ejercicio anterior, pero convierta todo a centímetros. Es decir, multiplique cada altura, incluyendo la desviación estándar, por 2.54. ¿Cuál es la respuesta ahora?

5. Noten que la respuesta a la pregunta no cambia cuando cambian las unidades. Esto tiene sentido ya que la respuesta a la pregunta no debe ser afectada por las unidades que usamos. De hecho, si se fija bien, verá que 61 y 64 están a 1 SD de distancia del promedio. Calcule la probabilidad de que una variable aleatoria distribuida normal y aleatoriamente esté dentro de 1 SD del promedio.

6. Para ver las matemáticas que explican por qué las respuestas a las preguntas 3, 4 y 5 son las mismas, suponga que tiene una variable aleatoria con promedio \(m\) y error estándar \(s\). Suponga que quiere saber la probabilidad de que \(X\) sea más pequeña o igual a \(a\). Recuerda que, por definición, \(a\) está a \((a - m)/s\) desviaciones estandar \(s\) del promedio \(m\). La probabilidad es:

\[
\mbox{Pr}(X \leq a)
\]

Ahora reste \(\mu\) a ambos lados y luego divida ambos lados por \(\sigma\):

\[
\mbox{Pr}\left(\frac{X-m}{s} \leq \frac{a-m}{s} \right)
\]

La cantidad a la izquierda es una variable aleatoria con distribución normal unitaria. Tiene un promedio de 0 y un error estándar de 1. Lo llamaremos \(Z\):

\[
\mbox{Pr}\left(Z \leq \frac{a-m}{s} \right)
\]

Entonces, sin importar las unidades, la probabilidad de \(X\leq a\) es igual a la probabilidad de que una variable normal unitaria sea menor que \((a - m)/s\). Si \texttt{mu} es el promedio y \texttt{sigma} el error estándar, ¿cuál de los siguientes códigos de R le dará la respuesta correcta en cada situación?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \texttt{mean(X\textless{}=a)}
\item
  \texttt{pnorm((a\ -\ m)/s)}
\item
  \texttt{pnorm((a\ -\ m)/s,\ m,\ s)}
\item
  \texttt{pnorm(a)}
\end{enumerate}

7. Imagine que la distribución de los hombres adultos es aproximadamente normal con un valor esperado de 69 y una desviación estándar de 3. ¿Cuán alto es el hombre en el percentil 99? Sugerencia: use \texttt{qnorm}.

8. La distribución de las puntuaciones de los coeficientes intelectuales, o CI (\emph{IQ} en inglés), se distribuye aproximadamente de manera normal. El promedio es 100 y la desviación estándar es 15. Suponga que desea conocer la distribución de los CI más altos en todas las clases graduandas de cada distrito escolar, cada uno con 10,000 personas. Ejecute una simulación Monte Carlo con \texttt{B=1000} generando 10,000 puntuaciones de CI y manteniendo los CI más altos. Haga un histograma.

\hypertarget{variables-aleatorias}{%
\chapter{Variables aleatorias}\label{variables-aleatorias}}

En la ciencia de datos, a menudo trabajamos con datos que se ven afectados de alguna manera por el azar. Algunos ejemplos son datos que provienen de una muestra aleatoria, datos afectados por un error de medición o datos que miden algún resultado que es de naturaleza aleatoria. Ser capaz de cuantificar la incertidumbre introducida por la aleatoriedad es uno de los trabajos más importantes de los analistas de datos. La inferencia estadística ofrece un acercamiento, así como varias herramientas prácticas para hacerlo. El primer paso es aprender a describir matemáticamente variables aleatorias.

En este capítulo, presentamos variables aleatorias y sus propiedades comenzando con su aplicación a juegos de azar. Luego describimos algunos de los eventos que rodearon la crisis financiera de 2007-2008\footnote{\url{https://en.wikipedia.org/w/index.php?title=Financial_crisis_of_2007\%E2\%80\%932008}} usando la teoría de la probabilidad. Esta crisis financiera fue causada en parte por subestimar el riesgo de ciertos valores\footnote{\url{https://en.wikipedia.org/w/index.php?title=Security_(finance)}} vendidos por instituciones financieras. Específicamente, los riesgos de los valores respaldados por hipotecas (MBS o \emph{mortgage-backed securities} en inglés) y las obligaciones de deuda garantizadas (CDO o \emph{collateralized debt obligations} en inglés) se subestimaron enormemente. Estos activos se vendieron a precios que suponían que la mayoría de los propietarios harían sus pagos a tiempo y se calculó como baja la probabilidad de que esto no ocurriera. Una combinación de factores resultó en muchos más incumplimientos de lo esperado, lo que condujo a una caída de los precios de estos valores. Como consecuencia, los bancos perdieron tanto dinero que necesitaron rescates del gobierno para evitar cerrar por completo.

\hypertarget{variables-aleatorias-1}{%
\section{Variables aleatorias}\label{variables-aleatorias-1}}

Las variables aleatorias son los resultados numéricos de procesos aleatorios. Podemos generar fácilmente variables aleatorias utilizando algunos de los ejemplos anteriores. Por ejemplo, definir \texttt{X} a ser 1 si la cuenta (\emph{bead} en inglés) es azul y 0 de lo contrario:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beads }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{( }\FunctionTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"blue"}\NormalTok{), }\AttributeTok{times =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{==} \StringTok{"blue"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Aquí \texttt{X} es una variable aleatoria: cada vez que seleccionamos una nueva cuenta, el resultado cambia aleatoriamente. Vean abajo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ifelse}\NormalTok{(}\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{==} \StringTok{"blue"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1}
\FunctionTok{ifelse}\NormalTok{(}\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{==} \StringTok{"blue"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0}
\FunctionTok{ifelse}\NormalTok{(}\FunctionTok{sample}\NormalTok{(beads, }\DecValTok{1}\NormalTok{) }\SpecialCharTok{==} \StringTok{"blue"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

A veces es 1 y a veces es 0.

\hypertarget{modelos-de-muestreo}{%
\section{Modelos de muestreo}\label{modelos-de-muestreo}}

Muchos procedimientos de generación de datos, aquellos que producen los datos que estudiamos, pueden modelarse relativamente bien como elecciones de una urna. Por ejemplo, podemos modelar el proceso de sondeo de votantes probables como sacar 0s (republicanos) y 1s (demócratas) de una urna que contiene el código 0 y 1 para todos los votantes probables. En los estudios epidemiológicos, a menudo suponemos que los sujetos de nuestro estudio son una muestra aleatoria de la población de interés. Los datos relacionados con un resultado específico se pueden modelar como una muestra aleatoria de una urna que contiene el resultado para toda la población de interés. De manera similar, en las investigaciones experimentales, a menudo suponemos que los organismos individuales que estamos estudiando, por ejemplo, gusanos, moscas o ratones, son una muestra aleatoria de una población más grande. Los experimentos aleatorios también se pueden modelar mediante selecciones de una urna dada la forma en que los individuos se asignan a grupos: cuando se les asignan, el grupo se escoge al azar. Los modelos de muestreo son, por lo tanto, omnipresentes en la ciencia de datos. Los juegos de casino ofrecen una gran cantidad de ejemplos de situaciones del mundo real en las que se utilizan modelos de muestreo para responder a preguntas específicas. Por lo tanto, comenzaremos con tales ejemplos.

Supongan que un casino muy pequeño los contratan para consultar si deben incluir las ruedas de la ruleta entre sus juegos. Para simplificar el ejemplo, suponemos que jugarán 1,000 personas y que la única apuesta que puedan hacer en la ruleta es apostar en rojo o negro. El casino quiere que predigan cuánto dinero ganarán o perderán. Quieren una gama de valores y, en particular, quieren saber cuál es la probabilidad de perder dinero. Si esta probabilidad es demasiado alta, no instalaran ruedas de ruleta.

Vamos a definir una variable aleatoria \(S\) que representará las ganancias totales del casino. Comencemos por construir la urna. Una rueda de ruleta tiene 18 casillas rojos, 18 casillas negros y 2 verdes. Entonces, jugar un color en un juego de ruleta es equivalente a escoger de la siguiente urna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{color }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Black"}\NormalTok{, }\StringTok{"Red"}\NormalTok{, }\StringTok{"Green"}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{18}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Los 1,000 resultados de 1,000 personas jugando son sorteos independientes de esta urna. Si aparece el rojo, el jugador gana y el casino pierde un dólar, por lo que sacamos un -\$1. De otra manera, el casino gana un dólar y sacamos un \$1. Para construir nuestra variable aleatoria \(S\), podemos usar este código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{ifelse}\NormalTok{(color }\SpecialCharTok{==} \StringTok{"Red"}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{X[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\CommentTok{\#\textgreater{}  [1] {-}1  1  1 {-}1 {-}1 {-}1  1  1  1  1}
\end{Highlighting}
\end{Shaded}

Como sabemos las proporciones de 1s y -1s, podemos generar las elecciones con una línea de código, sin definir \texttt{color}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Llamamos a esto un \textbf{modelo de muestreo} ya que estamos modelando el comportamiento aleatorio de la ruleta con el muestreo de elecciones de una urna. Las ganancias totales \(S\) son simplemente la suma de estos 1,000 sorteos independientes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
\NormalTok{S }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(X)}
\NormalTok{S}
\CommentTok{\#\textgreater{} [1] 22}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-distribuciuxf3n-de-probabilidad-de-una-variable-aleatoria}{%
\section{La distribución de probabilidad de una variable aleatoria}\label{la-distribuciuxf3n-de-probabilidad-de-una-variable-aleatoria}}

Si ejecutan el código anterior, verán que \(S\) cambia cada vez. Esto es porque \(S\) es una \textbf{variable aleatoria}. La distribución de probabilidad de una variable aleatoria nos dice la probabilidad de que el valor observado caiga en cualquier intervalo dado. Entonces, por ejemplo, si queremos saber la probabilidad de que perdamos dinero, estamos preguntando la probabilidad de que \(S\) esté en el intervalo \(S<0\).

Tengan en cuenta que si podemos definir una función de distribución acumulativa \(F(a) = \mbox{Pr}(S\leq a)\), entonces podremos responder a cualquier pregunta relacionada con la probabilidad de eventos definidos por nuestra variable aleatoria \(S\), incluyendo el evento \(S<0\). A esta \(F\) le decimos la \emph{función de distribución} de la variable aleatoria.

Podemos estimar la función de distribución para la variable aleatoria \(S\) mediante el uso de una simulación Monte Carlo para generar muchas realizaciones de la variable aleatoria. Con este código, ejecutamos el experimento de tener 1,000 personas jugando a la ruleta, una y otra vez, específicamente \(B = 10,000\) veces:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{roulette\_winnings }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
  \FunctionTok{sum}\NormalTok{(X)}
\NormalTok{\}}
\NormalTok{S }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{roulette\_winnings}\NormalTok{(n))}
\end{Highlighting}
\end{Shaded}

Ahora podemos preguntar lo siguiente: ¿en nuestras simulaciones, con qué frecuencia obtuvimos sumas menores o iguales a \texttt{a}?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(S }\SpecialCharTok{\textless{}=}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

Esta será una muy buena aproximación de \(F(a)\) y podemos responder fácilmente a la pregunta del casino: ¿cuán probable es que perdamos dinero? Podemos ver que la probabilidad es bastante baja:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(S}\SpecialCharTok{\textless{}}\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0456}
\end{Highlighting}
\end{Shaded}

Podemos visualizar la distribución de \(S\) creando un histograma que muestra la probabilidad \(F(b)-F(a)\) para varios intervalos \((a,b]\):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/normal-approximates-distribution-1} \end{center}

Vemos que la distribución parece ser aproximadamente normal. Un gráfico Q-Q confirmará que la aproximación normal está cerca de una aproximación perfecta para esta distribución. De hecho, si la distribución es normal, entonces todo lo que necesitamos para definir la distribución es el promedio y la desviación estándar. Debido a que tenemos los valores originales a partir de los cuales se crea la distribución, podemos calcularlos fácilmente con \texttt{mean(S)} y \texttt{sd(S)}. La curva azul que se añade al histograma anterior es una densidad normal con este promedio y desviación estándar.

Este promedio y esta desviación estándar tienen nombres especiales. Se les conoce como \emph{valor esperado} y \emph{error estándar} de la variable aleatoria \(S\) y se discutirán más en la siguiente sección.

La teoría estadística provee una forma de derivar la distribución de variables aleatorias definidas como extracciones aleatorias independientes de una urna. Específicamente, en nuestro ejemplo anterior, podemos mostrar que \((S+n)/2\) sigue una distribución binomial. Por lo tanto, no necesitamos ejecutar simulaciones Monte Carlo para saber la distribución de probabilidad de \(S\). Lo hicimos con fines ilustrativos.

Podemos usar las funciones \texttt{dbinom} y \texttt{pbinom} para calcular las probabilidades exactamente. Por ejemplo, para calcular \(\mbox{Pr}(S < 0)\) notamos que:

\[\mbox{Pr}(S < 0) = \mbox{Pr}((S+n)/2 < (0+n)/2)\]

y podemos usar \texttt{pbinom} para calcular: \[\mbox {Pr}(S \leq 0) \]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\FunctionTok{pbinom}\NormalTok{(n}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, }\AttributeTok{size =}\NormalTok{ n, }\AttributeTok{prob =} \DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0511}
\end{Highlighting}
\end{Shaded}

Debido a que esta es una función de probabilidad discreta, para obtener \(\mbox{Pr}(S < 0)\) en vez de \(\mbox{Pr}(S \leq 0)\), escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pbinom}\NormalTok{(n}\SpecialCharTok{/}\DecValTok{2{-}1}\NormalTok{, }\AttributeTok{size =}\NormalTok{ n, }\AttributeTok{prob =} \DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0448}
\end{Highlighting}
\end{Shaded}

Para más detalles sobre la distribución binomial, pueden consultar cualquier libro de probabilidad básico o incluso Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=Binomial_distribution}}.

Aquí no exploramos esos detalles. En cambio, discutiremos una aproximación increíblemente útil que nos da la teoría matemática que se aplica generalmente a sumas y promedios de sorteos de cualquier urna: el \emph{teorema del límite central} (\emph{Central Limit Theorem} o CLT por sus siglas en inglés).

\hypertarget{distribuciones-versus-distribuciones-de-probabilidad}{%
\section{Distribuciones versus distribuciones de probabilidad}\label{distribuciones-versus-distribuciones-de-probabilidad}}

Antes de continuar, hagamos una distinción y una conexión importante entre la distribución de una lista de números y una distribución de probabilidad. En el capítulo de visualización, describimos cómo cualquier lista de números \(x_1,\dots,x_n\) tiene una distribución. La definición es bastante sencilla. Definimos \(F(a)\) como la función que nos dice qué proporción de la lista es menor o igual a \(a\). Debido a que son resúmenes útiles cuando la distribución es aproximadamente normal, definimos el promedio y la desviación estándar. Estos se definen con una operación sencilla del vector que contiene la lista de números \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{((x }\SpecialCharTok{{-}}\NormalTok{ m)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/} \FunctionTok{length}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

Una variable aleatoria \(X\) tiene una función de distribución. Para definir esto, no necesitamos una lista de números. Es un concepto teórico. En este caso, definimos la distribución como la \(F(a)\) que responde a la pregunta: ¿cuál es la probabilidad de que \(X\) sea menor o igual que \(a\)? No hay una lista de números.

Sin embargo, si \(X\) se define como una selección de una urna con números en ella, entonces hay una lista: la lista de números dentro de la urna. En este caso, la distribución de esa lista es la distribución de probabilidad de \(X\) y el promedio y la desviación estándar de esa lista son el valor esperado y el error estándar de la variable aleatoria.

Otra forma de pensar en esto que no involucra una urna es ejecutar una simulación Monte Carlo y generar una lista muy grande de resultados de \(X\). Estos resultados son una lista de números. La distribución de esta lista será una muy buena aproximación de la distribución de probabilidad de \(X\). Cuanto más larga sea la lista, mejor será la aproximación. El promedio y la desviación estándar de esta lista se aproximarán al valor esperado y al error estándar de la variable aleatoria.

\hypertarget{notaciuxf3n-para-variables-aleatorias}{%
\section{Notación para variables aleatorias}\label{notaciuxf3n-para-variables-aleatorias}}

En los libros de texto estadísticos, las letras mayúsculas se usan para denotar variables aleatorias y seguimos esta convención aquí. Se usan letras minúsculas para los valores observados. Verán alguna notación que incluye ambos. Por ejemplo, verán eventos definidos como \(X \leq x\). Aquí \(X\) es una variable aleatoria, por lo que es un evento aleatorio, y \(x\) es un valor arbitrario y no aleatorio. Así, por ejemplo, \(X\) podría representar el número en un dado y \(x\) representará un valor real que vemos: 1, 2, 3, 4, 5 o 6. Entonces, en este caso, la probabilidad de \(X=x\) es 1/6 independientemente del valor observado \(x\). Esta notación es un poco extraña porque, cuando hacemos preguntas sobre probabilidad, \(X\) no es una cantidad observada, sino una cantidad aleatoria que veremos en el futuro. Podemos describir lo que esperamos ver, qué valores son probables, pero no lo qué es. Pero tan pronto tengamos datos, vemos una realización de \(X\). Entonces, los científicos de datos hablan de lo que pudo haber sido después de ver lo que realmente sucedió.

\hypertarget{el-valor-esperado-y-el-error-estuxe1ndar}{%
\section{El valor esperado y el error estándar}\label{el-valor-esperado-y-el-error-estuxe1ndar}}

Hemos descrito modelos de muestreo para sorteos. Ahora repasaremos la teoría matemática que nos permite aproximar las distribuciones de probabilidad para la suma de los sorteos. Una vez que hagamos esto, podremos ayudar al casino a predecir cuánto dinero ganarán. El mismo enfoque que usamos para la suma de los sorteos será útil para describir la distribución de promedios y la proporción que necesitaremos para entender cómo funcionan las encuestas.

El primer concepto importante para aprender es el \emph{valor esperado} (\emph{expected value} en inglés). En los libros de estadísticas, es común usar la letra \(\mbox{E}\) así:

\[\mbox{E}[X]\]

para denotar el valor esperado de la variable aleatoria \(X\).

Una variable aleatoria variará alrededor de su valor esperado de una manera que si toman el promedio de muchos, muchos sorteos, el promedio de los sorteos se aproximará al valor esperado, acercándose cada vez más mientras aumentan los sorteos.

La estadística teórica ofrece técnicas que facilitan el cálculo de los valores esperados en diferentes circunstancias. Por ejemplo, una fórmula útil nos dice que el \emph{valor esperado de una variable aleatoria definida por un sorteo es el promedio de los números en la urna}. En la urna que usamos para modelar las apuestas al rojo en la ruleta, tenemos 20 dólares y 18 dólares negativos. El valor esperado entonces es:

\[
\mbox{E}[X] = (20 + -18)/38
\]

que es como 5 centavos. Es un poco contradictorio decir que \(X\) varía alrededor de 0.05, cuando los únicos valores que toma son 1 y -1. Una manera de entender el valor esperado en este contexto es darse cuenta de que si jugamos el juego una y otra vez, el casino gana, en promedio, 5 centavos por juego. Una simulación Monte Carlo confirma esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{), B, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 0.0517}
\end{Highlighting}
\end{Shaded}

En general, si la urna tiene dos resultados posibles, digamos \(a\) y \(b\), con proporciones \(p\) y \(1-p\) respectivamente, el promedio es:

\[\mbox{E}[X] = ap + b(1-p)\]

Para ver esto, observen que si hay \(n\) cuentas en la urna, entonces tenemos \(np\) \(a\)s y \(n(1-p)\) \(b\)s, y como el promedio es la suma, \(n\times a \times p + n\times b \times (1-p)\), dividido por el total \(n\), obtenemos que el promedio es \(ap + b(1-p)\).

Ahora bien, la razón por la que definimos el valor esperado es porque esta definición matemática resulta útil para aproximar las distribuciones de probabilidad de la suma, que luego es útil para describir la distribución de promedios y proporciones. El primer hecho útil es que el \emph{valor esperado de la suma de los sorteos} es:

\[
\mbox{}\mbox{number of draws } \times \mbox{ average of the numbers in the urn}
\]

Entonces si 1,000 personas juegan a la ruleta, el casino espera ganar, en promedio, alrededor de 1,000 \(\times\) \$0.05 = \$50. Pero este es un valor esperado. ¿Cuán diferente puede ser una observación del valor esperado? El casino realmente necesita saber esto. ¿Cuál es el rango de probabilidades? Si los números negativos son muy probables, no instalarán las ruedas de ruleta. La teoría estadística una vez más responde a esta pregunta. El \emph{error estándar} (SE por sus siglas en inglés) nos da una idea del tamaño de la variación alrededor del valor esperado. En los libros de estadísticas, es común usar:

\[\mbox{SE}[X]\]

para denotar el error estándar de una variable aleatoria.

\textbf{Si nuestros sorteos son independientes}, entonces el \emph{error estándar de la suma} lo da la ecuación:

\[
\sqrt{\mbox{number of draws }} \times \mbox{ standard deviation of the numbers in the urn}
\]

Usando la definición de desviación estándar, podemos derivar, con un poco de matemática, que si una urna contiene dos valores \(a\) y \(b\) con proporciones \(p\) y \((1-p)\), respectivamente, la desviación estándar es:

\[\mid b - a \mid \sqrt{p(1-p)}.\]

Entonces en nuestro ejemplo de ruleta, la desviación estándar de los valores dentro de la urna es: \(\mid 1 - (-1) \mid \sqrt{10/19 \times 9/19}\) o:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{90}\NormalTok{)}\SpecialCharTok{/}\DecValTok{19}
\CommentTok{\#\textgreater{} [1] 0.999}
\end{Highlighting}
\end{Shaded}

El error estándar nos dice la diferencia típica entre una variable aleatoria y su expectativa. Dado que un sorteo es obviamente la suma de un solo sorteo, podemos usar la fórmula anterior para calcular que la variable aleatoria definida por un sorteo tiene un valor esperado de 0.05 y un error estándar de aproximadamente 1. Esto tiene sentido ya que obtenemos 1 o -1, con 1 ligeramente favorecido sobre -1.

Usando la fórmula anterior, la suma de 1,000 personas jugando tiene un error estándar de aproximadamente \$32:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\FunctionTok{sqrt}\NormalTok{(n) }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{90}\NormalTok{)}\SpecialCharTok{/}\DecValTok{19}
\CommentTok{\#\textgreater{} [1] 31.6}
\end{Highlighting}
\end{Shaded}

Como resultado, cuando 1,000 personas apuestan al rojo, se espera que el casino gane \$50 con un error estándar de \$32. Por lo tanto, parece una apuesta segura. Pero aún no hemos respondido a la pregunta: ¿qué probabilidades hay de perder dinero? Aquí el CLT nos ayudará.

\textbf{Nota avanzada}: Antes de continuar, debemos señalar que los cálculos exactos de probabilidad de las ganancias del casino se pueden realizar con la distribución binomial. Sin embargo, aquí nos enfocamos en el CLT, que generalmente se puede aplicar a sumas de variables aleatorias, algo que no se puede hacer con la distribución binomial.

\hypertarget{poblaciuxf3n-sd-versus-la-muestra-sd}{%
\subsection{Población SD versus la muestra SD}\label{poblaciuxf3n-sd-versus-la-muestra-sd}}

La desviación estándar (SD) de una lista \texttt{x} (a continuación usamos alturas como ejemplo) se define como la raíz cuadrada del promedio de las diferencias cuadradas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height}
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((x}\SpecialCharTok{{-}}\NormalTok{m)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Usando notación matemática escribimos:

\[
\mu = \frac{1}{n} \sum_{i=1}^n x_i \\
\sigma = \sqrt{\frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2}
\]

Sin embargo, tengan en cuenta que la función \texttt{sd} devuelve un resultado ligeramente diferente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{identical}\NormalTok{(s, }\FunctionTok{sd}\NormalTok{(x))}
\CommentTok{\#\textgreater{} [1] FALSE}
\NormalTok{s}\SpecialCharTok{{-}}\FunctionTok{sd}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] {-}0.00194}
\end{Highlighting}
\end{Shaded}

Esto es porque la función \texttt{sd} en R no devuelve el \texttt{sd} de la lista, sino que utiliza una fórmula que estima las desviaciones estándar de la población usando una muestra aleatoria \(X_1, \dots, X_N\) que, por razones no discutidas aquí, divide la suma de cuadrados por \(N-1\).

\[
\bar{X} = \frac{1}{N} \sum_{i=1}^N X_i, \,\,\,\,
s = \sqrt{\frac{1}{N-1} \sum_{i=1}^N (X_i - \bar{X})^2}
\]

Pueden ver que este es el caso escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{s}\SpecialCharTok{{-}}\FunctionTok{sd}\NormalTok{(x)}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{((n}\DecValTok{{-}1}\NormalTok{)}\SpecialCharTok{/}\NormalTok{ n)}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

Para toda la teoría discutida aquí, deben calcular la desviación estándar real como se define:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((x}\SpecialCharTok{{-}}\NormalTok{m)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Así que tengan cuidado al usar la función \texttt{sd} en R. Sin embargo, tengan en cuenta que a lo largo del libro a veces usamos la función \texttt{sd} cuando realmente queremos la SD real. Esto se debe a que cuando el tamaño de la lista es grande, estos dos son prácticamente equivalentes ya que \(\sqrt{(N-1)/N} \approx 1\).

\hypertarget{teorema-del-luxedmite-central}{%
\section{Teorema del límite central}\label{teorema-del-luxedmite-central}}

El teorema del límite central (CLT) nos dice que cuando el número de sorteos, también llamado \emph{tamaño de muestra}, es grande, la distribución de probabilidad de la suma de los sorteos independientes es aproximadamente normal. Debido a que los modelos de muestreo se utilizan para tantos procesos de generación de datos, el CLT se considera una de las ideas matemáticas más importantes de la historia.

Anteriormente, discutimos que si sabemos que la distribución de una lista de números se aproxima a la distribución normal, lo único que necesitamos para describir la lista es el promedio y la desviación estándar. También sabemos que lo mismo se aplica a las distribuciones de probabilidad. Si una variable aleatoria tiene una distribución de probabilidad que se aproxima a la distribución normal, entonces todo lo que necesitamos para describir la distribución de probabilidad son el promedio y la desviación estándar, lo que se conoce como el valor esperado y el error estándar.

Anteriormente ejecutamos esta simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{roulette\_winnings }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
  \FunctionTok{sum}\NormalTok{(X)}
\NormalTok{\}}
\NormalTok{S }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, }\FunctionTok{roulette\_winnings}\NormalTok{(n))}
\end{Highlighting}
\end{Shaded}

El CLT nos dice que la suma \(S\) se aproxima por una distribución normal. Usando las fórmulas anteriores, sabemos que el valor esperado y el error estándar son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{20{-}18}\NormalTok{)}\SpecialCharTok{/}\DecValTok{38}
\CommentTok{\#\textgreater{} [1] 52.6}
\FunctionTok{sqrt}\NormalTok{(n) }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{90}\NormalTok{)}\SpecialCharTok{/}\DecValTok{19}
\CommentTok{\#\textgreater{} [1] 31.6}
\end{Highlighting}
\end{Shaded}

Los valores teóricos anteriores coinciden con los obtenidos con la simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(S)}
\CommentTok{\#\textgreater{} [1] 52.2}
\FunctionTok{sd}\NormalTok{(S)}
\CommentTok{\#\textgreater{} [1] 31.7}
\end{Highlighting}
\end{Shaded}

Usando el CLT, podemos omitir la simulación Monte Carlo y en su lugar calcular la probabilidad de que el casino pierda dinero usando esta aproximación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}}\NormalTok{ n }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{20{-}18}\NormalTok{)}\SpecialCharTok{/}\DecValTok{38}
\NormalTok{se }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(n) }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{90}\NormalTok{)}\SpecialCharTok{/}\DecValTok{19}
\FunctionTok{pnorm}\NormalTok{(}\DecValTok{0}\NormalTok{, mu, se)}
\CommentTok{\#\textgreater{} [1] 0.0478}
\end{Highlighting}
\end{Shaded}

que también concuerda muy bien con nuestro resultado de la simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(S }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0458}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuuxe1n-grande-es-grande-en-el-teorema-del-luxedmite-central}{%
\subsection{¿Cuán grande es grande en el teorema del límite central?}\label{cuuxe1n-grande-es-grande-en-el-teorema-del-luxedmite-central}}

El CLT funciona cuando el número de sorteos es grande. Pero grande es un término relativo. En muchas circunstancias, solo 30 sorteos son suficientes para que el CLT sea útil. En algunos casos específicos, solo 10 son suficientes. Sin embargo, estas no deben considerarse reglas generales. Por ejemplo, cuando la probabilidad de éxito es muy pequeña, necesitamos tamaños de muestra mucho más grandes.

A modo de ilustración, consideremos la lotería. En la lotería, la probabilidad de ganar son menos de 1 en un millón. Miles de personas juegan, por lo que el número de sorteos es muy grande. Sin embargo, el número de ganadores, la suma de los sorteos, oscila entre 0 y 4. La distribución normal no es una buena aproximación de la suma, por lo cual el CLT no aplica, incluso cuando el tamaño de la muestra es muy grande. Esto es generalmente cierto cuando la probabilidad de éxito es muy baja. En estos casos, la distribución de Poisson es más apropiada.

Pueden examinar las propiedades de la distribución de Poisson usando \texttt{dpois} y \texttt{ppois}. Pueden generar variables aleatorias siguiendo esta distribución con \texttt{rpois}. Sin embargo, no discutimos la teoría aquí. Para aprender más sobre la distribución de Poisson, pueden consultar cualquier libro de texto de probabilidad e incluso Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=Poisson_distribution}}

\hypertarget{propiedades-estaduxedsticas-de-promedios}{%
\section{Propiedades estadísticas de promedios}\label{propiedades-estaduxedsticas-de-promedios}}

Hay varios resultados matemáticos útiles que usamos anteriormente y que a menudo empleamos al trabajar con datos. Los enumeramos a continuación.

1. El valor esperado de la suma de variables aleatorias es la suma del valor esperado de cada variable aleatoria. Podemos escribirlo así:

\[
\mbox{E}[X_1+X_2+\dots+X_n] = \mbox{E}[X_1] + \mbox{E}[X_2]+\dots+\mbox{E}[X_n]
\]

Si los \(X\) son sorteos independientes de la urna, entonces todos tienen el mismo valor esperado. Vamos a llamarlo \(\mu\) y por ende:

\[
\mbox{E}[X_1+X_2+\dots+X_n]= n\mu
\]

que es otra forma de escribir el resultado que mostramos arriba para la suma de los sorteos.

2. El valor esperado de una constante no aleatoria multiplicada por una variable aleatoria es la constante no aleatoria multiplicada por el valor esperado de una variable aleatoria. Esto es más fácil de explicar con símbolos:

\[
\mbox{E}[aX] = a\times\mbox{E}[X]
\]

Para ver por qué esto es intuitivo, consideren el cambio de unidades. Si cambiamos las unidades de una variable aleatoria, digamos de dólares a centavos, la expectativa debería cambiar de la misma manera. Una consecuencia de los dos hechos anteriores es que el valor esperado del promedio de extracciones independientes de la misma urna es el valor esperado de la urna, llámelo \(\mu\) de nuevo:

\[
\mbox{E}[(X_1+X_2+\dots+X_n)/ n]= \mbox{E}[X_1+X_2+\dots+X_n]/ n = n\mu/n = \mu
\]

3. El cuadrado del error estándar de la suma de variables aleatorias \textbf{independientes} es la suma del cuadrado del error estándar de cada variable aleatoria. Esto es más fácil de entender en forma matemática:

\[
\mbox{SE}[X_1+X_2+\dots+X_n] = \sqrt{\mbox{SE}[X_1]^2 + \mbox{SE}[X_2]^2+\dots+\mbox{SE}[X_n]^2 }
\]

El cuadrado del error estándar se denomina \emph{varianza} en los libros de texto estadísticos. Tengan en cuenta que esta propiedad en particular no es tan intuitiva como las dos anteriores y que pueden encontrar explicaciones detalladas en los libros de texto de estadísticas.

4. El error estándar de una constante no aleatoria multiplicada por una variable aleatoria es la constante no aleatoria multiplicada por el error estándar de la variable aleatoria. Igual que para el valor esperado:
\[
\mbox{SE}[aX] = a \times \mbox{SE}[X]
\]

Para ver por qué esto es intuitivo, piensen nuevamente en las unidades.

Una consecuencia de 3 y 4 es que el error estándar del promedio de sorteos independientes de la misma urna es la desviación estándar de la urna dividida por la raíz cuadrada de \(n\) (el número de sorteos), llámenlo \(\sigma\):

\[
\begin{aligned}
\mbox{SE}[(X_1+X_2+\dots+X_n)/ n] &= \mbox{SE}[X_1+X_2+\dots+X_n]/n \\
&= \sqrt{\mbox{SE}[X_1]^2+\mbox{SE}[X_2]^2+\dots+\mbox{SE}[X_n]^2}/n \\
&= \sqrt{\sigma^2+\sigma^2+\dots+\sigma^2}/n\\
&= \sqrt{n\sigma^2}/n\\
&= \sigma/ \sqrt{n}
\end{aligned}
\]

5. Si \(X\) es una variable aleatoria normalmente distribuida, entonces si \(a\) y \(b\) son constantes no aleatorias, \(aX + b\) también es una variable aleatoria normalmente distribuida. Lo único que estamos haciendo es cambiando las unidades de la variable aleatoria multiplicando por \(a\) y entonces desplazando el centro por \(b\).

Recuerden que los libros de texto de estadísticas usan las letras griegas \(\mu\) y \(\sigma\) para denotar el valor esperado y el error estándar, respectivamente. Esto es porque \(\mu\) es la letra griega para \(m\), la primera letra de \emph{mean}, que es otro término utilizado para el valor esperado. Asimismo, \(\sigma\) es la letra griega para \(s\), la primera letra de \emph{standard error}.

\hypertarget{ley-de-los-grandes-nuxfameros}{%
\section{Ley de los grandes números}\label{ley-de-los-grandes-nuxfameros}}

Una implicación importante del resultado final es que el error estándar del promedio se vuelve más y más pequeño a medida que \(n\) se hace más grande. Cuando \(n\) es muy grande, entonces el error estándar es prácticamente 0 y el promedio de los sorteos converge al promedio de la urna. Esto se conoce en los libros de texto estadísticos como la ley de los grandes números o la ley de los promedios.

\hypertarget{malinterpretando-la-ley-de-promedios}{%
\subsection{Malinterpretando la ley de promedios}\label{malinterpretando-la-ley-de-promedios}}

La ley de los promedios a veces se malinterpreta. Por ejemplo, si tiran una moneda 5 veces y sale cara cada vez, es posible que alguien argumente que el próximo lanzamiento probablemente sea cruz debido a la ley de los promedios: en promedio, deberíamos ver 50\% cara y 50\% cruz. Un argumento similar sería decir que ``le toca'' al rojo en la rueda de la ruleta después de ver que el negro aparece cinco veces corridos. Estos eventos son independientes, por lo que la probabilidad de que una moneda salga cara es 50\% independientemente de los 5 resultados anteriores. Este también es el caso del resultado de la ruleta. La ley de promedios se aplica solo cuando el número de sorteos es muy grande y no en muestras pequeñas. Después de un millón de lanzamientos, definitivamente verán alrededor del 50\% caras independientemente del resultado de los primeros cinco lanzamientos.

Otro mal uso interesante de la ley de los promedios es en los deportes cuando los presentadores de televisión predicen que un jugador está a punto de triunfar porque ha fallado varias veces seguidas.

\hypertarget{ejercicios-24}{%
\section{Ejercicios}\label{ejercicios-24}}

1. En la ruleta americana también se puede apostar al verde. Hay 18 rojos, 18 negros y 2 verdes (0 y 00). ¿Cuáles son las probabilidades de que salga un verde?

2. El pago por ganar en verde es \$17. Esto significa que si apuesta un dólar y cae en verde, obtiene \$17. Cree un modelo de muestreo usando una muestra para simular la variable aleatoria \(X\) de sus ganancias. Sugerencia: vea el ejemplo a continuación del código para apostar en rojo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{), }\DecValTok{1}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{9}\SpecialCharTok{/}\DecValTok{19}\NormalTok{, }\DecValTok{10}\SpecialCharTok{/}\DecValTok{19}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

3. ¿Cuál es el valor esperado de \(X\)?

4. ¿Cuál es el error estándar de \(X\)?

5. Ahora cree una variable aleatoria \(S\) que es la suma de sus ganancias después de apostar en verde 1,000 veces. Sugerencia: cambie los argumentos \texttt{size} y \texttt{replace} en su respuesta a la pregunta 2. Comience su código fijando la semilla en 1 con \texttt{set.seed(1)}.

6. ¿Cuál es el valor esperado de \(S\)?

7. ¿Cuál es el error estándar de \(S\)?

8. ¿Cuál es la probabilidad de que termine ganando dinero? Sugerencia: use el CLT.

9. Cree una simulación Monte Carlo que genere 1,000 resultados de \(S\). Calcule el promedio y la desviación estándar de la lista resultante para confirmar los resultados de 6 y 7. Comience su código fijando la semilla en 1 con \texttt{set.seed(1)}.

10. Ahora verifique su respuesta a la pregunta 8 usando el resultado de la simulación Monte Carlo.

11. El resultado de la simulación Monte Carlo y la aproximación CLT están cerca, pero no tan cerca. ¿Qué podría explicar esto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  1,000 simulaciones no son suficientes. Si hacemos más, coinciden.
\item
  El CLT no funciona tan bien cuando la probabilidad de éxito es pequeña. En este caso, fue 1/19. Si hacemos que el número de juegos de ruleta sea mayor, coincidirán mejor.
\item
  La diferencia está dentro del error de redondeo.
\item
  El CLT solo funciona para promedios.
\end{enumerate}

12. Ahora cree una variable aleatoria \(Y\) que sea su promedio de ganancias por apuesta tras apostar al verde 1,000 veces.

13. ¿Cuál es el valor esperado de \(Y\)?

14. ¿Cuál es el error estándar de \(Y\)?

15. ¿Cuál es la probabilidad de que cuando acabe de jugar, las ganancias por juego sean positivas? Sugerencia: use el CLT.

16. Cree una simulación Monte Carlo que genere 2,500 resultados de \(Y\). Calcule el promedio y la desviación estándar de la lista resultante para confirmar los resultados de 6 y 7. Comience su código fijando la semilla en 1 con \texttt{set.seed(1)}.

17. Ahora verifique su respuesta a 8 usando el resultado de la simulación Monte Carlo.

18. El resultado de la simulación Monte Carlo y la aproximación CLT ahora están mucho más cerca. ¿Qué podría explicar esto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Ahora estamos calculando promedios en lugar de sumas.
\item
  2,500 simulaciones de Monte Carlo no son mejores que 1,000.
\item
  El CLT funciona mejor cuando el tamaño de la muestra es mayor. Aumentamos de 1,000 a 2,500.
\item
  No está más cerca. La diferencia está dentro del error de redondeo.
\end{enumerate}

\hypertarget{estudio-de-caso-the-big-short}{%
\section{\texorpdfstring{Estudio de caso: \emph{The Big Short}}{Estudio de caso: The Big Short}}\label{estudio-de-caso-the-big-short}}

\hypertarget{tasas-de-interuxe9s-explicadas-con-modelo-de-oportunidad}{%
\subsection{Tasas de interés explicadas con modelo de oportunidad}\label{tasas-de-interuxe9s-explicadas-con-modelo-de-oportunidad}}

Los bancos también usan versiones más complejas de los modelos de muestreo que hemos discutido para determinar sus tasas de interés. Supongan que compran un banco pequeño que tiene un historial de identificar posibles propietarios de viviendas en los que se pueden confiar para realizar pagos. De hecho, históricamente, en un año determinado, solo el 2\% de sus clientes no pagan el dinero que se les prestó. Sin embargo, el banco sabe que si simplemente le prestan dinero a todos sus clientes sin intereses, terminará perdiendo dinero debido a este 2\%. Aunque el banco sabe que el 2\% de sus clientes probablemente no pagarán, no sabe cuáles son esos. Pero al cobrarles a todos un poco más en intereses, pueden compensar las pérdidas incurridas debido a ese 2\% y también cubrir sus costos operativos. También pueden obtener ganancias, aunque si establecen tasas de interés demasiado altas, los clientes se irán a otro banco. Utilizaremos todos estos hechos y un poco de teoría de probabilidad para determinar qué tasa de interés deben cobrar.

Supongan que su banco otorgará 1,000 préstamos de \$180,000 este año. Además, tras sumar todos los costos, supongan que su banco pierde \$200,000 por ejecución hipotecaria. Para simplificar, suponemos que esto incluye todos los costos operativos. Un modelo de muestreo para este escenario puede codificarse así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{loss\_per\_foreclosure }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{200000}
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.02}
\NormalTok{defaults }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{( }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{sum}\NormalTok{(defaults }\SpecialCharTok{*}\NormalTok{ loss\_per\_foreclosure)}
\CommentTok{\#\textgreater{} [1] {-}5800000}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que la pérdida total definida por la suma final es una variable aleatoria. Cada vez que ejecutan el código anterior, obtienen una respuesta diferente. Podemos construir fácilmente una simulación Monte Carlo para tener una idea de la distribución de esta variable aleatoria.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{losses }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  defaults }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{( }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), n, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(defaults }\SpecialCharTok{*}\NormalTok{ loss\_per\_foreclosure)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Realmente no necesitamos una simulación Monte Carlo. Usando lo que hemos aprendido, el CLT nos dice que, debido a que las pérdidas son una suma de sorteos independientes, su distribución es aproximadamente normal con el valor esperado y los errores estándar dados por:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\SpecialCharTok{*}\NormalTok{(p}\SpecialCharTok{*}\NormalTok{loss\_per\_foreclosure }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)}\SpecialCharTok{*}\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] {-}4e+06}
\FunctionTok{sqrt}\NormalTok{(n)}\SpecialCharTok{*}\FunctionTok{abs}\NormalTok{(loss\_per\_foreclosure)}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{(p}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}
\CommentTok{\#\textgreater{} [1] 885438}
\end{Highlighting}
\end{Shaded}

Ahora podemos establecer una tasa de interés para garantizar que, como promedio, lleguen a un punto de equilibrio. Básicamente, necesitan añadir una cantidad \(x\) a cada préstamo, que en este caso están representados por sorteos, de modo que el valor esperado sea 0. Si definen \(l\) para ser la pérdida por ejecución hipotecaria, necesitan:

\[
lp + x(1-p) = 0
\]

que implica \(x\) es:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{{-}}\NormalTok{ loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p}\SpecialCharTok{/}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)}
\CommentTok{\#\textgreater{} [1] 4082}
\end{Highlighting}
\end{Shaded}

o una tasa de interés de 0.023.

Sin embargo, todavía tenemos un problema. Aunque esta tasa de interés garantiza que, como promedio, lleguen a un punto de equilibrio, existe una probabilidad del 50\% de que pierdan dinero. Si su banco pierde dinero, tendrán que cerrarlo. Por lo tanto, deben elegir una tasa de interés que los protega de esto. Al mismo tiempo, si la tasa de interés es demasiado alta, sus clientes se irán a otro banco, por lo que deben estar dispuestos a asumir algunos riesgos. Entonces, digamos que quieren que sus probabilidades de perder dinero sean de 1 en 100, entonces ¿qué cantidad debe ser \(x\) ahora? Esto es un poco más difícil. Queremos que la suma \(S\) tenga:

\[\mbox{Pr}(S<0) = 0.01\]

Sabemos que \(S\) es aproximadamente normal. El valor esperado de \(S\) es:

\[\mbox{E}[S] = \{ lp + x(1-p)\}n\]

con \(n\) el número de selecciones, que en este caso representa préstamos. El error estándar es:

\[\mbox{SD}[S] = |x-l| \sqrt{np(1-p)}.\]

Porque \(x\) es positivo y \(l\) negativo \(|x-l|=x-l\). Recuerden que estas son solo una aplicación de las fórmulas mostradas anteriormente, pero que usan símbolos más compactos.

Ahora vamos a utilizar un ``truco'' matemático que es muy común en las estadísticas. Sumamos y restamos las mismas cantidades a ambos lados del evento \(S<0\) para que la probabilidad no cambie y terminemos con una variable aleatoria con distribución normal unitaria a la izquierda, que luego nos permitirá escribir una ecuación con solo \(x\) como un desconocido. Este ``truco'' es el siguiente:

Si \(\mbox{Pr}(S<0) = 0.01\), entonces:

\[
\mbox{Pr}\left(\frac{S - \mbox{E}[S]}{\mbox{SE}[S]} < \frac{ - \mbox{E}[S]}{\mbox{SE}[S]}\right)
\]
Y recuerden que \(\mbox{E}[S]\) y \(\mbox{SE}[S]\) son el valor esperado y el error estándar de \(S\), respectivamente. Lo único que hicimos arriba fue sumar y dividir por la misma cantidad en ambos lados. Hicimos esto porque ahora el término de la izquierda es una variable aleatoria con distribución normal unitaria, a la que le cambiaremos el nombre a \(Z\).
Ahora completamos los espacios en blanco con la fórmula actual para el valor esperado y el error estándar:

\[
\mbox{Pr}\left(Z < \frac{- \{ lp + x(1-p)\}n}{(x-l) \sqrt{np(1-p)}}\right) = 0.01
\]

Puede parecer complicado, pero recuerden que \(l\), \(p\) y \(n\) son todas cantidades conocidas, por lo que eventualmente las reemplazaremos con números.

Ahora, como \(Z\) es una variable aleatorea normal con valor esperado 0 y error estándar 1, significa que la cantidad en el lado derecho del signo \textless{} debe ser igual a:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.01}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] {-}2.33}
\end{Highlighting}
\end{Shaded}

para que la ecuación sea cierta. Recuerden que \(z=\) \texttt{qnorm(0.01)} nos da el valor de \(z\) para cual:

\[
\mbox{Pr}(Z \leq z) = 0.01
\]

Esto significa que el lado derecho de la ecuación complicada debe ser \(z\)=\texttt{qnorm(0.01)}:

\[
\frac{- \{ lp + x(1-p)\}n} {(x-l) \sqrt{n p (1-p)}} = z
\]

El truco funciona porque terminamos con una expresión que contiene \(x\), que sabemos que tiene que ser igual a una cantidad conocida \(z\). Ahora, resolver para \(x\) es simplemente álgebra:

\[ x = - l \frac{ np - z \sqrt{np(1-p)}}{n(1-p) + z \sqrt{np(1-p)}}\]

que es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l }\OtherTok{\textless{}{-}}\NormalTok{ loss\_per\_foreclosure}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.01}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\NormalTok{l}\SpecialCharTok{*}\NormalTok{( n}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{{-}}\NormalTok{ z}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{(n}\SpecialCharTok{*}\NormalTok{p}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)))}\SpecialCharTok{/}\NormalTok{ ( n}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p) }\SpecialCharTok{+}\NormalTok{ z}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{(n}\SpecialCharTok{*}\NormalTok{p}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)))}
\NormalTok{x}
\CommentTok{\#\textgreater{} [1] 6249}
\end{Highlighting}
\end{Shaded}

Su tasa de interés ahora sube a 0.035. Esta sigue siendo una tasa de interés muy competitiva. Al elegir esa tasa de interés, ahora tendrán una ganancia esperada por préstamo de:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{+}\NormalTok{ x}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)}
\CommentTok{\#\textgreater{} [1] 2124}
\end{Highlighting}
\end{Shaded}

que es una ganancia total esperada de aproximadamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\SpecialCharTok{*}\NormalTok{(loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{+}\NormalTok{ x}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}
\CommentTok{\#\textgreater{} [1] 2124198}
\end{Highlighting}
\end{Shaded}

dolares!

Podemos ejecutar una simulación Monte Carlo para verificar nuestras aproximaciones teóricas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{100000}
\NormalTok{profit }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  draws }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{( }\FunctionTok{c}\NormalTok{(x, loss\_per\_foreclosure), n,}
                   \AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(draws)}
\NormalTok{\})}
\FunctionTok{mean}\NormalTok{(profit)}
\CommentTok{\#\textgreater{} [1] 2125441}
\FunctionTok{mean}\NormalTok{(profit}\SpecialCharTok{\textless{}}\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0133}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-big-short}{%
\subsection{\texorpdfstring{\emph{The Big Short}}{The Big Short}}\label{the-big-short}}

Uno de sus empleados señala que, dado que el banco está ganando 2,124 dólares por préstamo, ¡el banco debería otorgar más préstamos! ¿Por qué solo \(n\)? Ustedes explican que encontrar esos \(n\) clientes fue difícil. Necesitan un grupo que sea predecible y que mantenga bajas las probabilidades de incumplimiento. Su empleado entonces señala que aún si la probabilidad de incumplimiento es mayor, siempre que el valor esperado sea positivo, el banco puede minimizar sus probabilidades de pérdidas al aumentar \(n\) y confiar en la ley de grandes números.

Su empleado además afirma que incluso si la tasa predeterminada es el doble, digamos 4\%, si establecen la tasa un poco más alta que este valor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.04}
\NormalTok{r }\OtherTok{\textless{}{-}}\NormalTok{ (}\SpecialCharTok{{-}}\NormalTok{ loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p}\SpecialCharTok{/}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}\SpecialCharTok{/} \DecValTok{180000}
\NormalTok{r}
\CommentTok{\#\textgreater{} [1] 0.0463}
\end{Highlighting}
\end{Shaded}

el banco se beneficiará. Al 5\%, se garantizan un valor positivo esperado de:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r }\OtherTok{\textless{}{-}} \FloatTok{0.05}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ r}\SpecialCharTok{*}\DecValTok{180000}
\NormalTok{loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{+}\NormalTok{ x }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)}
\CommentTok{\#\textgreater{} [1] 640}
\end{Highlighting}
\end{Shaded}

y pueden minimizar sus probabilidades de perder dinero simplemente aumentando \(n\) ya que:

\[
\mbox{Pr}(S < 0) =
\mbox{Pr}\left(Z < - \frac{\mbox{E}[S]}{\mbox{SE}[S]}\right)
\]
con \(Z\) una variable aleatoria con distribución normal unitaria como se muestra anteriormente. Si definimos \(\mu\) y \(\sigma\) como el valor esperado y la desviación estándar, respectivamente, de la urna (es decir, de un solo préstamo), usando las fórmulas anteriores tenemos: \(\mbox{E}[S]= n\mu\) y \(\mbox{SE}[S]= \sqrt{n}\sigma\). Entonces, si definimos \(z\)=\texttt{qnorm(0.01)}, tenemos:
\[
- \frac{n\mu}{\sqrt{n}\sigma} = - \frac{\sqrt{n}\mu}{\sigma} = z
\]
lo que implica que si dejamos:

\[
n \geq z^2 \sigma^2/ \mu^2
\]
tenemos garantizada una probabilidad de menos de 0.01. La implicación es que, siempre y cuando \(\mu\) sea positivo, podemos encontrar una \(n\) que minimiza la probabilidad de una pérdida. Esta es una versión de la ley de los grandes números: cuando \(n\) es grande, nuestras ganancias promedio por préstamo convergen a la ganancia esperada \(\mu\).

Con \(x\) fijo, ahora podemos preguntar ¿qué \(n\) necesitamos para que la probabilidad sea 0.01? En nuestro ejemplo, si reparten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.01}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{ceiling}\NormalTok{((z}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{*}\NormalTok{(x}\SpecialCharTok{{-}}\NormalTok{l)}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{*}\NormalTok{p}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}\SpecialCharTok{/}\NormalTok{(l}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{+}\NormalTok{ x}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\NormalTok{n}
\CommentTok{\#\textgreater{} [1] 22163}
\end{Highlighting}
\end{Shaded}

préstamos, la probabilidad de perder es de aproximadamente 0.01 y se espera que ganen un total de:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\SpecialCharTok{*}\NormalTok{(loss\_per\_foreclosure}\SpecialCharTok{*}\NormalTok{p }\SpecialCharTok{+}\NormalTok{ x }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}
\CommentTok{\#\textgreater{} [1] 14184320}
\end{Highlighting}
\end{Shaded}

dolares! Podemos confirmar esto con una simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.04}
\NormalTok{x }\OtherTok{\textless{}{-}} \FloatTok{0.05}\SpecialCharTok{*}\DecValTok{180000}
\NormalTok{profit }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  draws }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{( }\FunctionTok{c}\NormalTok{(x, loss\_per\_foreclosure), n,}
                   \AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(draws)}
\NormalTok{\})}
\FunctionTok{mean}\NormalTok{(profit)}
\CommentTok{\#\textgreater{} [1] 14205099}
\end{Highlighting}
\end{Shaded}

Entonces esto parece ser una decisión obvia. Como resultado, su empleado decide abandonar el banco y comenzar su propia compañía hipotecaria de préstamos de alto riesgo. Unos meses después, el banco de su ex-empleado se declara en quiebra. Se escribe un libro y eventualmente se hace una película relatando el error que cometió su empleado y muchos otros. ¿Que pasó?

El esquema de su ex-empleado se basó principalmente en esta fórmula matemática:
\[
\mbox{SE}[(X_1+X_2+\dots+X_n)/ n] = \sigma/ \sqrt{n}
\]

Al hacer \(n\) grande, minimizan el error estándar de su ganancia por préstamo. Sin embargo, para que esta regla se cumpla, las \(X\)s deben ser eventos independientes: el incumplimiento de una persona debe ser independiente del incumplimiento de otros. Tengan en cuenta que en el caso de promediar el \textbf{mismo} evento una y otra vez, un ejemplo extremo de eventos que no son independientes, obtenemos un error estándar que es \(\sqrt{n}\) veces más grande:
\[
\mbox{SE}[(X_1+X_1+\dots+X_1)/ n] = \mbox{SE}[n X_1/ n] = \sigma > \sigma/ \sqrt{n}
\]

Para construir una simulación más realista que la original que ejecutó su ex-empleado, supongan que hay un evento global que afecta a todas las personas con hipotecas de alto riesgo y cambia su probabilidad. Suponemos que con una probabilidad de 50-50, todas las probabilidades suben o bajan ligeramente a algún lugar entre 0.03 y 0.05. Pero le sucede a todos a la vez, no solo a una persona. Estos eventos ya no son independientes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.04}
\NormalTok{x }\OtherTok{\textless{}{-}} \FloatTok{0.05}\SpecialCharTok{*}\DecValTok{180000}
\NormalTok{profit }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  new\_p }\OtherTok{\textless{}{-}} \FloatTok{0.04} \SpecialCharTok{+} \FunctionTok{sample}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.01}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\AttributeTok{length =} \DecValTok{100}\NormalTok{), }\DecValTok{1}\NormalTok{)}
\NormalTok{  draws }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{( }\FunctionTok{c}\NormalTok{(x, loss\_per\_foreclosure), n,}
                   \AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{new\_p, new\_p), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(draws)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Noten que la ganancia esperada sigue siendo grande:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(profit)}
\CommentTok{\#\textgreater{} [1] 14353079}
\end{Highlighting}
\end{Shaded}

Sin embargo, la probabilidad de que el banco tenga ganancias negativas se dispara a:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(profit}\SpecialCharTok{\textless{}}\DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.345}
\end{Highlighting}
\end{Shaded}

Aún más preocupante es que la probabilidad de perder más de 10 millones de dólares es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(profit }\SpecialCharTok{\textless{}} \SpecialCharTok{{-}}\DecValTok{10000000}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.238}
\end{Highlighting}
\end{Shaded}

Para entender cómo sucede esto, miren la distribución:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{profit\_in\_millions=}\NormalTok{profit}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(profit\_in\_millions)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{color=}\StringTok{"black"}\NormalTok{, }\AttributeTok{binwidth =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/profit-distribution-1} \end{center}

La teoría se rompe por completo y la variable aleatoria tiene mucha más variabilidad de lo esperado. El colapso financiero de 2007 se debió, entre otras cosas, a los ``expertos'' financieros que presumieron independencia cuando tal no era el caso.

\hypertarget{ejercicios-25}{%
\section{Ejercicios}\label{ejercicios-25}}

1. Cree una variable aleatoria \(S\) con las ganancias de su banco si otorga 10,000 préstamos, la tasa de incumplimiento es 0.3 y pierde \$200,000 en cada ejecución hipotecaria. Sugerencia: use el código que mostramos en la sección anterior, pero cambie los parámetros.

2. Ejecute una simulación Monte Carlo con 10,000 resultados para \(S\). Haga un histograma de los resultados.

3. ¿Cuál es el valor esperado de \(S\)?

4. ¿Cuál es el error estándar de \(S\)?

5. Supongan que otorgamos préstamos de \$180,000. ¿Cuál debería ser la tasa de interés para que nuestro valor esperado sea 0?

6. (Más difícil) ¿Cuál debería ser la tasa de interés para que la probabilidad de perder dinero sea 1 en 20? En notación matemática, ¿cuál debería ser la tasa de interés para que \(\mbox{Pr}(S<0) = 0.05\)?

7. Si el banco quiere minimizar las probabilidades de perder dinero, ¿cuál de las siguientes opciones \textbf{no} hace que suban las tasas de interés?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Un grupo más pequeño de préstamos.
\item
  Una mayor probabilidad de incumplimiento.
\item
  Una menor probabilidad requerida de perder dinero.
\item
  El número de simulaciones Monte Carlo.
\end{enumerate}

\hypertarget{inference}{%
\chapter{Inferencia estadística}\label{inference}}

En el Capítulo \ref{models}, describiremos, con cierto detalle, cómo los agregadores de encuestas, como FiveThirtyEight, usan los datos para predecir los resultados de las elecciones. Para entender cómo lo hacen, primero debemos aprender los conceptos básicos de la \emph{inferencia estadística}, la parte de la estadística que ayuda a distinguir los patrones reales de esos que surgen del azar. La inferencia estadística es un tema amplio y aquí repasaremos los conceptos básicos utilizando las encuestas como un ejemplo motivador. Para describir los conceptos, complementamos las fórmulas matemáticas con simulaciones Monte Carlo y el código R.

\hypertarget{encuestas}{%
\section{Encuestas}\label{encuestas}}

Las encuestas de opinión se han llevado a cabo desde el siglo XIX. El objetivo general es describir las opiniones de una población específica sobre un set particular de temas. Recientemente, estas encuestas han sido mas notables durante las elecciones presidenciales en EE.UU. Las encuestas son útiles cuando entrevistar a cada miembro de una población particular es logísticamente imposible. La estrategia general es entrevistar a un grupo más pequeño elegido al azar y luego inferir las opiniones de toda la población a partir de las opiniones del grupo más pequeño. La teoría estadística que se usa para justificar el proceso se conoce como \emph{inferencia} y es el tema principal de este capítulo.

Quizás las encuestas de opinión más conocidas son esas realizadas para determinar el candidato favorito de los votantes en una elección determinada. Los estrategas políticos hacen uso extensivo de las encuestas para decidir, entre otras cosas, cómo invertir recursos. Por ejemplo, es posible que quieran saber en qué regiones geográficas enfocar sus esfuerzos de ``sacar el voto''.

Las elecciones son un caso particularmente interesante de encuestas de opinión porque la opinión real de toda la población se revela el día de las elecciones. Por supuesto, cuesta millones de dólares realizar una elección real, lo que hace que las encuentas sean una estrategia efectiva para aquellos que quieren pronosticar los resultados.

Aunque típicamente los resultados de estas encuestas se mantienen privados, las organizaciones de noticias realizan encuestas similares porque los resultados tienden a ser de interés público y los datos se hacen públicos. Eventualmente estaremos analizando tales datos.

Real Clear Politics\footnote{\url{http://www.realclearpolitics.com}} es un ejemplo de un agregador de noticias que organiza y publica resultados de encuestas. Por ejemplo, presentan los siguientes resultados de las encuestas que ofrecen estimados del voto popular para las elecciones presidenciales del 2016\footnote{\url{http://www.realclearpolitics.com/epolls/2016/president/us/general_election_trump_vs_clinton-5491.html}}:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llllrrl}
\toprule
Poll & Date & Sample & MoE & Clinton & Trump & Spread\\
\midrule
Final Results & -- & -- & -- & 48.2 & 46.1 & Clinton +2.1\\
RCP Average & 11/1 - 11/7 & -- & -- & 46.8 & 43.6 & Clinton +3.2\\
Bloomberg & 11/4 - 11/6 & 799 LV & 3.5 & 46.0 & 43.0 & Clinton +3\\
IBD & 11/4 - 11/7 & 1107 LV & 3.1 & 43.0 & 42.0 & Clinton +1\\
Economist & 11/4 - 11/7 & 3669 LV & -- & 49.0 & 45.0 & Clinton +4\\
\addlinespace
LA Times & 11/1 - 11/7 & 2935 LV & 4.5 & 44.0 & 47.0 & Trump +3\\
ABC & 11/3 - 11/6 & 2220 LV & 2.5 & 49.0 & 46.0 & Clinton +3\\
FOX News & 11/3 - 11/6 & 1295 LV & 2.5 & 48.0 & 44.0 & Clinton +4\\
Monmouth & 11/3 - 11/6 & 748 LV & 3.6 & 50.0 & 44.0 & Clinton +6\\
NBC News & 11/3 - 11/5 & 1282 LV & 2.7 & 48.0 & 43.0 & Clinton +5\\
\addlinespace
CBS News & 11/2 - 11/6 & 1426 LV & 3.0 & 47.0 & 43.0 & Clinton +4\\
Reuters & 11/2 - 11/6 & 2196 LV & 2.3 & 44.0 & 39.0 & Clinton +5\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Aunque en Estados Unidos el voto popular no determina el resultado de las elecciones presidenciales, lo utilizaremos como un ejemplo ilustrativo y sencillo de cuán bien funcionan las encuestas. Pronosticar la elección es un proceso más complejo ya que implica combinar resultados de 50 estados y DC y lo describiremos en la Sección \ref{election-forecasting}.

Por ahora, hagamos algunas observaciones sobre la tabla anterior. Primero, tengan en cuenta que las diferentes encuestas, todas tomadas días antes de las elecciones, informan una \emph{diferencia} (\emph{spread} en inglés) diferente: la diferencia estimada entre el apoyo a los dos candidatos. Observen también que la diferencia indicada ronda en torno a lo que acabó siendo el resultado real: Clinton ganó el voto popular por 2.1\%. También vemos una columna titulada \textbf{MoE} que significa \emph{margen de error} (\emph{margin of error} en inglés).

En esta sección, mostraremos cómo se pueden aplicar los conceptos de probabilidad que aprendimos en capítulos anteriores para desarrollar enfoques estadísticos que hacen de las encuestas una herramienta eficaz. Estudiaremos los conceptos estadísticos necesarios para definir \emph{estimadores} y \emph{márgenes de errores}, y mostraremos cómo podemos usar estos para pronosticar resultados finales relativamente precisos y también proveer un estimador de la precisión de nuestro pronóstico. Una vez que aprendamos esto, podremos entender dos conceptos que son ubicuos en la ciencia de datos: \emph{intervalos de confianza} y \emph{valores-p}. Finalmente, para comprender las declaraciones probabilísticas sobre la probabilidad de que un candidato gane, tendremos que aprender sobre los modelos bayesianos. En las secciones finales, lo reunimos todo para recrear la versión simplificada del modelo de FiveThirtyEight y aplicarlo a las elecciones presidenciales del 2016.

Comenzamos conectando la teoría de probabilidad con la tarea de usar encuestas para aprender sobre una población.

\hypertarget{el-modelo-de-muestreo-para-encuestas}{%
\subsection{El modelo de muestreo para encuestas}\label{el-modelo-de-muestreo-para-encuestas}}

Para ayudarnos a entender la conexión entre las encuestas y lo que hemos aprendido, vamos a construir una situación similar a la que enfrentan los encuestadores. Para imitar el desafío que enfrentan en términos de competir con otros encuestadores para la atención de los medios, utilizaremos una urna llena de cuentas para representar a los votantes y fingiremos que estamos compitiendo por un premio de 25 dólares. El desafío es adivinar la diferencia entre la proporción de cuentas azules y de cuentas rojas en esta urna (en este caso, un frasco de pepinillos):

\begin{center}\includegraphics[width=0.3\linewidth]{inference/img/urn} \end{center}

Antes de hacer una predicción, pueden tomar una muestra (con reemplazo) de la urna. Para imitar el hecho de que realizar encuestas es costoso, les cuesta \$0.10 cada vez que escojen una cuenta. Por lo tanto, si el tamaño de su muestra es 250 y ganan, ni ganarán ni perderán ya que acabarían pagando \$25 por un premio de \$25. Su entrada en la competencia puede ser un intervalo. Si el intervalo que someten contiene la proporción real, obtienen la mitad de lo que pagaron y pasan a la segunda fase de la competencia. En la segunda fase, la entrada con el intervalo más pequeño será la ganadora.

El paquete \textbf{dslabs} incluye una función que muestra un sorteo aleatorio de esta urna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{take\_poll}\NormalTok{(}\DecValTok{25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/first-simulated-poll-1} \end{center}

Piensen en cómo construirían su intervalo según los datos que se muestran arriba.

Acabamos de describir un modelo de muestreo sencillo para encuestas de opinión. Las cuentas dentro de la urna representan a las personas que votarán el día de las elecciones. Los que votarán por el candidato republicano están representados con cuentas rojas y los demócratas con cuentas azules. Para simplificar, suponemos que no hay otros colores. Es decir, que solo hay dos partidos: republicano y demócrata.

\hypertarget{poblaciones-muestras-paruxe1metros-y-estimadores}{%
\section{Poblaciones, muestras, parámetros y estimadores}\label{poblaciones-muestras-paruxe1metros-y-estimadores}}

Queremos predecir la proporción de cuentas azules en la urna. Llamemos a esta cantidad \(p\), que luego nos dice la proporción de cuentas rojas \(1-p\) y la diferencia \(p - (1-p)\), que se simplifica a \(2p - 1\).

En los libros de texto estadísticos, las cuentas en la urna se llaman la \emph{población}. La proporción de cuentas azules en la población \(p\) se llama un \emph{parámetro}. Las 25 cuentas que vemos en el gráfico anterior se llaman la \emph{muestra}. La tarea de la inferencia estadística es predecir el parámetro \(p\) utilizando los datos observados en la muestra.

¿Podemos hacer esto con las 25 observaciones anteriores? Ciertamente es informativo. Por ejemplo, dado que vemos 13 cuentas rojas y 12 azules, es poco probable que \(p\) \textgreater{} .9 o \(p\) \textless.1. ¿Pero estamos listos para predecir con certeza que hay más cuentas rojas que azules en el frasco?

Queremos construir un estimador de \(p\) utilizando solo la información que observamos. Un estimador se debe considerar un resumen de los datos observados que consideramos informativos sobre el parámetro de interés. Parece intuitivo pensar que la proporción de cuentas azules en la muestra \(0.48\) debe estar al menos relacionado con la proporción real \(p\). ¿Pero entonces predecimos que \(p\) es 0.48? Primero, recuerden que la proporción muestral es una variable aleatoria. Si ejecutamos el comando \texttt{take\_poll(25)} cuatro veces, obtenemos una respuesta diferente cada vez, ya que la proporción muestral es una variable aleatoria.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/four-simulated-polls-1} \end{center}

Tengan en cuenta que en las cuatro muestras aleatorias de arriba, las proporciones de la muestra varían de 0.44 a 0.60. Al describir la distribución de esta variable aleatoria, podremos obtener información sobre cuán buena es este estimador y cómo mejorarla.

\hypertarget{el-promedio-de-la-muestra}{%
\subsection{El promedio de la muestra}\label{el-promedio-de-la-muestra}}

La realización de una encuesta de opinión se modela como la toma de una muestra aleatoria de una urna. Estamos proponiendo el uso de la proporción de cuentas azules en nuestra muestra como un estimador del parámetro \(p\). Una vez que tengamos este estimador, podemos reportar fácilmente un estimador para la diferencia \(2p-1\), pero, para simplificar, ilustraremos los conceptos para estimar \(p\). Usaremos nuestro conocimiento de probabilidad para defender nuestro uso de la proporción muestral y cuantificaremos cuán cerca creemos que está de la proporción poblacional \(p\).

Comenzamos definiendo la variable aleatoria \(X\) como: \(X=1\) si elegimos una cuenta azul al azar y \(X=0\) si es roja. Esto implica que la población es una lista de 0s y 1s. Si muestramos \(N\) cuentas, entonces el promedio de los sorteos \(X_1, \dots, X_N\) es equivalente a la proporción de cuentas azules en nuestra muestra. Esto es porque sumar las \(X\)s es equivalente a contar las cuentas azules y dividir esta suma por el total \(N\) a calcular una proporción. Usamos el símbolo \(\bar{X}\) para representar este promedio. En general, en los libros de texto de estadísticas, una barra en la parte superior de un símbolo significa el promedio. La teoría que acabamos de aprender sobre la suma de los sorteos es útil porque el promedio es una suma de sorteos multiplicada por la constante \(1/N\):

\[\bar{X} = 1/N \times \sum_{i=1}^N X_i\]

Para simplificar, supongan que los sorteos son independientes: después de ver cada cuenta muestreada, la devolvemos a la urna. En este caso, ¿qué sabemos sobre la distribución de la suma de los sorteos? Primero, sabemos que el valor esperado de la suma de los sorteos es \(N\) veces el promedio de los valores en la urna. Además, sabemos que el promedio de los 0s y 1s en la urna debe ser \(p\), la proporción de cuentas azules.

Aquí encontramos una diferencia importante con lo que hicimos en el capítulo de probabilidad: no sabemos qué hay en la urna. Sabemos que hay cuentas azules y rojas, pero no sabemos cuántas de cada una. Esto es lo que queremos descubrir: estamos tratando de \textbf{estimar} \(p\).

\hypertarget{paruxe1metros}{%
\subsection{Parámetros}\label{paruxe1metros}}

Al igual que usamos variables para definir las cantidades desconocidas en los sistemas de ecuaciones, en la inferencia estadística definimos \emph{parámetros} para definir los componentes desconocidos de nuestros modelos. En el modelo de urna que estamos utilizando para imitar una encuesta de opinión, no sabemos la proporción de cuentas azules en la urna. Definimos los parametros \(p\) para representar esta cantidad. \(p\) es el promedio de la urna porque si tomamos el promedio de 1s (azul) y 0s (rojo), obtenemos la proporción de cuentas azules. Dado que nuestro objetivo principal es descubrir qué es \(p\), vamos a estimar este parámetro.

Las ideas presentadas aquí sobre cómo estimar los parámetros y proveer información sobre cuán buenos son estos estimadores, se extrapolan a muchas tareas de la ciencia de datos. Por ejemplo, es posible que queramos saber: ¿cuánto más mejora la salud de los pacientes que reciben un tratamiento comparado a un grupo control? Podemos preguntarnos, ¿cuáles son los efectos de fumar en la salud de una población? ¿Cuáles son las diferencias entre grupos raciales de disparos mortales por parte de la policía? ¿Cuál es la tasa de cambio en esperanza de vida en Estados Unidos durante los últimos 10 años? Todas estas preguntas se pueden considerar como una tarea de estimar un parámetro de una muestra.

\hypertarget{encuesta-versus-pronuxf3stico}{%
\subsection{Encuesta versus pronóstico}\label{encuesta-versus-pronuxf3stico}}

Antes de continuar, hagamos una aclaración importante relacionada con el problema práctico de pronosticar las elecciones. Si se realiza una encuesta cuatro meses antes de las elecciones, se estima la \(p\) para ese momento y no para el día de las elecciones. La \(p\) para la noche de las elecciones podría ser diferente ya que las opiniones de las personas fluctúan a través del tiempo. Las encuestas realizadas la noche anterior a las elecciones tienden a ser las más precisas ya que las opiniones no cambian tanto en un día. Sin embargo, los pronosticadores intentan crear herramientas que modelan cómo las opiniones varían a lo largo del tiempo e intentan predecir los resultados de la noche de elecciones tomando en cuenta el hecho de que las opiniones fluctúan. Describiremos algunos enfoques para hacer esto en una sección posterior.

\hypertarget{propiedades-de-nuestro-estimador-valor-esperado-y-error-estuxe1ndar}{%
\subsection{Propiedades de nuestro estimador: valor esperado y error estándar}\label{propiedades-de-nuestro-estimador-valor-esperado-y-error-estuxe1ndar}}

Para comprender cuán bueno es nuestro estimador, describiremos las propiedades estadísticas de la variable aleatoria definida anteriormente: la proporción muestral \(\bar{X}\). Recuerden que \(\bar{X}\) es la suma de los sorteos independientes, por lo que aplican las reglas que cubrimos en el capítulo de probabilidad.

Usando lo que ya hemos aprendido, el valor esperado de la suma \(N\bar{X}\) es \(N \times\) el promedio de la urna, \(p\). Entonces, dividir por la constante no aleatoria \(N\) nos da que el valor esperado del promedio \(\bar{X}\) es \(p\). Podemos escribirlo usando nuestra notación matemática:

\[
\mbox{E}(\bar{X}) = p
\]

También podemos usar lo que aprendimos para determinar el error estándar: el error estándar de la suma es \(\sqrt{N} \times\) la desviación estándar de la urna. ¿Podemos calcular el error estándar de la urna? Aprendimos una fórmula que nos dice que es \((1-0) \sqrt{p (1-p)}\) = \(\sqrt{p (1-p)}\). Como estamos dividiendo la suma por \(N\), llegamos a la siguiente fórmula para el error estándar del promedio:

\[
\mbox{SE}(\bar{X}) = \sqrt{p(1-p)/N}
\]

Este resultado demuestra el poder de las encuestas. El valor esperado de la proporción muestral \(\bar{X}\) es el parámetro de interés \(p\) y podemos hacer que el error estándar sea tan pequeño como queramos aumentando \(N\). La ley de los grandes números nos dice que con una encuesta lo suficientemente grande, nuestra estimación converge a \(p\).

Si realizamos una encuesta lo suficientemente grande como para que nuestro error estándar sea alrededor de 1\%, estaremos bastante seguros de quién ganará. Pero, ¿cuán grande debe ser la encuesta para que el error estándar sea tan pequeño?

Un problema es que no sabemos \(p\), por lo que no podemos calcular el error estándar. Sin embargo, para fines ilustrativos, supongan que \(p=0.51\) y grafiquemos el error estándar versus el tamaño de la muestra \(N\):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/standard-error-versus-sample-size-1} \end{center}

Del gráfico vemos que necesitaríamos una encuesta de más de 10,000 personas para obtener un error estándar tan bajo. Raras veces vemos encuestas de este tamaño debido en parte a los costos. De la tabla de Real Clear Politics, aprendemos que los tamaños de muestra en las encuestas de opinión oscilan entre 500-3,500 personas. Para un tamaño de muestra de 1,000 y \(p=0.51\), el error estándar es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(p}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p))}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(}\DecValTok{1000}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.0158}
\end{Highlighting}
\end{Shaded}

o 1.5 puntos porcentuales. Entonces, incluso con grandes encuestas, para elecciones cerradas, \(\bar{X}\) puede llevarnos por mal camino si no nos damos cuenta de que es una variable aleatoria. Sin embargo, podemos decir más sobre cuán cerca nos acercamos con el \(p\) y los hacemos en la Sección \ref{clt}.

\hypertarget{ejercicios-26}{%
\section{Ejercicios}\label{ejercicios-26}}

1. Suponga que sondea una población en la que una proporción \(p\) de los votantes son demócratas y \(1-p\) son republicanos. Su tamaño de muestra es \(N=25\). Considere la variable aleatoria \(S\) que es el \textbf{total} número de demócratas en su muestra. ¿Cuál es el valor esperado de esta variable aleatoria? Sugerencia: es una función de \(p\).

2. ¿Cuál es el error estándar de \(S\)? Sugerencia: es una función de \(p\).

3. Considere la variable aleatoria \(S/N\). Esta es equivalente al promedio de la muestra, que hemos estado denotando como \(\bar{X}\). ¿Cuál es el valor esperado de la \(\bar{X}\)? Sugerencia: es una función de \(p\).

4. ¿Cuál es el error estándar de \(\bar{X}\)? Sugerencia: es una función de \(p\).

5. Escriba una línea de código que le dé el error estándar \texttt{se} para el problema anterior para varios valores de \(p\), especificamente para \texttt{p\ \textless{}-\ seq(0,\ 1,\ length\ =\ 100)}. Haga un gráfico de \texttt{se} versus \texttt{p}.

6. Copie el código anterior y póngalo dentro de un bucle-for para hacer el gráfico para \(N=25\), \(N=100\) y \(N=1000\).

7. Si nos interesa la diferencia en proporciones, \(p - (1-p)\), nuestra estimación es \(d = \bar{X} - (1-\bar{X})\). Use las reglas que aprendimos sobre sumas de variables aleatorias y variables aleatorias escaladas para derivar el valor esperado de \(d\).

8. ¿Cuál es el error estándar de \(d\)?

9. Si el valor verdadero de \(p=.45\), eso significa que los republicanos están ganando por un margen relativamente grande dado que \(d= -.1\), que es un margen de victoria de 10\%. En este caso, ¿cuál es el error estándar de \(2\hat{X}-1\) si tomamos una muestra de \(N=25\)?

10. Dada la respuesta a 9, ¿cuál de las siguientes opciones describe mejor su estrategia de usar un tamaño de muestra de \(N=25\)?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  El valor esperado de nuestra estimación \(2\bar{X}-1\) es \(d\), por lo que nuestra predicción será cierta.
\item
  Nuestro error estándar es mayor que la diferencia, por lo que las posibilidades de que \(2\bar{X}-1\) sea positivo y nos confunda no son tan pequeñas. Deberíamos elegir un tamaño de muestra más grande.
\item
  La diferencia es de 10\% y el error estándar es de aproximadamente 0.2, por lo tanto, mucho más pequeño que la diferencia.
\item
  Como no sabemos \(p\), no tenemos manera de saber si hacer \(N\) más grande mejoraría nuestro error estándar.
\end{enumerate}

\hypertarget{clt}{%
\section{Teorema del límite central en la práctica}\label{clt}}

El teorema del límite central (CLT) nos dice que la función de distribución para una suma de sorteos es aproximadamente normal. También aprendimos que dividir una variable aleatoria normalmente distribuida por una constante también es una variable normalmente distribuida. Esto implica que la distribución de \(\bar{X}\) es aproximadamente normal.

En resumen, determinamos que \(\bar{X}\) tiene una distribución aproximadamente normal con valor esperado \(p\) y error estándar \(\sqrt{p(1-p)/N}\).

Ahora, ¿cómo nos ayuda esto? Supongan que queremos saber cuál es la probabilidad de que estamos a 1\% de \(p\). Básicamente estamos preguntando cuánto es:

\[
\mbox{Pr}(| \bar{X} - p| \leq .01)
\]
que es lo mismo que:

\[
\mbox{Pr}(\bar{X}\leq p + .01) - \mbox{Pr}(\bar{X} \leq p - .01)
\]

Para contestar a esta pregunta, podemos usar el truco matemático que aprendimos en el capítulo anterior. Resten el valor esperado y dividan por el error estándar para obtener una variable aleatoria que sigue la distribución normal unitaria, llámenla \(Z\), a la izquierda. Ya que \(p\) es el valor esperado y \(\mbox{SE}(\bar{X}) = \sqrt{p(1-p)/N}\) es el error estándar, obtenemos:

\[
\mbox{Pr}\left(Z \leq \frac{ \,.01} {\mbox{SE}(\bar{X})} \right) -
\mbox{Pr}\left(Z \leq - \frac{ \,.01} {\mbox{SE}(\bar{X})} \right)
\]

Un problema que tenemos es que como no sabemos \(p\), no sabemos \(\mbox{SE}(\bar{X})\). Pero resulta que el CLT aún funciona si estimamos el error estándar usando \(\bar{X}\) en lugar de \(p\). En inglés, decimos que tenemos que \emph{plug-in} el estimador. Por lo tanto, nuestro estimador del error estándar es:

\[
\hat{\mbox{SE}}(\bar{X})=\sqrt{\bar{X}(1-\bar{X})/N}
\]
En los libros de texto de estadísticas, usamos un sombrerito para denotar estimadores. El estimador se puede construir utilizando los datos observados y \(N\).

Ahora continuamos con nuestro cálculo, pero dividiendo por \(\hat{\mbox{SE}}(\bar{X})=\sqrt{\bar{X}(1-\bar{X})/N})\). En nuestra primera muestra teníamos 12 azules y 13 rojos así que \(\bar{X} = 0.48\) y nuestro estimador del error estándar es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FloatTok{0.48}
\NormalTok{se }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(x\_hat}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{x\_hat)}\SpecialCharTok{/}\DecValTok{25}\NormalTok{)}
\NormalTok{se}
\CommentTok{\#\textgreater{} [1] 0.0999}
\end{Highlighting}
\end{Shaded}

Y ahora podemos responder a la pregunta sobre la probabilidad de estar cerca de \(p\). La respuesta es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{0.01}\SpecialCharTok{/}\NormalTok{se) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.01}\SpecialCharTok{/}\NormalTok{se)}
\CommentTok{\#\textgreater{} [1] 0.0797}
\end{Highlighting}
\end{Shaded}

Por lo tanto, existe una pequeña posibilidad de que estamos cerca. Una encuesta de solo \(N=25\) personas no es realmente muy útil, al menos no para una elección cerrada.

Anteriormente mencionamos el \emph{margen de error}. Ahora podemos definirlo porque es simplemente dos veces el error estándar, que ahora podemos estimar. En nuestro caso es:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1.96}\SpecialCharTok{*}\NormalTok{se}
\CommentTok{\#\textgreater{} [1] 0.196}
\end{Highlighting}
\end{Shaded}

¿Por qué multiplicamos por 1.96? Porque si preguntan cuál es la probabilidad de que estemos dentro de 1.96 errores estándar de \(p\), obtenemos:

\[
\mbox{Pr}\left(Z \leq \, 1.96\,\mbox{SE}(\bar{X})/ \mbox{SE}(\bar{X}) \right) -
\mbox{Pr}\left(Z \leq - 1.96\, \mbox{SE}(\bar{X})/ \mbox{SE}(\bar{X}) \right)
\]
que es:

\[
\mbox{Pr}\left(Z \leq 1.96 \right) -
\mbox{Pr}\left(Z \leq - 1.96\right)
\]

que sabemos es aproximadamente 95\%:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{1.96}\NormalTok{)}\SpecialCharTok{{-}}\FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.96}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.95}
\end{Highlighting}
\end{Shaded}

Por lo tanto, hay un 95\% de probabilidad de que \(\bar{X}\) estará dentro \(1.96\times \hat{SE}(\bar{X})\), en nuestro caso aproximadamente dentro de 0.2, de \(p\). Tengan en cuenta que el 95\% es una elección arbitraria y, a veces, se utilizan otros porcentajes, pero es el valor más utilizado para definir el margen de error. A menudo redondeamos 1.96 a 2 para simplificar la presentación.

En resumen, el CLT nos dice que nuestra encuesta que se basa en un tamaño de muestra de \(25\) no es muy útil. Efectivamente no aprendemos mucho cuando el margen de error es tan grande. Lo único que realmente podemos decir es que el voto popular no se ganará por un margen amplio. Esta es la razón por la cual los encuestadores tienden a usar tamaños de muestra más grandes.

En la tabla anterior, vemos que los tamaños de muestra típicos oscilan entre 700 y 3500. Para ver cómo esto nos da un resultado mucho más práctico, noten que si hubiéramos obtenido un \(\bar{X}\)= 0.48 con un tamaño de muestra de 2,000, nuestro error estándar \(\hat{\mbox{SE}}(\bar{X})\) habría sido 0.011. Entonces nuestro resultado es un estimador de \texttt{48}\% con un margen de error de 2\%. En este caso, el resultado es mucho más informativo y nos haría pensar que hay más cuentas rojas que azules. Recuerden, sin embargo, que esto es hipotético. No hicimos una encuesta de 2,000 ya que no queremos dañar el concurso.

\hypertarget{una-simulaciuxf3n-monte-carlo}{%
\subsection{Una simulación Monte Carlo}\label{una-simulaciuxf3n-monte-carlo}}

Supongan que queremos usar una simulación Monte Carlo para corroborar las herramientas que hemos construido utilizando la teoría de la probabilidad. Para crear la simulación, escribiríamos código como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size =}\NormalTok{ N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
  \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

El problema es, por supuesto, que no sabemos \texttt{p}. Podríamos construir una urna como la que se muestra arriba y ejecutar una simulación analógica (sin una computadora). Nos tomaría mucho tiempo, pero podríamos tomar 10,000 muestras, contar las cuentas y registrar las proporciones de azul. Podemos usar la función \texttt{take\_poll(n=1000)} en lugar de escoger de una urna real, pero todavía tomaría tiempo contar las cuentas y registrar los resultados.

Por lo tanto, algo que hacemos para corroborar los resultados teóricos es elegir uno o varios valores de \texttt{p} y ejecutar las simulaciones. Vamos a configurar \texttt{p=0.45}. Entonces podemos simular una encuesta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.45}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{1000}

\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size =}\NormalTok{ N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

En esta muestra particular, nuestro estimador es \texttt{x\_hat}. Podemos usar ese código para hacer una simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size =}\NormalTok{ N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
  \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Para repasar, la teoría nos dice que la distribución de \(\bar{X}\) es aproximadamente normal, tiene valor esperado \(p=\) 0.45 y error estándar \(\sqrt{p(1-p)/N}\) = 0.016. La simulación confirma esto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(x\_hat)}
\CommentTok{\#\textgreater{} [1] 0.45}
\FunctionTok{sd}\NormalTok{(x\_hat)}
\CommentTok{\#\textgreater{} [1] 0.0158}
\end{Highlighting}
\end{Shaded}

Un histograma y un gráfico Q-Q confirman que la aproximación normal también es precisa:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/normal-approximation-for-polls-1} \end{center}

Por supuesto, en la vida real nunca podríamos realizar un experimento así porque no sabemos \(p\). Pero podríamos ejecutarlo para varios valores de \(p\) y \(N\) y ver que la teoría realmente funciona bien para la mayoría de los valores. Pueden hacerlo fácilmente volviendo a ejecutar el código anterior después de cambiar \texttt{p} y \texttt{N}.

\hypertarget{la-diferencia}{%
\subsection{La diferencia}\label{la-diferencia}}

El reto es predecir la diferencia, no la proporción \(p\). Sin embargo, dado que suponemos que solo hay dos partidos, sabemos que la diferencia es \(p - (1-p) = 2p - 1\). Como resultado, todo lo que hemos hecho se puede adaptar fácilmente a estimar \(2p - 1\). Una vez que tengamos nuestro estimador \(\bar{X}\) y \(\hat{\mbox{SE}}(\bar{X})\), estimamos la diferencia con \(2\bar{X} - 1\) y, dado que estamos multiplicando por 2, el error estándar es \(2\hat{\mbox{SE}}(\bar{X})\). Noten que restar 1 no añade variabilidad, por lo que no afecta el error estándar.

Para nuestra muestra anterior de 25 artículos, nuestro \(p\) estimado es \texttt{.48} con margen de error \texttt{.20} y nuestro estimador de la diferencia es \texttt{0.04} con margen de error \texttt{.40}. Nuevamente, no es un tamaño de muestra muy útil. Sin embargo, el punto es que una vez que tengamos un estimador y un error estándar para \(p\), lo tenemos para la diferencia \(2p-1\).

\hypertarget{sesgo-por-quuxe9-no-realizar-una-encuesta-bien-grande}{%
\subsection{Sesgo: ¿por qué no realizar una encuesta bien grande?}\label{sesgo-por-quuxe9-no-realizar-una-encuesta-bien-grande}}

Para valores realistas de \(p\), digamos de 0.35 a 0.65, si realizamos una encuesta bien grande con 100,000 personas, la teoría nos dice que predeciríamos la elección perfectamente ya que el mayor margen de error posible es de alrededor de 0.3\%:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/standard-error-versus-p-1} \end{center}

Una razón es que realizar una encuesta de este tipo es muy costosa. Otra razón posiblemente más importante es que la teoría tiene sus limitaciones. El sondeo es mucho más complicado que escoger cuentas de una urna. Algunas personas pueden mentirle a los encuestadores y otras pueden no tener teléfonos. Pero quizás la manera más importante en que una encuesta real difiere de un modelo de urna es que no sabemos con certeza quién está en nuestra población y quién no. ¿Cómo sabemos quién va a votar? ¿Todos los votantes tienen la misma posibilidad de ser encuestado? Aunque nuestro margen de error es bien pequeño, es posible que nuestro valor esperado no sea exactamente \(p\). A esto lo llamamos sesgo (\emph{bias} en inglés). Históricamente, observamos que las encuestas están sesgadas, aunque no por mucho. El sesgo típico parece ser de aproximadamente 1-2\%. Esto hace que el pronóstico de las elecciones sea un poco más interesante y hablaremos sobre cómo modelar esto en un capítulo posterior.

\hypertarget{ejercicios-27}{%
\section{Ejercicios}\label{ejercicios-27}}

1. Escriba una función que modele una urna que toma la proporción de demócratas \(p\) y el tamaño de la muestra \(N\) como argumentos y devuelve el promedio de la muestra si los demócratas son 1s y los republicanos son 0s. Llame a la función \texttt{take\_sample}.

2. Ahora suponga que \texttt{p\ \textless{}-\ 0.45} y que su tamaño de muestra es \(N=100\). Tome una muestra 10,000 veces y guarde el vector de \texttt{mean(X)\ -\ p} en un objeto llamado \texttt{errors}. Sugerencia: use la función que escribió para el ejercicio 1 para escribir esto en una línea de código.

3. El vector \texttt{errors} contiene, para cada muestra simulada, la diferencia entre el valor real \(p\) y nuestro estimador \(\bar{X}\). Nos referimos a esta diferencia como el \emph{error}. Calcule el promedio y haga un histograma de los errores generados en la simulación Monte Carlo y seleccione cuál de las siguientes opciones describe mejor sus distribuciones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(errors)}
\FunctionTok{hist}\NormalTok{(errors)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Los errores son alrededor de 0.05.
\item
  Los errores son todos alrededor de -0.05.
\item
  Los errores se distribuyen simétricamente alrededor de 0.
\item
  Los errores varían de -1 a 1.
\end{enumerate}

4. El error \(\bar{X}-p\) es una variable aleatoria. En la práctica, el error no se observa porque no sabemos \(p\). Aquí lo observamos porque construimos la simulación. ¿Cuál es el tamaño promedio del error si definimos el tamaño tomando el valor absoluto \(\mid \bar{X} - p \mid\)?

5. El error estándar está relacionado con el \textbf{tamaño} típico del error que cometemos al predecir. Decimos \textbf{tamaño} porque acabamos de ver que los errores están centrados alrededor de 0, por lo que el valor de error promedio es 0. Por razones matemáticas relacionadas con el teorema del límite central, utilizamos la desviación estándar de \texttt{errors} en lugar del promedio de los valores absolutos para cuantificar el tamaño típico. ¿Cuál es esta desviación estándar de los errores?

6. La teoría que acabamos de aprender nos dice cuál será esta desviación estándar porque es el error estándar de \(\bar{X}\). Según la teoría, ¿cuánto es el error estándar de \(\bar{X}\) para un tamaño de muestra de 100?

7. En la práctica, no sabemos \(p\), por lo que construimos un estimador de la predicción teórica basada en remplazar \(p\) con \(\bar{X}\). Calcule este estimador. Fije la semilla en 1 con \texttt{set.seed(1)}.

8. Observe cuán cerca están los estimadores de error estándar obtenidos de la simulación Monte Carlo (ejercicio 5), la predicción teórica (ejercicio 6) y el estimador de la predicción teórica (ejercicio 7). La teoría está funcionando y nos da un enfoque práctico para conocer el error típico que cometeremos si predecimos \(p\) con \(\bar{X}\). Otra ventaja que provee el resultado teórico es que da una idea de cuán grande tiene que ser el tamaño de muestra para obtener la precisión que necesitamos. Anteriormente vimos que los errores estándar más grandes ocurren para \(p=0.5\). Cree un gráfico del error estándar más grande para \(N\) que va desde 100 hasta 5,000. Según este gráfico, ¿cuán grande debe ser el tamaño de la muestra para tener un error estándar de aproximadamente 1\%?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  100
\item
  500
\item
  2,500
\item
  4,000
\end{enumerate}

9. Para el tamaño de la muestra \(N=100\), el teorema del límite central nos dice que la distribución de \(\bar{X}\) es:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  prácticamente igual a \(p\).
\item
  aproximadamente normal con el valor esperado \(p\) y error estándar \(\sqrt{p(1-p)/N}\).
\item
  aproximadamente normal con el valor esperado \(\bar{X}\) y error estándar \(\sqrt{\bar{X}(1-\bar{X})/N}\).
\item
  no es una variable aleatoria.
\end{enumerate}

10. Según la respuesta del ejercicio 8, el error \(\bar{X} - p\) es:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  prácticamente igual a 0.
\item
  aproximadamente normal con el valor esperado \(0\) y error estándar \(\sqrt{p(1-p)/N}\).
\item
  aproximadamente normal con el valor esperado \(p\) y error estándar \(\sqrt{p(1-p)/N}\).
\item
  No es una variable aleatoria.
\end{enumerate}

11. Para corroborar su respuesta al ejercicio 9, haga un gráfico Q-Q de los \texttt{errors} que generó en el ejercicio 2 para ver si siguen una distribución normal.

12. Si \(p=0.45\) y \(N=100\) como en el ejercicio 2, use el CLT para estimar la probabilidad de que \(\bar{X}>0.5\). Puede suponer que sabe que \(p=0.45\) para este cálculo

13. Suponga que está en una situación práctica y no sabe \(p\). Tome una muestra de tamaño \(N=100\) y obtenga una muestra promedio de \(\bar{X} = 0.51\). ¿Cuál es la aproximación del CLT para la probabilidad de que su error sea igual o mayor que 0.01?

\hypertarget{intervalos-de-confianza}{%
\section{Intervalos de confianza}\label{intervalos-de-confianza}}

Los \emph{intervalos de confianza} (\emph{confidence intervals} en inglés) son un concepto muy útil ampliamente utilizado por los analistas de datos. Una versión de estos que vemos comúnmente proviene de la geometría \texttt{geom\_smooth} de \texttt{ggplot}. Aquí tenemos un ejemplo usando un set de datos de temperatura disponible en R:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/first-confidence-intervals-example-1} \end{center}

En la parte sobre \emph{machine learning}, aprenderemos cómo se forma la curva, pero por ahora consideren el área sombreada alrededor de la curva. Esto se crea utilizando el concepto de intervalos de confianza.

En nuestro concurso anterior, se les pidió que dieran un intervalo. Si el intervalo que indicaron incluye el \(p\), obtienen la mitad del dinero que gastaron en su ``encuesta'' y pasan a la siguiente etapa del concurso. Una forma de pasar a la segunda ronda es informar un intervalo muy grande. Por ejemplo, el intervalo \([0,1]\) está garantizado a siempre incluir \(p\). Sin embargo, con un intervalo tan grande, no tenemos posibilidades de ganar el concurso. Del mismo modo, si ustedes son pronosticadores de elecciones y predicen que la diferencia será entre -100\% y 100\%, serán ridiculizados por decir lo obvio. Incluso hasta un intervalo más pequeño, como decir que la diferencia será entre -10 y 10\%, no se consideraría serio.

Por otro lado, entre más pequeño sea el intervalo que escogemos, más bajas serán nuestras posibilidades de ganar el premio. Del mismo modo, un encuestador audaz que informa intervalos demasiado pequeños y se equivoca la mayor parte del tiempo no se considerará un buen encuestador. Queremos estar en algún punto intermedio.

Podemos usar la teoría estadística que hemos aprendido para calcular la probabilidad de cualquier intervalo dado, incluyendo \(p\). Si se nos pide crear un intervalo con, digamos, una probabilidad de 95\% de incluir \(p\), podemos hacer eso también. Estos se denominan intervalos de confianza de 95\%.

Cuando un encuestador informa un estimador y un margen de error, de alguna manera informa un intervalo de confianza de 95\%. Mostremos cómo funciona esto matemáticamente.

Queremos saber la probabilidad de que el intervalo \([\bar{X} - 2\hat{\mbox{SE}}(\bar{X}), \bar{X} + 2\hat{\mbox{SE}}(\bar{X})]\) contenga la verdadera proporción \(p\). Primero, consideren que el inicio y el final de estos intervalos son variables aleatorias: cada vez que tomamos una muestra, cambian. Para ilustrar esto, ejecuten la simulación Monte Carlo arriba dos veces. Usamos los mismos parámetros que arriba:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.45}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{1000}
\end{Highlighting}
\end{Shaded}

Y observen que el intervalo aquí:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{size =}\NormalTok{ N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{se\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(x\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ x\_hat)}\SpecialCharTok{/}\NormalTok{ N)}
\FunctionTok{c}\NormalTok{(x\_hat }\SpecialCharTok{{-}} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat, x\_hat }\SpecialCharTok{+} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat)}
\CommentTok{\#\textgreater{} [1] 0.416 0.478}
\end{Highlighting}
\end{Shaded}

es diferente de este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size=}\NormalTok{N, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{se\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(x\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ x\_hat)}\SpecialCharTok{/}\NormalTok{ N)}
\FunctionTok{c}\NormalTok{(x\_hat }\SpecialCharTok{{-}} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat, x\_hat }\SpecialCharTok{+} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat)}
\CommentTok{\#\textgreater{} [1] 0.419 0.481}
\end{Highlighting}
\end{Shaded}

Sigan muestreando y creando intervalos y verán la variación aleatoria.

Para determinar la probabilidad de que el intervalo incluya \(p\), necesitamos calcular esto:
\[
\mbox{Pr}\left(\bar{X} - 1.96\hat{\mbox{SE}}(\bar{X}) \leq p \leq \bar{X} + 1.96\hat{\mbox{SE}}(\bar{X})\right)
\]

Al restar y dividir las mismas cantidades en todas las partes de la ecuación, nosotros obtenemos que lo anterior es equivalente a:

\[
\mbox{Pr}\left(-1.96 \leq \frac{\bar{X}- p}{\hat{\mbox{SE}}(\bar{X})} \leq 1.96\right)
\]

El término en el medio es una variable aleatoria aproximadamente normal con valor esperado 0 y error estándar 1, que hemos estado denotando con \(Z\), y por lo tanto tenemos:

\[
\mbox{Pr}\left(-1.96 \leq Z \leq 1.96\right)
\]

que podemos calcular rápidamente usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(}\FloatTok{1.96}\NormalTok{) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.96}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.95}
\end{Highlighting}
\end{Shaded}

demostrando que tenemos una probabilidad de 95\%.

Si queremos tener una probabilidad más grande, digamos 99\%, necesitamos multiplicar por cualquier \texttt{z} que cumpla lo siguiente:

\[
\mbox{Pr}\left(-z \leq Z \leq z\right) = 0.99
\]

Utilizando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.995}\NormalTok{)}
\NormalTok{z}
\CommentTok{\#\textgreater{} [1] 2.58}
\end{Highlighting}
\end{Shaded}

lograremos esto porque por definición \texttt{pnorm(qnorm(0.995))} es 0.995 y por simetría \texttt{pnorm(1-qnorm(0.995))} es 1 - 0.995. Como consecuencia, tenemos que:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pnorm}\NormalTok{(z) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{z)}
\CommentTok{\#\textgreater{} [1] 0.99}
\end{Highlighting}
\end{Shaded}

es \texttt{0.995\ -\ 0.005\ =\ 0.99}. Podemos usar este enfoque para cualquier proporción \(p\): nosotros fijamos \texttt{z\ =\ qnorm(1\ -\ (1\ -\ p)/2)} porque \(1 - (1 - p)/2 - (1 - p)/2 = p\).

Entonces, por ejemplo, para \(p=0.95\), \(1 - (1-p)/2 = 0.975\) y obtenemos el 1.96 que hemos estado usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1.96}
\end{Highlighting}
\end{Shaded}

\hypertarget{una-simulaciuxf3n-monte-carlo-1}{%
\subsection{Una simulación Monte Carlo}\label{una-simulaciuxf3n-monte-carlo-1}}

Podemos ejecutar una simulación Monte Carlo para confirmar que, de hecho, un intervalo de confianza de 95\% incluye \(p\) 95\% del tiempo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{inside }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size =}\NormalTok{ N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
\NormalTok{  x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{  se\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(x\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ x\_hat)}\SpecialCharTok{/}\NormalTok{ N)}
  \FunctionTok{between}\NormalTok{(p, x\_hat }\SpecialCharTok{{-}} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat, x\_hat }\SpecialCharTok{+} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se\_hat)}
\NormalTok{\})}
\FunctionTok{mean}\NormalTok{(inside)}
\CommentTok{\#\textgreater{} [1] 0.948}
\end{Highlighting}
\end{Shaded}

El siguiente gráfico muestra los primeros 100 intervalos de confianza. En este caso, creamos la simulación para que la línea negra denote el parámetro que estamos tratando de estimar:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/confidence-interval-coverage-1} \end{center}

\hypertarget{el-idioma-correcto}{%
\subsection{El idioma correcto}\label{el-idioma-correcto}}

Al usar la teoría que describimos anteriormente, es importante recordar que los intervalos son aleatorios, no \(p\). En el gráfico anterior, podemos ver los intervalos aleatorios moviéndose. En cambio, la proporción de cuentas azules en la urna, \(p\), representada por la línea vertical, no se mueve. Entonces el 95\% se refiere a la probabilidad de que este intervalo aleatorio caiga encima de \(p\). Decir que \(p\) tiene una probabilidad de 95\% de estar entre esto y eso es técnicamente una declaración incorrecta porque \(p\) no es aleatorio.

\hypertarget{ejercicios-28}{%
\section{Ejercicios}\label{ejercicios-28}}

Para estos ejercicios, utilizaremos encuestas reales de las elecciones del 2016. Puede cargar los datos del paquete \textbf{dslabs}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_us\_election\_2016"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Específicamente, utilizaremos todas las encuestas nacionales que acabaron dentro de una semana antes de las elecciones.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}\NormalTok{ state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

1. Para la primera encuesta, puede obtener el tamaño de las muestras y el porcentaje estimado para Clinton con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}}\NormalTok{ polls}\SpecialCharTok{$}\NormalTok{samplesize[}\DecValTok{1}\NormalTok{]}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}}\NormalTok{ polls}\SpecialCharTok{$}\NormalTok{rawpoll\_clinton[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{/}\DecValTok{100}
\end{Highlighting}
\end{Shaded}

Suponga que solo hay dos candidatos. Construya un intervalo de confianza de 95\% para la proporción \(p\) observada la noche de elecciones.

2. Ahora use \textbf{dplyr} para añadir dos columnas al objeto \texttt{poll}, llámelas \texttt{lower} y \texttt{upper}, para representar el intervalo de confianza. Luego use \texttt{select} para mostrar los variables \texttt{pollster}, \texttt{enddate}, \texttt{x\_hat},\texttt{lower}, \texttt{upper}. Sugerencia: defina columnas temporeras \texttt{x\_hat} y \texttt{se\_hat}.

3. El conteo final para el voto popular fue Clinton 48.2\% y Trump 46.1\%. Agregue una columna, llámela \texttt{hit}, a la tabla anterior que indica si el intervalo de confianza incluía la proporción verdadera \(p=0.482\) o no.

4. Para la tabla que acaba de crear, ¿qué proporción de intervalos de confianza incluyeron \(p\)?

5. Si estos intervalos de confianza se construyen correctamente y la teoría se sostiene, ¿qué proporción debería incluir \(p\)?

6. De estas encuestas, una proporción menor de lo esperado resulta en intervalos de confianza que contienen \(p\). Si examina la tabla cuidadosamente, verá que la mayoría de las encuestas que no incluyen \(p\) están subestimando. La razón es que hay votantes indecisos, las personas encuestadas que aún no saben por quién votarán o no quieren decir. Debido a que históricamente los indecisos se dividen igualmente entre los dos candidatos principales el día de las elecciones, es más informativo estimar la variabilidad o la diferencia entre la proporción de dos candidatos \(d\), que en esta elección fue \(0. 482 - 0.461 = 0.021\).
Suponga que solo hay dos partidos y que \(d = 2p - 1\), redefina \texttt{polls} como se hace abajo y repita el ejercicio 1, pero para la diferencia.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}\NormalTok{ state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{d\_hat =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/} \DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

7. Ahora repita el ejercicio 3, pero para la diferencia.

8. Ahora repita el ejercicio 4, pero para la diferencia.

9. Aunque la proporción de intervalos de confianza aumenta sustancialmente, sigue siendo menor que 0.95. En el próximo capítulo, aprendemos la razón de esto. Para motivar esto, haga un gráfico del error, la diferencia entre el estimador de cada encuesta y la diferencia real \(d=0.021\). Estratifique por encuestador.

10. Vuelva a hacer el gráfico que hizo para el ejercicio 9, pero solo para los encuestadores que tomaron cinco o más encuestas.

\hypertarget{poder}{%
\section{Poder}\label{poder}}

Los encuestadores no se consideran exitosos al proveer intervalos de confianza correctos, sino al predecir quién ganará. Cuando tomamos un tamaño de muestra de 25 cuentas, el intervalo de confianza para la diferencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{25}
\NormalTok{x\_hat }\OtherTok{\textless{}{-}} \FloatTok{0.48}
\NormalTok{(}\DecValTok{2} \SpecialCharTok{*}\NormalTok{ x\_hat }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.96}\NormalTok{, }\FloatTok{1.96}\NormalTok{) }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(x\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ x\_hat)}\SpecialCharTok{/}\NormalTok{ N)}
\CommentTok{\#\textgreater{} [1] {-}0.432  0.352}
\end{Highlighting}
\end{Shaded}

incluye 0. Si esto fuera una encuesta y nos viéramos obligados a hacer una declaración, tendríamos que decir que ambos resultados son probables.

Un problema con los resultados de nuestra encuesta es que, dado el tamaño de la muestra y el valor de \(p\), tendríamos que sacrificar la probabilidad de una predicción incorrecta para crear un intervalo que no incluya 0.

Esto no significa que la elección está cerrada. Solo significa que tenemos un tamaño de muestra pequeño. En los libros de texto estadísticos esto se llama falta de \emph{poder}. En el contexto de las encuestas, el \emph{poder} es la probabilidad de detectar diferencias que no sean 0.

Al aumentar el tamaño de nuestra muestra, disminuimos nuestro error estándar y, por lo tanto, tenemos muchas más posibilidades de detectar la dirección de la diferencia.

\hypertarget{valores-p}{%
\section{valores-p}\label{valores-p}}

Los \emph{valores-p} (\emph{p-values} en inglés) son ubicuos en la literatura científica. Están relacionados con los intervalos de confianza, por lo que presentamos el concepto aquí.

Consideremos las cuentas azules y rojas. Supongan que, en lugar de querer un estimador de la diferencia o de la proporción de azul, solo nos interesa la pregunta: ¿hay más cuentas azules o cuentas rojas? Queremos saber si la diferencia \(2p-1 > 0\).

Digamos que tomamos una muestra aleatoria de \(N=100\) y observamos \(52\) cuentas azules, lo que nos da \(2\bar{X}-1=0.04\). Esto parece estar apuntando a la existencia de más cuentas azules que rojas ya que 0.04 es mayor que 0. Sin embargo, como científicos de datos, debemos ser escépticos. Sabemos que el azar afecta este proceso y podríamos obtener un 52 incluso cuando la diferencia real es 0. Llamamos a la suposición de que la diferencia es \(2p-1=0\) una \emph{hipótesis nula}. La hipótesis nula es la hipótesis del escéptico. Hemos observado una variable aleatoria \(2\bar{X}-1 = 0.04\) y el valor-p es la respuesta a la pregunta: ¿cuán probable es ver un valor tan grande, cuando la hipótesis nula es cierta? Entonces escribimos:

\[\mbox{Pr}(\mid \bar{X} - 0.5 \mid > 0.02 ) \]

suponiendo que \(2p-1=0\) o \(p=0.5\). Bajo la hipótesis nula sabemos que:

\[
\sqrt{N}\frac{\bar{X} - 0.5}{\sqrt{0.5(1-0.5)}}
\]

es normal unitaria. Por lo tanto, podemos calcular la probabilidad anterior, que es el valor-p.

\[\mbox{Pr}\left(\sqrt{N}\frac{\mid \bar{X} - 0.5\mid}{\sqrt{0.5(1-0.5)}} > \sqrt{N} \frac{0.02}{ \sqrt{0.5(1-0.5)}}\right)\]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(N)}\SpecialCharTok{*}\FloatTok{0.02}\SpecialCharTok{/}\FloatTok{0.5}
\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ (}\FunctionTok{pnorm}\NormalTok{(z) }\SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{z))}
\CommentTok{\#\textgreater{} [1] 0.689}
\end{Highlighting}
\end{Shaded}

En este caso, existe una gran posibilidad de ver 52 o más bajo la hipótesis nula.

Tengan en cuenta que existe una conexión entre los valores-p y los intervalos de confianza. Si un intervalo de confianza de 95\% de la diferencia no incluye 0, sabemos que el valor-p tiene que ser menor que 0.05.

Para aprender más sobre los valores-p, pueden consultar cualquier libro de texto de estadísticas. Sin embargo, en general, preferimos resumir nuestros resultados con intervalos de confianza en vez de valores-p, ya que nos da una idea del tamaño del estimador. Si solo informamos el valor-p, no proveemos información sobre la importancia del hallazgo en el contexto del problema.

\hypertarget{association-tests}{%
\section{Pruebas de asociación}\label{association-tests}}

Las pruebas estadísticas que hemos estudiado hasta ahora no incluyen varios tipos de datos. Específicamente, no hemos discutido la inferencia para datos binarios, categóricos y ordinales. Para dar un ejemplo muy específico, consideren el siguiente estudio de caso.

Una publicación del 2014 de PNAS\footnote{\url{http://www.pnas.org/content/112/40/12349.abstract}} analizó las tasas de éxito de las agencias de financiamiento en los Países Bajos y concluyó que:

\begin{quote}
los resultados revelan un sesgo de género que favorece a los hombres solicitantes sobre las mujeres solicitantes en la priorización de sus evaluaciones de ``calidad de investigador'' (pero no de ``calidad de propuesta''), así como en el uso del lenguaje en los materiales de instrucción y de evaluación.
\end{quote}

La evidencia principal de esta conclusión se reduce a una comparación de los porcentajes. La Tabla S1 en el documento incluye la información que necesitamos. Aquí están las tres columnas que muestran los resultados generales:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"research\_funding\_rates"}\NormalTok{)}
\NormalTok{research\_funding\_rates }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(discipline, applications\_total,}
\NormalTok{                                  success\_rates\_total) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}           discipline applications\_total success\_rates\_total}
\CommentTok{\#\textgreater{} 1  Chemical sciences                122                26.2}
\CommentTok{\#\textgreater{} 2  Physical sciences                174                20.1}
\CommentTok{\#\textgreater{} 3            Physics                 76                26.3}
\CommentTok{\#\textgreater{} 4         Humanities                396                16.4}
\CommentTok{\#\textgreater{} 5 Technical sciences                251                17.1}
\CommentTok{\#\textgreater{} 6  Interdisciplinary                183                15.8}
\end{Highlighting}
\end{Shaded}

Tenemos estos valores para cada género:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(research\_funding\_rates)}
\CommentTok{\#\textgreater{}  [1] "discipline"          "applications\_total"  "applications\_men"   }
\CommentTok{\#\textgreater{}  [4] "applications\_women"  "awards\_total"        "awards\_men"         }
\CommentTok{\#\textgreater{}  [7] "awards\_women"        "success\_rates\_total" "success\_rates\_men"  }
\CommentTok{\#\textgreater{} [10] "success\_rates\_women"}
\end{Highlighting}
\end{Shaded}

Podemos calcular el total de los que tuvieron éxito y el total de los que no lo tuvieron de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{totals }\OtherTok{\textless{}{-}}\NormalTok{ research\_funding\_rates }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{discipline) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize\_all}\NormalTok{(sum) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{yes\_men =}\NormalTok{ awards\_men,}
            \AttributeTok{no\_men =}\NormalTok{ applications\_men }\SpecialCharTok{{-}}\NormalTok{ awards\_men,}
            \AttributeTok{yes\_women =}\NormalTok{ awards\_women,}
            \AttributeTok{no\_women =}\NormalTok{ applications\_women }\SpecialCharTok{{-}}\NormalTok{ awards\_women)}
\end{Highlighting}
\end{Shaded}

Entonces vemos que un mayor porcentaje de hombres que mujeres recibieron premios:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{totals }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{percent\_men =}\NormalTok{ yes\_men}\SpecialCharTok{/}\NormalTok{(yes\_men}\SpecialCharTok{+}\NormalTok{no\_men),}
                     \AttributeTok{percent\_women =}\NormalTok{ yes\_women}\SpecialCharTok{/}\NormalTok{(yes\_women}\SpecialCharTok{+}\NormalTok{no\_women))}
\CommentTok{\#\textgreater{}   percent\_men percent\_women}
\CommentTok{\#\textgreater{} 1       0.177         0.149}
\end{Highlighting}
\end{Shaded}

Pero, ¿esto se debe solo a la variabilidad aleatoria? Aquí aprenderemos a llevar a cabo inferencia estadística para este tipo de datos.

\hypertarget{lady-tasting-tea}{%
\subsection{Lady Tasting Tea}\label{lady-tasting-tea}}

R.A. Fisher\footnote{\url{https://en.wikipedia.org/wiki/Ronald_Fisher}} fue uno de los primeros en formalizar las pruebas de hipótesis. El ``Lady Tasting Tea'' es uno de los ejemplos más famosos.

La historia es la siguiente: una conocida de Fisher insistió que ella podía detectar si añadían leche antes o después de verter el té. Fisher se mostró escéptico. Diseñó un experimento para probar esta afirmación. Él le dio cuatro pares de tazas de té. Cada par incluía una taza con leche vertida primero y la otra después del té. El orden era aleatorio. La hipótesis nula aquí es que ella está adivinando. Fisher dedujo la distribución del número de selecciones correctas suponiendo que las elecciones eran aleatorias e independientes.

Como ejemplo, supongan que la amiga escogió 3 de 4 correctamente. ¿Creemos que ella tiene una habilidad especial? La pregunta básica que hacemos es: si ella realmente está adivinando, ¿cuáles son las posibilidades de que ella saque 3 o más correctas? Tal como lo hemos hecho antes, podemos calcular una probabilidad bajo la hipótesis nula de que ella está adivinando 4 con leche vertida primero y 4 después. Bajo esta hipótesis nula, podemos pensar en este ejemplo particular como sacar 4 cuentas de una urna con 4 cuentas azules (respuesta correcta) y 4 cuentas rojas (respuesta incorrecta). Recuerden, ella sabe que hay cuatro tasas con leche antes del té y cuatro con leche después.

Bajo la hipótesis nula de que ella simplemente está adivinando, cada cuenta tiene la misma posibilidad de ser elegida. Entonces podemos usar combinaciones para averiguar cada probabilidad. La probabilidad de elegir 3 es \({4 \choose 3} {4 \choose 1}/ {8 \choose 4} = 16/70\). La probabilidad de elegir bien las 4 veces es
\({4 \choose 4} {4 \choose 0}/{8 \choose 4}= 1/70\).
Por lo tanto, la posibilidad de observar un 3 o algo más extremo,
bajo la hipótesis nula, es \(\approx 0.24\). Este es el valor-p.~El procedimiento que produjo este valor-p se llama la \emph{prueba exacta de Fisher} (\emph{Fisher's exact test} en inglés) y utiliza la \emph{distribución hipergeométrica}.

\hypertarget{tablas-2x2}{%
\subsection{Tablas 2x2}\label{tablas-2x2}}

Los datos del experimento generalmente se resumen en una tabla como esta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{),}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\FunctionTok{rownames}\NormalTok{(tab)}\OtherTok{\textless{}{-}}\FunctionTok{c}\NormalTok{(}\StringTok{"Poured Before"}\NormalTok{,}\StringTok{"Poured After"}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(tab)}\OtherTok{\textless{}{-}}\FunctionTok{c}\NormalTok{(}\StringTok{"Guessed before"}\NormalTok{,}\StringTok{"Guessed after"}\NormalTok{)}
\NormalTok{tab}
\CommentTok{\#\textgreater{}               Guessed before Guessed after}
\CommentTok{\#\textgreater{} Poured Before              3             1}
\CommentTok{\#\textgreater{} Poured After               1             3}
\end{Highlighting}
\end{Shaded}

que se conoce como una tabla 2x2. Para cada una de las cuatro combinaciones que se pueden obtener con un par de variables binarias, la tabla muestra los recuentos observados para cada ocurrencia.

La función \texttt{fisher.test} realiza los cálculos de inferencia anteriores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fisher.test}\NormalTok{(tab, }\AttributeTok{alternative=}\StringTok{"greater"}\NormalTok{)}\SpecialCharTok{$}\NormalTok{p.value}
\CommentTok{\#\textgreater{} [1] 0.243}
\end{Highlighting}
\end{Shaded}

\hypertarget{prueba-de-chi-cuadrado}{%
\subsection{Prueba de chi-cuadrado}\label{prueba-de-chi-cuadrado}}

En cierto sentido, nuestro ejemplo de tasas de financiamiento es parecido al de ``Lady Tasting Tea''. Sin embargo, en el ejemplo de ``Lady Tasting Tea'', el número de cuentas azules y rojas se fija experimentalmente y el número de respuestas dadas para cada categoría también. Esto se debe a que Fisher se aseguró de que se vertieran cuatro tazas con leche antes del té y cuatro tazas con leche después del té y la señora lo sabía, por lo que las respuestas también tendrían que incluir cuatro antes y cuatro después. Si este es el caso, la suma de las filas y la suma de las columnas son fijas. Esto define restricciones sobre las posibles formas en que podemos llenar la tabla 2x2 y también nos permite usar la distribución hipergeométrica. En general, este no es el caso. No obstante, hay otro enfoque, la prueba de chi-cuadrado, que se describe a continuación.

Imaginen que tenemos 290, 1,345, 177, 1,011 solicitantes, algunos son hombres y otros son mujeres y algunos reciben financiamiento, mientras que otros no. Vimos que las tasas de éxito para hombres y mujeres eran:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{totals }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{percent\_men =}\NormalTok{ yes\_men}\SpecialCharTok{/}\NormalTok{(yes\_men}\SpecialCharTok{+}\NormalTok{no\_men),}
                     \AttributeTok{percent\_women =}\NormalTok{ yes\_women}\SpecialCharTok{/}\NormalTok{(yes\_women}\SpecialCharTok{+}\NormalTok{no\_women))}
\CommentTok{\#\textgreater{}   percent\_men percent\_women}
\CommentTok{\#\textgreater{} 1       0.177         0.149}
\end{Highlighting}
\end{Shaded}

respectivamente. ¿Volveríamos a ver esto si asignamos fondos al azar usando como tasa la tasa general?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rate }\OtherTok{\textless{}{-}}\NormalTok{ totals }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{percent\_total =}
\NormalTok{              (yes\_men }\SpecialCharTok{+}\NormalTok{ yes\_women)}\SpecialCharTok{/}
\NormalTok{              (yes\_men }\SpecialCharTok{+}\NormalTok{ no\_men }\SpecialCharTok{+}\NormalTok{yes\_women }\SpecialCharTok{+}\NormalTok{ no\_women)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(percent\_total)}
\NormalTok{rate}
\CommentTok{\#\textgreater{} [1] 0.165}
\end{Highlighting}
\end{Shaded}

La prueba de chi-cuadrado responde a esta pregunta. El primer paso es crear la tabla de datos 2x2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{two\_by\_two }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{awarded =} \FunctionTok{c}\NormalTok{(}\StringTok{"no"}\NormalTok{, }\StringTok{"yes"}\NormalTok{),}
                         \AttributeTok{men =} \FunctionTok{c}\NormalTok{(totals}\SpecialCharTok{$}\NormalTok{no\_men, totals}\SpecialCharTok{$}\NormalTok{yes\_men),}
                         \AttributeTok{women =} \FunctionTok{c}\NormalTok{(totals}\SpecialCharTok{$}\NormalTok{no\_women, totals}\SpecialCharTok{$}\NormalTok{yes\_women))}
\NormalTok{two\_by\_two}
\CommentTok{\#\textgreater{}   awarded  men women}
\CommentTok{\#\textgreater{} 1      no 1345  1011}
\CommentTok{\#\textgreater{} 2     yes  290   177}
\end{Highlighting}
\end{Shaded}

La idea general de la prueba de chi-cuadrado es comparar esta tabla 2x2 con lo que esperamos ver, que sería:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{awarded =} \FunctionTok{c}\NormalTok{(}\StringTok{"no"}\NormalTok{, }\StringTok{"yes"}\NormalTok{),}
           \AttributeTok{men =}\NormalTok{ (totals}\SpecialCharTok{$}\NormalTok{no\_men }\SpecialCharTok{+}\NormalTok{ totals}\SpecialCharTok{$}\NormalTok{yes\_men) }\SpecialCharTok{*} \FunctionTok{c}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ rate, rate),}
           \AttributeTok{women =}\NormalTok{ (totals}\SpecialCharTok{$}\NormalTok{no\_women }\SpecialCharTok{+}\NormalTok{ totals}\SpecialCharTok{$}\NormalTok{yes\_women) }\SpecialCharTok{*} \FunctionTok{c}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ rate, rate))}
\CommentTok{\#\textgreater{}   awarded  men women}
\CommentTok{\#\textgreater{} 1      no 1365   991}
\CommentTok{\#\textgreater{} 2     yes  270   197}
\end{Highlighting}
\end{Shaded}

Podemos ver que más hombres y menos mujeres de lo esperado recibieron fondos. Sin embargo, bajo la hipótesis nula, estas observaciones son variables aleatorias. La prueba de chi-cuadrado nos dice cuán probable es ver una desviación así de grande o más grande. Esta prueba utiliza un resultado asintótico, similar al CLT, relacionado con las sumas de resultados binarios independientes. La función \texttt{chisq.test} de R toma una tabla 2x2 y devuelve los resultados de la prueba:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chisq\_test }\OtherTok{\textless{}{-}}\NormalTok{ two\_by\_two }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{awarded) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{chisq.test}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Vemos que el valor-p es 0.0509:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chisq\_test}\SpecialCharTok{$}\NormalTok{p.value}
\CommentTok{\#\textgreater{} [1] 0.0509}
\end{Highlighting}
\end{Shaded}

\hypertarget{odds-ratio}{%
\subsection{Riesgo relativo}\label{odds-ratio}}

Un resumen estadístico informativo para tablas 2x2 es el \emph{riesgo relativo} (\emph{odds ratio} en inglés). Definan las dos variables como \(X = 1\) si eres hombre y 0 de lo contrario, e \(Y=1\) si recibe financiamiento y 0 de lo contrario. Las probabilidades de obtener fondos si eres hombre se definen así:

\[\mbox{Pr}(Y=1 \mid X=1)/ \mbox{Pr}(Y=0 \mid X=1)\]

y se pueden calcular así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{odds\_men }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(two\_by\_two, (men[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(men))}\SpecialCharTok{/}\NormalTok{ (men[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(men)))}
\NormalTok{odds\_men}
\CommentTok{\#\textgreater{} [1] 0.216}
\end{Highlighting}
\end{Shaded}

Y las probabilidades de recibir financiamiento si eres mujer son:

\[\mbox{Pr}(Y=1 \mid X=0)/ \mbox{Pr}(Y=0 \mid X=0)\]

y se pueden calcular así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{odds\_women }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(two\_by\_two, (women[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(women))}\SpecialCharTok{/}\NormalTok{ (women[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(women)))}
\NormalTok{odds\_women}
\CommentTok{\#\textgreater{} [1] 0.175}
\end{Highlighting}
\end{Shaded}

El riesgo relativo es la razón de estas dos probabilidades: ¿cuántas veces más grandes son las probabilidades para los hombres que para las mujeres?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{odds\_men}\SpecialCharTok{/}\NormalTok{ odds\_women}
\CommentTok{\#\textgreater{} [1] 1.23}
\end{Highlighting}
\end{Shaded}

A menudo vemos tablas de 2x2 escritas usando \(a\), \(b\), \(c\), y \(d\) como en la siguiente tabla. En este caso, el riesgo relativo es \(\frac{a/c}{b/d}\) que es equivalente a \((ad)/ (bc)\).

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lcc}
\toprule
  & Men & Women\\
\midrule
Awarded & a & b\\
Not Awarded & c & d\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

\hypertarget{intervalos-de-confianza-para-el-riesgo-relativo}{%
\subsection{Intervalos de confianza para el riesgo relativo}\label{intervalos-de-confianza-para-el-riesgo-relativo}}

Calcular intervalos de confianza para el riesgo relativo no es matemáticamente sencillo. A diferencia de otras estadísticas, para las cuales podemos derivar aproximaciones útiles de sus distribuciones, el riesgo relativo no es solo una razón, sino una razón de razones. Por lo tanto, no hay una forma sencilla de utilizar, por ejemplo, el CLT.

Sin embargo, la teoría estadística nos dice que cuando las cuatro entradas de la tabla 2x2 son lo suficientemente grandes, entonces el logaritmo del riesgo relativo es aproximadamente normal con error estándar:

\[
\sqrt{1/a + 1/b + 1/c + 1/d}
\]

Esto implica que un intervalo de confianza de 95\% para el logaritmo del riesgo relativo se puede formar por:

\[
\log\left(\frac{ad}{bc}\right) \pm 1.96 \sqrt{1/a + 1/b + 1/c + 1/d}
\]

Exponenciando estos dos números podemos construir un intervalo de confianza del riesgo relativo.

Usando R, podemos calcular este intervalo de confianza de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log\_or }\OtherTok{\textless{}{-}} \FunctionTok{log}\NormalTok{(odds\_men}\SpecialCharTok{/}\NormalTok{ odds\_women)}
\NormalTok{se }\OtherTok{\textless{}{-}}\NormalTok{ two\_by\_two }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{awarded) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{se =} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{men) }\SpecialCharTok{+} \FunctionTok{sum}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{women))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(se)}
\NormalTok{ci }\OtherTok{\textless{}{-}}\NormalTok{ log\_or }\SpecialCharTok{+} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{) }\SpecialCharTok{*} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{) }\SpecialCharTok{*}\NormalTok{ se}
\end{Highlighting}
\end{Shaded}

Si queremos convertirlo de nuevo a la escala de riesgo relativo, podemos exponenciar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(ci)}
\CommentTok{\#\textgreater{} [1] 1.00 1.51}
\end{Highlighting}
\end{Shaded}

Observen que 1 no está incluido en el intervalo de confianza, lo que significa que el valor-p es menor que 0.05. Podemos confirmar esto usando:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(log\_or, }\DecValTok{0}\NormalTok{, se))}
\CommentTok{\#\textgreater{} [1] 0.0454}
\end{Highlighting}
\end{Shaded}

Este es un valor-p un poco diferente al de la prueba de chi-cuadrado. Esto se debe a que estamos utilizando una aproximación asintótica diferente a la distribución nula. Para obtener más información sobre la inferencia y la teoría asintótica del riesgo relativo, consulten el libro \emph{Generalized Linear Models} de McCullagh y Nelder.

\hypertarget{correcciuxf3n-de-recuento-pequeuxf1o}{%
\subsection{Corrección de recuento pequeño}\label{correcciuxf3n-de-recuento-pequeuxf1o}}

Si cualquiera de las celdas de la tabla 2x2 es 0, el logaritmo del riesgo relativo es indefinido. Esto se debe a que si \(a\), \(b\), \(c\) o \(d\) es 0, el \(\log(\frac{ad}{bc})\) es el logaritmo de 0 o tiene un 0 en el denominador. Para esta situación, es una práctica común evitar los 0 añadiendo 0.5 a cada celda. Esto se conoce como la \emph{corrección de Haldane-Anscombe} y se ha demostrado, tanto en la práctica como en la teoría, que funciona bien.

\hypertarget{muestras-grandes-valores-p-pequeuxf1os}{%
\subsection{Muestras grandes, valores-p pequeños}\label{muestras-grandes-valores-p-pequeuxf1os}}

Como se mencionó anteriormente, informar solo valores-p no es una forma apropiada de informar los resultados del análisis de datos. En revistas científicas, por ejemplo, algunos estudios parecen enfatizar demasiado los valores-p.~Algunos de estos estudios tienen muestras de gran tamaño e indican valores-p impresionantemente pequeños. Sin embargo, cuando uno mira de cerca los resultados, se da cuenta que los riesgos relativos son pequeños: apenas mayores que 1. En este caso, la diferencia puede que no sea \emph{prácticamente significativa} o \emph{científicamente significativa}.

Tengan en cuenta que la relación entre el riesgo relativo y el valor-p no es una correspondencia uno-a-uno. La relacion depende del tamaño de la muestra. Por lo tanto, un valor-p muy pequeño no necesariamente significa un riesgo relativo muy grande. Observen lo que sucede con el valor-p si multiplicamos nuestra tabla 2x2 por 10, lo cual no cambia el riesgo relativo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{two\_by\_two }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{awarded) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{men =}\NormalTok{ men}\SpecialCharTok{*}\DecValTok{10}\NormalTok{, }\AttributeTok{women =}\NormalTok{ women}\SpecialCharTok{*}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{chisq.test}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .}\SpecialCharTok{$}\NormalTok{p.value}
\CommentTok{\#\textgreater{} [1] 2.63e{-}10}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-29}{%
\section{Ejercicios}\label{ejercicios-29}}

1. Una atleta famosa tiene una carrera impresionante, ganando 70\% de los 500 partidos de su carrera. Sin embargo, critican a esta atleta porque en eventos importantes, como los Juegos Olímpicos, tiene un récord perdedor de 8 victorias y 9 derrotas. Realice una prueba de chi-cuadrado para determinar si este récord se debe simplemente al azar en vez de no competir bien bajo presión.

2. ¿Por qué usamos la prueba de chi-cuadrado en lugar de la prueba exacta de Fisher en el ejercicio anterior?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Realmente no importa ya que dan exactamente el mismo valor-p.
\item
  La prueba exacta de Fisher y la de chi-cuadrado son nombres diferentes para la misma prueba.
\item
  Debido a que la suma de las filas y columnas de la tabla 2x2 no son fijas, la distribución hipergeométrica no es una suposición apropiada para la hipótesis nula. Por esta razón, la prueba exacta de Fisher rara vez es aplicable a datos observacionales.
\item
  Porque la prueba de chi-cuadrado se ejecuta más rápido.
\end{enumerate}

3. Calcule el riesgo relativo de ``perder bajo presión'' junto con un intervalo de confianza.

4. Observe que el valor-p es mayor que 0.05, pero el intervalo de confianza de 95\% no incluye 1. ¿Qué explica esto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Cometimos un error en nuestro código.
\item
  Estas no son estadísticas t, por lo que no aplica la conexión entre el valor-p y los intervalos de confianza.
\item
  Se utilizan diferentes aproximaciones para el valor-p y el cálculo del intervalo de confianza. Si tuviéramos un tamaño de muestra más grande, la coincidencia sería mejor.
\item
  Deberíamos usar la prueba exacta de Fisher para obtener intervalos de confianza.
\end{enumerate}

5. Multiplique la tabla 2x2 por dos y vea si el valor-p y el intervalo de confianza coinciden mejor.

\hypertarget{models}{%
\chapter{Modelos estadísticos}\label{models}}

\begin{quote}
\begin{quote}
``Todos los modelos están equivocados, pero algunos son útiles.'' --George E. P. Box
\end{quote}
\end{quote}

El día antes de las elecciones presidenciales del 2008, FiveThirtyEight de Nate Silver declaró que ``Barack Obama parece estar listo para una victoria electoral decisiva''. Fueron hasta más lejos y predijeron que Obama ganaría las elecciones con 349 votos electorales a 189 y el voto popular por un margen de 6.1\%. FiveThirtyEight también añadió una declaración probabilística a su predicción declarando que Obama tenía una probablidad de 91\% de ganar las elecciones. Las predicciones fueron bastante precisas y, en los resultados finales, Obama ganó el colegio electoral 365 a 173 y el voto popular por una diferencia de 7.2\%. El desempeño de FiveThirtyEight en las elecciones del 2008 atrajo la atención de expertos políticos y personalidades de la televisión. Cuatro años después, la semana antes de las elecciones presidenciales del 2012, Nate Silver de FiveThirtyEight le estaba dando a Obama una probabilidad de 90\% de ganar a pesar de que muchos de los expertos pensaban que los resultados finales estarían más cerca. El comentarista político Joe Scarborough dijo durante su show\footnote{\url{https://www.youtube.com/watch?v=TbKkjm-gheY}}:

\begin{quote}
\begin{quote}
Cualquiera que piense que esta elección no está cerrada en este momento es un tremendo ideólogo \ldots{} son un chiste.
\end{quote}
\end{quote}

A lo que Nate Silver respondió a través de Twitter:

\begin{quote}
\begin{quote}
Si cree que la elección está cerrada, apostemos. Si Obama gana, Ud. dona \$1,000 a la Cruz Roja Americana. Si Romney gana, yo lo hago. ¿De acuerdo?
\end{quote}
\end{quote}

En 2016, Silver no estaba tan seguro y le dio a Hillary Clinton solo una probabilidad de 71\% de ganar. En cambio, la mayoría de los otros pronosticadores estaban casi seguros de que ella ganaría. Ella perdió. Pero 71\% sigue siendo más de 50\%, ¿se equivocó el Sr.~Silver? Además, ¿qué significa la probabilidad en este contexto? ¿Alguien está tirando dados?

En este capítulo demostraremos cómo los \emph{agregadores de encuestas}, como FiveThirtyEight, recopilaron y combinaron datos informados por diferentes expertos para producir mejores predicciones. Presentaremos las ideas detrás de los \emph{modelos estadísticos}, también conocidos como \emph{modelos de probabilidad}, que utilizaron los agregadores de encuestas para mejorar los pronósticos electorales en comparación a las encuestas individuales. En este capítulo, motivamos los modelos, construyendo sobre los conceptos de inferencia estadística que aprendimos en el Capítulo \ref{inference}. Comenzamos con modelos relativamente sencillos, tomando en cuenta que el ejercicio real de la ciencia de datos de pronosticar elecciones involucra algunos modelos bastante complejos, que presentamos al final del capítulo en la Sección \ref{election-forecasting}.

\hypertarget{agregadores-de-encuestas}{%
\section{Agregadores de encuestas}\label{agregadores-de-encuestas}}

Como describimos anteriormente, unas semanas antes de las elecciones del 2012, Nate Silver le estaba dando a Obama una probabilidad de 90\% de ganar. ¿Por qué tenía tanta confianza el señor Silver? Utilizaremos una simulación Monte Carlo para ilustrar la idea que tuvo el Sr.~Silver y que otros no vieron. Para hacer esto, generamos resultados para 12 encuestas realizadas la semana anterior a las elecciones. Imitaremos tamaños de muestra de encuestas reales y construiremos e informaremos intervalos de confianza de 95\% para cada una de las 12 encuestas. Guardaremos los resultados de esta simulación en un set de datos y añadiremos una columna de ID de encuesta.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{d }\OtherTok{\textless{}{-}} \FloatTok{0.039}
\NormalTok{Ns }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1298}\NormalTok{, }\DecValTok{533}\NormalTok{, }\DecValTok{1342}\NormalTok{, }\DecValTok{897}\NormalTok{, }\DecValTok{774}\NormalTok{, }\DecValTok{254}\NormalTok{, }\DecValTok{812}\NormalTok{, }\DecValTok{324}\NormalTok{, }\DecValTok{1291}\NormalTok{, }\DecValTok{1056}\NormalTok{, }\DecValTok{2172}\NormalTok{, }\DecValTok{516}\NormalTok{)}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ (d }\SpecialCharTok{+} \DecValTok{1}\NormalTok{)}\SpecialCharTok{/} \DecValTok{2}

\NormalTok{polls }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(Ns, }\ControlFlowTok{function}\NormalTok{(N) \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\AttributeTok{size=}\NormalTok{N, }\AttributeTok{replace=}\ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p, p))}
\NormalTok{  x\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(x)}
\NormalTok{  se\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(x\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ x\_hat)}\SpecialCharTok{/}\NormalTok{ N)}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{estimate =} \DecValTok{2} \SpecialCharTok{*}\NormalTok{ x\_hat }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{,}
       \AttributeTok{low =} \DecValTok{2}\SpecialCharTok{*}\NormalTok{(x\_hat }\SpecialCharTok{{-}} \FloatTok{1.96}\SpecialCharTok{*}\NormalTok{se\_hat) }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{,}
       \AttributeTok{high =} \DecValTok{2}\SpecialCharTok{*}\NormalTok{(x\_hat }\SpecialCharTok{+} \FloatTok{1.96}\SpecialCharTok{*}\NormalTok{se\_hat) }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{,}
       \AttributeTok{sample\_size =}\NormalTok{ N)}
\NormalTok{\}) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{poll =} \FunctionTok{seq\_along}\NormalTok{(Ns))}
\end{Highlighting}
\end{Shaded}

Aquí tenemos una visualización que muestra los intervalos que los encuestadores reportaron para la diferencia entre Obama y Romney:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-polls-1} \end{center}

No es sorprendente que las 12 encuestas informen intervalos de confianza que incluyen el resultado de la noche electoral (línea discontinua). Sin embargo, las 12 encuestas también incluyen 0 (línea negra sólida). Por lo tanto, si se les pide individualmente una predicción, los encuestadores tendrían que decir: las probabilidades están parejas. A continuación describimos una idea clave que no consideraron.

Los agregadores de encuestas, como Nate Silver, se dieron cuenta de que al combinar los resultados de diferentes encuestas, la precisión podría mejorar enormemente. Al hacer esto, estamos llevando a cabo una encuesta con un gran tamaño de muestra. Por lo tanto, podemos informar un intervalo de confianza menor de 95\% y una predicción más precisa.

Aunque como agregadores no tenemos acceso a los datos sin procesar de la encuesta, podemos usar las matemáticas para reconstruir lo que habríamos obtenido si hubiéramos hecho una encuesta grande con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(polls}\SpecialCharTok{$}\NormalTok{sample\_size)}
\CommentTok{\#\textgreater{} [1] 11269}
\end{Highlighting}
\end{Shaded}

participantes. Básicamente, construimos un estimador de la diferencia, llamémosla \(d\), con un promedio ponderado de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_hat }\OtherTok{\textless{}{-}}\NormalTok{ polls }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{sum}\NormalTok{(estimate}\SpecialCharTok{*}\NormalTok{sample\_size)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(sample\_size)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(avg)}
\end{Highlighting}
\end{Shaded}

Una vez que tengamos un estimador de \(d\), podemos construir un estimador de la proporción votando por Obama, que luego podemos usar para estimar el error estándar. Tan pronto hacemos esto, vemos que nuestro margen de error es 0.018.

Por lo tanto, podemos predecir que la diferencia será 3.1 más o menos 1.8, que no solo incluye el resultado real que observamos en la noche de las elecciones, sino que está bastante lejos de incluir 0. Al combinar las 12 encuestas, acabamos seguros de que Obama ganará el voto popular.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/confidence-coverage-2008-election-1} \end{center}

Por supuesto, esto fue solo una simulación para ilustrar la idea. El ejercicio real de la ciencia de datos de pronosticar elecciones es mucho más complicado y requiere modelos estadísticos. A continuación explicamos cómo los encuestadores ajustan los modelos multinivel a los datos y los utilizan para pronosticar los resultados electorales. En las elecciones presidenciales estadounidensas del 2008 y 2012, Nate Silver utilizó este enfoque para hacer una predicción casi perfecta y callar a los expertos.

Desde las elecciones del 2008, otras organizaciones han establecido sus propios grupos de pronóstico de elecciones que, como el de Nate Silver, agrega datos de encuestas y utiliza modelos estadísticos para hacer predicciones. En 2016, los pronosticadores subestimaron por mucho las posibilidades de Trump de ganar. El día antes de las elecciones, el \emph{New York Times} informó\footnote{\url{https://www.nytimes.com/interactive/2016/upshot/presidential-polls-forecast.html}} las siguientes probabilidades de que Hillary Clinton ganara la presidencia:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lllllllll}
\toprule
  & NYT & 538 & HuffPost & PW & PEC & DK & Cook & Roth\\
\midrule
Win Prob & 85\% & 71\% & 98\% & 89\% & >99\% & 92\% & Lean Dem & Lean Dem\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Por ejemplo, el Consorcio Electoral de Princeton (\emph{Princeton Election Consortium} en inglés) le dio a Trump menos de 1\% de probabilidad de ganar, mientras que el \emph{Huffington Post} le dio una probabilidad de 2\%. Por el contrario, FiveThirtyEight le daba a Trump una probabilidad de ganar de 29\%, más que la probabilidad de lanzar dos monedas y obtener dos caras. De hecho, cuatro días antes de las elecciones, FiveThirtyEight publicó un artículo titulado \emph{Trump is Just A Normal Polling Error Behind Clinton}\footnote{\url{https://fivethirtyeight.com/features/trump-is-just-a-normal-polling-error-behind-Clinton/}}.
Al entender los modelos estadísticos y cómo los pronosticadores los usan, comenzaremos a entender cómo sucedió esto.

Aunque no tan interesante como predecir el colegio electoral, para fines ilustrativos comenzaremos analizando las predicciones para el voto popular. FiveThirtyEight predijo una ventaja de 3.6\% para Clinton\footnote{\url{https://projects.fivethirtyeight.com/2016-election-forecast/}} y su intervalo de confianza incluyó el resultado real de una diferencia de 2.1\% (48.2\% a 46.1\%). Además, FiveThirtyEight estuvo mucho más seguro sobre la posibilidad de que Clinton ganara el voto popular, dándole una probabilidad de 81.4\%. Su predicción se resumió con un gráfico como este:

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/fivethirtyeight-densities-1} \end{center}

Las áreas coloreadas representan valores con una probabilidad de 80\% de incluir el resultado real, según el modelo de FiveThirtyEight.

Presentamos datos reales de las elecciones presidenciales de EE. UU. del 2016 para mostrar cómo se motivan y se contruyen los modelos para producir estas predicciones. Para comprender la declaración ``81.4\% de probabilidad'', necesitamos describir las estadísticas bayesianas, lo que hacemos en las Secciones \ref{bayesian-statistics} y \ref{bayesian-approach}.

\hypertarget{datos-de-encuesta}{%
\subsection{Datos de encuesta}\label{datos-de-encuesta}}

Utilizamos datos públicos de encuestas organizados por FiveThirtyEight para las elecciones presidenciales del 2016. Los datos se incluyen como parte del paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(polls\_us\_election\_2016)}
\end{Highlighting}
\end{Shaded}

La tabla incluye los resultados de las encuestas nacionales, así como las encuestas estatales, tomadas durante el año anterior a la elección. Para este primer ejemplo, filtraremos los datos para incluir encuestas nacionales realizadas durante la semana previa a las elecciones. También eliminamos las encuestas que FiveThirtyEight ha determinado que no son confiables y calificaron con una ``B'' o menos. Algunas encuestas no han sido calificadas e incluimos aquellas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{==} \StringTok{"U.S."} \SpecialCharTok{\&}\NormalTok{ enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}
\NormalTok{           (grade }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"A+"}\NormalTok{,}\StringTok{"A"}\NormalTok{,}\StringTok{"A{-}"}\NormalTok{,}\StringTok{"B+"}\NormalTok{) }\SpecialCharTok{|} \FunctionTok{is.na}\NormalTok{(grade)))}
\end{Highlighting}
\end{Shaded}

Agregamos el estimador de la diferencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para este ejemplo, suponemos que solo hay dos partes y llamaremos \(p\) a la proporción de votos para Clinton y \(1-p\) a la proporción votando por Trump. Estamos interesados en la diferencia \(2p-1\). Llamemos a la diferencia \(d\).

Tenemos 49 estimadores de la diferencia. La teoría que aprendimos nos dice que estos estimadores son una variable aleatoria con una distribución de probabilidad que es aproximadamente normal. El valor esperado es la diferencia de la noche electoral \(d\) y el error estándar es \(2\sqrt{p (1 - p)/ N}\). Suponiendo que el modelo de urna que describimos anteriormente es bueno, podemos usar esta información para construir un intervalo de confianza basado en los datos agregados. El estimador de la diferencia es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_hat }\OtherTok{\textless{}{-}}\NormalTok{ polls }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{d\_hat =} \FunctionTok{sum}\NormalTok{(spread }\SpecialCharTok{*}\NormalTok{ samplesize)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(samplesize)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(d\_hat)}
\end{Highlighting}
\end{Shaded}

y el error estándar es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_hat }\OtherTok{\textless{}{-}}\NormalTok{ (d\_hat}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)}\SpecialCharTok{/}\DecValTok{2}
\NormalTok{moe }\OtherTok{\textless{}{-}} \FloatTok{1.96} \SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(p\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ p\_hat)}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(polls}\SpecialCharTok{$}\NormalTok{samplesize))}
\NormalTok{moe}
\CommentTok{\#\textgreater{} [1] 0.00662}
\end{Highlighting}
\end{Shaded}

Entonces informamos una diferencia de 1.43\% con un margen de error de 0.66\%. En la noche de las elecciones, descubrimos que el porcentaje real era 2.1\%, que está fuera de un intervalo de confianza de 95\%. ¿Que pasó?

Un histograma de las variabilidades reportadas muestra un problema:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(spread)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{color=}\StringTok{"black"}\NormalTok{, }\AttributeTok{binwidth =}\NormalTok{ .}\DecValTok{01}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2016-spread-histogram-1} \end{center}

Los datos no parecen estar distribuidos normalmente y el error estándar parece ser mayor que 0.007. La teoría no está funcionando bien aquí.

\hypertarget{sesgo-de-los-encuestadores}{%
\subsection{Sesgo de los encuestadores}\label{sesgo-de-los-encuestadores}}

Observen que varios encuestadores están involucrados y algunos toman varias encuestas por semana:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(pollster) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\FunctionTok{n}\NormalTok{())}
\CommentTok{\#\textgreater{} \# A tibble: 15 x 2}
\CommentTok{\#\textgreater{}   pollster                                                   \textasciigrave{}n()\textasciigrave{}}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}                                                      \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 ABC News/Washington Post                                       7}
\CommentTok{\#\textgreater{} 2 Angus Reid Global                                              1}
\CommentTok{\#\textgreater{} 3 CBS News/New York Times                                        2}
\CommentTok{\#\textgreater{} 4 Fox News/Anderson Robbins Research/Shaw \& Company Research     2}
\CommentTok{\#\textgreater{} 5 IBD/TIPP                                                       8}
\CommentTok{\#\textgreater{} \# ... with 10 more rows}
\end{Highlighting}
\end{Shaded}

Visualicemos los datos de los encuestadores que sondean regularmente:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pollster-bias-1} \end{center}

Este gráfico revela un resultado inesperado. Primero, consideren que el error estándar predicho por la teoría para cada encuesta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(pollster) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{se =} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(p\_hat }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p\_hat)}\SpecialCharTok{/} \FunctionTok{median}\NormalTok{(samplesize)))}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 2}
\CommentTok{\#\textgreater{}   pollster                     se}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}                     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 ABC News/Washington Post 0.0265}
\CommentTok{\#\textgreater{} 2 IBD/TIPP                 0.0333}
\CommentTok{\#\textgreater{} 3 Ipsos                    0.0225}
\CommentTok{\#\textgreater{} 4 The Times{-}Picayune/Lucid 0.0196}
\CommentTok{\#\textgreater{} 5 USC Dornsife/LA Times    0.0183}
\end{Highlighting}
\end{Shaded}

está entre 0.018 y 0.033, que concuerda con la variación de encuesta a encuesta que vemos para cada encuestador. Sin embargo, parece haber diferencias \emph{entre los encuestadores}. Observen, por ejemplo, cómo el encuestador USC Dornsife/LA Times predice una ventaja de 4\% para Trump, mientras que Ipsos predice una ventaja mayor de 5\% para Clinton. La teoría que aprendimos no dice nada acerca de diferentes encuestadores que producen encuestas con diferentes valores esperados. Todas las encuestas deben tener el mismo valor esperado. FiveThirtyEight se refiere a estas diferencias como ``house effects''. También las llamamos \emph{sesgo de encuestadores}.

En la siguiente sección, en lugar de utilizar la teoría del modelo de urna, desarrollaremos un modelo basado en datos.

\hypertarget{data-driven-model}{%
\section{Modelos basados en datos}\label{data-driven-model}}

Para cada encuestador, recopilemos el último resultado que informan antes de las elecciones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_poll\_per\_pollster }\OtherTok{\textless{}{-}}\NormalTok{ polls }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(pollster) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(enddate }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(enddate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Aquí hay un histograma de los datos para estos 15 encuestadores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(spread, }\AttributeTok{data =}\NormalTok{ one\_poll\_per\_pollster, }\AttributeTok{binwidth =} \FloatTok{0.01}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pollster-bias-histogram-1} \end{center}

En la sección anterior, vimos que usar la teoría del modelo de urna para combinar estos resultados a veces no es apropiado debido al efecto de encuestador. En cambio, modelaremos estos datos de las diferencias directamente.

El nuevo modelo también puede considerarse como un modelo de urna, aunque la conexión no es tan directa. En lugar de 0s (republicanos) y 1s (demócratas), nuestra urna ahora contiene los resultados de las encuestas de todos los posibles encuestadores. Suponemos que el valor esperado de nuestra urna es la diferencia real \(d=2p-1\).

Dado que en lugar de 0s y 1s, nuestra urna contiene números continuos entre -1 y 1, la desviación estándar de la urna ya no es \(\sqrt{p(1-p)}\). En vez de la variabilidad del muestreo de votantes, el error estándar ahora incluye la variabilidad entre encuestadores. Nuestra nueva urna también incluye la variabilidad de muestreo del sondeo. De cualquier manera, esta desviación estándar ahora es un parámetro desconocido. En los libros de texto de estadística, el símbolo griego \(\sigma\) se usa para representar este parámetro.

En resumen, tenemos dos parámetros desconocidos: el valor esperado \(d\) y la desviación estándar \(\sigma\).

Nuestra tarea es estimar \(d\). Como modelamos los valores observados \(X_1,\dots X_N\) como una muestra aleatoria de la urna, el CLT aún podría funcionar en esta situación porque es un promedio de variables aleatorias independientes. Para un tamaño de muestra suficientemente grande \(N\), la distribución de probabilidad del promedio de la muestra \(\bar{X}\) es aproximadamente normal con valor esperado \(\mu\) y error estándar \(\sigma/\sqrt{N}\). Si estamos dispuestos a considerar \(N=15\) como suficientemente grande, podemos usar esto para construir intervalos de confianza.

Un problema es que no sabemos \(\sigma\). Pero la teoría nos dice que podemos estimar el modelo de urna \(\sigma\) con la \emph{desviación estándar de la muestra} definida como
\(s = \sqrt{ \sum_{i=1}^N (X_i - \bar{X})^2/ (N-1)}\).

A diferencia de la definición de desviación estándar de la población, ahora dividimos por \(N-1\). Esto hace \(s\) un mejor estimador de \(\sigma\). Hay una explicación matemática para esto, que se enseña en la mayoría de los libros de texto de estadística, pero no la cubrimos aquí.

En R, la función \texttt{sd} calcula la desviación estándar de la muestra:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(one\_poll\_per\_pollster}\SpecialCharTok{$}\NormalTok{spread)}
\CommentTok{\#\textgreater{} [1] 0.0242}
\end{Highlighting}
\end{Shaded}

Ahora estamos listos para formar un nuevo intervalo de confianza basado en nuestro nuevo modelo y en datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results }\OtherTok{\textless{}{-}}\NormalTok{ one\_poll\_per\_pollster }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(spread),}
            \AttributeTok{se =} \FunctionTok{sd}\NormalTok{(spread)}\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{length}\NormalTok{(spread))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{start =}\NormalTok{ avg }\SpecialCharTok{{-}} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se,}
         \AttributeTok{end =}\NormalTok{ avg }\SpecialCharTok{+} \FloatTok{1.96} \SpecialCharTok{*}\NormalTok{ se)}
\FunctionTok{round}\NormalTok{(results }\SpecialCharTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{}   avg  se start end}
\CommentTok{\#\textgreater{} 1 2.9 0.6   1.7 4.1}
\end{Highlighting}
\end{Shaded}

Nuestro intervalo de confianza ahora es más amplio ya que incorpora la variabilidad de encuestador. Incluye el resultado de la noche electoral de 2.1\%. Además, observen que era lo suficientemente pequeño como para no incluir 0, lo que significa que estábamos seguros de que Clinton ganaría el voto popular.

¿Estamos listos ahora para declarar una probabilidad de que Clinton gane el voto popular? Aún no. En nuestro modelo, \(d\) es un parámetro fijo, por lo que no podemos hablar de probabilidades. Para ofrecer probabilidades, necesitaremos aprender sobre las estadísticas bayesianas.

\hypertarget{ejercicios-30}{%
\section{Ejercicios}\label{ejercicios-30}}

Hemos estado utilizando modelos de urna para motivar el uso de modelos de probabilidad. La mayoría de las aplicaciones de ciencia de datos no están relacionadas con datos obtenidos de urnas. Más comunes son los datos que provienen de individuos. La razón por la que la probabilidad importa aquí es porque los datos provienen de una muestra aleatoria. La muestra aleatoria se toma de una población y la urna sirve como analogía para la población.

Volvamos al set de datos de alturas. Suponga que consideramos a los varones de nuestra clase como la población.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(height)}
\end{Highlighting}
\end{Shaded}

1. Matemáticamente hablando, \texttt{x} es nuestra población. Usando la analogía de la urna, tenemos una urna con los valores de \texttt{x} dentro de ella. ¿Cuáles son el promedio y la desviación estándar de nuestra población?

2. Llame al promedio de población calculado arriba \(\mu\) y la desviación estándar \(\sigma\). Ahora tome una muestra de tamaño 50, con reemplazo, y construya un estimador para \(\mu\) y \(\sigma\).

3. ¿Qué nos dice la teoría sobre el promedio de la muestra \(\bar{X}\) y como se relaciona con \(\mu\)?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Es prácticamente idéntico a \(\mu\).
\item
  Es una variable aleatoria con valor esperado \(\mu\) y error estándar \(\sigma/\sqrt{N}\).
\item
  Es una variable aleatoria con valor esperado \(\mu\) y error estándar \(\sigma\).
\item
  No contiene información.
\end{enumerate}

4. Entonces, ¿cómo es esto útil? Vamos a utilizar un ejemplo simplificado pero ilustrativo. Suponga que queremos saber la altura promedio de nuestros estudiantes varones, pero solo llegamos a medir 50 de los 708. Usaremos \(\bar{X}\) como nuestro estimador. Sabemos por la respuesta al ejercicio 3 que el estimador estándar de nuestro error \(\bar{X}-\mu\) es \(\sigma/\sqrt{N}\). Queremos calcular esto, pero no sabemos \(\sigma\). Según lo que se describe en esta sección, indique su estimador de \(\sigma\).

5. Ahora que tenemos un estimador de \(\sigma\), llamemos a nuestro estimador \(s\). Construya un intervalo de confianza de 95\% para \(\mu\).

6. Ahora ejecute una simulación Monte Carlo en la que calcula 10,000 intervalos de confianza como acaba de hacer. ¿Qué proporción de estos intervalos incluye \(\mu\)?

7. En esta sección, discutimos el sesgo de encuestador. Utilizamos la visualización para motivar la presencia de tal sesgo. Aquí le daremos un tratamiento más riguroso. Consideraremos dos encuestadores que realizaron encuestas diarias. Examinaremos las encuestas nacionales del mes anterior a las elecciones.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(polls\_us\_election\_2016)}
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(pollster }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Rasmussen Reports/Pulse Opinion Research"}\NormalTok{,}
                         \StringTok{"The Times{-}Picayune/Lucid"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{           enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}15"} \SpecialCharTok{\&}
\NormalTok{           state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Queremos contestar la pregunta: ¿hay un sesgo en la encuesta? Haga un gráfico que muestre la diferencia para cada encuesta.

8. Los datos parecen sugerir que hay una diferencia. Sin embargo, estos datos están sujetos a variabilidad. Quizás las diferencias que observamos se deben al azar.

La teoría del modelo de urna no dice nada sobre el efecto del encuestador. Bajo el modelo de urna, ambos encuestadores tienen el mismo valor esperado: la diferencia del día de las elecciones, que llamamos \(d\).

Para responder a la pregunta ``¿hay un modelo de urna?'', modelaremos los datos observados \(Y_{i,j}\) de la siguiente manera:

\[
Y_{i,j} = d + b_i + \varepsilon_{i,j}
\]

con \(i=1,2\) indexando los dos encuestadores, \(b_i\) el sesgo para el encuestador \(i\) y \(\varepsilon_{ij}\) representando la variabilidad aleatoria de las encuestas. Suponemos que los \(\varepsilon\) son independientes entre sí, tienen valor esperado \(0\) y desviación estándar \(\sigma_i\) independientemente de \(j\).

¿Cuál de las siguientes mejor representa nuestra pregunta?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  ¿Es \(\varepsilon_{i,j}\) = 0?
\item
  ¿Cuán cerca están los \(Y_{i,j}\) a \(d\)?
\item
  ¿Es \(b_1 \neq b_2\)?
\item
  ¿Son \(b_1 = 0\) y \(b_2 = 0\)?
\end{enumerate}

9. En el lado derecho de este modelo solo \(\varepsilon_{i,j}\) es una variable aleatoria. Los otros dos son constantes. ¿Cuál es el valor esperado de \(Y_{1,j}\)?

10. Suponga que definimos \(\bar{Y}_1\) como el promedio de los resultados de la encuesta del primer encuestador, \(Y_{1,1},\dots,Y_{1,N_1}\) con \(N_1\) el número de encuestas realizadas por el primer encuestador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(pollster}\SpecialCharTok{==}\StringTok{"Rasmussen Reports/Pulse Opinion Research"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{N\_1 =} \FunctionTok{n}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

¿Cuál es el valor esperado de \(\bar{Y}_1\)?

11. ¿Cuál es el error estándar de \(\bar{Y}_1\) ?

12. Suponga que definimos \(\bar{Y}_2\) como el promedio de los resultados de la encuesta de la primera encuesta, \(Y_{2,1},\dots,Y_{2,N_2}\) con \(N_2\) el número de encuestas realizadas por el primer encuestador. ¿Cuál es el valor esperado \(\bar{Y}_2\)?

13. ¿Cuál es el error estándar de \(\bar{Y}_2\) ?

14. Usando lo que aprendimos al responder a las preguntas anteriores, ¿cuál es el valor esperado de \(\bar{Y}_{2} - \bar{Y}_1\)?

15. Usando lo que aprendimos al responder a las preguntas anteriores, ¿cuál es el error estándar de \(\bar{Y}_{2} - \bar{Y}_1\)?

16. La respuesta a la pregunta anterior depende de \(\sigma_1\) y \(\sigma_2\), que no sabemos. Aprendimos que podemos estimarlos con la desviación estándar de la muestra. Escriba un código que calcule estos dos estimadores.

17. ¿Qué nos dice el CLT sobre la distribución de \(\bar{Y}_2 - \bar{Y}_1\)?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Nada porque este no es el promedio de una muestra.
\item
  Como el \(Y_{ij}\) son aproximadamente normales, también lo son los promedios.
\item
  Como \(\bar{Y}_2\) y \(\bar{Y}_1\) son promedios de muestras, si suponemos que \(N_2\) y \(N_1\) son lo suficientemente grandes, cada uno es aproximadamente normal. La diferencia de normales también es normal.
\item
  Los datos no son 0 o 1, por lo que el CLT no se aplica.
\end{enumerate}

18. Hemos construido una variable aleatoria que tiene un valor esperado \(b_2 - b_1\), la diferencia de sesgo del encuestador. Si nuestro modelo funciona, entonces esta variable aleatoria tiene una distribución aproximadamente normal y sabemos su error estándar. El error estándar depende de \(\sigma_1\) y \(\sigma_2\), pero podemos usar las desviaciones estándar de muestra que calculamos anteriormente. Comenzamos preguntando: ¿\(b_2 - b_1\) es diferente de 0? Use toda la información que hemos aprendido anteriormente para construir un intervalo de confianza de 95\% para la diferencia \(b_2\) y \(b_1\).

19. El intervalo de confianza nos dice que hay un efecto encuestador relativamente fuerte que resulta en una diferencia de aproximadamente 5\%. La variabilidad aleatoria no parece explicarlo. Podemos calcular un valor-p para explicar el hecho de que el azar no lo explica. ¿Cuál es el valor-p?

20. La estadística formada al dividir nuestro estimador de \(b_2-b_1\) por su error estándar estimado:

\[
\frac{\bar{Y}_2 - \bar{Y}_1}{\sqrt{s_2^2/N_2 + s_1^2/N_1}}
\]

se llama la estadística t. Ahora observe que tenemos más de dos encuestadores. También podemos probar para el efecto de encuestador utilizando todos los encuestadores, no solo dos. La idea es comparar la variabilidad entre encuestas con la variabilidad dentro de las encuestas. De hecho, podemos construir estadísticas para probar los efectos y aproximar su distribución. El área de estadísticas que hace esto se llama \emph{análisis de la varianza} (ANOVA por sus siglas en inglés). No lo cubrimos aquí, pero ANOVA provee un set muy útil de herramientas para responder a preguntas como: ¿hay un efecto encuestador?

Para este ejercicio, cree una nueva tabla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}15"} \SpecialCharTok{\&}
\NormalTok{           state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(pollster) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{5}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Calcule el promedio y la desviación estándar para cada encuestador y examine la variabilidad entre los promedios y cómo se compara con la variabilidad dentro de los encuestadores, resumida por la desviación estándar.

\hypertarget{bayesian-statistics}{%
\section{Estadísticas bayesianas}\label{bayesian-statistics}}

¿Qué significa que un pronosticador electoral nos diga que un candidato tiene un 90\% probabilidad de ganar? En el contexto del modelo de urna, esto sería equivalente a afirmar que la probabilidad \(p>0.5\) es 90\%. Sin embargo, como discutimos anteriormente, en el modelo de urna \(p\) es un parámetro fijo y no tiene sentido hablar de probabilidad. Con estadísticas bayesianas, modelamos \(p\) como variable aleatoria y, por lo tanto, una declaración como ``90\% probabilidad de ganar'' es coherente.

Los pronosticadores también usan modelos para describir la variabilidad en diferentes niveles. Por ejemplo, la variabilidad de muestreo, la variabilidad de encuestador a encuestador, la variabilidad diaria y la variabilidad de elección a elección. Uno de los enfoques más exitosos utilizados para esto son los modelos jerárquicos, que pueden explicarse en el contexto de las estadísticas bayesianas.

En este capítulo describimos brevemente las estadísticas bayesianas. Para una exploración más profunda de este tema, recomendamos uno de los siguientes libros de texto:

\begin{itemize}
\item
  Berger JO (1985). \emph{Statistical Decision Theory and Bayesian Analysis}, 2nd edition. Springer-Verlag.
\item
  Lee PM (1989). \emph{Bayesian Statistics: An Introduction}. Oxford.
\end{itemize}

\hypertarget{teorema-de-bayes}{%
\subsection{Teorema de Bayes}\label{teorema-de-bayes}}

Comenzamos describiendo el teorema de Bayes. Hacemos esto usando una prueba hipotética de fibrosis quística como ejemplo.
Supongan que una prueba de fibrosis quística tiene una exactitud de 99\%. Vamos a utilizar la siguiente notación:

\[
\mbox{Prob}(+ \mid D=1)=0.99, \mbox{Prob}(- \mid D=0)=0.99
\]

con \(+\) significando una prueba positiva y \(D\) representando si realmente tiene la enfermedad (1) o no (0).

Supongan que seleccionamos una persona al azar y dan positivo. ¿Cuál es la probabilidad de que tengan la enfermedad? Escribimos esto como \(\mbox{Prob}(D=1 \mid +)\). La tasa de fibrosis quística es de 1 en 3,900, lo que implica que \(\mbox{Prob}(D=1)=0.00025\). Para responder a esta pregunta, utilizaremos el teorema de Bayes, que por lo general nos dice que:

\[
\mbox{Pr}(A \mid B) = \frac{\mbox{Pr}(B \mid A)\mbox{Pr}(A)}{\mbox{Pr}(B)}
\]

Esta ecuación aplicada a nuestro problema se convierte en:

\[
\begin{aligned}
\mbox{Pr}(D=1 \mid +) & = \frac{ P(+ \mid D=1) \cdot P(D=1)} {\mbox{Pr}(+)} \\
& = \frac{\mbox{Pr}(+ \mid D=1)\cdot P(D=1)} {\mbox{Pr}(+ \mid D=1) \cdot P(D=1) + \mbox{Pr}(+ \mid D=0) \mbox{Pr}( D=0)}
\end{aligned}
\]

usando estos números obtenemos:

\[
\frac{0.99 \cdot 0.00025}{0.99 \cdot 0.00025 + 0.01 \cdot (.99975)} = 0.02
\]

Esto dice que a pesar de que la prueba tiene una precisión de 0.99, la probabilidad de tener la enfermedad dado una prueba positiva es solo 0.02. Aunque parezca contrario al sentido común, la razón de esto es porque tenemos que considerar la muy rara probabilidad de que una persona, elegida al azar, tenga la enfermedad. Para ilustrar esto, ejecutamos una simulación Monte Carlo.

\hypertarget{simulaciuxf3n-del-teorema-de-bayes}{%
\section{Simulación del teorema de Bayes}\label{simulaciuxf3n-del-teorema-de-bayes}}

La siguiente simulación está destinada a ayudarles visualizar el teorema de Bayes. Comenzamos seleccionando aleatoriamente 100,000 personas de una población en la cual la enfermedad en cuestión tiene una prevalencia de 1 en 4,000.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prev }\OtherTok{\textless{}{-}} \FloatTok{0.00025}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{100000}
\NormalTok{outcome }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Disease"}\NormalTok{,}\StringTok{"Healthy"}\NormalTok{), N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{,}
                  \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(prev, }\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ prev))}
\end{Highlighting}
\end{Shaded}

Recuerden que hay muy pocas personas con la enfermedad:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N\_D }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(outcome }\SpecialCharTok{==} \StringTok{"Disease"}\NormalTok{)}
\NormalTok{N\_D}
\CommentTok{\#\textgreater{} [1] 23}
\NormalTok{N\_H }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(outcome }\SpecialCharTok{==} \StringTok{"Healthy"}\NormalTok{)}
\NormalTok{N\_H}
\CommentTok{\#\textgreater{} [1] 99977}
\end{Highlighting}
\end{Shaded}

Además, hay muchas sin la enfermedad, lo que hace más probable que veamos algunos falsos positivos dado que la prueba no es perfecta. Ahora cada persona se hace la prueba, que acierta 99\% del tiempo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{accuracy }\OtherTok{\textless{}{-}} \FloatTok{0.99}
\NormalTok{test }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\StringTok{"character"}\NormalTok{, N)}
\NormalTok{test[outcome }\SpecialCharTok{==} \StringTok{"Disease"}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"+"}\NormalTok{, }\StringTok{"{-}"}\NormalTok{), N\_D, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{,}
                                     \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(accuracy, }\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ accuracy))}
\NormalTok{test[outcome }\SpecialCharTok{==} \StringTok{"Healthy"}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"{-}"}\NormalTok{, }\StringTok{"+"}\NormalTok{), N\_H, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{,}
                                     \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(accuracy, }\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ accuracy))}
\end{Highlighting}
\end{Shaded}

Debido a que hay muchos más controles que casos, incluso con una tasa baja de falsos positivos obtenemos más controles que los casos en el grupo que dio positivo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(outcome, test)}
\CommentTok{\#\textgreater{}          test}
\CommentTok{\#\textgreater{} outcome       {-}     +}
\CommentTok{\#\textgreater{}   Disease     0    23}
\CommentTok{\#\textgreater{}   Healthy 99012   965}
\end{Highlighting}
\end{Shaded}

De esta tabla, vemos que la proporción de pruebas positivas que tienen la enfermedad es 23 de 988. Podemos ejecutar esto una y otra vez para ver que, de hecho, la probabilidad converge a aproximadamente 0.022.

\hypertarget{bayes-en-la-pruxe1ctica}{%
\subsection{Bayes en la práctica}\label{bayes-en-la-pruxe1ctica}}

José Iglesias es un jugador de béisbol profesional. En abril de 2013, cuando comenzaba su carrera, se desempeñaba bastante bien:

\begin{longtable}[]{@{}llll@{}}
\toprule
Mes & At Bats & H & AVG \\
\midrule
\endhead
abril & 20 & 9 & .450 \\
\bottomrule
\end{longtable}

La estadística del promedio de bateo (\texttt{AVG}) es una forma de medir éxito. En términos generales, nos dice la tasa de éxito al batear. Un \texttt{AVG} de .450 significa que José ha tenido éxito el 45\% de las veces que ha bateado (\texttt{At\ Bats}) que es bastante alto, históricamente hablando. Tengan en cuenta que nadie ha terminado una temporada con un \texttt{AVG} de .400 o más desde que Ted Williams lo hizo en 1941. Para ilustrar la forma en que los modelos jerárquicos son eficaces, intentaremos predecir el promedio de bateo de José al final de la temporada. Recuerden que en una temporada típica, los jugadores tienen alrededor de 500 turnos al bate.

Con las técnicas que hemos aprendido hasta ahora, denominadas \emph{técnicas frecuentistas}, lo mejor que podemos hacer es ofrecer un intervalo de confianza. Podemos pensar en los resultados de batear como un binomio con una tasa de éxito de \(p\). Entonces, si la tasa de éxito es .450, el error estándar de solo 20 turnos al bate es:

\[
\sqrt{\frac{.450 (1-.450)}{20}}=.111
\]

Esto significa que nuestro intervalo de confianza es \(.450 - .222\) a \(.450 + .222\) o \(.228\) a \(.672\).

Esta predicción tiene dos problemas. Primero, es muy grande, por lo que no es muy útil. Segundo, está centrada en .450, lo que implica que nuestra mejor conjetura es que este nuevo jugador romperá el récord de Ted Williams.

Sin embargo, para los fanáticos del béisbol, esta última afirmación no tiene sentido. Los fanáticos implícitamente emplean un modelo jerárquico que toma en cuenta la información de años de seguir el béisbol. Aquí mostramos cómo podemos cuantificar esta intuición.

Primero, exploremos la distribución de los promedios de bateo para todos los jugadores con más de 500 turnos al bate durante las tres temporadas anteriores:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/batting-averages-histogram-1} \end{center}

El jugador promedio tuvo un \texttt{AVG} de .275 y la desviación estándar de la población de jugadores fue 0.027. Entonces podemos ver que .450 sería una anomalía, ya que está a más de seis desviaciones estándar de la media.

Entonces, ¿tiene suerte José o es el mejor bateador de los últimos 50 años? Quizás sea una combinación de suerte y talento. ¿Pero cuánto de cada uno? Si nos convencemos de que tiene suerte, deberíamos cambiarlo a otro equipo que confíe en la observación de .450 y tal vez sobreestime su potencial.

\hypertarget{modelos-jeruxe1rquicos}{%
\section{Modelos jerárquicos}\label{modelos-jeruxe1rquicos}}

El modelo jerárquico ofrece una descripción matemática de cómo llegamos a ver la observación de .450. Primero, elegimos un jugador al azar con una habilidad intrínseca resumida por, por ejemplo, \(p\). Luego vemos 20 resultados aleatorios con probabilidad de éxito \(p\).

Utilizamos un modelo para representar dos niveles de variabilidad en nuestros datos. Primero, a cada jugador se le asigna una habilidad natural para batear. Usaremos el símbolo \(p\) para representar esta habilidad. Pueden pensar en \(p\) como el promedio de bateo al que convergería si este jugador en particular bateara repetidas veces.

De acuerdo con los gráficos que mostramos anteriormente, suponemos que \(p\) tiene una distribución normal, con valor esperado .270 y error estándar 0.027.

Ahora el segundo nivel de variabilidad tiene que ver con la suerte al batear. Independientemente de lo bueno que sea el jugador, a veces tiene mala suerte y a veces tiene buena suerte. En cada turno al bate, este jugador tiene una probabilidad de éxito \(p\). Si sumamos estos éxitos y fracasos, entonces el CLT nos dice que el promedio observado, llámelo \(Y\), tiene una distribución normal con el valor esperado \(p\) y error estándar \(\sqrt{p(1-p)/N}\) con \(N\) el número de turnos al bate.

Los libros de texto estadísticos escribirán el modelo así:
\[
\begin{aligned}
p &\sim N(\mu, \tau^2) \\
Y \mid p &\sim N(p, \sigma^2)
\end{aligned}
\]
Aquí el símbolo \(\sim\) nos dice que la variable aleatoria a la izquierda del símbolo sigue la distribución a la derecha y \(N(a,b^2)\) representa la distribución normal con media \(a\) y desviación estándar \(b\). El \(\mid\) significa que estamos \emph{condicionando en} la variable aleatoria a la derecha del símbolo como si se conociera su valor. Nos referimos al modelo como jerárquico porque necesitamos saber \(p\), el primer nivel, para modelar \(Y\), el segundo nivel. En nuestro ejemplo, el primer nivel describe la aleatoriedad en la asignación de talento a un jugador y en el segundo se describe la aleatoriedad en el desempeño de este jugador una vez fijemos el parámetro de talento. En un marco bayesiano, el primer nivel se llama \emph{distribución a priori} y el segundo la \emph{distribución muestral}. El análisis de datos que hemos realizado aquí sugiere que establezcamos \(\mu = .270\), \(\tau = 0.027\) y \(\sigma^2 = p(1-p)/N\).

Ahora, usemos este modelo para los datos de José. Supongan que queremos predecir su habilidad innata en la forma de su verdadero promedio de bateo \(p\). Este sería el modelo jerárquico para nuestros datos:

\[
\begin{aligned}
p &\sim N(.275, .027^2) \\
Y \mid p &\sim N(p, .111^2)
\end{aligned}
\]

Ahora estamos listos para calcular una distribución a posteriori para resumir nuestra predicción de \(p\). La versión continua de la regla de Bayes se puede usar aquí para derivar la \emph{función de probabilidad a posteriori}, que es la distribución de \(p\) suponiendo que observemos \(Y=y\). En nuestro caso, podemos demostrar que cuando fijamos \(Y=y\), \(p\) sigue una distribución normal con el valor esperado:

\[
\begin{aligned}
\mbox{E}(p \mid Y=y) &= B \mu + (1-B) y\\
&= \mu + (1-B)(y-\mu)\\
\mbox{with } B &= \frac{\sigma^2}{\sigma^2+\tau^2}
\end{aligned}
\]

Este es un promedio ponderado del promedio de la población \(\mu\) y los datos observados \(y\). El peso depende de la SD de la población \(\tau\) y de la SD de nuestros datos observados \(\sigma\). Este promedio ponderado a veces se denomina \emph{contracción} (\emph{shrinking} en inglés) porque \emph{contrae} los estimadores hacia la media de la distribución a priori. En el caso de José Iglesias tenemos:

\[
\begin{aligned}
\mbox{E}(p \mid Y=.450) &= B \times .275 + (1 - B) \times .450 \\
&= .275 + (1 - B)(.450 - .275) \\
B &=\frac{.111^2}{.111^2 + .027^2} = 0.944\\
\mbox{E}(p \mid Y=450) &\approx .285
\end{aligned}
\]

No mostramos la derivación aquí, pero el error estándar se puede demostrar que es:

\[
\mbox{SE}(p\mid y)^2 = \frac{1}{1/\sigma^2+1/\tau^2}
= \frac{1}{1/.111^2 + 1/.027^2} = 0.00069
\]
y, por lo tanto, la desviación estándar es \(0.026\). Entonces comenzamos con un intervalo de confianza frecuentista de 95\% que ignoraba los datos de otros jugadores y resumía solo los datos de José: .450 \(\pm\) 0.220. Luego usamos un enfoque bayesiano que incorporaba datos de otros jugadores y otros años para obtener una probabilidad a posteriori. De hecho, esto se conoce como un enfoque empírico bayesiano porque utilizamos datos para construir la distribución a priori. Desde la distribución a posteriori, podemos calcular lo que se llama un \emph{intervalo de confianza de Bayes} o \emph{intervalo de Bayes} (\emph{credible interval} en inglés) de 95\%. Para hacer esto, construimos una región, centrada en la media, con una probabilidad de 95\% de ocurrir. En nuestro caso, esto resulta ser: .285 \(\pm\) 0.052.

El intervalo de Bayes sugiere que si otro equipo está impresionado por el promedio observado de .450, deberíamos considerar cambiar a José, ya que pronosticamos que estará ligeramente por encima del promedio. Curiosamente, los Red Sox cambiaron a José a los Detroit Tigers en julio. Estos son los promedios de bateo de José Iglesias para los próximos cinco meses:

\begin{longtable}[]{@{}llll@{}}
\toprule
Mes & At Bat & Hits & AVG \\
\midrule
\endhead
abril & 20 & 9 & .450 \\
mayo & 26 & 11 & .423 \\
junio & 86 & 34 & .395 \\
julio & 83 & 17 & .205 \\
agosto & 85 & 25 & .294 \\
septiembre & 50 & 10 & .200 \\
Total sin abril & 330 & 97 & .293 \\
\bottomrule
\end{longtable}

Aunque ambos intervalos incluyeron el promedio final de bateo, el intervalo de Bayes ofreció una predicción mucho más precisa. En particular, predijo que no sería tan bueno durante el resto de la temporada.

\hypertarget{ejercicios-31}{%
\section{Ejercicios}\label{ejercicios-31}}

1. En 1999, en Inglaterra, Sally Clark\footnote{\url{https://en.wikipedia.org/wiki/Sally_Clark}} fue declarada culpable del asesinato de dos de sus hijos. Ambos bebés fueron encontrados muertos por la mañana, uno en 1996 y otro en 1998. En ambos casos, Clark afirmó que la causa de la muerte fue el síndrome de muerte súbita del lactante (\emph{Sudden Infant Death Syndrome} o SIDS por sus siglas en inglés). A ninguno de los niños le encontraron lesiones físicas, por lo que la principal evidencia en su contra fue el testimonio del profesor Sir Roy Meadow, quien testificó que las probabilidades de que dos niños de la misma madre murieran de SIDS eran de 1 en 73 millones. Llegó a esta cifra al encontrar que la tasa de SIDS era de 1 en 8,500 y luego calcular que la posibilidad de dos casos de SIDS era 8,500 \(\times\) 8,500 \(\approx\) 73 millones. ¿Con cuál de las siguientes declaraciones está de acuerdo?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Sir Meadow supuso que la probabilidad de que el segundo hijo fuera afectado por el SIDS era independiente de la del primer hijo afectado, ignorando así posibles causas genéticas. Si la genética juega un papel, entonces: \(\mbox{Pr}(\mbox{second case of SIDS} \mid \mbox{first case of SIDS}) < \mbox{P}r(\mbox{first case of SIDS})\).
\item
  Nada. La regla de multiplicación siempre se aplica de esta manera: \(\mbox{Pr}(A \mbox{ and } B) =\mbox{Pr}(A)\mbox{Pr}(B)\)
\item
  Sir Meadow es un experto y debemos confiar en sus cálculos.
\item
  Los números no mienten.
\end{enumerate}

2. Suponga que definitivamente hay un componente genético para el SIDS y la probabilidad de \(\mbox{Pr}(\mbox{second case of SIDS} \mid \mbox{first case of SIDS}) = 1/100\), es mucho mayor que 1 en 8,500. ¿Cuál es la probabilidad de que sus dos hijos mueran de SIDS?

3. Muchos informes de prensa declararon que el experto afirmó que la probabilidad de que Sally Clark fuera inocente era 1 en 73 millones. Quizás el jurado y el juez también interpretaron el testimonio de esta manera. Esta probabilidad se puede escribir como la probabilidad de que \emph{una madre sea una psicópata asesina de hijos, dado que encuentran a dos de sus hijos muertos sin lesiones físicas.} Según la regla de Bayes, ¿cuánta es esta probabilidad?

4. Suponga que la probabilidad de que una psicópata asesina de hijos encuentre la manera de matar a sus hijos, sin dejar evidencia física, es:

\[
\mbox{Pr}(A \mid B) = 0.50
\]

con \(A =\) dos de sus hijos los encuentran muertos sin lesiones físicas y \(B =\) una madre es una psicópata asesina de hijos = 0.50. Suponga que la tasa de madres psicópatas que asesinan hijos es 1 en 1,000,000. Según el teorema de Bayes, ¿cuál es la probabilidad de \(\mbox{Pr}(B \mid A)\)?

5. Después de que Sally Clark fue declarada culpable, la Royal Statistical Society emitió un comunicado diciendo que ``no había base estadística'' para el reclamo del experto. Expresaron preocupación por el ``mal uso de las estadísticas en los tribunales''. Sally Clark fue absuelta en junio de 2003. ¿Qué no consideró el experto Sir Roy Meadow?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Cometió un error aritmético.
\item
  Cometió dos errores. Primero, hizo un mal uso de la regla de multiplicación y, segundo, no tomó en cuenta lo raro que es que una madre asesine a sus hijos. Después de usar la regla de Bayes, encontramos una probabilidad más cercana a 0.5 que a 1 en 73 millones.
\item
  Confundió el numerador y el denominador de la regla de Bayes.
\item
  No usó R.
\end{enumerate}

6. Florida es uno de los estados más vigilados en las elecciones de EE. UU. porque tiene muchos votos electorales y las elecciones generalmente son cerradas. Además, Florida tiende a ser un estado decisivo que puede votar por cualquiera de los dos partidos. Cree la siguiente tabla con las encuestas realizadas durante las últimas dos semanas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(polls\_us\_election\_2016)}
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{==} \StringTok{"Florida"} \SpecialCharTok{\&}\NormalTok{ enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}11{-}04"}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Tome la diferencia promedio de estas encuestas. El CLT nos dice que este promedio es aproximadamente normal. Calcule un promedio y provea un estimador del error estándar. Guarde sus resultados en un objeto llamado \texttt{results}.

7. Ahora suponga un modelo bayesiano con distribución a priori normal para la diferencia de la noche electoral de Florida \(d\) con valor esperado \(\mu\) y desviación estándar \(\tau\). ¿Cuáles son las interpretaciones de \(\mu\) y \(\tau\)?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \(\mu\) y \(\tau\) son números arbitrarios que nos permiten hacer declaraciones de probabilidad sobre \(d\).
\item
  \(\mu\) y \(\tau\) resumen lo que predeciríamos para Florida antes de ver las encuestas. Basado en elecciones pasadas, fijaríamos \(\mu\) cerca de 0 porque tanto republicanos como demócratas han ganado y \(\tau\) en aproximadamente \(0.02\) porque estas elecciones tienden a ser cerradas.
\item
  \(\mu\) y \(\tau\) resumen lo que queremos que sea verdad. Por lo tanto, fijamos \(\mu\) en \(0.10\) y \(\tau\) en \(0.01\).
\item
  La decisión de que distribución a priori usar no tiene ningún efecto en el análisis bayesiano.
\end{enumerate}

8. El CLT nos dice que nuestro estimador de la diferencia \(\hat{d}\) tiene distribución normal con valor esperado \(d\) y desviación estándar \(\sigma\) calculada en el problema 6. Use las fórmulas que mostramos para la distribución a posteriori para calcular el valor esperado de la distribución a posteriori si fijamos \(\mu = 0\) y \(\tau = 0.01\).

9. Ahora calcule la desviación estándar de la distribución a posteriori.

10. Usando el hecho de que la distribución a posteriori es normal, cree un intervalo que tenga un 95\% de probabilidad de ocurrir centrado en el valor esperado a posteriori. Recuerden que estos los llamamos intervalos de Bayes.

11. Según este análisis, ¿cuál fue la probabilidad de que Trump ganara Florida?

12. Ahora use la función \texttt{sapply} para cambiar la varianza de la probabilidad a priori de \texttt{seq(0.05,\ 0.05,\ len\ =\ 100)} y observe cómo cambia la probabilidad haciendo un gráfico.

\hypertarget{election-forecasting}{%
\section{Estudio de caso: pronóstico de elecciones}\label{election-forecasting}}

En una sección anterior, generamos las siguientes tablas de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{==} \StringTok{"U.S."} \SpecialCharTok{\&}\NormalTok{ enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}
\NormalTok{           (grade }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"A+"}\NormalTok{,}\StringTok{"A"}\NormalTok{,}\StringTok{"A{-}"}\NormalTok{,}\StringTok{"B+"}\NormalTok{) }\SpecialCharTok{|} \FunctionTok{is.na}\NormalTok{(grade))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}

\NormalTok{one\_poll\_per\_pollster }\OtherTok{\textless{}{-}}\NormalTok{ polls }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(pollster) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(enddate }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(enddate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}

\NormalTok{results }\OtherTok{\textless{}{-}}\NormalTok{ one\_poll\_per\_pollster }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(spread), }\AttributeTok{se =} \FunctionTok{sd}\NormalTok{(spread)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{length}\NormalTok{(spread))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{start =}\NormalTok{ avg }\SpecialCharTok{{-}} \FloatTok{1.96}\SpecialCharTok{*}\NormalTok{se, }\AttributeTok{end =}\NormalTok{ avg }\SpecialCharTok{+} \FloatTok{1.96}\SpecialCharTok{*}\NormalTok{se)}
\end{Highlighting}
\end{Shaded}

A continuación, las utilizaremos para nuestro pronóstico.

\hypertarget{bayesian-approach}{%
\subsection{Enfoque bayesiano}\label{bayesian-approach}}

Los encuestadores tienden a hacer declaraciones probabilísticas sobre los resultados de las elecciones. Por ejemplo, ``La probabilidad de que Obama gane el colegio electoral es 91\%'' es una declaración probabilística sobre un parámetro que en secciones anteriores hemos denotado con \(d\). Mostramos que para las elecciones del 2016, FiveThirtyEight le dio a Clinton una probabilidad de 81.4\% de ganar el voto popular. Para hacer esto, utilizaron el enfoque bayesiano que describimos anteriormente.

Suponemos un modelo jerárquico similar al que hicimos para predecir el desempeño de un jugador de béisbol. Los libros de texto estadísticos escribirán el modelo así:

\[
\begin{aligned}
d &\sim N(\mu, \tau^2) \mbox{ describes our best guess had we not seen any polling data}\\
\bar{X} \mid d &\sim N(d, \sigma^2) \mbox{ describes randomness due to sampling and the pollster effect}
\end{aligned}
\]

Para hacer nuestro mejor pronóstico, notamos que antes de que haya datos de encuestas disponibles, podemos usar fuentes de datos que no son datos de encuestas. Un enfoque popular es utilizar la situación económica y demográfica que históricamente parecen tener un efecto a favor o en contra del partido en poder. No usaremos estos aquí. En cambio, usaremos \(\mu = 0\), que se interpreta como un modelo que no ofrece información sobre quién ganará. Para la desviación estándar, usaremos datos históricos recientes que muestran que el ganador del voto popular tiene una variabilidad promedio de aproximadamente 3.5\%. Por lo tanto, fijamos \(\tau = 0.035\).

Ahora podemos usar las fórmulas para la distribución a posteriori del parámetro \(d\): la probabilidad de que \(d>0\) dado los datos de la encuesta observada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{tau }\OtherTok{\textless{}{-}} \FloatTok{0.035}
\NormalTok{sigma }\OtherTok{\textless{}{-}}\NormalTok{ results}\SpecialCharTok{$}\NormalTok{se}
\NormalTok{Y }\OtherTok{\textless{}{-}}\NormalTok{ results}\SpecialCharTok{$}\NormalTok{avg}
\NormalTok{B }\OtherTok{\textless{}{-}}\NormalTok{ sigma}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{ (sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}

\NormalTok{posterior\_mean }\OtherTok{\textless{}{-}}\NormalTok{ B}\SpecialCharTok{*}\NormalTok{mu }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{B)}\SpecialCharTok{*}\NormalTok{Y}
\NormalTok{posterior\_se }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{( }\DecValTok{1}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{/}\NormalTok{sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}

\NormalTok{posterior\_mean}
\CommentTok{\#\textgreater{} [1] 0.0281}
\NormalTok{posterior\_se}
\CommentTok{\#\textgreater{} [1] 0.00615}
\end{Highlighting}
\end{Shaded}

Para hacer una declaración de probabilidad, usamos el hecho de que la distribución a posteriori también es normal. Y tenemos un intervalo de confianza de Bayes de:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{posterior\_mean }\SpecialCharTok{+} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.96}\NormalTok{, }\FloatTok{1.96}\NormalTok{)}\SpecialCharTok{*}\NormalTok{posterior\_se}
\CommentTok{\#\textgreater{} [1] 0.0160 0.0401}
\end{Highlighting}
\end{Shaded}

La probabilidad a posteriori \(\mbox{Pr}(d>0 \mid \bar{X})\) se puede calcular así:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\DecValTok{0}\NormalTok{, posterior\_mean, posterior\_se)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

Esto dice que estamos 100\% seguros de que Clinton ganará el voto popular, lo que parece demasiado confiado. Además, no está de acuerdo con el 81.4\% de FiveThirtyEight. ¿Qué explica esta diferencia?

\hypertarget{el-sesgo-general}{%
\subsection{El sesgo general}\label{el-sesgo-general}}

Una vez finalizadas las elecciones, se puede observar la diferencia entre las predicciones de los encuestadores y el resultado real. Una observación importante que nuestro modelo no considera es que es común ver un sesgo general que afecta a muchos encuestadores de la misma manera, que entonces conduce a que los datos observados estén correlacionados. No hay una buena explicación para esto, pero se observa en datos históricos: en una elección, el promedio de las encuestas favorece a los demócratas por 2\%, luego en las siguientes elecciones favorece a los republicanos por 1\%, entonces en las próximas elecciones no hay sesgo, luego en la siguiente los republicanos son los favoritos por 3\%, y así sucesivamente. En 2016, las encuestas favorecieron a los demócratas por 1-2\%.

Aunque sabemos que este sesgo afecta a nuestras encuestas, no tenemos forma de saber cuán grande es este sesgo hasta la noche de las elecciones. Como consecuencia, no podemos corregir nuestras encuestas para tomar este sesgo en cuenta. Lo que podemos hacer es incluir un término en nuestro modelo que explique esta variabilidad.

\hypertarget{representaciones-matemuxe1ticas-de-modelos}{%
\subsection{Representaciones matemáticas de modelos}\label{representaciones-matemuxe1ticas-de-modelos}}

Imagínense que estamos recopilando datos de un encuestador y suponemos que no hay sesgo general. El encuestador recoge varias encuestas con un tamaño de muestra de \(N\), por lo que observamos varias mediciones de la variabilidad \(X_1, \dots, X_J\). La teoría nos dice que estas variables aleatorias tienen un valor esperado \(d\) y un error estándar \(2 \sqrt{p(1-p)/N}\). Comencemos usando el siguiente modelo para describir la variabilidad observada:

\[
X_j = d + \varepsilon_j.
\]
Usamos el índice \(j\) para representar las diferentes encuestas y definimos \(\varepsilon_j\) para ser una variable aleatoria que explica la variabilidad entre encuestas individuales introducida por el error de muestreo. Para hacer esto, suponemos que su promedio es 0 y su error estándar es \(2 \sqrt{p(1-p)/N}\). Si \(d\) es 2.1 y el tamaño de la muestra para estas encuestas es de 2,000, podemos simular \(J=6\) puntos de datos de este modelo así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\NormalTok{J }\OtherTok{\textless{}{-}} \DecValTok{6}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{2000}
\NormalTok{d }\OtherTok{\textless{}{-}}\NormalTok{ .}\DecValTok{021}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ (d }\SpecialCharTok{+} \DecValTok{1}\NormalTok{)}\SpecialCharTok{/}\DecValTok{2}
\NormalTok{X }\OtherTok{\textless{}{-}}\NormalTok{ d }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(J, }\DecValTok{0}\NormalTok{, }\DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(p }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ p)}\SpecialCharTok{/}\NormalTok{ N))}
\end{Highlighting}
\end{Shaded}

Ahora supongan que tenemos \(J=6\) puntos de datos de \(I=5\) diferentes encuestadores. Para representar esto, necesitamos dos índices, uno para el encuestador y otro para las encuestas que cada encuestador toma. Usamos \(X_{ij}\) con \(i\) representando al encuestador y \(j\) representando la encuesta número \(j\) de ese encuestador. Si aplicamos el mismo modelo, escribimos:

\[
X_{i,j} = d + \varepsilon_{i,j}
\]

Para simular datos, ahora tenemos que usar un bucle para simular los datos de cada encuestador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{I }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{J }\OtherTok{\textless{}{-}} \DecValTok{6}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{2000}
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{I, }\ControlFlowTok{function}\NormalTok{(i)\{}
\NormalTok{  d }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(J, }\DecValTok{0}\NormalTok{, }\DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(p }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ p)}\SpecialCharTok{/}\NormalTok{ N))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Los datos simulados realmente no parecen capturar las características de los datos reales:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simulated-data-without-bias-1} \end{center}

El modelo anterior no toma en cuenta la variabilidad entre encuestadores. Para arreglar esto, añadimos un nuevo término para el efecto de los encuestadores. Usaremos \(h_i\) para representar el sesgo del encuestador número \(i\). Le añadimos este nuevo término al modelo:

\[
X_{i,j} = d + h_i + \varepsilon_{i,j}
\]

Para simular datos de un encuestador específico, ahora necesitamos escojer un \(h_i\) y luego añadir los \(\varepsilon\)s. Entonces, para un encuestador específico, suponemos que \(\sigma_h\) es 0.025:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{I }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{J }\OtherTok{\textless{}{-}} \DecValTok{6}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{2000}
\NormalTok{d }\OtherTok{\textless{}{-}}\NormalTok{ .}\DecValTok{021}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ (d }\SpecialCharTok{+} \DecValTok{1}\NormalTok{)}\SpecialCharTok{/} \DecValTok{2}
\NormalTok{h }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(I, }\DecValTok{0}\NormalTok{, }\FloatTok{0.025}\NormalTok{)}
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{I, }\ControlFlowTok{function}\NormalTok{(i)\{}
\NormalTok{  d }\SpecialCharTok{+}\NormalTok{ h[i] }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(J, }\DecValTok{0}\NormalTok{, }\DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(p }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ p)}\SpecialCharTok{/}\NormalTok{ N))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Los datos simulados ahora se parecen más a los datos reales:

\begin{center}\includegraphics[width=0.35\linewidth]{libro_files/figure-latex/simulated-pollster-data-1} \end{center}

Noten que \(h_i\) es común a todas las variabilidades observadas de un encuestador específico. Diferentes encuestadores tienen una \(h_i\) diferente, lo que explica por qué cuando vemos los datos de los distintos encuestadores, podemos ver los diferentes grupos de puntos desplazarse hacia arriba y hacia abajo.

Ahora, en el modelo anterior, suponemos que el promedio de los sesgos de los encuestadores es 0. Creemos que para cada encuestador sesgado a favor de nuestro partido, hay otro a favor del otro partido y suponemos que la desviación estándar es \(\sigma_h\). Pero históricamente vemos que cada elección tiene un sesgo general que afecta a todas las encuestas. Podemos observar esto con los datos del 2016, pero si recopilamos datos históricos, vemos que el promedio de las encuestas falla por más de lo que predicen modelos como el anterior. Para ver esto, tomaríamos el promedio de las encuestas para cada año electoral y lo compararíamos con el valor real. Si hiciéramos esto, veríamos una diferencia con una desviación estándar de entre 2-3\%. Para incorporar esto en el modelo, podemos añadir otro término para explicar esta variabilidad:
\[
X_{i,j} = d + b + h_i + \varepsilon_{i,j}.
\]

Aquí \(b\) es una variable aleatoria que explica la variabilidad de elección a elección. Esta variable aleatoria cambia de elección a elección, pero para cualquier elección dada, es la misma para todos los encuestadores y las encuestas dentro de la elección. Por eso no tiene índices. Esto implica que todas las variables aleatorias \(X_{i,j}\) para un año electoral están correlacionadas ya que todas tienen \(b\) en común.

Una forma de interpretar \(b\) es como la diferencia entre el promedio de todas las encuestas de todos los encuestadores y el resultado real de la elección. Como no conocemos el resultado real hasta después de las elecciones, no podemos estimar \(b\) hasta entonces. Sin embargo, podemos estimar \(b\) de las elecciones anteriores y estudiar la distribución de estos valores. Conforme a este enfoque, suponemos que, a lo largo de los años electorales, \(b\) tiene el valor esperado 0 y el error estándar es aproximadamente \(\sigma_b = 0.025\).

Una implicación de añadir este término al modelo es que la desviación estándar de \(X_{i,j}\) es mayor que lo que llamamos anteriormente \(\sigma\), que combina la variabilidad del encuestador y la variabilidad de la muestra, y que se estimó con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(one\_poll\_per\_pollster}\SpecialCharTok{$}\NormalTok{spread)}
\CommentTok{\#\textgreater{} [1] 0.0242}
\end{Highlighting}
\end{Shaded}

Este estimador no incluye la variabilidad introducida por \(b\). Tengan en cuenta que como:

\[
\bar{X} = d + b + \frac{1}{N}\sum_{i=1}^N X_i,
\]

la desviación estándar de \(\bar{X}\) es:

\[
\sqrt{\sigma^2/N + \sigma_b^2}.
\]
Ya que la misma \(b\) está en cada medición, el promedio no reduce la variabilidad introducida por este término. Este es un punto importante: no importa cuántas encuestas realicen, este sesgo no se reduce.

Si rehacemos el cálculo bayesiano tomando en cuenta esta variabilidad, obtenemos un resultado mucho más cercano al de FiveThirtyEight:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{tau }\OtherTok{\textless{}{-}} \FloatTok{0.035}
\NormalTok{sigma }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(results}\SpecialCharTok{$}\NormalTok{se}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ .}\DecValTok{025}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\NormalTok{Y }\OtherTok{\textless{}{-}}\NormalTok{ results}\SpecialCharTok{$}\NormalTok{avg}
\NormalTok{B }\OtherTok{\textless{}{-}}\NormalTok{ sigma}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{ (sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}

\NormalTok{posterior\_mean }\OtherTok{\textless{}{-}}\NormalTok{ B}\SpecialCharTok{*}\NormalTok{mu }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{B)}\SpecialCharTok{*}\NormalTok{Y}
\NormalTok{posterior\_se }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{( }\DecValTok{1}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{/}\NormalTok{sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}

\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{pnorm}\NormalTok{(}\DecValTok{0}\NormalTok{, posterior\_mean, posterior\_se)}
\CommentTok{\#\textgreater{} [1] 0.817}
\end{Highlighting}
\end{Shaded}

\hypertarget{prediciendo-el-colegio-electoral}{%
\subsection{Prediciendo el colegio electoral}\label{prediciendo-el-colegio-electoral}}

Hasta ahora nos hemos enfocado en el voto popular. Pero en Estados Unidos, las elecciones no se deciden por el voto popular, sino por lo que se conoce como el colegio electoral. Cada estado obtiene una cantidad de votos electorales que dependen, de una manera algo compleja, del tamaño de la población del estado. Aquí están los 5 principales estados clasificados por votos electorales en 2016.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{top\_n}\NormalTok{(}\DecValTok{5}\NormalTok{, electoral\_votes)}
\CommentTok{\#\textgreater{}          state electoral\_votes clinton trump others}
\CommentTok{\#\textgreater{} 1   California              55    61.7  31.6    6.7}
\CommentTok{\#\textgreater{} 2        Texas              38    43.2  52.2    4.5}
\CommentTok{\#\textgreater{} 3      Florida              29    47.8  49.0    3.2}
\CommentTok{\#\textgreater{} 4     New York              29    59.0  36.5    4.5}
\CommentTok{\#\textgreater{} 5     Illinois              20    55.8  38.8    5.4}
\CommentTok{\#\textgreater{} 6 Pennsylvania              20    47.9  48.6    3.6}
\end{Highlighting}
\end{Shaded}

Con algunas excepciones que no discutimos, los votos electorales se ganan todo o nada. Por ejemplo, si un candidato gana California con solo 1 voto, aún obtiene los 55 votos electorales. Esto significa que al ganar algunos estados grandes por un amplio margen, pero al perder muchos estados pequeños por pequeños márgenes, se puede ganar el voto popular, pero perder el colegio electoral que es lo que decide el ganador. Esto sucedió en 1876, 1888, 2000 y 2016. La idea detrás de esto es evitar que algunos estados grandes tengan el poder de dominar las elecciones presidenciales. Sin embargo, muchas personas en Estados Unidos consideran que el colegio electoral es injusto y les gustaría abolirlo.

Ahora estamos listos para predecir el resultado del colegio electoral para 2016. Comenzamos agregando los resultados de una encuesta realizada durante la última semana antes de las elecciones. Utilizamos \texttt{str\_detect}, una función que discutiremos más adelante en la Sección \ref{stringr}, para eliminar encuestas que cubren solo parte de un estado.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state}\SpecialCharTok{!=}\StringTok{"U.S."} \SpecialCharTok{\&}
           \SpecialCharTok{!}\FunctionTok{str\_detect}\NormalTok{(state, }\StringTok{"CD"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{           enddate }\SpecialCharTok{\textgreater{}=}\StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}
\NormalTok{           (grade }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"A+"}\NormalTok{,}\StringTok{"A"}\NormalTok{,}\StringTok{"A{-}"}\NormalTok{,}\StringTok{"B+"}\NormalTok{) }\SpecialCharTok{|} \FunctionTok{is.na}\NormalTok{(grade))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(state) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(spread), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(spread), }\AttributeTok{n =} \FunctionTok{n}\NormalTok{()) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{state =} \FunctionTok{as.character}\NormalTok{(state))}
\end{Highlighting}
\end{Shaded}

Aquí están los cinco estados con los resultados más cerrados según las encuestas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(}\FunctionTok{abs}\NormalTok{(avg))}
\CommentTok{\#\textgreater{} \# A tibble: 47 x 4}
\CommentTok{\#\textgreater{}   state               avg     sd     n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}             \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 Florida         0.00356 0.0163     7}
\CommentTok{\#\textgreater{} 2 North Carolina {-}0.0073  0.0306     9}
\CommentTok{\#\textgreater{} 3 Ohio           {-}0.0104  0.0252     6}
\CommentTok{\#\textgreater{} 4 Nevada          0.0169  0.0441     7}
\CommentTok{\#\textgreater{} 5 Iowa           {-}0.0197  0.0437     3}
\CommentTok{\#\textgreater{} \# ... with 42 more rows}
\end{Highlighting}
\end{Shaded}

Ahora utilizaremos el comando \texttt{left\_join} que nos permitirá añadir fácilmente el número de votos electorales para cada estado del set de datos \texttt{us\_electoral\_votes\_2016}. Describiremos esta función en detalle en el capítulo ``\emph{Wrangling} de datos''. Aquí, simplemente observaremos que la función combina los dos sets de datos para que la información del segundo argumento se agregue a la información del primero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results }\OtherTok{\textless{}{-}} \FunctionTok{left\_join}\NormalTok{(results, results\_us\_election\_2016, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Observen que algunos estados no tienen encuestas porque prácticamente se conoce el ganador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{state }\SpecialCharTok{\%in\%}\NormalTok{ results}\SpecialCharTok{$}\NormalTok{state) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(state)}
\CommentTok{\#\textgreater{} [1] "Rhode Island"         "Alaska"               "Wyoming"             }
\CommentTok{\#\textgreater{} [4] "District of Columbia"}
\end{Highlighting}
\end{Shaded}

No se realizaron encuestas en DC, Rhode Island, Alaska y Wyoming porque los demócratas seguramente ganarán en los primeros dos y los republicanos en los últimos dos.

Debido a que no podemos estimar la desviación estándar para los estados con una sola encuesta, la calcularemos como la mediana de las desviaciones estándar estimadas para los estados con más de una encuesta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results }\OtherTok{\textless{}{-}}\NormalTok{ results }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sd =} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(sd), }\FunctionTok{median}\NormalTok{(results}\SpecialCharTok{$}\NormalTok{sd, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{), sd))}
\end{Highlighting}
\end{Shaded}

Para hacer argumentos probabilísticos, utilizaremos una simulación Monte Carlo. Para cada estado, aplicamos el enfoque bayesiano para generar una \(d\) para el día de elecciones. Podríamos construir las probabilidades a priori de cada estado basado en la historia reciente. Sin embargo, para simplificar, asignamos una probabilidad a priori a cada estado que supone que no sabemos nada sobre lo que sucederá. Dado que de un año electoral a otro, los resultados de un estado específico no cambian tanto, asignaremos una desviación estándar de 2\% o \(\tau=0.02\). Por ahora, vamos a suponer incorrectamente que los resultados de la encuesta de cada estado son independientes. El código para el cálculo bayesiano bajo estos supuestos se ve así:

\begin{verbatim}
#> # A tibble: 47 x 12
#>   state          avg       sd     n electoral_votes clinton trump others
#>   <chr>        <dbl>    <dbl> <int>           <int>   <dbl> <dbl>  <dbl>
#> 1 Alabama    -0.149  0.0253       3               9    34.4  62.1    3.6
#> 2 Arizona    -0.0326 0.0270       9              11    45.1  48.7    6.2
#> 3 Arkansas   -0.151  0.000990     2               6    33.7  60.6    5.8
#> 4 California  0.260  0.0387       5              55    61.7  31.6    6.7
#> 5 Colorado    0.0452 0.0295       7               9    48.2  43.3    8.6
#> # ... with 42 more rows, and 4 more variables: sigma <dbl>, B <dbl>,
#> #   posterior_mean <dbl>, posterior_se <dbl>
\end{verbatim}

Los estimadores basadas en las probabilidades a posteriori mueven los estimadores hacia 0, aunque los estados con muchas encuestas están menos influenciados. Esto se espera ya que mientras más datos de encuestas recolectamos, más confiamos en esos resultados:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/posterior-versus-original-estimates-1} \end{center}

Ahora repetimos esto 10,000 veces y generamos un resultado de la probabilidad a posteriori. En cada iteración, hacemos un seguimiento del número total de votos electorales para Clinton. Recuerden que Trump obtiene 270 votos electorales menos los votos para Clinton. También noten que la razón por la que añadimos 7 en el código es para tomar en cuenta Rhode Island y DC:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{mu }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{tau }\OtherTok{\textless{}{-}} \FloatTok{0.02}
\NormalTok{clinton\_EV }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  results }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sigma =}\NormalTok{ sd}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(n),}
                     \AttributeTok{B =}\NormalTok{ sigma}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{ (sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{),}
                     \AttributeTok{posterior\_mean =}\NormalTok{ B }\SpecialCharTok{*}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ B) }\SpecialCharTok{*}\NormalTok{ avg,}
                     \AttributeTok{posterior\_se =} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{/}\NormalTok{sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)),}
                     \AttributeTok{result =} \FunctionTok{rnorm}\NormalTok{(}\FunctionTok{length}\NormalTok{(posterior\_mean),}
\NormalTok{                                    posterior\_mean, posterior\_se),}
                     \AttributeTok{clinton =} \FunctionTok{ifelse}\NormalTok{(result }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, electoral\_votes, }\DecValTok{0}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{clinton =} \FunctionTok{sum}\NormalTok{(clinton)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(clinton) }\SpecialCharTok{+} \DecValTok{7}
\NormalTok{\})}

\FunctionTok{mean}\NormalTok{(clinton\_EV }\SpecialCharTok{\textgreater{}} \DecValTok{269}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.998}
\end{Highlighting}
\end{Shaded}

Este modelo le da a Clinton una probabilidad de ganar mayor que 99\%.
El Consorcio Electoral de Princeton hizo una predicción similar. Ahora sabemos que fallaron por mucho. ¿Que pasó?

El modelo anterior ignora el sesgo general y supone que los resultados de diferentes estados son independientes. Después de las elecciones, nos dimos cuenta de que el sesgo general en 2016 no era tan grande: estaba entre 1 y 2\%. Pero debido a que la elección estuvo cerrada en varios estados grandes y estos estados tenían una gran cantidad de encuestas, los encuestadores que ignoraron el sesgo general subestimaron considerablemente el error estándar. Utilizando la notación que presentamos, supusieron que el error estándar era \(\sqrt{\sigma^2/N}\) que con N grande es bastante más pequeño que el estimador más preciso
\(\sqrt{\sigma^2/N + \sigma_b^2}\). FiveThirtyEight, que modela el sesgo general de una manera bastante sofisticada, informó un resultado más cercano. Podemos simular los resultados ahora con un término de sesgo. Para el nivel de estado, el sesgo general puede ser mayor, por lo que lo establecemos en \(\sigma_b = 0.03\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tau }\OtherTok{\textless{}{-}} \FloatTok{0.02}
\NormalTok{bias\_sd }\OtherTok{\textless{}{-}} \FloatTok{0.03}
\NormalTok{clinton\_EV\_2 }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{1000}\NormalTok{, \{}
\NormalTok{  results }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sigma =} \FunctionTok{sqrt}\NormalTok{(sd}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{n }\SpecialCharTok{+}\NormalTok{ bias\_sd}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{),}
                     \AttributeTok{B =}\NormalTok{ sigma}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{ (sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{),}
                     \AttributeTok{posterior\_mean =}\NormalTok{ B}\SpecialCharTok{*}\NormalTok{mu }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{B)}\SpecialCharTok{*}\NormalTok{avg,}
                     \AttributeTok{posterior\_se =} \FunctionTok{sqrt}\NormalTok{( }\DecValTok{1}\SpecialCharTok{/}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{/}\NormalTok{sigma}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{tau}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)),}
                     \AttributeTok{result =} \FunctionTok{rnorm}\NormalTok{(}\FunctionTok{length}\NormalTok{(posterior\_mean),}
\NormalTok{                                    posterior\_mean, posterior\_se),}
                     \AttributeTok{clinton =} \FunctionTok{ifelse}\NormalTok{(result}\SpecialCharTok{\textgreater{}}\DecValTok{0}\NormalTok{, electoral\_votes, }\DecValTok{0}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{clinton =} \FunctionTok{sum}\NormalTok{(clinton) }\SpecialCharTok{+} \DecValTok{7}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(clinton)}
\NormalTok{\})}
\FunctionTok{mean}\NormalTok{(clinton\_EV\_2 }\SpecialCharTok{\textgreater{}} \DecValTok{269}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.848}
\end{Highlighting}
\end{Shaded}

Esto nos da un estimador mucho más sensato. Al observar los resultados de la simulación, vemos cómo el término de sesgo agrega variabilidad a los resultados finales.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/comparison-forecast-with-and-without-bias-1} \end{center}

El modelo de FiveThirtyEight incluye muchas otras características que no describimos aquí. Una es que modelan la variabilidad con distribuciones que tienen altas probabilidades para eventos extremos en comparación con la distribución normal. Una forma que nosotros podemos hacerlo es cambiando la distribución utilizada en la simulación de una distribución normal a una distribución t. FiveThirtyEight predijo una probabilidad de 71\%.

\hypertarget{pronuxf3sticos}{%
\subsection{Pronósticos}\label{pronuxf3sticos}}

A los pronosticadores les gusta hacer predicciones mucho antes de las elecciones. Las predicciones se adaptan a medida que salen nuevas encuestas. Sin embargo, una pregunta importante que deben hacer los pronosticadores es: ¿cuán informativas son las encuestas que se hacen varias semanas antes de las elecciones sobre la elección real? Aquí estudiamos la variabilidad de los resultados de las encuestas a lo largo del tiempo.

Para asegurarnos de que la variabilidad que observamos no se debe a efectos del encuestador, estudiemos los datos de un encuestador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_pollster }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(pollster }\SpecialCharTok{==} \StringTok{"Ipsos"} \SpecialCharTok{\&}\NormalTok{ state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Como no hay efecto de encuestador, quizás el error estándar teórico coincide con la desviación estándar derivada de los datos. Calculamos ambos aquí:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{se }\OtherTok{\textless{}{-}}\NormalTok{ one\_pollster }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{empirical =} \FunctionTok{sd}\NormalTok{(spread),}
            \AttributeTok{theoretical =} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{(spread) }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(spread))}\SpecialCharTok{/}
                                     \FunctionTok{min}\NormalTok{(samplesize)))}
\NormalTok{se}
\CommentTok{\#\textgreater{}   empirical theoretical}
\CommentTok{\#\textgreater{} 1    0.0403      0.0326}
\end{Highlighting}
\end{Shaded}

Pero la desviación estándar empírica es más alta que el estimador teórico más alto posible. Además, los datos de la variabilidad no se ven normales como la teoría predeciría:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/time-trend-variability-1} \end{center}

Los modelos que hemos descrito incluyen la variabilidad entre encuestadores y el error de muestreo. Pero este gráfico es para un encuestador y la variabilidad que vemos ciertamente no la explica el error de muestreo. ¿De dónde viene la variabilidad extra? Los siguientes gráficos muestran un fuerte argumento de que esta variabilidad proviene de fluctuaciones de tiempo no explicadas por la teoría que supone que \(p\) es fija:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/time-trend-estimate-1} \end{center}

Algunos de los picos y valles que vemos coinciden con eventos como las convenciones de los partidos, que tienden a dar un impulso a los candidatos. Vemos consistencia entre los distintos encuestadores en cuanto a la localización de los picos y valles.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/time-trend-estimate-several-pollsters-1} \end{center}

Esto implica que, si vamos a pronosticar, nuestro modelo debe incluir un término que toma en cuenta el efecto temporero. Necesitamos escribir un modelo que incluya un término de sesgo para el tiempo:

\[
Y_{i,j,t} = d + b + h_j + b_t + \varepsilon_{i,j,t}
\]

La desviación estándar de \(b_t\) va a depender de \(t\) ya que en cuanto más nos acercamos al día de las elecciones, más cerca de 0 debería estar este término de sesgo.

Los encuestadores también intentan estimar las tendencias de estos datos e incorporarlos en sus predicciones. Podemos modelar la tendencia temporera con una función \(f(t)\) y reescribir el modelo así:

\[
Y_{i,j,t} = d + b + h_j + b_t + f(t) + \varepsilon_{i,jt,}
\]

Usualmente vemos el estimador de \(f(t)\) no para la diferencia, sino para los porcentajes reales para cada candidato así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/trend-estimate-for-all-pollsters-1} \end{center}

Una vez que se seleccione un modelo como el anterior, podemos usar datos históricos y actuales para estimar todos los parámetros necesarios para hacer predicciones. Existe una variedad de métodos para estimar tendencias \(f(t)\) que discutimos en la parte de \emph{machine learning}.

\hypertarget{ejercicios-32}{%
\section{Ejercicios}\label{ejercicios-32}}

1. Cree esta tabla:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_us\_election\_2016"}\NormalTok{)}
\NormalTok{polls }\OtherTok{\textless{}{-}}\NormalTok{ polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{!=} \StringTok{"U.S."} \SpecialCharTok{\&}\NormalTok{ enddate }\SpecialCharTok{\textgreater{}=} \StringTok{"2016{-}10{-}31"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora, para cada encuesta, use el CLT para crear un intervalo de confianza de 95\% para la diferencia informada por cada encuesta. Llame al objeto resultante \texttt{cis} con columnas inferior y superior para los límites de los intervalos de confianza. Utilice la función \texttt{select} para mantener las columnas \texttt{state,\ startdate,\ end\ date,\ pollster,\ grade,\ spread,\ lower,\ upper}.

2. Puede añadir el resultado final a la tabla \texttt{cis} que acaba de crear utilizando la función \texttt{right\_join} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add }\OtherTok{\textless{}{-}}\NormalTok{ results\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{actual\_spread =}\NormalTok{ clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(state, actual\_spread)}
\NormalTok{cis }\OtherTok{\textless{}{-}}\NormalTok{ cis }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{state =} \FunctionTok{as.character}\NormalTok{(state)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(add, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora determine con qué frecuencia el intervalo de confianza de 95\% incluye el resultado real.

3. Repita esto, pero muestre la proporción de veces que cada encuestador acierta. Muestre solo encuestadores con más de 5 encuestas y póngalos en orden de mejor a peor. Muestre el número de encuestas realizadas por cada encuestador y la calificación de FiveThirtyEight para cada encuestador. Sugerencia: use \texttt{n=n(),\ grade\ =\ grade{[}1{]}} en la llamada a \texttt{summarize}.

4. Repita el ejercicio 3, pero en lugar de estratificar por encuestador, estratifique por estado. Recuerden que aquí no podemos mostrar calificaciones.

5. Haga un diagrama de barras basado en el resultado del ejercicio 4. Use \texttt{coord\_flip}.

6. Para cada encuesta, calcule la diferencia entre la diferencia que predijimos y la diferencia observada. Añada una columna a la tabla \texttt{cis}. Entonces, añada otra columna llamada \texttt{hit} que es \texttt{TRUE} cuando los signos son los mismos. Sugerencia: use la función \texttt{sign}. Llame al objeto \texttt{resids}.

7. Cree un gráfico como en el ejercicio 5, pero para la proporción de veces que los signos de la diferencia fueron iguales.

8. En el ejercicio 7, vemos que para la mayoría de los estados las encuestas acertaron el 100\% de las veces. En solo 9 estados las encuestas fallaron más de 25\% de las veces. En particular, observe que en Wisconsin todas las encuestas se equivocaron. En Pennsylvania y Michigan, más de 90\% de las encuestas predijeron incorrectamente el ganador. Haga un histograma de los errores. ¿Cuál es la mediana de estos errores?

9. Vemos que a nivel estatal, el error medio fue 3\% a favor de Clinton. La distribución no está centrada en 0, sino en 0.03. Este es el sesgo general que describimos en la sección anterior. Cree un diagrama de caja para ver si el sesgo fue general para todos los estados o si afectó a algunos estados de manera diferente. Utilice \texttt{filter(grade\ \%in\%\ c("A+","A","A-","B+")\ \textbar{}\ is.na(grade)))} para incluir solo encuestadores con altas calificaciones.

10. Algunos de estos estados solo tienen unas pocas encuestas. Repita el ejercicio 9, pero solo incluya estados con 5 o más encuestas buenas. Sugerencia: use \texttt{group\_by}, \texttt{filter} y luego \texttt{ungroup}. Verá que el Oeste (Washington, Nuevo México, California) subestimó el desempeño de Hillary, mientras que el Medio Oeste (Michigan, Pennsylvania, Wisconsin, Ohio, Missouri) lo sobrestimó. En nuestra simulación, no modelamos este comportamiento ya que añadimos un sesgo general, en lugar de un sesgo regional. Tenga en cuenta que algunos encuestadores ahora pueden modelar la correlación entre estados similares y estimar esta correlación a partir de datos históricos. Para obtener más información sobre esto, puede aprender sobre efectos aleatorios y modelos mixtos.

\hypertarget{t-dist}{%
\section{La distribución t}\label{t-dist}}

Arriba utilizamos el CLT con un tamaño de muestra de 15. Como estamos estimando un segundo parámetro \(\sigma\), se introduce más variabilidad a nuestro intervalo de confianza, lo que da como resultado intervalos muy pequeños. Para tamaños de muestra muy grandes, esta variabilidad adicional es insignificante, pero, en general, para valores menores de 30 debemos ser cautelosos al usar el CLT.

Sin embargo, si se sabe que los datos en la urna siguen una distribución normal, entonces tenemos una teoría matemática que nos dice cuánto más grande necesitamos hacer los intervalos para tomar en cuenta el estimador de \(\sigma\). Usando esta teoría, podemos construir intervalos de confianza para cualquier \(N\). Pero, de nuevo, esto funciona solo si \textbf{sabemos que los datos en la urna siguen una distribución normal}. Entonces, para los datos 0, 1 de nuestro modelo de urna anterior, esta teoría definitivamente no aplica.

La estadística en la que se basan los intervalos de confianza para \(d\) es:

\[
Z = \frac{\bar{X} - d}{\sigma/\sqrt{N}}
\]

El CLT nos dice que la distribución de Z es aproximadamente normal con valor esperado 0 y error estándar 1. Pero en la práctica no sabemos \(\sigma\), entonces usamos:

\[
t = \frac{\bar{X} - d}{s/\sqrt{N}}
\]

A esto se le conoce la estadística t. Al sustituir \(\sigma\) con \(s\), introducimos cierta variabilidad. La teoría nos dice que \(t\) sigue una distribución t con \(N-1\) \emph{grados de libertad}. Los grados de libertad son un parámetro que controla la variabilidad a través de colas más pesadas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/t-distribution-examples-1} \end{center}

Si estamos dispuestos a suponer que los datos del efecto del encuestador siguen una distribución normal, según la muestra de datos \(X_1, \dots, X_N\),

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_poll\_per\_pollster }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample=}\NormalTok{spread)) }\SpecialCharTok{+} \FunctionTok{stat\_qq}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/poll-spread-qq-1} \end{center}

entonces \(t\) sigue una distribución t con \(N-1\) grados de libertad. Por eso, quizás un mejor intervalo de confianza para \(d\) es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{qt}\NormalTok{(}\FloatTok{0.975}\NormalTok{, }\FunctionTok{nrow}\NormalTok{(one\_poll\_per\_pollster)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{one\_poll\_per\_pollster }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(spread), }\AttributeTok{moe =}\NormalTok{ z}\SpecialCharTok{*}\FunctionTok{sd}\NormalTok{(spread)}\SpecialCharTok{/}\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{length}\NormalTok{(spread))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{start =}\NormalTok{ avg }\SpecialCharTok{{-}}\NormalTok{ moe, }\AttributeTok{end =}\NormalTok{ avg }\SpecialCharTok{+}\NormalTok{ moe)}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 4}
\CommentTok{\#\textgreater{}      avg    moe  start    end}
\CommentTok{\#\textgreater{}    \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 0.0290 0.0134 0.0156 0.0424}
\end{Highlighting}
\end{Shaded}

que es un poco más grande que cuando usamos la distribución normal. Esto es porque:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qt}\NormalTok{(}\FloatTok{0.975}\NormalTok{, }\DecValTok{14}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2.14}
\end{Highlighting}
\end{Shaded}

es más grande que:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1.96}
\end{Highlighting}
\end{Shaded}

La distribución t y la estadística t son la base para llevar acabo pruebas t, un acercamiento comúnmente usado para calcular valores p.~Para aprender más sobre las prueba t, puede consultar un libro de texto de estadística.

La distribución t también se puede usar para modelar errores cuando esperamos que la probabilidad de grandes desviaciones de la media sea mayor de lo que dicta la distribución normal. FiveThirtyEight utiliza la distribución t para generar errores que modelan mejor las desviaciones que vemos en los datos electorales. Por ejemplo, en Wisconsin, el promedio de seis encuestas fue 7\% a favor de Clinton con una desviación estándar de 1\%, pero Trump ganó por 0.7\%. Incluso después de tomar en cuenta el sesgo general, este residuo de 7.7\% está más en línea con datos que siguen la distribución t, que con datos que siguen la distribución normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_us\_election\_2016"}\NormalTok{)}
\NormalTok{polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state }\SpecialCharTok{==}\StringTok{"Wisconsin"} \SpecialCharTok{\&}
\NormalTok{           enddate }\SpecialCharTok{\textgreater{}=}\StringTok{"2016{-}10{-}31"} \SpecialCharTok{\&}
\NormalTok{           (grade }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"A+"}\NormalTok{,}\StringTok{"A"}\NormalTok{,}\StringTok{"A{-}"}\NormalTok{,}\StringTok{"B+"}\NormalTok{) }\SpecialCharTok{|} \FunctionTok{is.na}\NormalTok{(grade))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{spread =}\NormalTok{ rawpoll\_clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{state =} \FunctionTok{as.character}\NormalTok{(state)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(results\_us\_election\_2016, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{actual =}\NormalTok{ clinton}\SpecialCharTok{/}\DecValTok{100} \SpecialCharTok{{-}}\NormalTok{ trump}\SpecialCharTok{/}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{actual =} \FunctionTok{first}\NormalTok{(actual), }\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(spread),}
            \AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(spread), }\AttributeTok{n =} \FunctionTok{n}\NormalTok{()) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(actual, avg, sd, n)}
\CommentTok{\#\textgreater{}   actual    avg     sd n}
\CommentTok{\#\textgreater{} 1 {-}0.007 0.0711 0.0104 6}
\end{Highlighting}
\end{Shaded}

\hypertarget{regression}{%
\chapter{Regresión}\label{regression}}

Hasta ahora, este libro se ha enfocado principalmente en variables individuales. Sin embargo, en aplicaciones de ciencia de datos, es muy común estar interesado en la relación entre dos o más variables. Por ejemplo, en el Capítulo \ref{linear-models}, utilizaremos un enfoque basado en datos que examina la relación entre las estadísticas de los jugadores y el éxito para guiar la construcción de un equipo de béisbol con un presupuesto limitado. Antes de profundizar en este ejemplo más complejo, presentamos los conceptos necesarios para entender la regresión utilizando una ilustración más sencilla. De hecho, utilizamos el set de datos con el cual se inventó la regresión.

El ejemplo es de la genética. Francis Galton\footnote{\url{https://en.wikipedia.org/wiki/Francis_Galton}} estudió la variación y la herencia de los rasgos humanos. Entre muchos otros rasgos, Galton recopiló y estudió datos de estatura de familias para tratar de entender la herencia. Mientras hacía eso, desarrolló los conceptos de correlación y regresión, así como una conexión a pares de datos que siguen una distribución normal. Por supuesto, en el momento en que se recopilaron estos datos, nuestro conocimiento de la genética era bastante limitado en comparación con lo que sabemos hoy. Una pregunta muy específica que Galton intentó contestar fue: ¿cuán bien podemos predecir la altura de un niño basándose en la altura de los padres? La técnica que desarrolló para responder a esta pregunta, la regresión, también se puede aplicar a nuestra pregunta de béisbol y a muchas otras circunstancias.

\textbf{Nota histórica}: Galton hizo importantes contribuciones a las estadísticas y la genética, pero también fue uno de los primeros defensores de la eugenesia, un movimiento filosófico científicamente defectuoso favorecido por muchos biólogos de la época de Galton, pero con terribles consecuencias históricas\footnote{\url{https://pged.org/history-eugenics-and-genetics/}}.

\hypertarget{estudio-de-caso-la-altura-es-hereditaria}{%
\section{Estudio de caso: ¿la altura es hereditaria?}\label{estudio-de-caso-la-altura-es-hereditaria}}

Tenemos acceso a los datos de altura familiar de Galton a través del paquete \textbf{HistData}. Estos datos contienen alturas de varias docenas de familias: madres, padres, hijas e hijos. Para imitar el análisis de Galton, crearemos un set de datos con las alturas de los padres y un hijo de cada familia seleccionado al azar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(HistData)}
\FunctionTok{data}\NormalTok{(}\StringTok{"GaltonFamilies"}\NormalTok{)}

\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1983}\NormalTok{)}
\NormalTok{galton\_heights }\OtherTok{\textless{}{-}}\NormalTok{ GaltonFamilies }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(gender }\SpecialCharTok{==} \StringTok{"male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(family) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(father, childHeight) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{son =}\NormalTok{ childHeight)}
\end{Highlighting}
\end{Shaded}

En los ejercicios, veremos otras relaciones, incluyendo la de madres e hijas.

Supongan que nos piden que resumamos los datos de padre e hijo. Dado que ambas distribuciones están bien aproximadas por la distribución normal, podríamos usar los dos promedios y las dos desviaciones estándar como resúmenes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{mean}\NormalTok{(father), }\FunctionTok{sd}\NormalTok{(father), }\FunctionTok{mean}\NormalTok{(son), }\FunctionTok{sd}\NormalTok{(son))}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 4}
\CommentTok{\#\textgreater{}   \textasciigrave{}mean(father)\textasciigrave{} \textasciigrave{}sd(father)\textasciigrave{} \textasciigrave{}mean(son)\textasciigrave{} \textasciigrave{}sd(son)\textasciigrave{}}
\CommentTok{\#\textgreater{}            \textless{}dbl\textgreater{}        \textless{}dbl\textgreater{}       \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1           69.1         2.55        69.2      2.71}
\end{Highlighting}
\end{Shaded}

Sin embargo, este resumen no describe una característica importante de los datos: la tendencia de que entre más alto es el padre, más alto es el hijo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(father, son)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/scatterplot-1} \end{center}

Aprenderemos que el coeficiente de correlación es un resumen informativo de cómo dos variables se mueven juntas y luego veremos cómo esto se puede usar para predecir una variable usando la otra.

\hypertarget{corr-coef}{%
\section{El coeficiente de correlación}\label{corr-coef}}

El coeficiente de correlación se define para una lista de pares \((x_1, y_1), \dots, (x_n,y_n)\) como el promedio del producto de los valores estandarizados:

\[
\rho = \frac{1}{n} \sum_{i=1}^n \left( \frac{x_i-\mu_x}{\sigma_x} \right)\left( \frac{y_i-\mu_y}{\sigma_y} \right)
\]
con \(\mu_x, \mu_y\) los promedios de \(x_1,\dots, x_n\) y \(y_1, \dots, y_n\), respectivamente, y \(\sigma_x, \sigma_y\) las desviaciones estándar. La letra griega para \(r\), \(\rho\), se usa comúnmente en libros de estadística para denotar la correlación porque es la primera letra de la palabra regresión. Pronto aprenderemos sobre la conexión entre correlación y regresión. Podemos representar la fórmula anterior con código R usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rho }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(}\FunctionTok{scale}\NormalTok{(x) }\SpecialCharTok{*} \FunctionTok{scale}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

Para entender por qué esta ecuación resume cómo se mueven juntas dos variables, consideren que la entrada número \(i\) de \(x\) está \(\left( \frac{x_i-\mu_x}{\sigma_x} \right)\) desviaciones estándar del promedio \(\mu_x\). Del mismo modo, el \(y_i\) que se combina con \(x_i\), está \(\left( \frac{y_1-\mu_y}{\sigma_y} \right)\) desviaciones estándar del promedio \(\mu_y\). Si \(x\) e \(y\) no están relacionadas, el producto \(\left( \frac{x_i-\mu_x}{\sigma_x} \right)\left( \frac{y_i-\mu_y}{\sigma_y} \right)\) será positivo (\(+ \times +\) y \(- \times -\)) tan frecuentemente como negativo (\(+ \times -\) y \(- \times +\)) y tendrá un promedio de alrededor de 0. La correlación es el promedio de estos productos y, por lo tanto, las variables no relacionadas tendrán correlación 0. En cambio, si las cantidades varían juntas, entonces estamos promediando productos mayormente positivos (\(+ \times +\) y \(- \times -\)) y obtenemos una correlación positiva. Si varían en direcciones opuestas, obtenemos una correlación negativa.

El coeficiente de correlación siempre está entre -1 y 1. Podemos mostrar esto matemáticamente: consideren que no podemos tener una correlación más alta que cuando comparamos una lista consigo misma (correlación perfecta) y, en este caso, la correlación es:

\[
\rho = \frac{1}{n} \sum_{i=1}^n \left( \frac{x_i-\mu_x}{\sigma_x} \right)^2 =
\frac{1}{\sigma_x^2} \frac{1}{n} \sum_{i=1}^n \left( x_i-\mu_x \right)^2 =
\frac{1}{\sigma_x^2} \sigma^2_x =
1
\]

Una derivación similar, pero con \(x\) y su opuesto exacto, prueba que la correlación tiene que ser mayor o igual a -1.

Para otros pares, la correlación está entre -1 y 1. La correlación entre las alturas de padre e hijo es de aproximadamente 0.5:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{r =} \FunctionTok{cor}\NormalTok{(father, son)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(r)}
\CommentTok{\#\textgreater{} [1] 0.433}
\end{Highlighting}
\end{Shaded}

Para ver cómo se ven los datos para diferentes valores de \(\rho\), aquí tenemos seis ejemplos de pares con correlaciones que van desde -0.9 a 0.99:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/what-correlation-looks-like-1} \end{center}

\hypertarget{la-correlaciuxf3n-de-muestra-es-una-variable-aleatoria}{%
\subsection{La correlación de muestra es una variable aleatoria}\label{la-correlaciuxf3n-de-muestra-es-una-variable-aleatoria}}

Antes de continuar conectando la correlación con la regresión, recordemos la variabilidad aleatoria.

En la mayoría de las aplicaciones de ciencia de datos, observamos datos que incluyen variación aleatoria. Por ejemplo, en muchos casos, no observamos datos para toda la población de interés, sino para una muestra aleatoria. Al igual que con la desviación promedio y estándar, la \emph{correlación de muestra} (\emph{sample correlation} en inglés) es el estimador más comúnmente utilizado de la correlación de la población. Esto implica que la correlación que calculamos y usamos como resumen es una variable aleatoria.

A modo de ilustración, supongan que los 179 pares de padres e hijos es toda nuestra población. Un genetista menos afortunado solo puede permitirse mediciones de una muestra aleatoria de 25 pares. La correlación de la muestra se puede calcular con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{R }\OtherTok{\textless{}{-}} \FunctionTok{sample\_n}\NormalTok{(galton\_heights, }\DecValTok{25}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{r =} \FunctionTok{cor}\NormalTok{(father, son)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(r)}
\end{Highlighting}
\end{Shaded}

\texttt{R} es una variable aleatoria. Podemos ejecutar una simulación Monte Carlo para ver su distribución:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{25}
\NormalTok{R }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
  \FunctionTok{sample\_n}\NormalTok{(galton\_heights, N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{r=}\FunctionTok{cor}\NormalTok{(father, son)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(r)}
\NormalTok{\})}
\FunctionTok{qplot}\NormalTok{(R, }\AttributeTok{geom =} \StringTok{"histogram"}\NormalTok{, }\AttributeTok{binwidth =} \FloatTok{0.05}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/sample-correlation-distribution-1} \end{center}

Vemos que el valor esperado de \texttt{R} es la correlación de la población:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(R)}
\CommentTok{\#\textgreater{} [1] 0.431}
\end{Highlighting}
\end{Shaded}

y que tiene un error estándar relativamente alto en relación con el rango de valores que \texttt{R} puede tomar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(R)}
\CommentTok{\#\textgreater{} [1] 0.161}
\end{Highlighting}
\end{Shaded}

Entonces, al interpretar las correlaciones, recuerden que las correlaciones derivadas de las muestras son estimadores que contienen incertidumbre.

Además, tengan en cuenta que debido a que la correlación de la muestra es un promedio de sorteos independientes, el límite central aplica. Por lo tanto, para \(N\) suficientemente grande, la distribución de \texttt{R} es aproximadamente normal con valor esperado \(\rho\). La desviación estándar, que es algo compleja para derivar, es \(\sqrt{\frac{1-r^2}{N-2}}\).

En nuestro ejemplo, \(N=25\) no parece ser lo suficientemente grande como para que la aproximación sea buena:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample=}\NormalTok{R), }\AttributeTok{data =} \FunctionTok{data.frame}\NormalTok{(R)) }\SpecialCharTok{+}
  \FunctionTok{stat\_qq}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \FunctionTok{mean}\NormalTok{(R), }\AttributeTok{slope =} \FunctionTok{sqrt}\NormalTok{((}\DecValTok{1}\SpecialCharTok{{-}}\FunctionTok{mean}\NormalTok{(R)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\NormalTok{(N}\DecValTok{{-}2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/small-sample-correlation-not-normal-1} \end{center}

Si aumentan \(N\), verán que la distribución converge a la normalidad.

\hypertarget{la-correlaciuxf3n-no-siempre-es-un-resumen-uxfatil}{%
\subsection{La correlación no siempre es un resumen útil}\label{la-correlaciuxf3n-no-siempre-es-un-resumen-uxfatil}}

La correlación no siempre es un buen resumen de la relación entre dos variables. Los siguientes cuatro sets de datos artificiales, conocidos como el cuarteto de Anscombe, ilustran este punto. Todos estos pares tienen una correlación de 0.82:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ascombe-quartet-1} \end{center}

La correlación solo tiene sentido en un contexto particular. Para ayudarnos a entender cuándo la correlación tiene sentido como resumen estadístico, volveremos al ejemplo de predecir la altura de un hijo usando la altura de su padre. Esto ayudará a motivar y definir la regresión lineal. Comenzamos demostrando cómo la correlación puede ser útil para la predicción.

\hypertarget{conditional-expectation}{%
\section{Valor esperado condicional}\label{conditional-expectation}}

Supongan que se nos pide que adivinemos la altura de un hijo, seleccionado al azar, y no sabemos la altura de su padre. Debido a que la distribución de las alturas de los hijos es aproximadamente normal, conocemos que la altura promedio, 69.2, es el valor con la mayor proporción y sería la predicción con la mayor probabilidad de minimizar el error. Pero, ¿qué pasa si nos dicen que el padre es más alto que el promedio, digamos que mide 72 pulgadas, todavía adivinaríamos 69.2 para el hijo?

Resulta que si pudiéramos recopilar datos de un gran número de padres que miden 72 pulgadas, la distribución de las alturas de sus hijos sigue una distribución normal. Esto implica que el promedio de la distribución calculada en este subconjunto sería nuestra mejor predicción.

En general, llamamos a este enfoque \emph{condicionar} (\emph{conditioning} en inglés). La idea general es que estratificamos una población en grupos y calculamos resúmenes para cada grupo. Por lo tanto, condicionar está relacionado con el concepto de estratificación descrito en la Sección \ref{stratification}. Para proveer una descripción matemática del condicionamiento, consideren que tenemos una población de pares de valores \((x_1,y_1),\dots,(x_n,y_n)\), por ejemplo, todas las alturas de padres e hijos en Inglaterra. En el capítulo anterior, aprendimos que si tomamos un par aleatorio \((X,Y)\), el valor esperado y el mejor predictor de \(Y\) es \(\mbox{E}(Y) = \mu_y\), el promedio de la población \(1/n\sum_{i=1}^n y_i\). Sin embargo, ya no estamos interesados en la población general, sino en el subconjunto de la población con un valor específico de \(x_i\), 72 pulgadas en nuestro ejemplo. Este subconjunto de la población también es una población y, por lo tanto, los mismos principios y propiedades que hemos aprendido aplican. Los \(y_i\) en la subpoblación tienen una distribución, denominada \emph{distribución condicional} (\emph{conditional distribution} en inglés), y esta distribución tiene un valor esperado denominado \emph{valor esperado condicional} (\emph{conditional expectation} en inglés). En nuestro ejemplo, el valor esperado condicional es la altura promedio de todos los hijos en Inglaterra con padres que miden 72 pulgadas. La notación estadística para el valor esperado condicional es:

\[
\mbox{E}(Y \mid X = x)
\]

con \(x\) representando el valor fijo que define ese subconjunto, por ejemplo, en nuestro caso 72 pulgadas. Del mismo modo, denotamos la desviación estándar de los estratos con:

\[
\mbox{SD}(Y \mid X = x) = \sqrt{\mbox{Var}(Y \mid X = x)}
\]

Como el valor esperado condicional \(E(Y\mid X=x)\) es el mejor predictor para la variable aleatoria \(Y\) para un individuo en los estratos definidos por \(X=x\), muchos retos de la ciencia de datos se reducen a los estimadores de esta cantidad. La desviación estándar condicional cuantifica la precisión de la predicción.

En el ejemplo que hemos estado considerando, queremos calcular la altura promedio del hijo \emph{condicionado en} que el padre mida 72 pulgadas. Queremos estimar \(E(Y|X=72)\) utilizando la muestra recopilada por Galton. Anteriormente aprendimos que el promedio de la muestra es el enfoque preferido para estimar el promedio de la población. Sin embargo, un reto al usar este enfoque para estimar los valores esperados condicionales es que para los datos continuos no tenemos muchos puntos de datos que coincidan exactamente con un valor en nuestra muestra. Por ejemplo, solo tenemos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father }\SpecialCharTok{==} \DecValTok{72}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 8}
\end{Highlighting}
\end{Shaded}

padres que miden exactamente 72 pulgadas. Si cambiamos el número a 72.5, obtenemos aún menos puntos de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father }\SpecialCharTok{==} \FloatTok{72.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

Una forma práctica de mejorar estos estimadores de los valores esperados condicionales es definir estratos con valores similares de \(x\). En nuestro ejemplo, podemos redondear las alturas del padre a la pulgada más cercana y suponer que todas son 72 pulgadas. Si hacemos esto, terminamos con la siguiente predicción para el hijo de un padre que mide 72 pulgadas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{conditional\_avg }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{round}\NormalTok{(father) }\SpecialCharTok{==} \DecValTok{72}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(son)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(avg)}
\NormalTok{conditional\_avg}
\CommentTok{\#\textgreater{} [1] 70.5}
\end{Highlighting}
\end{Shaded}

Noten que un padre que mide 72 pulgadas es más alto que el promedio, específicamente (72.0 - 69.1)/2.5 =
1.1 desviaciones estándar más alto que el padre promedio. Nuestra predicción 70.5 también es más alta que el promedio, pero solo 0.49 desviaciones estándar más que el hijo promedio. Los hijos de padres que miden 72 pulgadas han \emph{retrocedido} (\emph{regressed} en inglés) un poco hacia la altura promedio. Observamos que la reducción en la cantidad de desviaciones estandár es de aproximadamente 0.5, que es la correlación. Como veremos en una sección posterior, esto no es una coincidencia.

Si queremos hacer una predicción de cualquier altura, no solo 72 pulgadas, podríamos aplicar el mismo enfoque a cada estrato. La estratificación seguida por diagramas de caja nos permite ver la distribución de cada grupo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{father\_strata =} \FunctionTok{factor}\NormalTok{(}\FunctionTok{round}\NormalTok{(father))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(father\_strata, son)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/boxplot-1-1} \end{center}

No es sorprendente que los centros de los grupos estén aumentando con la altura. Además, estos centros parecen seguir una relación lineal. A continuación graficamos los promedios de cada grupo. Si tomamos en cuenta que estos promedios son variables aleatorias con errores estándar, los datos son consistentes con estos puntos siguiendo una línea recta:

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/conditional-averages-follow-line-1} \end{center}

El hecho de que estos promedios condicionales sigan una línea no es una coincidencia. En la siguiente sección, explicamos que la línea que siguen estos promedios es lo que llamamos la \emph{línea de regresión} (\emph{regression line} en inglés), que mejora la precisión de nuestros estimadores. Sin embargo, no siempre es apropiado estimar los valores esperados condicionales con la línea de regresión, por lo que también describimos la justificación teórica de Galton para usar la línea de regresión.

\hypertarget{la-luxednea-de-regresiuxf3n}{%
\section{La línea de regresión}\label{la-luxednea-de-regresiuxf3n}}

Si estamos prediciendo una variable aleatoria \(Y\) sabiendo el valor de otra variable \(X=x\) y usando una línea de regresión, entonces predecimos que por cada desviación estándar \(\sigma_X\) que \(x\) aumenta por encima del promedio \(\mu_X\), \(Y\) aumenta \(\rho\) desviaciones estándar \(\sigma_Y\) por encima del promedio \(\mu_Y\) con \(\rho\) la correlación entre \(X\) y \(Y\). Por lo tanto, la fórmula para la regresión es:

\[
\left( \frac{Y-\mu_Y}{\sigma_Y} \right) = \rho \left( \frac{x-\mu_X}{\sigma_X} \right)
\]

Podemos reescribirla así:

\[
Y = \mu_Y + \rho \left( \frac{x-\mu_X}{\sigma_X} \right) \sigma_Y
\]

Si hay una correlación perfecta, la línea de regresión predice un aumento que es el mismo número de desviaciones estandár. Si hay 0 correlación, entonces no usamos \(x\) para la predicción y simplemente predecimos el promedio \(\mu_Y\). Para valores entre 0 y 1, la predicción está en algún punto intermedio. Si la correlación es negativa, predecimos una reducción en vez de un aumento.

Tengan en cuenta que si la correlación es positiva e inferior a 1, nuestra predicción está más cerca, en unidades estándar, de la altura promedio que el valor utilizado para predecir, \(x\), está del promedio de las \(x\)s. Es por eso que lo llamamos \emph{regresión}: el hijo retrocede a la altura promedio. De hecho, el título del artículo de Galton era: \emph{Regression towards mediocrity in hereditary stature}. Para añadir líneas de regresión a los gráficos, necesitaremos la siguiente versión de la fórmula anterior:

\[
y= b + mx \mbox{ with slope } m = \rho \frac{\sigma_y}{\sigma_x} \mbox{ and intercept } b=\mu_y - m \mu_x
\]

Aquí añadimos la línea de regresión a los datos originales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu\_x }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{mu\_y }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{s\_x }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{s\_y }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{r }\OtherTok{\textless{}{-}} \FunctionTok{cor}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father, galton\_heights}\SpecialCharTok{$}\NormalTok{son)}

\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(father, son)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{slope =}\NormalTok{ r }\SpecialCharTok{*}\NormalTok{ s\_y}\SpecialCharTok{/}\NormalTok{s\_x, }\AttributeTok{intercept =}\NormalTok{ mu\_y }\SpecialCharTok{{-}}\NormalTok{ r }\SpecialCharTok{*}\NormalTok{ s\_y}\SpecialCharTok{/}\NormalTok{s\_x }\SpecialCharTok{*}\NormalTok{ mu\_x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/regression-line-1} \end{center}

La fórmula de regresión implica que si primero estandarizamos las variables, es decir, restamos el promedio y dividimos por la desviación estándar, entonces la línea de regresión tiene un intercepto 0 y una pendiente igual a la correlación \(\rho\). Pueden hacer el mismo gráfico, pero usando unidades estándar así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\FunctionTok{scale}\NormalTok{(father), }\FunctionTok{scale}\NormalTok{(son))) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \DecValTok{0}\NormalTok{, }\AttributeTok{slope =}\NormalTok{ r)}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-regresiuxf3n-mejora-la-precisiuxf3n}{%
\subsection{La regresión mejora la precisión}\label{la-regresiuxf3n-mejora-la-precisiuxf3n}}

Comparemos los dos enfoques de predicción que hemos presentado:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Redondear las alturas de los padres a la pulgada más cercana, estratificar y luego tomar el promedio.
\item
  Calcular la línea de regresión y usarla para predecir.
\end{enumerate}

Utilizamos una simulación Monte Carlo que muestrea \(N=50\) familias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{50}

\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1983}\NormalTok{)}
\NormalTok{conditional\_avg }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  dat }\OtherTok{\textless{}{-}} \FunctionTok{sample\_n}\NormalTok{(galton\_heights, N)}
\NormalTok{  dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(}\FunctionTok{round}\NormalTok{(father) }\SpecialCharTok{==} \DecValTok{72}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(son)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(avg)}
\NormalTok{\})}

\NormalTok{regression\_prediction }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  dat }\OtherTok{\textless{}{-}} \FunctionTok{sample\_n}\NormalTok{(galton\_heights, N)}
\NormalTok{  mu\_x }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{  mu\_y }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{  s\_x }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{  s\_y }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{  r }\OtherTok{\textless{}{-}} \FunctionTok{cor}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{father, dat}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{  mu\_y }\SpecialCharTok{+}\NormalTok{ r}\SpecialCharTok{*}\NormalTok{(}\DecValTok{72} \SpecialCharTok{{-}}\NormalTok{ mu\_x)}\SpecialCharTok{/}\NormalTok{s\_x}\SpecialCharTok{*}\NormalTok{s\_y}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Aunque el valor esperado de estas dos variables aleatorias es casi el mismo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(conditional\_avg, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 70.5}
\FunctionTok{mean}\NormalTok{(regression\_prediction)}
\CommentTok{\#\textgreater{} [1] 70.5}
\end{Highlighting}
\end{Shaded}

El error estándar para la predicción usando la regresión es sustancialmente más pequeño:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(conditional\_avg, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.964}
\FunctionTok{sd}\NormalTok{(regression\_prediction)}
\CommentTok{\#\textgreater{} [1] 0.452}
\end{Highlighting}
\end{Shaded}

La línea de regresión es, por lo tanto, mucho más estable que la media condicional. Hay una razón intuitiva para esto. El promedio condicional se basa en un subconjunto relativamente pequeño: los padres que miden aproximadamente 72 pulgadas. De hecho, en algunas de las permutaciones no tenemos datos, por eso utilizamos \texttt{na.rm=TRUE}. La regresión siempre usa todos los datos.

Entonces, ¿por qué no siempre usar la regresión para predecir? Porque no siempre es apropiado. Por ejemplo, Anscombe ofreció casos para los cuales los datos no tienen una relación lineal. Entonces, ¿tiene sentido usar la línea de regresión para predecir en nuestro ejemplo? Galton encontró que sí, en el caso de los datos de altura. La justificación, que incluimos en la siguiente sección, es algo más avanzada que el resto del capítulo.

\hypertarget{distribuciuxf3n-normal-de-dos-variables-avanzada}{%
\subsection{Distribución normal de dos variables (avanzada)}\label{distribuciuxf3n-normal-de-dos-variables-avanzada}}

La correlación y la pendiente de regresión son resumenes estadísticos ampliamente utilizados, pero que a menudo se malinterpretan o se usan mal. Los ejemplos de Anscombe ofrecen casos simplificados de sets de datos en los que resumir con correlación sería un error. Sin embargo, hay muchos más ejemplos de la vida real.

La manera principal en que motivamos el uso de la correlación involucra lo que se llama la \emph{distribución normal de dos variables} (\emph{bivariate normal distribution} en inglés).

Cuando un par de variables aleatorias se aproxima por la distribución normal de dos variables, los diagramas de dispersión parecen óvalos. Como vimos en la Sección \ref{corr-coef}, pueden ser delgados (alta correlación) o en forma de círculo (sin correlación).

Una forma más técnica de definir la distribución normal de dos variables es la siguiente: si \(X\) es una variable aleatoria normalmente distribuida, \(Y\) también es una variable aleatoria normalmente distribuida, y la distribución condicional de \(Y\) para cualquier \(X=x\) es aproximadamente normal, entonces el par sigue una distribución normal de dos variables.

Si creemos que los datos de altura están bien aproximados por la distribución normal de dos variables, entonces deberíamos ver que la aproximación normal aplica a cada estrato. Aquí estratificamos las alturas de los hijos por las alturas estandarizadas de los padres y vemos que el supuesto parece ser válido:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{z\_father =} \FunctionTok{round}\NormalTok{((father }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(father))}\SpecialCharTok{/} \FunctionTok{sd}\NormalTok{(father))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(z\_father }\SpecialCharTok{\%in\%} \SpecialCharTok{{-}}\DecValTok{2}\SpecialCharTok{:}\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{stat\_qq}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample =}\NormalTok{ son)) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{( }\SpecialCharTok{\textasciitilde{}}\NormalTok{ z\_father)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/qqnorm-of-strata-1} \end{center}

Ahora volvemos a tratar de definir correlación. Galton utilizó estadísticas matemáticas para demostrar que, cuando dos variables siguen una distribución normal de dos variables, calcular la línea de regresión es equivalente a calcular los valores esperados condicionales. No mostramos la derivación aquí, pero podemos mostrar que bajo este supuesto, para cualquier valor dado de \(x\), el valor esperado de \(Y\) en pares para los cuales \(X=x\) es:

\[
\mbox{E}(Y | X=x) = \mu_Y + \rho \frac{X-\mu_X}{\sigma_X}\sigma_Y
\]

Esta es la línea de regresión, con pendiente: \[\rho \frac {\sigma_Y} {\sigma_X}\]

e intercepto \(\mu_y - m\mu_X\). Es equivalente a la ecuación de regresión que mostramos anteriormente que se puede escribir así:

\[
\frac{\mbox{E}(Y \mid X=x) - \mu_Y}{\sigma_Y} = \rho \frac{x-\mu_X}{\sigma_X}
\]

Esto implica que, si la distribución de nuestros datos se puede aproximar con una distribución normal de dos variables, la línea de regresión da el valor esperado condicional. Por lo tanto, podemos obtener un estimador mucho más estable del valor esperado condicional al encontrar la línea de regresión y usarla para predecir.

En resumen, si nuestros datos se pueden aproximar con una distribución normal de dos variables, entonces el valor esperado condicional, la mejor predicción de \(Y\) cuando sabemos el valor de \(X\), lo da la línea de regresión.

\hypertarget{varianza-explicada}{%
\subsection{Varianza explicada}\label{varianza-explicada}}

La teoría de la distribución normal de dos variables también nos dice que la desviación estándar de la distribución \emph{condicional} descrita anteriormente es:

\[
\mbox{SD}(Y \mid X=x ) = \sigma_Y \sqrt{1-\rho^2}
\]

Para ver por qué esto es intuitivo, observen que sin condicionar, \(\mbox{SD}(Y) = \sigma_Y\), estamos viendo la variabilidad de todos los hijos. Pero tan pronto condicionamos, solo observamos la variabilidad de los hijos con un padre alto, de 72 pulgadas. Este grupo tenderá a ser algo alto, por lo que se reduce la desviación estándar.

Específicamente, se reduce a \(\sqrt{1-\rho^2} = \sqrt{1 - 0.25}\) = 0.87 de lo que era originalmente. Podríamos decir que las alturas de los padres ``explican'' el 13\% de la variabilidad observada en las alturas de los hijos.

La declaración ``\(X\) explica tal y cual porcentaje de la variabilidad'' se usa comúnmente en los trabajos académicos. En este caso, este porcentaje realmente se refiere a la varianza (la desviación estándar al cuadrado). Entonces si los datos siguen una distribución normal de dos variables, la varianza se reduce por \(1-\rho^2\) y entonces decimos que \(X\) explica \(1- (1-\rho^2)=\rho^2\) (la correlación al cuadrado) de la varianza.

Pero es importante recordar que la declaración de ``varianza explicada'' solo tiene sentido cuando los datos se aproximan mediante una distribución normal de dos variables.

\hypertarget{advertencia-hay-dos-luxedneas-de-regresiuxf3n}{%
\subsection{Advertencia: hay dos líneas de regresión}\label{advertencia-hay-dos-luxedneas-de-regresiuxf3n}}

Calculamos una línea de regresión para predecir la altura del hijo basada en la altura del padre. Utilizamos estos cálculos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu\_x }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{mu\_y }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{s\_x }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father)}
\NormalTok{s\_y }\OtherTok{\textless{}{-}} \FunctionTok{sd}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{r }\OtherTok{\textless{}{-}} \FunctionTok{cor}\NormalTok{(galton\_heights}\SpecialCharTok{$}\NormalTok{father, galton\_heights}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{m\_1 }\OtherTok{\textless{}{-}}\NormalTok{ r }\SpecialCharTok{*}\NormalTok{ s\_y}\SpecialCharTok{/}\NormalTok{ s\_x}
\NormalTok{b\_1 }\OtherTok{\textless{}{-}}\NormalTok{ mu\_y }\SpecialCharTok{{-}}\NormalTok{ m\_1}\SpecialCharTok{*}\NormalTok{mu\_x}
\end{Highlighting}
\end{Shaded}

que nos da la función \(\mbox{E}(Y\mid X=x) =\) 37.3 + 0.46 \(x\).

¿Qué pasa si queremos predecir la altura del padre basada en la del hijo? Es importante saber que esto no se determina calculando la función inversa:
\(x = \{ \mbox{E}(Y\mid X=x) -\) 37.3 \(\}/0.5\).

Necesitamos calcular \(\mbox{E}(X \mid Y=y)\). Dado que los datos se aproximan mediante una distribución normal de dos variables, la teoría descrita anteriormente nos dice que este valor esperado condicional seguirá una línea con pendiente e intercepto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_2 }\OtherTok{\textless{}{-}}\NormalTok{ r }\SpecialCharTok{*}\NormalTok{ s\_x}\SpecialCharTok{/}\NormalTok{ s\_y}
\NormalTok{b\_2 }\OtherTok{\textless{}{-}}\NormalTok{ mu\_x }\SpecialCharTok{{-}}\NormalTok{ m\_2 }\SpecialCharTok{*}\NormalTok{ mu\_y}
\end{Highlighting}
\end{Shaded}

Entonces obtenemos \(\mbox{E}(X \mid Y=y) =40.9 + 0.41y\). Nuevamente vemos una regresión al promedio: la predicción para la altura del padre está más cerca del promedio del padre que la altura del hijo \(y\) está a la altura del hijo promedio.

Aquí tenemos un gráfico que muestra las dos líneas de regresión. La azul predice las alturas de los hijos según las alturas de los padres y la roja predice las alturas de los padres según las alturas de los hijos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(father, son)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =}\NormalTok{ b\_1, }\AttributeTok{slope =}\NormalTok{ m\_1, }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =} \SpecialCharTok{{-}}\NormalTok{b\_2}\SpecialCharTok{/}\NormalTok{m\_2, }\AttributeTok{slope =} \DecValTok{1}\SpecialCharTok{/}\NormalTok{m\_2, }\AttributeTok{col =} \StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/two-regression-lines-1} \end{center}

\hypertarget{ejercicios-33}{%
\section{Ejercicios}\label{ejercicios-33}}

1. Cargue los datos \texttt{GaltonFamilies} de \textbf{HistData}. Los niños de cada familia se enumeran por género y luego por estatura. Cree un set de datos llamado \texttt{galton\_heights} eligiendo un varón y una hembra al azar.

2. Haga un diagrama de dispersión para las alturas entre madres e hijas, madres e hijos, padres e hijas, y padres e hijos.

3. Calcule la correlación en las alturas entre madres e hijas, madres e hijos, padres e hijas, y padres e hijos.

\hypertarget{linear-models}{%
\chapter{Modelos lineales}\label{linear-models}}

Desde el desarrollo original de Galton, la regresión se ha convertido en una de las herramientas más utilizadas en la ciencia de datos. Una razón por esto es que la regresión nos permite encontrar relaciones entre dos variables tomando en cuenta los efectos de otras variables que afectan a ambas. Esto ha sido particularmente popular en campos donde los experimentos aleatorios son difíciles de ejecutar, como la economía y la epidemiología.

Cuando no podemos asignar aleatoriamente a cada individuo a un grupo de tratamiento o control, la confusión (\emph{confounding} en inglés) es particularmente frecuente. Por ejemplo, consideren estimar el efecto de comer comidas rápidas en la esperanza de vida utilizando datos recopilados de una muestra aleatoria de personas en una jurisdicción. Es más probable que los consumidores de comida rápida sean fumadores, bebedores y tengan ingresos más bajos. Por lo tanto, un modelo sencillo de regresión puede sobrestimar el efecto negativo de la comida rápida en la salud. Entonces, ¿cómo explicamos la confusión en la práctica? En este capítulo aprendemos cómo los modelos lineales pueden ayudar con estas situaciones y cómo pueden usarse para describir cómo una o más variables afectan el resultado.

\hypertarget{estudio-de-caso-moneyball}{%
\section{\texorpdfstring{Estudio de caso: \emph{Moneyball}}{Estudio de caso: Moneyball}}\label{estudio-de-caso-moneyball}}

El libro \emph{Moneyball: El arte de ganar un juego injusto} de Michael Lewis se trata del equipo de béisbol los Atléticos de Oakland, también conocidos como los A's, y su gerente general, la persona encargada de construir el equipo, Billy Beane.

Tradicionalmente, los equipos de béisbol usan \emph{scouts}, o buscadores de talento, para ayudarlos a decidir qué jugadores contratar. Estos \emph{scouts} evalúan a los jugadores viéndolos jugar. Por esta razón, tienden a favorecer a los jugadores atléticos con habilidades físicas observables y, en general, hay consenso entre los \emph{scouts} sobre quiénes son los mejores jugadores. Como consecuencia, hay mucha demanda para estos jugadores, lo cual aumenta sus salarios.

De 1989 a 1991, los A's tuvieron una de las nóminas más altas del béisbol. Pudieron comprar los mejores jugadores y, durante estos años, fueron uno de los mejores equipos. Sin embargo, en 1995, el dueño del equipo cambió y la nueva administración recortó drásticamente el presupuesto, dejando al entonces gerente general, Sandy Alderson, con una de las nóminas más bajas en el béisbol. Éste ya no podía permitirse el lujo de los jugadores más codiciados y, por eso, comenzó a utilizar un enfoque estadístico para encontrar ineficiencias en el mercado. Alderson fue mentor de Billy Beane, quien lo sucedió en 1998 y aceptó por completo la ciencia de los datos, en vez de los \emph{scouts}, como un método para encontrar jugadores de bajo costo que, según los datos, ayudarían al equipo a ganar. Hoy, esta estrategia ha sido adaptada por la mayoría de los equipos de béisbol. Como veremos, la regresión juega un papel importante en este enfoque.

Como motivación para este capítulo, fingiremos que es 2002 y trataremos de construir un equipo de béisbol con un presupuesto limitado, tal como lo hicieron los Atléticos. Para apreciar la dificultad del reto, tengan en cuenta que en 2002 la nómina de los Yankees de \$125,928,583 era más del triple de la de los Atléticos de Oakland de \$39,679,746.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mlb-2002-payroll-1} \end{center}

\hypertarget{sabermetrics}{%
\subsection{Sabermetrics}\label{sabermetrics}}

Las estadísticas se han utilizado en el béisbol desde sus inicios. El set de datos que usaremos, que se incluye en el paquete \textbf{Lahman}, se remonta al siglo XIX. Por ejemplo, un resumen estadístico que describiremos pronto, el \emph{promedio de bateo} (\emph{batting average} en inglés), se ha utilizado durante décadas para resumir el éxito de un bateador. Otras estadísticas\footnote{\url{http://mlb.mlb.com/stats/league_leaders.jsp}} como cuadrangulares (HR o \emph{homeruns} en inglés), carreras impulsadas (RBI o \emph{runs batted in} en inglés) y bases robadas (SB o \emph{stolen bases} en inglés) se indican para cada jugador en los resúmenes del juego que se incluyen en la sección de deportes de periódicos, con jugadores recompensados por números altos. Aunque resúmenes estadísticos como estos se utilizaron ampliamente en el béisbol, el análisis de datos en sí se ignoraba. Estas estadísticas se escogieron arbitrariamente sin pensar mucho en si realmente predecían algo o si estaban relacionadas con ayudar a un equipo a ganar.

Esto cambió con Bill James\footnote{\url{https://en.wikipedia.org/wiki/Bill_James}}. A fines de la década de 1970, este fanático del béisbol y aspirante a escritor comenzó a publicar artículos que describían un análisis más profundo de los datos del béisbol. Denominó \emph{sabermetrics}\footnote{\url{https://en.wikipedia.org/wiki/Sabermetrics}} al enfoque de usar datos para pronosticar qué resultados mejor predicen si un equipo ganará. Hasta que Billy Beane convirtió a \emph{sabermetrics} en el centro de su operación de béisbol, el mundo del béisbol por lo general ignoró el trabajo de Bill James. Actualmente, la popularidad de \emph{sabermetrics} ya no se limita solo al béisbol; varios otros deportes también han comenzado a usar este enfoque.

En este capítulo, para simplificar el ejercicio, nos enfocaremos en carreras (R o \emph{runs} en inglés) anotadas e ignoraremos los otros dos aspectos importantes del juego: lanzar y fildear. Veremos cómo el análisis de regresión puede ayudar a desarrollar estrategias para construir un equipo de béisbol competitivo con un presupuesto limitado. El acercamiento se puede dividir en dos análisis de datos separados. En el primero, determinamos qué estadísticas específicas del jugador predicen carreras. En el segundo, examinamos si los jugadores estaban infravalorados según lo que predice nuestro primer análisis.

\hypertarget{conceptos-buxe1sicos-de-buxe9isbol}{%
\subsection{Conceptos básicos de béisbol}\label{conceptos-buxe1sicos-de-buxe9isbol}}

Para ver cómo la regresión nos ayudará a encontrar jugadores infravalorados, no necesitamos entender todos los detalles sobre el juego de béisbol, que tiene más de 100 reglas. Aquí, destilamos el deporte al conocimiento básico que uno necesita saber para atacar efectivamente el reto de analizar los datos.

El objetivo de un juego de béisbol es anotar más carreras (puntos) que el otro equipo. Cada equipo tiene 9 bateadores que tienen la oportunidad de darle a una pelota con un bate en un orden predeterminado. Después de que el noveno bateador haya tenido su turno, el primer bateador vuelve a batear, luego el segundo y así sucesivamente. Cada vez que un bateador tiene la oportunidad de batear, lo llamamos una \emph{turno al bate} (PA o \emph{plate appearance} en inglés). En cada PA, el lanzador (\emph{pitcher} en inglés) del otro equipo lanza la pelota y el bateador intenta darle. El PA termina con un resultado binario: el bateador hace un \emph{out} (falla) y regresa al banco o el bateador le da a la bola (éxito) y puede correr alrededor de las bases, y potencialmente anotar una carrera (llegar a las 4 bases). Cada equipo tiene nueve intentos, denominados \emph{entradas} (\emph{innings} en inglés), para anotar carreras y cada entrada termina después de tres \emph{outs}.

Aquí pueden ver un video que muestra un éxito: \url{https://www.youtube.com/watch?v=HL-XjMCPfio}. Y aquí hay uno que muestra una falla: \url{https://www.youtube.com/watch?v=NeloljCx-1g}. En estos videos, vemos cómo la suerte está involucrada en el proceso. Cuando está al bate, el bateador quiere darle a la pelota con fuerza. Si le da lo suficientemente fuerte, es un HR o cuadrangular, el mejor resultado posible ya que el bateador obtiene al menos una carrera automática. Pero a veces, debido al azar, el bateador le da a la pelota muy fuerte y un defensor la atrapa, lo que resulta en un \emph{out}. Por el contrario, a veces el bateador le da a la pelota suavemente, pero cae justo en el lugar correcto. El hecho de que el azar afecta sugiere por qué los modelos de probabilidad son útiles.

Ahora hay varias formas de tener éxito. Entender esta distinción será importante para nuestro análisis. Cuando el bateador le da a la pelota, él quiere pisar cuantas más bases sea posible. Hay cuatro bases y la cuarta se llama \emph{home} o \emph{home plate}. Ahí es donde los bateadores comienzan bateando, por lo que las bases forman un ciclo.

\begin{center}\includegraphics[width=0.5\linewidth]{regression/img//Baseball_Diamond1} \end{center}

(Cortesía de Cburnett\footnote{\url{https://en.wikipedia.org/wiki/User:Cburnett}}. Licencia CC BY-SA 3.0\footnote{\url{https://creativecommons.org/licenses/by-sa/3.0/deed.en}}.)

Un bateador que \emph{llega a todas las bases} y a \emph{home}, anota una carrera.

Estamos simplificando un poco, pero hay cinco formas en que un bateador puede tener éxito, es decir, no hacer un \emph{out}:

\begin{itemize}
\tightlist
\item
  Bases por bolas (BB): el lanzador no logra lanzar la pelota dentro de un área predefinida donde el bateador le puede dar (la zona de \emph{strike}), por lo que el bateador puede ir a primera base.
\item
  Sencillo: el bateador le da a la bola y llega a primera base.
\item
  Doble (2B): el bateador le da a la bola y llega a segunda base.
\item
  Triple (3B): el bateador le da a la bola y llega a tercera base.
\item
  Cuadrangular (HR)\footnote{\url{https://www.youtube.com/watch?v=xYxSZJ9GZ-w}}: el bateador le da a la bola, llega a \emph{home} y anota una carrera.
\end{itemize}

Si un bateador llega a una base, ese bateador aún tiene la posibilidad de llegar a \emph{home} y anotar una carrera si el siguiente bateador batea con éxito. Mientras el bateador está \emph{en base}, él también puede intentar robarse una base (SB o \emph{stolen bases} en inglés). Si un bateador corre lo suficientemente rápido, el bateador puede intentar ir de una base a la siguiente sin que el otro equipo lo toque (\emph{tag} en inglés)\footnote{\url{https://www.youtube.com/watch?v=JSE5kfxkzfk}}.

Todos estos eventos se registran durante la temporada y están disponibles para nosotros a través del paquete \textbf{Lahman}. Ahora comenzaremos a discutir cómo el análisis de datos puede ayudarnos a decidir cómo usar estas estadísticas para evaluar a los jugadores.

\hypertarget{no-hay-premios-para-bb}{%
\subsection{No hay premios para BB}\label{no-hay-premios-para-bb}}

Históricamente, el \emph{promedio de bateo} se ha considerado la estadística ofensiva más importante. Para definir este promedio, definimos un \emph{hit} (H) y un \emph{al bate} (AB o \emph{at bat} en inglés). Sencillos, dobles, triples y cuadrangulares son éxitos. La quinta forma de tener éxito, BB, no es un éxito. Un AB es la cantidad de veces que un bateador logra un \emph{hit} o un \emph{out}; los BB se excluyen. El promedio de bateo es simplemente H/AB y se considera la medida principal de una tasa de éxito. Hoy esta tasa de éxito oscila entre el 20\% y el 38\%. Nos referimos al promedio de bateo en miles, por lo que, por ejemplo, si su índice de éxito es 28\%, decimos que \emph{está bateando 280}.

\begin{center}\includegraphics[width=0.7\linewidth]{regression/img//JumboTron} \end{center}

(Imagen cortesía de Keith Allison\footnote{\url{https://www.flickr.com/people/27003603@N00}}. Licencia CC BY-SA 2.0\footnote{\url{https://creativecommons.org/licenses/by-sa/2.0}}. )

Una de las primeras ideas importantes de Bill James es que el promedio de bateo ignora BB, pero un BB es un éxito. James propuso que se usara el \emph{on-base percentage} (OBP), el porcentaje de veces que un bateador llega a una base, en lugar del promedio de bateo. Definió OBP como (H + BB)/(AB + BB), que es simplemente la proporción de turnos al bate que no resultan en un \emph{out}, una medida muy intuitiva. Señaló que un jugador que obtiene muchos más BB que el jugador promedio podría no ser reconocido si su promedio de bateo no es alto. ¿Pero este jugador no está ayudando a producir carreras? Aún así, no se le otorga premio al jugador con más BB. Además, el béisbol no adoptó de inmediato el OBP como una estadística importante. En cambio, el total de bases robadas se considera importante y le otorgan un premio al jugador con la mayor cantidad\footnote{\url{http://www.baseball-almanac.com/awards/lou_brock_award.shtml}}. Pero los jugadores con altos totales de SB también hacen más \emph{outs} ya que no siempre tienen éxito. ¿Un jugador con un alto total de SB ayuda a producir carreras? ¿Podemos usar la ciencia de datos para determinar si es mejor pagar por jugadores con totales altos de BB o de SB?

\hypertarget{base-por-bolas-o-bases-robadas}{%
\subsection{¿Base por bolas o bases robadas?}\label{base-por-bolas-o-bases-robadas}}

Uno de los desafíos en este análisis es que no es obvio cómo determinar si un jugador produce carreras porque mucho depende de sus compañeros de equipo. Llevamos un registro del número de carreras anotadas por un jugador. Sin embargo, recuerden que si un jugador X batea justo antes de alguien que logra muchos cuadrangulares, el bateador X marcará muchas carreras. Pero estas carreras no necesariamente suceden si contratamos al jugador X pero no a su compañero de equipo que batea cuadrangulares. No obstante, podemos examinar las estadísticas a nivel de equipo. ¿Cómo se comparan los equipos con muchos SB con los equipos con pocos? ¿Qué tal BB? ¡Tenemos datos! Vamos a examinar algunos.

Comencemos con una obvia: HR. ¿Los equipos que tienen más cuadrangulares anotan más carreras? Examinamos los datos de 1961 a 2001. La visualización de las opciones al explorar la relación entre dos variables, como HR y triunfos, es un diagrama de dispersión:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(Lahman)}

\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_per\_game =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{ G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{ G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(HR\_per\_game, R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/runs-vs-hrs-1} \end{center}

El gráfico muestra una fuerte asociación: los equipos con más HR tienden a anotar más carreras. Ahora examinemos la relación entre bases robadas y carreras:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{SB\_per\_game =}\NormalTok{ SB}\SpecialCharTok{/}\NormalTok{ G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{ G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(SB\_per\_game, R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/runs-vs-sb-1} \end{center}

Aquí la relación no es tan clara. Finalmente, examinemos la relación entre BB y carreras:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{BB\_per\_game =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(BB\_per\_game, R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/runs-vs-bb-1} \end{center}

Aquí nuevamente vemos una asociación clara. Pero, ¿esto significa que aumentar las BB de un equipo \textbf{causa} un aumento en las carreras? Una de las lecciones más importantes que aprenderemos en este libro es que \textbf{la asociación no implica causalidad.}

De hecho, parece que los BB y HR también están asociados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_per\_game =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{BB\_per\_game =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(HR\_per\_game, BB\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/bb-vs-hrs-1} \end{center}

Sabemos que los HR causan carreras porque, como su nombre sugiere, cuando un jugador logra un ``home run'', se le garantiza al menos una carrera. ¿Podría ser que los HR también causen BB y esto hace que parezca que los BB también causen carreras? Cuando esto sucede, decimos que hay \emph{confusión}, un concepto importante sobre el que aprenderemos más a lo largo de este capítulo.

La regresión lineal nos ayudará a analizar todo esto y cuantificar las asociaciones para determinar qué jugadores reclutar. Específicamente, trataremos de predecir cosas como cuántas carreras más anotará un equipo si aumentamos el número de BB, pero mantenemos los HR fijos. La regresión nos ayudará a responder preguntas como esta.

\hypertarget{regresiuxf3n-aplicada-a-las-estaduxedsticas-de-buxe9isbol}{%
\subsection{Regresión aplicada a las estadísticas de béisbol}\label{regresiuxf3n-aplicada-a-las-estaduxedsticas-de-buxe9isbol}}

¿Podemos usar la regresión con estos datos? Primero, observen que los datos de HR y carreras parecen seguir una distribución normal de dos variables. Guardamos el gráfico en el objeto \texttt{p} ya que lo usaremos más tarde.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(Lahman)}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_per\_game =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(HR\_per\_game, R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/hr-runs-bivariate-1} \end{center}

Los gráficos Q-Q confirman que la aproximación normal es útil aquí:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{z\_HR =} \FunctionTok{round}\NormalTok{((HR }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(HR))}\SpecialCharTok{/}\FunctionTok{sd}\NormalTok{(HR)),}
         \AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(z\_HR }\SpecialCharTok{\%in\%} \SpecialCharTok{{-}}\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{stat\_qq}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{sample=}\NormalTok{R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{z\_HR)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/hr-by-runs-qq-1} \end{center}

Ahora estamos listos para usar la regresión lineal para predecir el número de carreras que anotará un equipo si sabemos cuántos cuadrangulares logrará el equipo. Lo único que necesitamos hacer es calcular los cinco resúmenes estadísticos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary\_stats }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_per\_game =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg\_HR =} \FunctionTok{mean}\NormalTok{(HR\_per\_game),}
            \AttributeTok{s\_HR =} \FunctionTok{sd}\NormalTok{(HR\_per\_game),}
            \AttributeTok{avg\_R =} \FunctionTok{mean}\NormalTok{(R\_per\_game),}
            \AttributeTok{s\_R =} \FunctionTok{sd}\NormalTok{(R\_per\_game),}
            \AttributeTok{r =} \FunctionTok{cor}\NormalTok{(HR\_per\_game, R\_per\_game))}
\NormalTok{summary\_stats}
\CommentTok{\#\textgreater{}   avg\_HR  s\_HR avg\_R   s\_R     r}
\CommentTok{\#\textgreater{} 1  0.855 0.243  4.36 0.589 0.762}
\end{Highlighting}
\end{Shaded}

y usar las fórmulas dadas arriba para crear las líneas de regresión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reg\_line }\OtherTok{\textless{}{-}}\NormalTok{ summary\_stats }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =}\NormalTok{ r}\SpecialCharTok{*}\NormalTok{s\_R}\SpecialCharTok{/}\NormalTok{s\_HR,}
                                        \AttributeTok{intercept =}\NormalTok{ avg\_R }\SpecialCharTok{{-}}\NormalTok{ slope}\SpecialCharTok{*}\NormalTok{avg\_HR)}

\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =}\NormalTok{ reg\_line}\SpecialCharTok{$}\NormalTok{intercept, }\AttributeTok{slope =}\NormalTok{ reg\_line}\SpecialCharTok{$}\NormalTok{slope)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/hr-versus-runs-regression-1} \end{center}

Pronto aprenderemos más sobre las funciones de R, como \texttt{lm}, que facilitan el ajuste de las líneas de regresión. Otro ejemplo que estudiaremos es la función \texttt{geom\_smooth} de \textbf{ggplot2} que calcula y agrega una línea de regresión junto con intervalos de confianza al gráfico. Usamos el argumento \texttt{method\ =\ "lm"} que significa \emph{modelo lineal} (\emph{linear model} en inglés), el título de una próxima sección. Entonces podemos simplificar el código anterior así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\SpecialCharTok{+} \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/hr-versus-runs-regression-easy-1} \end{center}

En el ejemplo anterior, la pendiente es 1.845. Esto nos dice que los equipos que logran 1 HR más por juego que el equipo promedio, anotan más carreras por juego que el equipo promedio. Dado que la puntuación final más común es la diferencia de una carrera, esto ciertamente puede conducir a un gran aumento en victorias. No es sorprendente que los jugadores con muchos HR sean muy caros. Debido a que estamos trabajando con un presupuesto limitado, necesitaremos encontrar otra forma de aumentar las victorias. Entonces, en la siguiente sección, trasladamos nuestra atención a BB.

\hypertarget{confusiuxf3n}{%
\section{Confusión}\label{confusiuxf3n}}

Anteriormente, notamos una fuerte relación entre carreras y BB. Si encontramos la línea de regresión para predecir carreras desde bases por bolas, obtendremos una pendiente de:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(Lahman)}
\NormalTok{get\_slope }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) }\FunctionTok{cor}\NormalTok{(x, y) }\SpecialCharTok{*} \FunctionTok{sd}\NormalTok{(y)}\SpecialCharTok{/} \FunctionTok{sd}\NormalTok{(x)}

\NormalTok{bb\_slope }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{BB\_per\_game =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(BB\_per\_game, R\_per\_game))}

\NormalTok{bb\_slope}
\CommentTok{\#\textgreater{}   slope}
\CommentTok{\#\textgreater{} 1 0.735}
\end{Highlighting}
\end{Shaded}

Entonces, ¿esto significa que si contratamos jugadores de bajo salario con muchos BB y así aumentamos por 2 el número de BB por juego, nuestro equipo marcará 1.5 más carreras por juego?

Nuevamente debemos recordar que la asociación no implica la causalidad. Los datos ofrecen evidencia sólida de que un equipo con dos BB más por juego que el equipo promedio, anota 1.5 carreras por juego. Pero esto no significa que los BB sean la causa.

Noten que si calculamos la pendiente de la línea de regresión para sencillos obtenemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{singles\_slope }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{Singles\_per\_game =}\NormalTok{ (H}\SpecialCharTok{{-}}\NormalTok{HR}\SpecialCharTok{{-}}\NormalTok{X2B}\SpecialCharTok{{-}}\NormalTok{X3B)}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(Singles\_per\_game, R\_per\_game))}

\NormalTok{singles\_slope}
\CommentTok{\#\textgreater{}   slope}
\CommentTok{\#\textgreater{} 1 0.449}
\end{Highlighting}
\end{Shaded}

que es un valor más bajo que el que obtenemos para BB.

Además, observen que un sencillo lleva a un jugador a primera base igual que un BB. Aquellos que saben de béisbol señalarán que con un sencillo, los corredores en base tienen una mejor oportunidad de anotar que con un BB. Entonces, ¿cómo puede un BB ser más predictivo de las carreras? La razón por la que esto sucede es por \emph{confusión}. Aquí mostramos la correlación entre HR, BB y sencillos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{Singles =}\NormalTok{ (H}\SpecialCharTok{{-}}\NormalTok{HR}\SpecialCharTok{{-}}\NormalTok{X2B}\SpecialCharTok{{-}}\NormalTok{X3B)}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{BB =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{HR =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{cor}\NormalTok{(BB, HR), }\FunctionTok{cor}\NormalTok{(Singles, HR), }\FunctionTok{cor}\NormalTok{(BB, Singles))}
\CommentTok{\#\textgreater{}   cor(BB, HR) cor(Singles, HR) cor(BB, Singles)}
\CommentTok{\#\textgreater{} 1       0.404           {-}0.174           {-}0.056}
\end{Highlighting}
\end{Shaded}

Resulta que los lanzadores, temerosos de los HR, a veces evitarán lanzar \emph{strikes} a los bateadores de HR. Como resultado, los bateadores de HR tienden a tener más BB y un equipo con muchos bateadores de HR también tendrá más BB. Aunque puede parecer que BB causan carreras, realmente son HR los que causan la mayoría de estas carreras. Decimos que BB están \emph{confundidos} (\emph{confounded} en inglés) con HR. Sin embargo, ¿es posible que las BB todavía ayuden? Para averiguar, tenemos que ajustar para el efecto de HR. La regresión también puede ayudar con esto.

\hypertarget{cuxf3mo-entender-la-confusiuxf3n-a-travuxe9s-de-la-estratificaciuxf3n}{%
\subsection{Cómo entender la confusión a través de la estratificación}\label{cuxf3mo-entender-la-confusiuxf3n-a-travuxe9s-de-la-estratificaciuxf3n}}

Un primer acercamiento es mantener los HR fijos a un valor determinado y luego examinar la relación entre BB y las carreras. Como lo hicimos cuando estratificamos a los padres redondeando a la pulgada más cercana, aquí podemos estratificar HR por juego a los diez más cercanos. Filtramos los estratos con pocos puntos para evitar estimadores muy variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_strata =} \FunctionTok{round}\NormalTok{(HR}\SpecialCharTok{/}\NormalTok{G, }\DecValTok{1}\NormalTok{),}
         \AttributeTok{BB\_per\_game =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{ G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(HR\_strata }\SpecialCharTok{\textgreater{}=} \FloatTok{0.4} \SpecialCharTok{\&}\NormalTok{ HR\_strata }\SpecialCharTok{\textless{}=}\FloatTok{1.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y luego hacemos un diagrama de dispersión para cada estrato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(BB\_per\_game, R\_per\_game)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{( }\SpecialCharTok{\textasciitilde{}}\NormalTok{ HR\_strata)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/runs-vs-bb-by-hr-strata-1} \end{center}

Recuerden que la pendiente de regresión para predecir carreras con BB era 0.7. Una vez que estratificamos por HR, estas pendientes se reducen sustancialmente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(HR\_strata) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(BB\_per\_game, R\_per\_game))}
\CommentTok{\#\textgreater{} \# A tibble: 9 x 2}
\CommentTok{\#\textgreater{}   HR\_strata slope}
\CommentTok{\#\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1       0.4 0.734}
\CommentTok{\#\textgreater{} 2       0.5 0.566}
\CommentTok{\#\textgreater{} 3       0.6 0.412}
\CommentTok{\#\textgreater{} 4       0.7 0.285}
\CommentTok{\#\textgreater{} 5       0.8 0.365}
\CommentTok{\#\textgreater{} \# ... with 4 more rows}
\end{Highlighting}
\end{Shaded}

Las pendientes se reducen, pero no son 0, lo que indica que las BB son útiles para producir carreras, pero no tanto como se pensaba anteriormente. De hecho, los valores anteriores están más cerca de la pendiente que obtuvimos de sencillos, 0.45, que es más consistente con nuestra intuición. Dado que tanto los sencillos como los BB nos llevan a primera base, deberían tener aproximadamente el mismo poder predictivo.

Aunque nuestra comprensión de la aplicación nos dice que los HR causan BB pero no al revés, aún podemos verificar si la estratificación por BB hace que el efecto de HR disminuya. Para hacer esto, usamos el mismo código, excepto que intercambiamos HR y BB para obtener este gráfico:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/runs-vs-hr-by-bb-strata-1} \end{center}

En este caso, las pendientes no cambian mucho del valor original:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(BB\_strata) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(HR\_per\_game, R\_per\_game))}
\CommentTok{\#\textgreater{} \# A tibble: 12 x 2}
\CommentTok{\#\textgreater{}   BB\_strata slope}
\CommentTok{\#\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1       2.8  1.52}
\CommentTok{\#\textgreater{} 2       2.9  1.57}
\CommentTok{\#\textgreater{} 3       3    1.52}
\CommentTok{\#\textgreater{} 4       3.1  1.49}
\CommentTok{\#\textgreater{} 5       3.2  1.58}
\CommentTok{\#\textgreater{} \# ... with 7 more rows}
\end{Highlighting}
\end{Shaded}

Se reducen un poco, lo que es consistente con el hecho de que BB sí conducen a algunas carreras.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hr\_slope }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{ ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR\_per\_game =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R\_per\_game =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(HR\_per\_game, R\_per\_game))}

\NormalTok{hr\_slope}
\CommentTok{\#\textgreater{}   slope}
\CommentTok{\#\textgreater{} 1  1.84}
\end{Highlighting}
\end{Shaded}

De todos modos, parece que si estratificamos por HR, tenemos una distribución normal de dos variables para carreras versus BB. Del mismo modo, si estratificamos por BB, tenemos una distribución normal de dos variables aproximada para HR versus carreras.

\hypertarget{regresiuxf3n-lineal-muxfaltiple}{%
\subsection{Regresión lineal múltiple}\label{regresiuxf3n-lineal-muxfaltiple}}

Es un poco complejo calcular líneas de regresión para cada estrato. Básicamente, estamos ajustando modelos como este:

\[
\mbox{E}[R \mid BB = x_1, \, HR = x_2] = \beta_0 + \beta_1(x_2) x_1 + \beta_2(x_1) x_2
\]

con las pendientes para \(x_1\) cambiando para diferentes valores de \(x_2\) y viceversa. ¿Pero hay un acercamiento más fácil?

Si tomamos en cuenta la variabilidad aleatoria, las pendientes en los estratos no parecen cambiar mucho. Si estas pendientes son iguales, esto implica que \(\beta_1(x_2)\) y \(\beta_2(x_1)\) son constantes. Esto a su vez implica que la expectativa de carreras condicionadas en HR y BB se puede escribir así:

\[
\mbox{E}[R \mid BB = x_1, \, HR = x_2] = \beta_0 + \beta_1 x_1 + \beta_2 x_2
\]

Este modelo sugiere que si el número de HR se fija en \(x_2\), observamos una relación lineal entre carreras y BB con un intercepto de \(\beta_0 + \beta_2 x_2\). Nuestro análisis exploratorio de datos sugirió esto. El modelo también sugiere que a medida que aumenta el número de HR, el crecimiento del intercepto también es lineal y está determinado por \(\beta_1 x_1\).

En este análisis, denominado \emph{regresión lineal múltiple} (\emph{multivariable linear regression} en inglés), a menudo escucharán a la gente decir que la pendiente BB \(\beta_1\) está \emph{ajustada} (\emph{adjusted} en inglés) para el efecto HR. Si el modelo es correcto, entonces se ha tomado en cuenta la confusión. ¿Pero cómo estimamos \(\beta_1\) y \(\beta_2\) de los datos? Para esto, aprendemos sobre modelos lineales y estimaciones de mínimos cuadrados.

\hypertarget{lse}{%
\section{Estimaciones de mínimos cuadrados}\label{lse}}

Hemos explicado cómo cuando los datos tienen una distribución normal de dos variables, entonces los valores esperados condicionales siguen la línea de regresión. El hecho de que el valor esperado condicional es una línea no es una suposición adicional, sino más bien un resultado derivado. Sin embargo, en la práctica es común escribir un modelo que describa la relación entre dos o más variables utilizando un \emph{modelo lineal} (\emph{linear model} en inglés).

Notamos que ``lineal'' aquí no se refiere exclusivamente a líneas, sino al hecho de que el valor esperado condicional es una combinación lineal de cantidades conocidas. En matemáticas, cuando multiplicamos cada variable por una constante y luego las sumamos, decimos que formamos una combinación lineal de las variables. Por ejemplo, \(3x - 4y + 5z\) es una combinación lineal de \(x\), \(y\) y \(z\). Además, podemos añadir una constante y por eso \(2 + 3x - 4y + 5z\) también es una combinación lineal de \(x\), \(y\) y \(z\).

Entonces \(\beta_0 + \beta_1 x_1 + \beta_2 x_2\) es una combinación lineal de \(x_1\) y \(x_2\). El modelo lineal más sencillo es una constante \(\beta_0\); el segundo más sencillo es una línea \(\beta_0 + \beta_1 x\). Si tuviéramos que especificar un modelo lineal para los datos de Galton, denotaríamos las \(N\) alturas de padres observadas con \(x_1, \dots, x_n\), entonces modelamos las \(N\) alturas de hijos que estamos tratando de predecir con:

\[
Y_i = \beta_0 + \beta_1 x_i + \varepsilon_i, \, i=1,\dots,N.
\]

Aquí \(x_i\) es la altura del padre, que es fija (no aleatoria) debido al condicionamiento, y \(Y_i\) es la altura aleatoria del hijo que queremos predecir. Suponemos además que \(\varepsilon_i\) son independientes entre sí, tienen valor esperado 0 y la desviación estándar, llámenla \(\sigma\), no depende de \(i\).

En el modelo anterior, sabemos el \(x_i\), pero para tener un modelo útil para la predicción, necesitamos \(\beta_0\) y \(\beta_1\). Los estimamos a partir de los datos. Una vez que hagamos esto, podemos predecir alturas de hijos para cualquier altura de padre \(x\). Mostramos cómo hacer esto en la siguiente sección.

Noten que si además suponemos que el \(\varepsilon\) tiene una distribución normal, entonces este modelo es exactamente el mismo que obtuvimos anteriormente suponiendo que los datos siguen una distribución normal de dos variables. Una diferencia algo matizada es que en el primer acercamiento suponemos que los datos siguen una distribución normal de dos variables y que no suponemos un modelo lineal, sino que lo derivamos. En la práctica, los modelos lineales son simplemente supuestos y no necesariamente suponemos normalidad: la distribución de \(\varepsilon\)s no se específica. Sin embargo, si sus datos siguen una distribución normal de dos variables, se cumple el modelo lineal anterior. Si sus datos no siguen una distribución normal de dos variables, necesitarán justificar el modelo de otra forma.

\hypertarget{interpretando-modelos-lineales}{%
\subsection{Interpretando modelos lineales}\label{interpretando-modelos-lineales}}

Una razón por la que los modelos lineales son populares es porque son interpretables. En el caso de los datos de Galton, podemos interpretar los datos de esta manera: debido a los genes heredados, la predicción de la altura del hijo crece por \(\beta_1\) para cada pulgada que aumentamos la altura del padre \(x\). Porque no todos los hijos con padres de estatura \(x\) son de la misma altura, necesitamos el término \(\varepsilon\), lo que explica la variabilidad restante. Esta variabilidad restante incluye el efecto genético de la madre, los factores ambientales y otros factores biológicos aleatorios.

Dada la forma en que escribimos el modelo anterior, el intercepto \(\beta_0\) no es muy interpretable, ya que es la altura pronosticada de un hijo con un padre que mide 0 pulgadas. Debido a la regresión a la media, la predicción generalmente será un poco más grande que 0. Para hacer que el parámetro de pendiente sea más interpretable, podemos reescribir el modelo como:

\[
Y_i = \beta_0 + \beta_1 (x_i - \bar{x}) + \varepsilon_i, \, i=1,\dots,N
\]

con \(\bar{x} = 1/N \sum_{i=1}^N x_i\) el promedio de \(x\). En este caso, \(\beta_0\) representa la altura cuando \(x_i = \bar{x}\), que es la altura del hijo de un padre promedio.

\hypertarget{estimadores-de-muxednimos-cuadrados-lse}{%
\subsection{Estimadores de mínimos cuadrados (LSE)}\label{estimadores-de-muxednimos-cuadrados-lse}}

Para que los modelos lineales sean útiles, tenemos que estimar los \(\beta\)s desconocidos. El enfoque estándar en la ciencia es encontrar los valores que minimizan la distancia del modelo ajustado a los datos. La siguiente ecuación se llama la ecuación de mínimos cuadrados (LS o \emph{least squares} en inglés) y la veremos a menudo en este capítulo. Para los datos de Galton, escribiríamos:

\[
RSS = \sum_{i=1}^n \left\{ y_i - \left(\beta_0 + \beta_1 x_i \right)\right\}^2
\]

Esta cantidad se denomina suma de errores cuadrados (\emph{residual sum of squares} o RSS por sus siglas en inglés). Una vez que encontremos los valores que minimizan el RSS, llamaremos a los valores los estimadores de mínimos cuadrados (\emph{least squares estimates} o LSE por sus siglas en inglés) y los denotaremos con \(\hat{\beta}_0\) y \(\hat{\beta}_1\). Demostremos esto con el set de datos previamente definido:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(HistData)}
\FunctionTok{data}\NormalTok{(}\StringTok{"GaltonFamilies"}\NormalTok{)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1983}\NormalTok{)}
\NormalTok{galton\_heights }\OtherTok{\textless{}{-}}\NormalTok{ GaltonFamilies }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(gender }\SpecialCharTok{==} \StringTok{"male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(family) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(father, childHeight) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{son =}\NormalTok{ childHeight)}
\end{Highlighting}
\end{Shaded}

Escribamos una función que calcule el RSS para cualquier par de valores \(\beta_0\) y \(\beta_1\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rss }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(beta0, beta1, data)\{}
\NormalTok{  resid }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights}\SpecialCharTok{$}\NormalTok{son }\SpecialCharTok{{-}}\NormalTok{ (beta0}\SpecialCharTok{+}\NormalTok{beta1}\SpecialCharTok{*}\NormalTok{galton\_heights}\SpecialCharTok{$}\NormalTok{father)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{(resid}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Entonces, para cualquier par de valores, obtenemos un RSS. Aquí hay un gráfico del RSS como función de \(\beta_1\) cuando mantenemos el \(\beta_0\) fijo en 25.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beta1 }\OtherTok{=} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{len=}\FunctionTok{nrow}\NormalTok{(galton\_heights))}
\NormalTok{results }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{beta1 =}\NormalTok{ beta1,}
                      \AttributeTok{rss =} \FunctionTok{sapply}\NormalTok{(beta1, rss, }\AttributeTok{beta0 =} \DecValTok{25}\NormalTok{))}
\NormalTok{results }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(beta1, rss)) }\SpecialCharTok{+} \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(beta1, rss))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/rss-versus-estimate-1} \end{center}

Podemos ver un mínimo claro para \(\beta_1\) alrededor de 0.65. Sin embargo, este mínimo para \(\beta_1\) es para cuando \(\beta_0 = 25\), un valor que elegimos arbitrariamente. No sabemos si (25, 0.65) es el par que minimiza la ecuación en todos los pares posibles.

El método de prueba y error no funcionarán en este caso. Podríamos buscar un mínimo dentro de una cuadrícula fina de valores de \(\beta_0\) y \(\beta_1\), pero esto requiere mucho tiempo innecesariamente ya que podemos usar cálculo: tomen las derivadas parciales, fíjenlas en 0 y resuelvan para \(\beta_1\) y \(\beta_2\). Por supuesto, si tenemos muchos parámetros, estas ecuaciones pueden volverse bastante complejas. Pero hay funciones en R que hacen estos cálculos por nosotros. Aprenderemos esto a continuación. Para aprender las matemáticas detrás de esto, pueden consultar un libro sobre modelos lineales.

\hypertarget{la-funciuxf3n-lm}{%
\subsection{\texorpdfstring{La función \texttt{lm}}{La función lm}}\label{la-funciuxf3n-lm}}

En R, podemos obtener los estimadores de mínimos cuadrados usando la función \texttt{lm}. Para ajustar el modelo:

\[
Y_i = \beta_0 + \beta_1 x_i + \varepsilon_i
\]

con \(Y_i\) la altura del hijo y \(x_i\) la altura del padre, podemos usar este código para obtener los estimadores de mínimos cuadrados.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(son }\SpecialCharTok{\textasciitilde{}}\NormalTok{ father, }\AttributeTok{data =}\NormalTok{ galton\_heights)}
\NormalTok{fit}\SpecialCharTok{$}\NormalTok{coef}
\CommentTok{\#\textgreater{} (Intercept)      father }
\CommentTok{\#\textgreater{}      37.288       0.461}
\end{Highlighting}
\end{Shaded}

La forma más común que usamos \texttt{lm} es mediante el uso del cáracter \texttt{\textasciitilde{}} para dejar \texttt{lm} saber cuál es la variable que estamos prediciendo (a la izquierda de \texttt{\textasciitilde{}}) y que estamos utilizando para predecir (a la derecha de \texttt{\textasciitilde{}}). El intercepto se agrega automáticamente al modelo que se ajustará.

El objeto \texttt{fit} incluye más información sobre el ajuste. Podemos usar la función \texttt{summary} para extraer más de esta información (que no mostramos):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(fit)}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Call:}
\CommentTok{\#\textgreater{} lm(formula = son \textasciitilde{} father, data = galton\_heights)}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Residuals:}
\CommentTok{\#\textgreater{}    Min     1Q Median     3Q    Max }
\CommentTok{\#\textgreater{} {-}9.354 {-}1.566 {-}0.008  1.726  9.415 }
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Coefficients:}
\CommentTok{\#\textgreater{}             Estimate Std. Error t value Pr(\textgreater{}|t|)    }
\CommentTok{\#\textgreater{} (Intercept)  37.2876     4.9862    7.48  3.4e{-}12 ***}
\CommentTok{\#\textgreater{} father        0.4614     0.0721    6.40  1.4e{-}09 ***}
\CommentTok{\#\textgreater{} {-}{-}{-}}
\CommentTok{\#\textgreater{} Signif. codes:  0 \textquotesingle{}***\textquotesingle{} 0.001 \textquotesingle{}**\textquotesingle{} 0.01 \textquotesingle{}*\textquotesingle{} 0.05 \textquotesingle{}.\textquotesingle{} 0.1 \textquotesingle{} \textquotesingle{} 1}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Residual standard error: 2.45 on 177 degrees of freedom}
\CommentTok{\#\textgreater{} Multiple R{-}squared:  0.188,  Adjusted R{-}squared:  0.183 }
\CommentTok{\#\textgreater{} F{-}statistic: 40.9 on 1 and 177 DF,  p{-}value: 1.36e{-}09}
\end{Highlighting}
\end{Shaded}

Para entender parte de la información incluida en este resumen, debemos recordar que el LSE consiste de variables aleatorias. La estadística matemática nos da algunas ideas sobre la distribución de estas variables aleatorias.

\hypertarget{el-lse-consiste-de-variables-aleatorias}{%
\subsection{El LSE consiste de variables aleatorias}\label{el-lse-consiste-de-variables-aleatorias}}

El LSE se deriva de los datos \(y_1,\dots,y_N\), que son una realización de variables aleatorias \(Y_1, \dots, Y_N\). Esto implica que nuestros estimadores son variables aleatorias. Para ver esto, podemos ejecutar una simulación Monte Carlo en la que suponemos que los datos de altura del hijo y del padre definen una población, tomar una muestra aleatoria de tamaño \(N=50\), y calcular el coeficiente de pendiente de regresión para cada uno:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{lse }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
  \FunctionTok{sample\_n}\NormalTok{(galton\_heights, N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{lm}\NormalTok{(son }\SpecialCharTok{\textasciitilde{}}\NormalTok{ father, }\AttributeTok{data =}\NormalTok{ .) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{    .}\SpecialCharTok{$}\NormalTok{coef}
\NormalTok{\})}
\NormalTok{lse }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{beta\_0 =}\NormalTok{ lse[}\DecValTok{1}\NormalTok{,], }\AttributeTok{beta\_1 =}\NormalTok{ lse[}\DecValTok{2}\NormalTok{,])}
\end{Highlighting}
\end{Shaded}

Podemos ver la variabilidad de los estimadores graficando sus distribuciones:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/lse-distributions-1} \end{center}

La razón por la que se ven normales es porque el teorema del límite central también aplica aquí: para \(N\) suficientemente grande, los estimadores de mínimos cuadrados serán aproximadamente normales con el valor esperado \(\beta_0\) y \(\beta_1\), respectivamente. Los errores estándar son un poco complicados para calcular, pero la teoría matemática nos permite calcularlos y están incluidos en el resumen proporcionado por la función \texttt{lm}. Aquí lo vemos para uno de nuestros sets de datos simulados:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample\_n}\NormalTok{(galton\_heights, N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(son }\SpecialCharTok{\textasciitilde{}}\NormalTok{ father, }\AttributeTok{data =}\NormalTok{ .) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  summary }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .}\SpecialCharTok{$}\NormalTok{coef}
\CommentTok{\#\textgreater{}             Estimate Std. Error t value Pr(\textgreater{}|t|)}
\CommentTok{\#\textgreater{} (Intercept)    19.28     11.656    1.65 1.05e{-}01}
\CommentTok{\#\textgreater{} father          0.72      0.169    4.25 9.79e{-}05}
\end{Highlighting}
\end{Shaded}

Pueden ver que los estimadores de errores estándar informados por la función \texttt{summary} están cerca de los errores estándar de la simulación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lse }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{se\_0 =} \FunctionTok{sd}\NormalTok{(beta\_0), }\AttributeTok{se\_1 =} \FunctionTok{sd}\NormalTok{(beta\_1))}
\CommentTok{\#\textgreater{}   se\_0  se\_1}
\CommentTok{\#\textgreater{} 1 8.84 0.128}
\end{Highlighting}
\end{Shaded}

La función \texttt{summary} también informa estadísticas t (\texttt{t\ value}) y valores-p (\texttt{Pr(\textgreater{}\textbar{}t\textbar{})}). La estadística t no se basa realmente en el teorema del límite central, sino más bien en la suposición de que los \(\varepsilon\)s siguen una distribución normal. Bajo este supuesto, la teoría matemática nos dice que el LSE dividido por su error estándar, \(\hat{\beta}_0/ \hat{\mbox{SE}}(\hat{\beta}_0 )\) y \(\hat{\beta}_1/ \hat{\mbox{SE}}(\hat{\beta}_1 )\), sigue una distribución t con \(N-p\) grados de libertad, con \(p\) el número de parámetros en nuestro modelo. En el caso de la altura \(p=2\), los dos valores-p prueban la hipótesis nula de que \(\beta_0 = 0\) y \(\beta_1=0\), respectivamente.

Recuerden que, como describimos en la Sección \ref{t-dist}, para \(N\) suficientemente grande, el CLT funciona y la distribución t se vuelve casi igual a la distribución normal. Además, tengan en cuenta que podemos construir intervalos de confianza, pero pronto aprenderemos sobre \textbf{broom}, un paquete adicional que lo hace fácil.

Aunque no ofrecemos ejemplos en este libro, las pruebas de hipótesis con modelos de regresión se usan comúnmente en epidemiología y economía para hacer afirmaciones como ``el efecto de A en B fue estadísticamente significativo después de ajustar por X, Y y Z''. Sin embargo, varios supuestos tienen que ser válidos para que estas afirmaciones sean verdaderas.

\hypertarget{valores-pronosticados-son-variables-aleatorias}{%
\subsection{Valores pronosticados son variables aleatorias}\label{valores-pronosticados-son-variables-aleatorias}}

Una vez que ajustemos nuestro modelo, podemos obtener predicciones de \(Y\) usando los estimadores del modelo de regresión. Por ejemplo, si la altura del padre es \(x\), entonces nuestra predicción \(\hat{Y}\) para la altura del hijo será:

\[\hat{Y} = \hat{\beta}_0 + \hat{\beta}_1 x\]

Cuando graficamos \(\hat{Y}\) versus \(x\), vemos la línea de regresión.

Tengan en cuenta que la predicción \(\hat{Y}\) también es una variable aleatoria y la teoría matemática nos dice cuáles son los errores estándar. Si suponemos que los errores son normales o tienen un tamaño de muestra lo suficientemente grande, además podemos usar la teoría para construir intervalos de confianza. De hecho, la capa \texttt{geom\_smooth(method\ =\ "lm")} de \textbf{ggplot2} que anteriormente usamos grafica \(\hat{Y}\) y lo rodea por intervalos de confianza:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(son, father)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/father-son-regression-1} \end{center}

La función \texttt{predict} de R toma un objeto \texttt{lm} como entrada y devuelve la predicción. Si se lo pedimos, también provee los errores estándar y la información necesaria para construir intervalos de confianza:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{lm}\NormalTok{(son }\SpecialCharTok{\textasciitilde{}}\NormalTok{ father, }\AttributeTok{data =}\NormalTok{ .)}

\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, }\AttributeTok{se.fit =} \ConstantTok{TRUE}\NormalTok{)}

\FunctionTok{names}\NormalTok{(y\_hat)}
\CommentTok{\#\textgreater{} [1] "fit"            "se.fit"         "df"             "residual.scale"}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-34}{%
\section{Ejercicios}\label{ejercicios-34}}

Hemos demostrado cómo BB y sencillos tienen un poder predictivo similar para anotar carreras. Otra forma de comparar la utilidad de estas métricas de béisbol es evaluando cuán estables son a lo largo de los años. Dado que tenemos que elegir jugadores a base de sus desempeños anteriores, preferiremos métricas que sean más estables. En estos ejercicios, compararemos la estabilidad de sencillos y BBs.

1. Antes de comenzar, queremos generar dos tablas. Una para 2002 y otra para el promedio de las temporadas 1999-2001. Queremos definir estadísticas por turnos al bate. Aquí vemos como creamos la tabla para el 2017, quedándonos solo con jugadores con más de 100 turnos al bate.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(Lahman)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ Batting }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{==} \DecValTok{2002}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{pa =}\NormalTok{ AB }\SpecialCharTok{+}\NormalTok{ BB,}
         \AttributeTok{singles =}\NormalTok{ (H }\SpecialCharTok{{-}}\NormalTok{ X2B }\SpecialCharTok{{-}}\NormalTok{ X3B }\SpecialCharTok{{-}}\NormalTok{ HR)}\SpecialCharTok{/}\NormalTok{ pa, }\AttributeTok{bb =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{ pa) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(pa }\SpecialCharTok{\textgreater{}=} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(playerID, singles, bb)}
\end{Highlighting}
\end{Shaded}

Ahora calcule una tabla similar pero con tasas calculadas durante 1999-2001.

2. En la Sección \ref{joins}, aprenderemmos sobre \texttt{inner\_join}, que se puede usar para poner los datos y promedios de 2001 en la misma tabla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{inner\_join}\NormalTok{(dat, avg, }\AttributeTok{by =} \StringTok{"playerID"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Calcule la correlación entre 2002 y las temporadas anteriores para sencillos y BB.

3. Note que la correlación es mayor para BB. Para rápidamente tener una idea de la incertidumbre asociada con este estimador de correlación, ajustaremos un modelo lineal y calcularemos los intervalos de confianza para el coeficiente de pendiente. Sin embargo, primero haga diagramas de dispersión para confirmar que es apropiado ajustar un modelo lineal.

4. Ahora ajuste un modelo lineal para cada métrica y use la función \texttt{confint} para comparar los estimadores.

\hypertarget{regresiuxf3n-lineal-en-el-tidyverse}{%
\section{Regresión lineal en el tidyverse}\label{regresiuxf3n-lineal-en-el-tidyverse}}

Para ver cómo usamos la función \texttt{lm} en un análisis más complejo, volvamos al ejemplo del béisbol. En ese caso, estimamos líneas de regresión para predecir carreras por BB en diferentes estratos de HR. Primero construimos un \emph{data frame} similar a este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{HR =} \FunctionTok{round}\NormalTok{(HR}\SpecialCharTok{/}\NormalTok{G, }\DecValTok{1}\NormalTok{),}
         \AttributeTok{BB =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{R =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(HR, BB, R) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(HR }\SpecialCharTok{\textgreater{}=} \FloatTok{0.4} \SpecialCharTok{\&}\NormalTok{ HR}\SpecialCharTok{\textless{}=}\FloatTok{1.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Como en ese momento no sabíamos de la función \texttt{lm} para calcular la línea de regresión en cada estrato, utilizamos la fórmula así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_slope }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) }\FunctionTok{cor}\NormalTok{(x, y) }\SpecialCharTok{*} \FunctionTok{sd}\NormalTok{(y)}\SpecialCharTok{/} \FunctionTok{sd}\NormalTok{(x)}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(HR) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{slope =} \FunctionTok{get\_slope}\NormalTok{(BB, R))}
\end{Highlighting}
\end{Shaded}

Argumentamos que las pendientes son similares y que las diferencias quizás se debieron a una variación aleatoria. Para ofrecer una defensa más rigurosa de que las pendientes eran las mismas, lo que condujo a nuestro modelo de múltiples variables, pudimos calcular los intervalos de confianza para cada pendiente. No hemos aprendido la fórmula para esto, pero la función \texttt{lm} provee suficiente información para construirlos.

Primero, noten que si intentamos usar la función \texttt{lm} para obtener la pendiente estimada de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(HR) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(R }\SpecialCharTok{\textasciitilde{}}\NormalTok{ BB, }\AttributeTok{data =}\NormalTok{ .) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .}\SpecialCharTok{$}\NormalTok{coef}
\CommentTok{\#\textgreater{} (Intercept)          BB }
\CommentTok{\#\textgreater{}       2.198       0.638}
\end{Highlighting}
\end{Shaded}

no obtenemos el resultado que queremos. La función \texttt{lm} ignora el \texttt{group\_by} ya que \texttt{lm} no es parte del \textbf{tidyverse} y no sabe cómo manejar el resultado de un tibble agrupado.

Las funciones de \textbf{tidyverse} saben cómo interpretar los tibbles agrupados. Además, para facilitar la creación de una secuencia de comandos con el \emph{pipe} \texttt{\%\textgreater{}\%}, las funciones de \textbf{tidyverse} consistentemente devuelven \emph{data frames}, ya que esto asegura que el resultado de una función sea aceptado como la entrada de otra. Pero la mayoría de las funciones de R no reconocen los tibbles agrupados ni devuelven \emph{data frames}. La función \texttt{lm} es un ejemplo. Sin embargo, podemos escribir una función que usa \texttt{lm} para calcular y devolver los resúmenes relevantes en un data frame y entonces usar \texttt{summarize}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_slope }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y)\{}
\NormalTok{  fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x)}
  \FunctionTok{tibble}\NormalTok{(}\AttributeTok{slope =}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coefficients[}\DecValTok{2}\NormalTok{], }
         \AttributeTok{se =} \FunctionTok{summary}\NormalTok{(fit)}\SpecialCharTok{$}\NormalTok{coefficient[}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{])}
\NormalTok{\}}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}  
  \FunctionTok{group\_by}\NormalTok{(HR) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{get\_slope}\NormalTok{(BB, R))}
\CommentTok{\#\textgreater{} \# A tibble: 9 x 3}
\CommentTok{\#\textgreater{}      HR slope     se}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1   0.4 0.734 0.208 }
\CommentTok{\#\textgreater{} 2   0.5 0.566 0.110 }
\CommentTok{\#\textgreater{} 3   0.6 0.412 0.0974}
\CommentTok{\#\textgreater{} 4   0.7 0.285 0.0705}
\CommentTok{\#\textgreater{} 5   0.8 0.365 0.0653}
\CommentTok{\#\textgreater{} \# ... with 4 more rows}
\end{Highlighting}
\end{Shaded}

Aquí un ejemplo que devuelve estimadores para ambos parametros:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_lse }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y)\{}
\NormalTok{  fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x)}
  \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{term =} \FunctionTok{names}\NormalTok{(fit}\SpecialCharTok{$}\NormalTok{coefficients),}
             \AttributeTok{slope =}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coefficients, }
             \AttributeTok{se =} \FunctionTok{summary}\NormalTok{(fit)}\SpecialCharTok{$}\NormalTok{coefficient[,}\DecValTok{2}\NormalTok{])}
\NormalTok{\}}

\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}  
  \FunctionTok{group\_by}\NormalTok{(HR) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{get\_lse}\NormalTok{(BB, R))}
\CommentTok{\#\textgreater{} \# A tibble: 18 x 4}
\CommentTok{\#\textgreater{} \# Groups:   HR [9]}
\CommentTok{\#\textgreater{}      HR term        slope    se}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}chr\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1   0.4 (Intercept) 1.36  0.631}
\CommentTok{\#\textgreater{} 2   0.4 x           0.734 0.208}
\CommentTok{\#\textgreater{} 3   0.5 (Intercept) 2.01  0.344}
\CommentTok{\#\textgreater{} 4   0.5 x           0.566 0.110}
\CommentTok{\#\textgreater{} 5   0.6 (Intercept) 2.53  0.305}
\CommentTok{\#\textgreater{} \# ... with 13 more rows}
\end{Highlighting}
\end{Shaded}

Si creen que todo esto es demasiado complicado, no son los únicos. Para simplificar las cosas, presentamos el paquete \textbf{broom} que fue diseñado para facilitar el uso de funciones que ajustan modelos, como \texttt{lm}, con el \textbf{tidyverse}.

\hypertarget{el-paquete-broom}{%
\subsection{\texorpdfstring{El paquete \textbf{broom}}{El paquete broom}}\label{el-paquete-broom}}

Nuestra tarea original era proveer un estimador y un intervalo de confianza para los estimadores de la pendiente de cada estrato. El paquete \textbf{broom} hará esto bastante fácil.

El paquete \textbf{broom} tiene tres funciones principales, todas de las cuales extraen información del objeto devuelto por \texttt{lm} y lo devuelve en un \emph{data frame} que \textbf{tidyverse} entiende. Estas funciones son \texttt{tidy}, \texttt{glance} y \texttt{augment}. La función \texttt{tidy} devuelve estimadores e información relacionada como un \emph{data frame}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(broom)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(R }\SpecialCharTok{\textasciitilde{}}\NormalTok{ BB, }\AttributeTok{data =}\NormalTok{ dat)}
\FunctionTok{tidy}\NormalTok{(fit)}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 5}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic  p.value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)    2.20     0.113       19.4 1.12e{-}70}
\CommentTok{\#\textgreater{} 2 BB             0.638    0.0344      18.5 1.35e{-}65}
\end{Highlighting}
\end{Shaded}

Podemos agregar otros resúmenes importantes, como los intervalos de confianza:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tidy}\NormalTok{(fit, }\AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 7}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic  p.value conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)    2.20     0.113       19.4 1.12e{-}70    1.98      2.42 }
\CommentTok{\#\textgreater{} 2 BB             0.638    0.0344      18.5 1.35e{-}65    0.570     0.705}
\end{Highlighting}
\end{Shaded}

Debido a que el resultado es un \emph{data frame}, podemos usarlo inmediatamente con \texttt{summarize} para unir los comandos que producen la tabla que queremos. Como se devuelve un \emph{data frame}, podemos filtrar y seleccionar las filas y columnas que queramos, que facilita trabajar con \textbf{ggplot2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}  
  \FunctionTok{group\_by}\NormalTok{(HR) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{tidy}\NormalTok{(}\FunctionTok{lm}\NormalTok{(R }\SpecialCharTok{\textasciitilde{}}\NormalTok{ BB), }\AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(term }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(HR, estimate, conf.low, conf.high) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(HR, }\AttributeTok{y =}\NormalTok{ estimate, }\AttributeTok{ymin =}\NormalTok{ conf.low, }\AttributeTok{ymax =}\NormalTok{ conf.high)) }\SpecialCharTok{+}
  \FunctionTok{geom\_errorbar}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/do-tidy-example-1} \end{center}

Ahora volvemos a discutir nuestra tarea original de determinar si las pendientes cambiaron. El gráfico que acabamos de hacer, usando \texttt{summarize} y \texttt{tidy}, muestra que los intervalos de confianza se superponen, que provee una buena confirmación visual de que nuestra suposición de que la pendiente no cambia es cierta.

Las otras funciones ofrecidas por \textbf{broom}, \texttt{glance} y \texttt{augment}, se relacionan con resultados específicos del modelo y de la observación, respectivamente. Aquí podemos ver los resúmenes que resultan de ajustar modelos que \texttt{glance} devuelve:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{glance}\NormalTok{(fit)}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 12}
\CommentTok{\#\textgreater{}   r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC}
\CommentTok{\#\textgreater{}       \textless{}dbl\textgreater{}         \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     0.266         0.265 0.454      343. 1.35e{-}65     1  {-}596. 1199.}
\CommentTok{\#\textgreater{} \# ... with 4 more variables: BIC \textless{}dbl\textgreater{}, deviance \textless{}dbl\textgreater{},}
\CommentTok{\#\textgreater{} \#   df.residual \textless{}int\textgreater{}, nobs \textless{}int\textgreater{}}
\end{Highlighting}
\end{Shaded}

Pueden obtener más información sobre estos resúmenes en cualquier libro de texto de regresión.

Veremos un ejemplo de \texttt{augment} en la siguiente sección.

\hypertarget{ejercicios-35}{%
\section{Ejercicios}\label{ejercicios-35}}

1. En una sección anterior, calculamos la correlación entre madres e hijas, madres e hijos, padres e hijas, y padres e hijos, y notamos que la correlación más alta es entre padres e hijos y la más baja es entre madres e hijos. Podemos calcular estas correlaciones usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(HistData)}
\FunctionTok{data}\NormalTok{(}\StringTok{"GaltonFamilies"}\NormalTok{)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{galton\_heights }\OtherTok{\textless{}{-}}\NormalTok{ GaltonFamilies }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(family, gender) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}

\NormalTok{cors }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_longer}\NormalTok{(father}\SpecialCharTok{:}\NormalTok{mother, }\AttributeTok{names\_to =} \StringTok{"parent"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"parentHeight"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{child =} \FunctionTok{ifelse}\NormalTok{(gender }\SpecialCharTok{==} \StringTok{"female"}\NormalTok{, }\StringTok{"daughter"}\NormalTok{, }\StringTok{"son"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unite}\NormalTok{(pair, }\FunctionTok{c}\NormalTok{(}\StringTok{"parent"}\NormalTok{, }\StringTok{"child"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(pair) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{cor =} \FunctionTok{cor}\NormalTok{(parentHeight, childHeight))}
\end{Highlighting}
\end{Shaded}

¿Son estas diferencias estadísticamente significativas? Para responder, calcularemos las pendientes de la línea de regresión junto con sus errores estándar. Comience usando \texttt{lm} y el paquete \textbf{broom} para calcular el LSE de las pendientes y los errores estándar.

2. Repita el ejercicio anterior, pero calcule también un intervalo de confianza.

3. Grafique los intervalos de confianza y observe que se superponen, que implica que los datos son consistentes con que la herencia de altura y sexo son independientes.

4. Debido a que estamos seleccionando niños al azar, podemos hacer algo como una prueba de permutación aquí. Repita el cálculo de correlaciones 100 veces tomando una muestra diferente cada vez. Sugerencia: use un código similar al que usamos con las simulaciones.

5. Ajuste un modelo de regresión lineal para obtener los efectos de BB y HR en las carreras (a nivel de equipo) para el año 1971. Utilice la función \texttt{tidy} del paquete \textbf{broom} para obtener los resultados en un \emph{data frame}.

6. Ahora repita lo anterior para cada año desde 1961 y haga un gráfico. Utilice \texttt{summarize} y el paquete \textbf{broom} para ajustar este modelo para cada año desde 1961.

7. Use los resultados del ejercicio anterior para graficar los efectos estimados de BB en las carreras.

8. \textbf{Avanzado}: Escriba una función que tome R, HR y BB como argumentos y ajuste dos modelos lineales: \texttt{R\ \textasciitilde{}\ BB} y \texttt{R\textasciitilde{}BB+HR}. Luego use la función \texttt{summarize} para obtener el \texttt{BB} para ambos modelos para cada año desde 1961. Finalmente, grafíquelos como función de tiempo y compárelos.

\hypertarget{estudio-de-caso-moneyball-continuaciuxf3n}{%
\section{\texorpdfstring{Estudio de caso: \emph{Moneyball} (continuación)}{Estudio de caso: Moneyball (continuación)}}\label{estudio-de-caso-moneyball-continuaciuxf3n}}

Al tratar de responder de cuán bien las BB predicen las carreras, la exploración de datos nos llevó a un modelo:

\[
\mbox{E}[R \mid BB = x_1, HR = x_2] = \beta_0 + \beta_1 x_1 + \beta_2 x_2
\]

Aquí, los datos son aproximadamente normales y las distribuciones condicionales también fueron normales. Por lo tanto, tiene sentido usar un modelo lineal:

\[
Y_i = \beta_0 + \beta_1 x_{i,1} + \beta_2 x_{i,2} + \varepsilon_i
\]

con \(Y_i\) representando carreras por juego para el equipo \(i\), \(x_{i,1}\) representando BB por juego, y \(x_{i,2}\) representando HR por juego. Para usar \texttt{lm} aquí, necesitamos que la función sepa que tenemos dos variables predictivas. Entonces usamos el símbolo \texttt{+} de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{BB =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{HR =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{G, }\AttributeTok{R =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(R }\SpecialCharTok{\textasciitilde{}}\NormalTok{ BB }\SpecialCharTok{+}\NormalTok{ HR, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

Nosotros podemos usar \texttt{tidy} para ver un buen resumen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tidy}\NormalTok{(fit, }\AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 7}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic   p.value conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)    1.74     0.0824      21.2 7.62e{-} 83    1.58      1.91 }
\CommentTok{\#\textgreater{} 2 BB             0.387    0.0270      14.3 1.20e{-} 42    0.334     0.440}
\CommentTok{\#\textgreater{} 3 HR             1.56     0.0490      31.9 1.78e{-}155    1.47      1.66}
\end{Highlighting}
\end{Shaded}

Cuando ajustamos el modelo con una sola variable, las pendientes estimadas fueron 0.735328761775897 y 1.84482406982372 para BB y HR, respectivamente. Tengan en cuenta que cuando se ajusta el modelo de múltiples variables, ambos disminuyen, con el efecto BB disminuyendo mucho más.

Ahora queremos construir una métrica para elegir jugadores. Tenemos que considerar sencillos, dobles y triples. ¿Podemos construir un modelo que prediga carreras basado en todos estos resultados?

Ahora vamos a dar un ``salto de fe'' y suponer que estas cinco variables son conjuntamente normales. Esto significa que si elegimos cualquiera de ellas y mantenemos las otras cuatro fijas, la relación con el resultado es lineal y la pendiente no depende de los cuatro valores que se mantienen constantes. Si esto es cierto, entonces un modelo lineal para nuestros datos es:

\[
Y_i = \beta_0 + \beta_1 x_{i,1} + \beta_2 x_{i,2} + \beta_3 x_{i,3}+ \beta_4 x_{i,4} + \beta_5 x_{i,5} + \varepsilon_i
\]

con \(x_{i,1}, x_{i,2}, x_{i,3}, x_{i,4}, x_{i,5}\) representando BB, sencillos, dobles, triples y HR respectivamente.

Utilizando \texttt{lm}, podemos encontrar rápidamente el LSE para los parámetros usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1961}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{BB =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{singles =}\NormalTok{ (H }\SpecialCharTok{{-}}\NormalTok{ X2B }\SpecialCharTok{{-}}\NormalTok{ X3B }\SpecialCharTok{{-}}\NormalTok{ HR)}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{doubles =}\NormalTok{ X2B}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{triples =}\NormalTok{ X3B}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{HR =}\NormalTok{ HR}\SpecialCharTok{/}\NormalTok{ G,}
         \AttributeTok{R =}\NormalTok{ R}\SpecialCharTok{/}\NormalTok{ G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(R }\SpecialCharTok{\textasciitilde{}}\NormalTok{ BB }\SpecialCharTok{+}\NormalTok{ singles }\SpecialCharTok{+}\NormalTok{ doubles }\SpecialCharTok{+}\NormalTok{ triples }\SpecialCharTok{+}\NormalTok{ HR, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

Podemos ver los coeficientes usando \texttt{tidy}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coefs }\OtherTok{\textless{}{-}} \FunctionTok{tidy}\NormalTok{(fit, }\AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{coefs}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 7}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic   p.value conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)   {-}2.77     0.0862     {-}32.1 4.76e{-}157   {-}2.94     {-}2.60 }
\CommentTok{\#\textgreater{} 2 BB             0.371    0.0117      31.6 1.87e{-}153    0.348     0.394}
\CommentTok{\#\textgreater{} 3 singles        0.519    0.0127      40.8 8.67e{-}217    0.494     0.544}
\CommentTok{\#\textgreater{} 4 doubles        0.771    0.0226      34.1 8.44e{-}171    0.727     0.816}
\CommentTok{\#\textgreater{} 5 triples        1.24     0.0768      16.1 2.12e{-} 52    1.09      1.39 }
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

Para ver cuán bien nuestra métrica predice carreras, podemos predecir el número de carreras para cada equipo en 2002 usando la función \texttt{predict} y entonces hacer un gráfico:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Teams }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{2002}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{BB =}\NormalTok{ BB}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{singles =}\NormalTok{ (H}\SpecialCharTok{{-}}\NormalTok{X2B}\SpecialCharTok{{-}}\NormalTok{X3B}\SpecialCharTok{{-}}\NormalTok{HR)}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{doubles =}\NormalTok{ X2B}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{triples =}\NormalTok{X3B}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{HR=}\NormalTok{HR}\SpecialCharTok{/}\NormalTok{G,}
         \AttributeTok{R=}\NormalTok{R}\SpecialCharTok{/}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{R\_hat =} \FunctionTok{predict}\NormalTok{(fit, }\AttributeTok{newdata =}\NormalTok{ .)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(R\_hat, R, }\AttributeTok{label =}\NormalTok{ teamID)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{(}\AttributeTok{nudge\_x=}\FloatTok{0.1}\NormalTok{, }\AttributeTok{cex =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/model-predicts-runs-1} \end{center}

Nuestro modelo hace un buen trabajo, como lo demuestra el hecho de que los puntos del gráfico observado versus los del gráfico previsto caen cerca de la línea de identidad.

Entonces, en lugar de usar el promedio de bateo o solo el número de HR como una medida de selección de jugadores, podemos usar nuestro modelo ajustado para formar una métrica que se relacione más directamente con la producción de carreras. Específicamente, para definir una métrica para un jugador A, imaginamos un equipo compuesto por jugadores como el jugador A y usamos nuestro modelo de regresión ajustado para predecir cuántas carreras produciría este equipo. La fórmula se vería así:
-2.769 +
0.371 \(\times\) BB +
0.519 \(\times\) singles +
0.771 \(\times\) dobles +
1.24 \(\times\) triples +
1.443 \(\times\) HR.

Para definir una métrica específica al jugador, tenemos un poco más de trabajo por hacer. Un reto aquí es que derivamos la métrica para equipos, basada en estadísticas de resumen a nivel de equipo. Por ejemplo, el valor de HR que se ingresa en la ecuación es HR por juego para todo el equipo. Si en cambio calculamos el HR por juego para un jugador, el valor será mucho más bajo dado que ya no son 9 bateadores contribuyendo al total sino un solo jugador. Además, si un jugador solo juega parte del juego y obtiene menos oportunidades que el promedio, todavía se considera un juego jugado. Para los jugadores, una tasa que toma en cuenta oportunidades es la tasa por turnos al bate.

Para hacer que la tasa de equipo por juego sea comparable a la tasa de jugador por turno al bate, calculamos el número promedio de turnos al bate por juego:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pa\_per\_game }\OtherTok{\textless{}{-}}\NormalTok{ Batting }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{==} \DecValTok{2002}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(teamID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{pa\_per\_game =} \FunctionTok{sum}\NormalTok{(AB}\SpecialCharTok{+}\NormalTok{BB) }\SpecialCharTok{/} \FunctionTok{max}\NormalTok{(G)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(pa\_per\_game) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  mean}
\end{Highlighting}
\end{Shaded}

Calculamos las tasas de turnos al bate para jugadores disponibles en 2002 con datos de 1997-2001. Para evitar pequeños artefactos de muestra, filtramos jugadores con menos de 200 turnos al bate por año. Aquí está el cálculo completo en una línea:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\OtherTok{\textless{}{-}}\NormalTok{ Batting }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{\%in\%} \DecValTok{1997}\SpecialCharTok{:}\DecValTok{2001}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(playerID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{PA =}\NormalTok{ BB }\SpecialCharTok{+}\NormalTok{ AB) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{G =} \FunctionTok{sum}\NormalTok{(PA)}\SpecialCharTok{/}\NormalTok{pa\_per\_game,}
            \AttributeTok{BB =} \FunctionTok{sum}\NormalTok{(BB)}\SpecialCharTok{/}\NormalTok{G,}
            \AttributeTok{singles =} \FunctionTok{sum}\NormalTok{(H}\SpecialCharTok{{-}}\NormalTok{X2B}\SpecialCharTok{{-}}\NormalTok{X3B}\SpecialCharTok{{-}}\NormalTok{HR)}\SpecialCharTok{/}\NormalTok{G,}
            \AttributeTok{doubles =} \FunctionTok{sum}\NormalTok{(X2B)}\SpecialCharTok{/}\NormalTok{G,}
            \AttributeTok{triples =} \FunctionTok{sum}\NormalTok{(X3B)}\SpecialCharTok{/}\NormalTok{G,}
            \AttributeTok{HR =} \FunctionTok{sum}\NormalTok{(HR)}\SpecialCharTok{/}\NormalTok{G,}
            \AttributeTok{AVG =} \FunctionTok{sum}\NormalTok{(H)}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(AB),}
            \AttributeTok{PA =} \FunctionTok{sum}\NormalTok{(PA)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(PA }\SpecialCharTok{\textgreater{}=} \DecValTok{1000}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{G) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{R\_hat =} \FunctionTok{predict}\NormalTok{(fit, }\AttributeTok{newdata =}\NormalTok{ .) }\SpecialCharTok{/} \DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Como el modelo fue ajustado a data de equipos, dividimos la predicción entre 9 (el número de jugadores que batean) para que represente las carreras que predecimos cada jugador producirá por juego. La distribución demuestra que existe una gran variabilidad entre los jugadores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(R\_hat, }\AttributeTok{data =}\NormalTok{ players, }\AttributeTok{binwidth =} \FloatTok{0.05}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/r-hat-hist-1} \end{center}

\hypertarget{auxf1adiendo-informaciuxf3n-sobre-salario-y-posiciuxf3n}{%
\subsection{Añadiendo información sobre salario y posición}\label{auxf1adiendo-informaciuxf3n-sobre-salario-y-posiciuxf3n}}

Para realmente construir el equipo, necesitaremos conocer sus salarios y su posición defensiva. Para hacer esto, unimos el \emph{data frame} \texttt{players} que acabamos de crear con el \emph{data frame} de información del jugador incluido en algunas de las otras tablas de datos de \textbf{Lahman}. Aprenderemos más sobre la función \texttt{join} en la Sección \ref{joins}.

Comiencen añadiendo los salarios del 2002 para cada jugador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\OtherTok{\textless{}{-}}\NormalTok{ Salaries }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{==} \DecValTok{2002}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(playerID, salary) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{right\_join}\NormalTok{(players, }\AttributeTok{by=}\StringTok{"playerID"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A continuación, agregamos su posición defensiva. Esta es una tarea algo complicada porque los jugadores juegan más de una posición cada año. La tabla \texttt{Appearances} del paquete \textbf{Lahman} indica cuántos juegos jugó cada jugador en cada posición y podemos elegir la posición que más se jugó usando \texttt{which.max} en cada fila. Usamos \texttt{apply} para hacer esto. Sin embargo, debido a que algunos jugadores son intercambiados, aparecen más de una vez en la tabla, por lo que primero sumamos sus turnos al bate en los equipos. Aquí, escogemos la posición en la que más jugó el jugador usando la función \texttt{top\_n}. Para asegurarnos de que solo elegimos una posición, en el caso de empates, elegimos la primera fila del \emph{data frame} resultante. También eliminamos la posición \texttt{OF} que significa \emph{outfielder}, una generalización de tres posiciones: jardín izquierdo (LF o \emph{left field} en inglés), jardín central (CF o \emph{center field} en inglés) y campo derecho (RF o \emph{right field} en inglés). Además, eliminamos los lanzadores, ya que no batean en la liga en la que juegan los Atléticos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{position\_names }\OtherTok{\textless{}{-}}
  \FunctionTok{paste0}\NormalTok{(}\StringTok{"G\_"}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"p"}\NormalTok{,}\StringTok{"c"}\NormalTok{,}\StringTok{"1b"}\NormalTok{,}\StringTok{"2b"}\NormalTok{,}\StringTok{"3b"}\NormalTok{,}\StringTok{"ss"}\NormalTok{,}\StringTok{"lf"}\NormalTok{,}\StringTok{"cf"}\NormalTok{,}\StringTok{"rf"}\NormalTok{, }\StringTok{"dh"}\NormalTok{))}

\NormalTok{tmp }\OtherTok{\textless{}{-}}\NormalTok{ Appearances }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{==} \DecValTok{2002}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(playerID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize\_at}\NormalTok{(position\_names, sum) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}

\NormalTok{pos }\OtherTok{\textless{}{-}}\NormalTok{ tmp }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(position\_names) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{apply}\NormalTok{(., }\DecValTok{1}\NormalTok{, which.max)}
\CommentTok{\#\textgreater{} Note: Using an external vector in selections is ambiguous.}
\CommentTok{\#\textgreater{} i Use \textasciigrave{}all\_of(position\_names)\textasciigrave{} instead of \textasciigrave{}position\_names\textasciigrave{} to silence this message.}
\CommentTok{\#\textgreater{} i See \textless{}https://tidyselect.r{-}lib.org/reference/faq{-}external{-}vector.html\textgreater{}.}
\CommentTok{\#\textgreater{} This message is displayed once per session.}

\NormalTok{players }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\AttributeTok{playerID =}\NormalTok{ tmp}\SpecialCharTok{$}\NormalTok{playerID, }\AttributeTok{POS =}\NormalTok{ position\_names[pos]) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{POS =} \FunctionTok{str\_to\_upper}\NormalTok{(}\FunctionTok{str\_remove}\NormalTok{(POS, }\StringTok{"G\_"}\NormalTok{))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(POS }\SpecialCharTok{!=} \StringTok{"P"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{right\_join}\NormalTok{(players, }\AttributeTok{by=}\StringTok{"playerID"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(POS) }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(salary))}
\end{Highlighting}
\end{Shaded}

Finalmente, agregamos su nombre y apellido:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\OtherTok{\textless{}{-}}\NormalTok{ Master }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(playerID, nameFirst, nameLast, debut) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{debut =} \FunctionTok{as.Date}\NormalTok{(debut)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{right\_join}\NormalTok{(players, }\AttributeTok{by=}\StringTok{"playerID"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si son fanáticos del béisbol, reconocerán a los 10 mejores jugadores:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(nameFirst, nameLast, POS, salary, R\_hat) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(R\_hat)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{top\_n}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{} Selecting by R\_hat}
\CommentTok{\#\textgreater{}    nameFirst nameLast POS   salary R\_hat}
\CommentTok{\#\textgreater{} 1      Barry    Bonds  LF 15000000 0.938}
\CommentTok{\#\textgreater{} 2      Larry   Walker  RF 12666667 0.927}
\CommentTok{\#\textgreater{} 3       Todd   Helton  1B  5000000 0.863}
\CommentTok{\#\textgreater{} 4      Manny  Ramirez  LF 15462727 0.857}
\CommentTok{\#\textgreater{} 5      Sammy     Sosa  RF 15000000 0.840}
\CommentTok{\#\textgreater{} 6       Jeff  Bagwell  1B 11000000 0.823}
\CommentTok{\#\textgreater{} 7       Mike   Piazza   C 10571429 0.816}
\CommentTok{\#\textgreater{} 8      Jason   Giambi  1B 10428571 0.807}
\CommentTok{\#\textgreater{} 9      Edgar Martinez  DH  7086668 0.807}
\CommentTok{\#\textgreater{} 10       Jim    Thome  1B  8000000 0.804}
\end{Highlighting}
\end{Shaded}

\hypertarget{escoger-nueve-jugadores}{%
\subsection{Escoger nueve jugadores}\label{escoger-nueve-jugadores}}

En promedio, los jugadores con una métrica más alta tienen salarios más altos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(salary, R\_hat, }\AttributeTok{color =}\NormalTok{ POS)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_log10}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/predicted-runs-vs-salary-1} \end{center}

Podemos buscar buenas ofertas mirando a los jugadores que producen muchas más carreras que otros con salarios similares. Podemos usar esta tabla para decidir qué jugadores escoger y mantener nuestro salario total por debajo de los 40 millones de dólares con los que tuvo que trabajar Billy Beane. Esto se puede hacer usando lo que los científicos de la computación llaman programación lineal. Esto no es algo que enseñamos, pero en la siguiente tabla mostramos los jugadores seleccionados con este acercamiento, la posición que juegan, su salario y las carreras que predecimos producirían. Vemos que, en promedio, nuestro equipo produciría 6.6 carreras por juego! En la tabla también mostramos estadísticas estandarizadas usando todos los jugadores, de modo que, por ejemplo, los bateadores de HR por encima del promedio tienen valores superiores a 0. Vemos que todos estos jugadores tienen BB por encima del promedio y la mayoría tienen tasas de HR por encima del promedio, mientras que lo mismo no es cierto para sencillos:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llllrrrrrrr}
\toprule
nameFirst & nameLast & POS & salary & R\_hat & BB & singles & doubles & triples & HR & AVG\\
\midrule
Todd & Helton & 1B & 5,000,000 & 0.9 & 0.9 & -0.2 & 2.6 & -0.3 & 1.5 & 2.7\\
Mike & Piazza & C & 10,571,429 & 0.8 & 0.3 & 0.4 & 0.2 & -1.4 & 1.8 & 2.2\\
Edgar & Martinez & DH & 7,086,668 & 0.8 & 2.1 & 0.0 & 1.3 & -1.2 & 0.8 & 2.2\\
Jim & Edmonds & CF & 7,333,333 & 0.7 & 1.1 & -0.6 & 0.8 & -1.2 & 1.0 & 0.9\\
Jeff & Kent & 2B & 6,000,000 & 0.7 & 0.2 & -0.7 & 2.0 & 0.4 & 0.8 & 0.8\\
\addlinespace
Phil & Nevin & 3B & 2,600,000 & 0.7 & 0.3 & -0.9 & 0.5 & -1.2 & 1.2 & 0.1\\
Matt & Stairs & RF & 500,000 & 0.7 & 1.1 & -1.5 & 0.0 & -1.1 & 1.1 & -0.6\\
Henry & Rodriguez & LF & 300,000 & 0.7 & 0.2 & -1.6 & 0.3 & -0.8 & 1.3 & -0.7\\
John & Valentin & SS & 550,000 & 0.6 & 0.2 & -0.9 & 1.8 & -0.4 & 0.0 & -0.5\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

\hypertarget{la-falacia-de-la-regresiuxf3n}{%
\section{La falacia de la regresión}\label{la-falacia-de-la-regresiuxf3n}}

Wikipedia define la \emph{maldición de segundo año} (\emph{sophomore slump} en inglés) como:

\begin{quote}
Una caída de segundo año o maldición de segundo año se refiere a una instancia en la que un segundo esfuerzo, o segundo año, no cumple con los estándares del primer esfuerzo. Se usa comúnmente para referirse a la apatía de los estudiantes (segundo año de secundaria, colegio o universidad), el rendimiento de los atletas (segunda temporada de juego), cantantes/bandas (segundo álbum), programas de televisión (segunda temporada) y películas (secuelas/precuelas).
\end{quote}

En las Grandes Ligas de Béisbol, el premio al novato del año (\emph{Rookie of the Year} o ROY por sus siglas en inglés) se otorga al jugador de primer año que se considera que ha tenido el mejor desempeño. La frase \emph{maldición de segundo año} se usa para describir la observación de que a los ganadores del premio ROY no les va tan bien durante su segundo año. Por ejemplo, este artículo de Fox Sports\footnote{\url{https://www.foxsports.com/stories/mlb/will-mlbs-tremendous-rookie-class-of-2015-suffer-a-sophomore-slump}} que pregunta ``¿La impresionante clase de novatos del MLB de 2015 sufrirá una maldición de segundo año?''

¿Los datos confirman la existencia de una maldición de segundo año? Vamos a ver. Al examinar los datos para el promedio de bateo, vemos que esta observación es válida para los ROY de mayor rendimiento:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llrrr}
\toprule
nameFirst & nameLast & rookie\_year & rookie & sophomore\\
\midrule
Willie & McCovey & 1959 & 0.354 & 0.238\\
Ichiro & Suzuki & 2001 & 0.350 & 0.321\\
Al & Bumbry & 1973 & 0.337 & 0.233\\
Fred & Lynn & 1975 & 0.331 & 0.314\\
Albert & Pujols & 2001 & 0.329 & 0.314\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

De hecho, la proporción de jugadores que tienen un promedio de bateo más bajo en su segundo año es 0.686.

Entonces, ¿es ``nerviosismo'' o ``maldición''? Para responder a esta pregunta, volvamos nuestra atención a todos los jugadores que jugaron las temporadas 2013 y 2014 y batearon más de 130 veces (mínimo para ganar el ROY).

El mismo patrón surge cuando miramos a los jugadores con el mejor desempeño: los promedios de bateo disminuyen para la mayoría de los mejores jugadores.

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llrr}
\toprule
nameFirst & nameLast & 2013 & 2014\\
\midrule
Miguel & Cabrera & 0.348 & 0.313\\
Hanley & Ramirez & 0.345 & 0.283\\
Michael & Cuddyer & 0.331 & 0.332\\
Scooter & Gennett & 0.324 & 0.289\\
Joe & Mauer & 0.324 & 0.277\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

¡Pero estos no son novatos! Además, miren lo que les sucede a los peores jugadores del 2013:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llrr}
\toprule
nameFirst & nameLast & 2013 & 2014\\
\midrule
Danny & Espinosa & 0.158 & 0.219\\
Dan & Uggla & 0.179 & 0.149\\
Jeff & Mathis & 0.181 & 0.200\\
B. J. & Upton & 0.184 & 0.208\\
Adam & Rosales & 0.190 & 0.262\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

¡Sus promedios de bateo en su mayoría suben! ¿Es esto una especie de ``bendición'' de segundo año? No lo es. No hay tal cosa como una maldición de segundo año. Todo esto se explica con un simple hecho estadístico: la correlación para el rendimiento en dos años separados es alta, pero no perfecta:

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/regression-fallacy-1} \end{center}

La correlación es 0.46 y
los datos se parecen mucho a una distribución normal de dos variables, que significa que predecimos un promedio de bateo \(Y\) del 2014 para cualquier jugador que tuviera un promedio de bateo \(X\) en el 2013 con:

\[ \frac{Y - .255}{.032} = 0.46 \left( \frac{X - .261}{.023}\right) \]

Como la correlación no es perfecta, la regresión nos dice que, en promedio, esperamos que los jugadores de alto desempeño del 2013 tengan un peor desempeño en 2014. No es una maldición; es solo por casualidad. El ROY se selecciona de los valores superiores de \(X\), por lo cual se espera que \(Y\) muestre regresión a la media.

\hypertarget{modelos-de-error-de-mediciuxf3n}{%
\section{Modelos de error de medición}\label{modelos-de-error-de-mediciuxf3n}}

Hasta ahora, todos nuestros ejemplos de regresión lineal se han aplicado a dos o más variables aleatorias. Suponemos que los pares siguen una distribución normal de dos variables y lo usamos para motivar un modelo lineal. Este enfoque cubre la mayoría de los ejemplos reales de regresión lineal. La otra aplicación importante proviene de los modelos de errores de medición. En estas aplicaciones, es común tener una covariable no aleatoria, como el tiempo, y la aleatoriedad se introduce por error de medición en lugar de muestreo o variabilidad natural.

Para entender estos modelos, imaginen que son Galileo en el siglo XVI tratando de describir la velocidad de un objeto que cae. Un asistente sube a la torre de Pisa y deja caer una pelota, mientras que otros asistentes registran la posición en diferentes momentos. Simulemos algunos datos usando las ecuaciones que conocemos hoy y agregando algunos errores de medición. La función \texttt{rfalling\_object} de \textbf{dslabs} genera estas simulaciones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{falling\_object }\OtherTok{\textless{}{-}} \FunctionTok{rfalling\_object}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Los asistentes le entregan los datos a Galileo y esto es lo que él ve:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{falling\_object }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(time, observed\_distance)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Distance in meters"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Time in seconds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/gravity-1} \end{center}

Galileo no conoce la ecuación exacta, pero al observar el gráfico anterior, deduce que la posición debe seguir una parábola, que podemos escribir así:

\[ f(x) = \beta_0 + \beta_1 x + \beta_2 x^2\]

Los datos no caen exactamente en una parábola. Galileo sabe que esto se debe a un error de medición. Sus ayudantes cometen errores al medir la distancia. Para tomar esto en cuenta, modela los datos con:

\[ Y_i = \beta_0 + \beta_1 x_i + \beta_2 x_i^2 + \varepsilon_i, i=1,\dots,n \]

con \(Y_i\) representando la distancia en metros, \(x_i\) representando el tiempo en segundos y \(\varepsilon\) tomando en cuenta el error de medición. Se supone que el error de medición sea aleatorio, independiente el uno del otro y que con la misma distribución para cada \(i\). También suponemos que no hay sesgo, que significa que el valor esperado \(\mbox{E}[\varepsilon] = 0\).

Noten que este es un modelo lineal porque es una combinación lineal de cantidades conocidas (\(x\) y \(x^2\) son conocidas) y parámetros desconocidos (los \(\beta\)s son parámetros desconocidos para Galileo). A diferencia de nuestros ejemplos anteriores, aquí \(x\) es una cantidad fija; no estamos condicionando.

Para plantear una nueva teoría física y comenzar a hacer predicciones sobre la caída de otros objetos, Galileo necesita números reales, en lugar de parámetros desconocidos. Usar el LSE parece un enfoque razonable. ¿Cómo encontramos el LSE?

Los cálculos del LSE no requieren que los errores sean aproximadamente normales. La función \texttt{lm} encontrará los \(\beta\)s que minimizarán la suma residual de cuadrados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ falling\_object }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{time\_sq =}\NormalTok{ time}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(observed\_distance}\SpecialCharTok{\textasciitilde{}}\NormalTok{time}\SpecialCharTok{+}\NormalTok{time\_sq, }\AttributeTok{data=}\NormalTok{.)}
\FunctionTok{tidy}\NormalTok{(fit)}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 5}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic  p.value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)   56.1       0.592    94.9   2.23e{-}17}
\CommentTok{\#\textgreater{} 2 time          {-}0.786     0.845    {-}0.930 3.72e{-} 1}
\CommentTok{\#\textgreater{} 3 time\_sq       {-}4.53      0.251   {-}18.1   1.58e{-} 9}
\end{Highlighting}
\end{Shaded}

Verifiquemos si la parábola estimada se ajusta a los datos. La función \texttt{augment} de \textbf{broom} nos permite hacer esto fácilmente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{augment}\NormalTok{(fit) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(time, observed\_distance)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(time, .fitted), }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/falling-object-fit-1} \end{center}

Gracias a nuestros maestros de física de escuela secundaria, sabemos que la ecuación para la trayectoria de un objeto que cae es:

\[d = h_0 + v_0 t - 0.5 \times 9.8 t^2\]

con \(h_0\) y \(v_0\) la altura inicial y la velocidad, respectivamente. Los datos que simulamos anteriormente siguieron esta ecuación y agregaron un error de medición a fin de simular \texttt{n} observaciones para dejar caer una pelota \((v_0=0)\) desde la torre de Pisa \((h_0=55.86)\).

Estos son consistentes con los estimadores de los parámetros:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tidy}\NormalTok{(fit, }\AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 7}
\CommentTok{\#\textgreater{}   term        estimate std.error statistic  p.value conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 (Intercept)   56.1       0.592    94.9   2.23e{-}17    54.8      57.4 }
\CommentTok{\#\textgreater{} 2 time          {-}0.786     0.845    {-}0.930 3.72e{-} 1    {-}2.65      1.07}
\CommentTok{\#\textgreater{} 3 time\_sq       {-}4.53      0.251   {-}18.1   1.58e{-} 9    {-}5.08     {-}3.98}
\end{Highlighting}
\end{Shaded}

La altura de la torre de Pisa está dentro del intervalo de confianza para \(\beta_0\), la velocidad inicial 0 está en el intervalo de confianza para \(\beta_1\) (recuerden que el valor-p es mayor que 0.05) y la constante de aceleración está en un intervalo de confianza para \(-2 \times \beta_2\).

\hypertarget{ejercicios-36}{%
\section{Ejercicios}\label{ejercicios-36}}

Desde la década de 1980, los \emph{sabermetricians} han utilizado una estadística de resumen diferente del promedio de bateo para evaluar a los jugadores. Se dieron cuenta de que las BB eran importantes y que a los dobles, triples y HR se les debe dar más peso que los sencillos. Como resultado, propusieron la siguiente métrica:

\[
\frac{\mbox{BB}}{\mbox{PA}} + \frac{\mbox{Singles} + 2 \mbox{Doubles} + 3 \mbox{Triples} + 4\mbox{HR}}{\mbox{AB}}
\]

Denominaron a la métrica: \emph{on-base-percentage plus slugging percentage} o OPS. Aunque los \emph{sabermetricians} probablemente no usaron la regresión, aquí mostramos cómo OPS está cerca de lo que se obtiene con la regresión.

1. Calcule el OPS para cada equipo en la temporada 2001. Luego grafique carreras por juego versus OPS.

2. Para cada año desde 1961, calcule la correlación entre carreras por juego y OPS. Entonces grafique estas correlaciones como función del año.

3. Tenga en cuenta que podemos reescribir OPS como un promedio ponderado de BB, sencillos, dobles, triples y HR. Sabemos que los coeficientes para dobles, triples y HR son 2, 3 y 4 veces mayores que para los sencillos. ¿Pero y los BB? ¿Cuál es el peso para BB en relación con sencillos? Sugerencia: el peso de BB en relación con sencillos será una función de AB y PA.

4. Tenga en cuenta que el peso para BB, \(\frac{\mbox{AB}}{\mbox{PA}}\), cambiará de un equipo a otro. Para ver cuán variable es, calcule y grafique esta cantidad para cada equipo para cada año desde 1961. Luego vuelva a graficarla, pero en lugar de calcularla para cada equipo, calcule y grafique la razón para todo el año. Entonces, una vez que esté claro de que no hay mucha tendencia de tiempo o equipo, indique el promedio general.

5. Ahora sabemos que la fórmula para OPS es proporcional a \(0.91 \times \mbox{BB} + \mbox{singles} + 2 \times \mbox{doubles} + 3 \times \mbox{triples} + 4 \times \mbox{HR}\). Veamos cómo se comparan estos coeficientes con esos obtenidos con la regresión. Ajuste un modelo de regresión a los datos después de 1961, como se hizo anteriormente: usando estadísticas por juego para cada año para cada equipo. Después de ajustar este modelo, indique los coeficientes como pesos relativos al coeficiente para sencillos.

6. Vemos que nuestros coeficientes del modelo de regresión lineal siguen la misma tendencia general que esos utilizados por OPS, pero con un peso ligeramente menor para las métricas que no son sencillos. Para cada equipo en los años posteriores a 1961, calcule el OPS, las carreras predichas con el modelo de regresión y calcule la correlación entre los dos, así como la correlación con carreras por juego.

7. Vemos que el uso del enfoque de regresión predice carreras un poco mejor que OPS, pero no tanto. Sin embargo, tenga en cuenta que hemos estado calculando OPS y prediciendo carreras para los equipos cuando estas medidas se utilizan para evaluar a los jugadores. Demostremos que OPS es bastante similar a lo que se obtiene con la regresión a nivel de jugador. Para la temporada de 1961 y las posteriores, calcule el OPS y las carreras previstas de nuestro modelo para cada jugador y grafíquelas. Use la corrección de PA por juego que usamos en el capítulo anterior.

8. ¿Qué jugadores han mostrado la mayor diferencia entre su rango por carreras predichas y OPS?

\hypertarget{la-correlaciuxf3n-no-implica-causalidad}{%
\chapter{La correlación no implica causalidad}\label{la-correlaciuxf3n-no-implica-causalidad}}

La correlación no implica causalidad es quizás la lección más importante que uno aprende en una clase de estadística. A lo largo de la parte de estadísticas del libro, hemos descrito herramientas útiles para cuantificar asociaciones entre variables. Sin embargo, debemos tener cuidado de no malinterpretar estas asociaciones.

Hay muchas razones por las que una variable \(X\) se puede correlacionar con una variable \(Y\) sin tener ningún efecto directo sobre \(Y\). A continuación examinaremos cuatro formas comunes que pueden conducir a una malinterpretación de los datos.

\hypertarget{correlaciuxf3n-espuria}{%
\section{Correlación espuria}\label{correlaciuxf3n-espuria}}

El siguiente ejemplo cómico subraya que la correlación no es causalidad. Muestra una correlación muy fuerte entre las tasas de divorcio y el consumo de margarina.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/divorce-versus-margarine-1} \end{center}

¿Significa esto que la margarina causa divorcios? ¿O los divorcios hacen que las personas coman más margarina? Por supuesto, la respuesta a ambas preguntas es ``no''. Esto es solo un ejemplo de lo que llamamos una correlación espuria.

Pueden ver muchos más ejemplos absurdos en el sitio web \emph{Spurious Correlations}\footnote{\url{http://tylervigen.com/spurious-correlations}}.

Los casos que se presentan en el sitio de web de correlaciones espurias son todas instancias de lo que generalmente se llama \emph{dragado de datos} o \emph{pesca de datos} (\emph{data dredging}, \emph{data fishing}, o \emph{data snooping} en inglés). Básicamente es cuando se escogen los datos selectivamente para confirmar cierta hipótesis. Un ejemplo de dragado de datos sería si observamos muchos resultados producidos por un proceso aleatorio y elegimos solo los que muestran una relación que respalda una teoría que queremos defender.

Se puede usar una simulación Monte Carlo para mostrar cómo el dragado de datos puede resultar en altas correlaciones entre variables no correlacionadas. Guardaremos los resultados de nuestra simulación en un tibble:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{25}
\NormalTok{g }\OtherTok{\textless{}{-}} \DecValTok{1000000}
\NormalTok{sim\_data }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\AttributeTok{group =} \FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{g, }\AttributeTok{each=}\NormalTok{N),}
                   \AttributeTok{x =} \FunctionTok{rnorm}\NormalTok{(N }\SpecialCharTok{*}\NormalTok{ g),}
                   \AttributeTok{y =} \FunctionTok{rnorm}\NormalTok{(N }\SpecialCharTok{*}\NormalTok{ g))}
\end{Highlighting}
\end{Shaded}

La primera columna denota grupo. Creamos grupos y para cada uno generamos un par de vectores independientes, \(X\) e \(Y\), cada una con 25 observaciones, almacenadas en la segunda y tercera columnas. Debido a que construimos la simulación, sabemos que \(X\) e \(Y\) no están correlacionadas.

A continuación, calculamos la correlación entre \(X\) e \(Y\) para cada grupo y miramos el máximo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}}\NormalTok{ sim\_data }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(group) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{r =} \FunctionTok{cor}\NormalTok{(x, y)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(r))}
\NormalTok{res}
\CommentTok{\#\textgreater{} \# A tibble: 1,000,000 x 2}
\CommentTok{\#\textgreater{}    group     r}
\CommentTok{\#\textgreater{}    \textless{}int\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 566605 0.803}
\CommentTok{\#\textgreater{} 2 387075 0.784}
\CommentTok{\#\textgreater{} 3 230548 0.782}
\CommentTok{\#\textgreater{} 4 944766 0.782}
\CommentTok{\#\textgreater{} 5  47755 0.778}
\CommentTok{\#\textgreater{} \# ... with 999,995 more rows}
\end{Highlighting}
\end{Shaded}

Vemos una correlación máxima de 0.803 y, si solo graficamos los datos del grupo con esta correlación, vemos un gráfico convincente que \(X\) e \(Y\) sí están correlacionados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sim\_data }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(group }\SpecialCharTok{==}\NormalTok{ res}\SpecialCharTok{$}\NormalTok{group[}\FunctionTok{which.max}\NormalTok{(res}\SpecialCharTok{$}\NormalTok{r)]) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/dredging-1} \end{center}

Recuerden que el resumen de correlación es una variable aleatoria. Aquí tenemos la distribución generada por la simulación Monte Carlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x=}\NormalTok{r)) }\SpecialCharTok{+} \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =} \FloatTok{0.1}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/null-corr-hist-1} \end{center}

Es un hecho matemático que si observamos correlaciones aleatorias que se esperan que sean 0, pero tienen un error estándar de 0.204, la más grande estará cerca de 1.

Si realizamos una regresión en este grupo e interpretamos el valor-p, afirmaríamos incorrectamente que esta es una relación estadísticamente significativa:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(broom)}
\NormalTok{sim\_data }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(group }\SpecialCharTok{==}\NormalTok{ res}\SpecialCharTok{$}\NormalTok{group[}\FunctionTok{which.max}\NormalTok{(res}\SpecialCharTok{$}\NormalTok{r)]) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{tidy}\NormalTok{(}\FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(term }\SpecialCharTok{==} \StringTok{"x"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 5}
\CommentTok{\#\textgreater{}   term  estimate std.error statistic    p.value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}      \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 x        0.806     0.125      6.46 0.00000136}
\end{Highlighting}
\end{Shaded}

Esta forma particular de dragado de datos se conoce como \emph{p-hacking}. El \emph{p-hacking} es un tema de mucha discusión porque es un problema en publicaciones científicas. Debido a que los editores tienden a premiar resultados estadísticamente significativos sobre resultados negativos, existe un incentivo para informar resultados significativos. En la epidemiología y las ciencias sociales, por ejemplo, los investigadores pueden buscar asociaciones entre un resultado adverso y varias exposiciones a distintos tipos de riesgo e informar solo la exposición que resultó en un valor-p pequeño. Además, podrían intentar ajustar varios modelos diferentes para tomar en cuenta la confusión y elegir el que da el valor-p más pequeño. En disciplinas experimentales, un experimento puede repetirse más de una vez, pero solo informar los resultados del experimento con un valor-p pequeño. Esto no sucede necesariamente debido a comportamientos antiéticos, sino más bien como resultado de la ignorancia estadística o de meras ilusiones. En los cursos de estadística avanzada, pueden aprender métodos para tomar en cuenta estas múltiples comparaciones.

\hypertarget{valores-atuxedpicos-1}{%
\section{Valores atípicos}\label{valores-atuxedpicos-1}}

Supongan que tomamos medidas de dos resultados independientes, \(X\) e \(Y\), y estandarizamos las medidas. Sin embargo, cometemos un error y olvidamos estandarizar la entrada 23. Podemos simular dichos datos usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1985}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{,}\DecValTok{100}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{,}\DecValTok{84}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{x[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(x[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{])}
\NormalTok{y[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(y[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Los datos se ven así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/outlier-1} \end{center}

No es sorprendente que la correlación sea bien alta:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(x,y)}
\CommentTok{\#\textgreater{} [1] 0.988}
\end{Highlighting}
\end{Shaded}

Pero lo impulsa un valor atípico. Si eliminamos este valor atípico, la correlación se reduce considerablemente a casi 0, que es lo que debería ser:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(x[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{], y[}\SpecialCharTok{{-}}\DecValTok{23}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] {-}0.0442}
\end{Highlighting}
\end{Shaded}

En la Sección \ref{robust-summaries}, describimos alternativas al promedio y la desviación estándar que son robustas a valores atípicos. También hay una alternativa a la correlación muestral para estimar la correlación de población que es robusta a valores atípicos. Se llama \emph{la correlación de Spearman}. La idea es sencilla: calcular la correlación basada en los rangos de los valores. Aquí tenemos un gráfico de los rangos graficados uno contra el otro:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(}\FunctionTok{rank}\NormalTok{(x), }\FunctionTok{rank}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/scatter-plot-of-ranks-1} \end{center}

El valor atípico ya no está asociado con un valor muy grande y la correlación se reduce:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(}\FunctionTok{rank}\NormalTok{(x), }\FunctionTok{rank}\NormalTok{(y))}
\CommentTok{\#\textgreater{} [1] 0.00251}
\end{Highlighting}
\end{Shaded}

La correlación de Spearman también se puede calcular así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(x, y, }\AttributeTok{method =} \StringTok{"spearman"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 0.00251}
\end{Highlighting}
\end{Shaded}

Además, hay métodos robustos para ajustar modelos lineales que pueden aprender, por ejemplo, en en libro \emph{Robust Statistics: Edition 2} de Peter J. Huber y Elvezio M. Ronchetti.

\hypertarget{inversiuxf3n-de-causa-y-efecto}{%
\section{Inversión de causa y efecto}\label{inversiuxf3n-de-causa-y-efecto}}

Otra forma en que la asociación se confunde con la causalidad es cuando la causa y el efecto se invierten. Un ejemplo de esto es afirmar que la tutoría afecta negativamente a los estudiantes porque éstos evalúan peor que sus compañeros que no reciben tutoría. En este caso, la tutoría no está causando las bajas puntuaciones en las pruebas, sino al revés.

Una versión de este reclamo se convirtió en un artículo de opinión en el New York Times titulado \emph{Parental Involvement Is Overrated}\footnote{\url{https://opinionator.blogs.nytimes.com/2014/04/12/parental-involvement-is-overrated}}. Consideren esta cita del artículo:

\begin{quote}
\begin{quote}
Cuando examinamos si la ayuda frecuente con la tarea tuvo un impacto positivo en el desempeño académico de los niños, nos sorprendió lo que encontramos. Independientemente de la clase social de la familia, del origen racial o étnico, o del grado de un niño, ayuda consistente con la tarea casi nunca mejoró la puntuación de las pruebas o las notas \ldots{} Incluso más sorprendente para nosotros fue que cuando los padres ayudaban frecuentemente con la tarea, los niños generalmente salían peor.
\end{quote}
\end{quote}

Una posibilidad muy probable es que los niños que necesitan ayuda frecuente de sus padres reciban esta ayuda porque no se desempeñan bien en la escuela.

Fácilmente podemos construir un ejemplo de inversión de causa y efecto utilizando los datos de altura de padre e hijo. Si nos ajustamos al modelo:

\[X_i = \beta_0 + \beta_1 y_i + \varepsilon_i, i=1, \dots, N\]

a los datos de altura de padre e hijo, con \(X_i\) la altura del padre e \(y_i\) la altura del hijo, obtenemos un resultado estadísticamente significativo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(HistData)}
\FunctionTok{data}\NormalTok{(}\StringTok{"GaltonFamilies"}\NormalTok{)}
\NormalTok{GaltonFamilies }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(childNum }\SpecialCharTok{==} \DecValTok{1} \SpecialCharTok{\&}\NormalTok{ gender }\SpecialCharTok{==} \StringTok{"male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(father, childHeight) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{son =}\NormalTok{ childHeight) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{tidy}\NormalTok{(}\FunctionTok{lm}\NormalTok{(father }\SpecialCharTok{\textasciitilde{}}\NormalTok{ son)))}
\CommentTok{\#\textgreater{}          term estimate std.error statistic  p.value}
\CommentTok{\#\textgreater{} 1 (Intercept)   33.965    4.5682      7.44 4.31e{-}12}
\CommentTok{\#\textgreater{} 2         son    0.499    0.0648      7.70 9.47e{-}13}
\end{Highlighting}
\end{Shaded}

El modelo se ajusta muy bien a los datos. Si observamos la formulación matemática del modelo anterior, podría interpretarse fácilmente de manera incorrecta para sugerir que el hijo siendo alto hace que el padre sea alto. Pero dado lo que sabemos sobre genética y biología, sabemos que es al revés. El modelo es técnicamente correcto. Los estimadores y los valores-p también se obtuvieron correctamente. Lo que está mal aquí es la interpretación.

\hypertarget{factores-de-confusiuxf3n}{%
\section{Factores de confusión}\label{factores-de-confusiuxf3n}}

Los factores de confusión son quizás la razón más común que conduce a que las asociaciones se malinterpreten.

Si \(X\) e \(Y\) están correlacionados, llamamos \(Z\) un \emph{factor de confusión} (\emph{confounder} en inglés) si cambios en \(Z\) provocan cambios en ambos \(X\) e \(Y\). Anteriormente, al estudiar los datos del béisbol, vimos cómo los cuadrangulares eran un factor de confusión que resultaban en una correlación más alta de lo esperado al estudiar la relación entre BB y HR. En algunos casos, podemos usar modelos lineales para tomar en cuenta los factores de confusión. Sin embargo, este no siempre es el caso.

La interpretación incorrecta debido a factores de confusión es omnipresente en la prensa laica y, a menudo, son difíciles de detectar. Aquí, presentamos un ejemplo ampliamente utilizado relacionado con las admisiones a la universidad.

\hypertarget{ejemplo-admisiones-a-la-universidad-de-california-berkeley}{%
\subsection{Ejemplo: admisiones a la Universidad de California, Berkeley}\label{ejemplo-admisiones-a-la-universidad-de-california-berkeley}}

Los datos de admisión de seis concentraciones de U.C. Berkeley, de 1973, mostraron que se admitían a más hombres que mujeres: el 44\% de los hombres fueron aceptados en comparación con el 30\% de las mujeres. PJ Bickel, EA Hammel \& JW O'Connell. Science (1975). Podemos cargar los datos y
ejecutar una prueba estadística, que rechaza claramente la hipótesis de que el género y la admisión son independientes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(admissions)}
\NormalTok{admissions }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(gender) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{total\_admitted =} \FunctionTok{round}\NormalTok{(}\FunctionTok{sum}\NormalTok{(admitted}\SpecialCharTok{/} \DecValTok{100} \SpecialCharTok{*}\NormalTok{ applicants)),}
            \AttributeTok{not\_admitted =} \FunctionTok{sum}\NormalTok{(applicants) }\SpecialCharTok{{-}} \FunctionTok{sum}\NormalTok{(total\_admitted)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{gender) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\FunctionTok{tidy}\NormalTok{(}\FunctionTok{chisq.test}\NormalTok{(.))) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .}\SpecialCharTok{$}\NormalTok{p.value}
\CommentTok{\#\textgreater{} [1] 1.06e{-}21}
\end{Highlighting}
\end{Shaded}

Pero una inspección más cuidadosa muestra un resultado paradójico. Aquí están los porcentajes de admisión por concentración :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{admissions }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(major, gender, admitted) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =} \StringTok{"gender"}\NormalTok{, }\AttributeTok{values\_from =} \StringTok{"admitted"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{women\_minus\_men =}\NormalTok{ women }\SpecialCharTok{{-}}\NormalTok{ men)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 4}
\CommentTok{\#\textgreater{}   major   men women women\_minus\_men}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}           \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 A        62    82              20}
\CommentTok{\#\textgreater{} 2 B        63    68               5}
\CommentTok{\#\textgreater{} 3 C        37    34              {-}3}
\CommentTok{\#\textgreater{} 4 D        33    35               2}
\CommentTok{\#\textgreater{} 5 E        28    24              {-}4}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

Cuatro de las seis concentraciones favorecen a las mujeres. Más importante aún, todas las diferencias son mucho más pequeñas que la diferencia de 14.2 que vemos al examinar los totales.

La paradoja es que analizar los totales sugiere una dependencia entre admisión y género, pero cuando los datos se agrupan por concentración, esta dependencia parece desaparecer. ¿Qué está pasando? Esto puede suceder cuando un factor de confusión no detectado está impulsando la mayor parte de la variabilidad.

Así que definamos tres variables: \(X\) es 1 para hombres y 0 para mujeres, \(Y\) es 1 para los admitidos y 0 en caso contrario, y \(Z\) cuantifica la selectividad de la concentración. Una afirmación de sesgo de género se basaría en el hecho de que \(\mbox{Pr}(Y=1 | X = x)\) es mayor para \(x=1\) que \(x=0\). Sin embargo, \(Z\) es un factor de confusión importante para tomar en cuenta. Claramente \(Z\) está asociado con \(Y\), ya que entre más selectiva sea la concentración, \(\mbox{Pr}(Y=1 | Z = z)\) será menor. Pero, ¿está asociada la selección de concentración \(Z\) con el género \(X\)?

Una forma de ver esto es graficar el porcentaje total admitido a una concentración versus el porcentaje de mujeres que componen los solicitantes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(major) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{major\_selectivity =} \FunctionTok{sum}\NormalTok{(admitted }\SpecialCharTok{*}\NormalTok{ applicants)}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(applicants),}
            \AttributeTok{percent\_women\_applicants =} \FunctionTok{sum}\NormalTok{(applicants }\SpecialCharTok{*}\NormalTok{ (gender}\SpecialCharTok{==}\StringTok{"women"}\NormalTok{))}\SpecialCharTok{/}
              \FunctionTok{sum}\NormalTok{(applicants) }\SpecialCharTok{*} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(major\_selectivity, percent\_women\_applicants, }\AttributeTok{label =}\NormalTok{ major)) }\SpecialCharTok{+}
  \FunctionTok{geom\_text}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/uc-berkeley-majors-1} \end{center}

Parece haber asociación. El gráfico sugiere que las mujeres eran mucho más propensas a solicitar a las dos concentraciones ``difíciles'': el género y la selectividad de la concentración están confundidos. Compare, por ejemplo, la concentración B y la E. La concentración B es mucho más difícil de ingresar que la B y más del 60\% de los solicitantes a la concentración E eran mujeres, mientras que menos del 30\% de los solicitantes a la concentración B eran mujeres.

\hypertarget{confusiuxf3n-explicada-gruxe1ficamente}{%
\subsection{Confusión explicada gráficamente}\label{confusiuxf3n-explicada-gruxe1ficamente}}

El siguiente gráfico muestra el número de solicitantes que fueron admitidos y los que no fueron según sexo:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/confounding-1} \end{center}

También desglosamos las aceptaciones por concentración. Este gráfico nos permite ver que la mayoría de los hombres aceptados provenían de dos concentraciones: A y B, y que pocas mujeres solicitaron estas concentraciones.

\hypertarget{calcular-promedio-luego-de-estratificar}{%
\subsection{Calcular promedio luego de estratificar}\label{calcular-promedio-luego-de-estratificar}}

En este gráfico, podemos ver que si condicionamos o estratificamos por concentración, controlamos el factor de confusión y este efecto desaparece:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{admissions }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(major, admitted, }\AttributeTok{col =}\NormalTok{ gender, }\AttributeTok{size =}\NormalTok{ applicants)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/admission-by-major-1} \end{center}

Ahora vemos que concentración por concentración, no hay mucha diferencia. El tamaño del punto representa el número de solicitantes y explica la paradoja: vemos grandes puntos rojos y pequeños puntos azules para las concentraciones más fáciles/menos retantes, A y B.

Si promediamos la diferencia por concentración, encontramos que el porcentaje es 3.5\% más alto para las mujeres.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{admissions }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(gender) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{average =} \FunctionTok{mean}\NormalTok{(admitted))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 2}
\CommentTok{\#\textgreater{}   gender average}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}    \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 men       38.2}
\CommentTok{\#\textgreater{} 2 women     41.7}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-paradoja-de-simpson}{%
\section{La paradoja de Simpson}\label{la-paradoja-de-simpson}}

El caso que acabamos de discutir es un ejemplo de la paradoja de Simpson. Se le llama paradoja porque vemos que el signo de la correlación cambia al comparar la población entera y estratos específicos. Como ejemplo ilustrativo, supongan que observamos realizaciones de las tres variables aleatorias \(X\), \(Y\) y \(Z\). Aquí hay un gráfico de observaciones simuladas para \(X\) e \(Y\) junto con la correlación de muestra:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simpsons-paradox-1} \end{center}

Pueden ver que \(X\) e \(Y\) están correlacionados negativamente. Sin embargo, una vez que estratificamos por \(Z\) (se muestra en diferentes colores a continuación), surge otro patrón:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/simpsons-paradox-explained-1} \end{center}

Realmente es \(Z\) que está negativamente correlacionada con \(X\). Si estratificamos por \(Z\), las \(X\) e \(Y\) están positivamente correlacionadas como se observa en el gráfico anterior.

\hypertarget{ejercicios-37}{%
\section{Ejercicios}\label{ejercicios-37}}

Para el próximo set de ejercicios, examinamos los datos de un artículo de PNAS del 2014\footnote{\url{http://www.pnas.org/content/112/40/12349.abstract}} que analizó las tasas de éxito de agencias de financiación en los Países Bajos y concluyó que:

\begin{quote}
Nuestros resultados revelan un sesgo de género que favorece a los solicitantes sobre las solicitantes en la priorización de sus evaluaciones y tasas de éxito con respecto a su ``calidad de investigador'' (pero no ``calidad de propuesta''), así como en el lenguaje utilizado en los materiales de instrucción y evaluación.
\end{quote}

Unos meses después, se publicó una respuesta\footnote{\url{http://www.pnas.org/content/112/51/E7036.extract}} titulada \emph{No evidence that gender contributes to personal research funding success in The Netherlands: A reaction to Van der Lee and Ellemers} que concluyó:

\begin{quote}
Sin embargo, el efecto general del género apenas alcanza significancia estadística, a pesar del tamaño grande de la muestra. Además, su conclusión podría ser un excelente ejemplo de la paradoja de Simpson; si un mayor porcentaje de mujeres solicita subvenciones en disciplinas científicas más competitivas (es decir, con bajas tasas de éxito de solicitudes tanto para hombres como para mujeres), entonces un análisis de todas las disciplinas podría mostrar incorrectamente ``evidencia'' de desigualdad de género.
\end{quote}

¿Quién tiene la razón aquí? ¿El artículo original o la respuesta? Aquí, examinarán los datos y llegarán a su propia conclusión.

1. La evidencia principal para la conclusión del artículo original se reduce a una comparación de los porcentajes. La Tabla S1 en el artículo incluye la información que necesitamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"research\_funding\_rates"}\NormalTok{)}
\NormalTok{research\_funding\_rates}
\end{Highlighting}
\end{Shaded}

Construya la tabla 2 X 2 utilizada para la conclusión sobre las diferencias en los premios por género.

2. Calcule la diferencia en porcentaje de la tabla 2 X 2.

3. En el ejercicio anterior, notamos que la tasa de éxito es menor para las mujeres. ¿Pero es significativo? Calcule un valor-p usando una prueba de Chi-cuadrado.

4. Vemos que el valor-p es aproximadamente 0.05. Entonces parece haber algo de evidencia de una asociación. ¿Pero podemos inferir causalidad aquí? ¿El sesgo de género está causando esta diferencia observada? La respuesta al artículo original afirma que lo que vemos aquí es similar al ejemplo de las admisiones a U.C. Berkeley. Para resolver esta disputa, cree un set de datos con el número de solicitudes, premios y tasas de éxito para cada género. Reordene las disciplinas por su tasa de éxito general. Sugerencia: use la función \texttt{reorder} para reordenar las disciplinas como primer paso, luego use \texttt{pivot\_longer}, \texttt{separate} y \texttt{pivot\_wider} para crear la tabla deseada.

5. Para verificar si este es un caso de la paradoja de Simpson, grafique las tasas de éxito versus las disciplinas, que han sido ordenadas según éxito general, con colores para denotar los géneros y tamaño para denotar el número de solicitudes.

6. Definitivamente no vemos el mismo nivel de confusión que en el ejemplo de U.C. Berkeley. Es difícil decir que hay un factor de confusión aquí. Sin embargo, vemos que, según las tasas observadas, algunos campos favorecen a los hombres y otros favorecen a las mujeres. Además, vemos que los dos campos con la mayor diferencia que favorecen a los hombres también son los campos con más solicitudes. Pero, a diferencia del ejemplo de U.C. Berkeley, no es más probable que las mujeres soliciten las concentraciones más difíciles. Entonces, quizás algunos de los comités de selección son parciales y otros no.

Pero, antes de concluir esto, debemos verificar si estas diferencias son diferentes de lo que obtenemos por casualidad. ¿Alguna de las diferencias vistas anteriormente es estadísticamente significativa? Tengan en cuenta que incluso cuando no hay sesgo, veremos diferencias debido a la variabilidad aleatoria en el proceso de revisión, así como entre los candidatos. Realice una prueba de Chi-cuadrado para cada disciplina. Sugerencia: defina una función que reciba el total de una tabla 2 X 2 y devuelva un \emph{data frame} con el valor-p.~Use la corrección 0.5. Luego use la función \texttt{summarize}.

7. Para las ciencias médicas, parece haber una diferencia estadísticamente significativa. ¿Pero es esto una correlación espuria? Realice 9 pruebas. Informar solo el caso con un valor-p inferior a 0.05 podría considerarse un ejemplo de dragado de datos. Repita el ejercicio anterior, pero en lugar de un valor-p, calcule un logaritmo de riesgo relativo (\emph{log odds ratio} en inglés) dividido por su error estándar. Entonces use un gráfico Q-Q para ver cuánto se desvían estos logaritmos de riesgo relativo de la distribución normal que esperaríamos: una distribución normal estándar.

\hypertarget{part-wrangling-de-datos}{%
\part{Wrangling de datos}\label{part-wrangling-de-datos}}

\hypertarget{introducciuxf3n-al-wrangling-de-datos}{%
\chapter{Introducción al wrangling de datos}\label{introducciuxf3n-al-wrangling-de-datos}}

Los sets de datos utilizados en este libro se han puesto a su disposición como objetos R, específicamente como \emph{data frames}. Los datos de asesinatos de EE. UU., los datos reportados de alturas y los datos de Gapminder son todos \emph{data frames}. Estos sets de datos vienen incluidos en el paquete \textbf{dslabs} y los cargamos usando la función \texttt{data}. Además, hemos puesto a disposición los datos en formato \texttt{tidy}. Los paquetes y las funciones de tidyverse suponen que los datos son \texttt{tidy} y esta suposición es una gran parte de la razón por la que estos paquetes funcionan tan bien juntos.

Sin embargo, es bien raro que en un proyecto de ciencia de datos haya datos fácilmente disponibles como parte de un paquete. Hicimos un buen trabajo ``tras bastidores'' para convertir los datos originales en las tablas \emph{tidy} con que trabajamos. Mucho más común es que los datos estén en un archivo, una base de datos o extraídos de un documento, incluyendo páginas web, tuits o PDF. En estos casos, el primer paso es importar los datos a R y, cuando estemos usando \textbf{tidyverse}, ordenar los datos. Este paso inicial en el proceso de análisis de datos generalmente implica varios pasos, a menudo complicados, para convertir datos al formato \emph{tidy} que facilita enormemente el resto del análisis. Nos referimos a este proceso como \emph{wrangling de datos}.

Aquí cubrimos varios pasos comunes del proceso del \emph{wrangling} de datos, incluyendo cómo convertir los datos en formato \emph{tidy}, procesar cadenas, leer y procesar (\emph{parse} en inglés) HTML, trabajar con fechas y horas y, finalmente, \emph{mineria de textos} (\emph{text mining} en inglés). Raras veces se necesita hacer todos estos pasos de \emph{wrangling} en un solo análisis, pero los científicos de datos probablemente enfrentarán a todos en algún momento. Algunos de los ejemplos que utilizamos para demostrar las técnicas del \emph{wrangling} de datos se basan en el trabajo que hicimos para convertir datos sin procesar en los sets de datos \emph{tidy} ofrecidos por el paquete \textbf{dslabs} y utilizados en el libro como ejemplos.

\hypertarget{cuxf3mo-cambiar-el-formato-de-datos}{%
\chapter{Cómo cambiar el formato de datos}\label{cuxf3mo-cambiar-el-formato-de-datos}}

Como hemos visto a través del libro, tener datos en formato \emph{tidy} es lo que hace que el tidyverse fluya. Después del primer paso en el proceso de análisis de datos, la importación de datos, un siguiente paso común es cambiar la forma de los datos a una que facilite el resto del análisis. El paquete \textbf{tidyr} incluye varias funciones útiles para poner los datos en formato \emph{tidy}.

Utilizaremos el set de datos en formato ancho \emph{fertility}, descrito en la Sección \ref{tidy-data}, como ejemplo en esta sección.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{path }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package=}\StringTok{"dslabs"}\NormalTok{)}
\NormalTok{filename }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(path, }\StringTok{"fertility{-}two{-}countries{-}example.csv"}\NormalTok{)}
\NormalTok{wide\_data }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(filename)}
\end{Highlighting}
\end{Shaded}

\hypertarget{pivot_longer}{%
\section{\texorpdfstring{\texttt{pivot\_longer}}{pivot\_longer}}\label{pivot_longer}}

Una de las funciones más usadas del paquete \textbf{tidyr} es \texttt{pivot\_longer}, que nos permite convertir datos anchos (\emph{wide data} en inglés) en datos \emph{tidy}.

Igual que con la mayoría de las funciones de tidyverse, el primer argumento de la función \texttt{pivot\_longer} es el \emph{data frame} que será procesado. Aquí queremos cambiar la forma del set de datos \texttt{wide\_data} para que cada fila represente una observación de fertilidad, que implica que necesitamos tres columnas para almacenar el año, el país y el valor observado. En su forma actual, los datos de diferentes años están en diferentes columnas con los valores de año almacenados en los nombres de las columnas. A través de los argumentos \texttt{names\_to} y \texttt{values\_to}, le daremos a \texttt{pivot\_longer} los nombres de columna que le queremos asignar a las columnas que contienen los nombres de columna y las observaciones actuales, respectivamente. Por defecto, estos nombres son \texttt{name} (nombre) y \texttt{value} (valor), los cuales son buenas opciones en general. En este caso, una mejor opción para estos dos argumentos serían \texttt{year} y \texttt{fertility}. Noten que ninguna parte del archivo nos dice que se trata de datos de fertilidad. En cambio, desciframos esto del nombre del archivo. A través \texttt{cols}, el segundo argumento, especificamos las columnas que contienen los valores observados; estas son las columnas que serán \emph{pivotadas}. La acción por defecto es recopilar todas las columnas, por lo que, en la mayoría de los casos, tenemos que especificar las columnas. En nuestro ejemplo queremos las columnas \texttt{1960}, \texttt{1961} hasta \texttt{2015}.

El código para recopilar los datos de fertilidad se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_tidy\_data }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_longer}\NormalTok{(wide\_data, }\StringTok{\textasciigrave{}}\AttributeTok{1960}\StringTok{\textasciigrave{}}\SpecialCharTok{:}\StringTok{\textasciigrave{}}\AttributeTok{2015}\StringTok{\textasciigrave{}}\NormalTok{, }
                              \AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"fertility"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

También podemos usar el \emph{pipe} de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_tidy\_data }\OtherTok{\textless{}{-}}\NormalTok{ wide\_data }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_longer}\NormalTok{(}\StringTok{\textasciigrave{}}\AttributeTok{1960}\StringTok{\textasciigrave{}}\SpecialCharTok{:}\StringTok{\textasciigrave{}}\AttributeTok{2015}\StringTok{\textasciigrave{}}\NormalTok{, }\AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"fertility"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos ver que los datos se han convertido al formato \emph{tidy} con columnas \texttt{year} y \texttt{fertility}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(new\_tidy\_data)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 3}
\CommentTok{\#\textgreater{}   country year  fertility}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960       2.41}
\CommentTok{\#\textgreater{} 2 Germany 1961       2.44}
\CommentTok{\#\textgreater{} 3 Germany 1962       2.47}
\CommentTok{\#\textgreater{} 4 Germany 1963       2.49}
\CommentTok{\#\textgreater{} 5 Germany 1964       2.49}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

y que cada año resultó en dos filas ya que tenemos dos países y la columna de los países no se recopiló. Una forma un poco más rápida de escribir este código es especificar qué columna \textbf{no} se recopilará, en lugar de todas las columnas que se recopilarán:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_tidy\_data }\OtherTok{\textless{}{-}}\NormalTok{ wide\_data }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{country, }\AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"fertility"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

El objeto \texttt{new\_tidy\_data} se parece al original \texttt{tidy\_data} que definimos de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"gapminder"}\NormalTok{)}
\NormalTok{tidy\_data }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(country }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"South Korea"}\NormalTok{, }\StringTok{"Germany"}\NormalTok{) }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(fertility)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(country, year, fertility)}
\end{Highlighting}
\end{Shaded}

con solo una pequeña diferencia. ¿La pueden ver? Miren el tipo de datos de la columna del año:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(tidy\_data}\SpecialCharTok{$}\NormalTok{year)}
\CommentTok{\#\textgreater{} [1] "integer"}
\FunctionTok{class}\NormalTok{(new\_tidy\_data}\SpecialCharTok{$}\NormalTok{year)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

La función \texttt{pivot\_longer} supone que los nombres de columna son caracteres. Así que necesitamos un poco más de \emph{wrangling} antes de poder graficar. Necesitamos convertir la columna con los años en números. La función \texttt{pivot\_longer} incluye el argumento \texttt{convert} para este propósito:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_tidy\_data }\OtherTok{\textless{}{-}}\NormalTok{ wide\_data }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{country, }\AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"fertility"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \FunctionTok{as.integer}\NormalTok{(year))}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que también podríamos haber utilizado \texttt{mutate} y \texttt{as.numeric}.

Ahora que los datos están \emph{tidy}, podemos usar este código relativamente sencillo de \textbf{ggplot2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_tidy\_data }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, fertility, }\AttributeTok{color =}\NormalTok{ country)) }\SpecialCharTok{+} 
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{pivot_wider}{%
\section{\texorpdfstring{\texttt{pivot\_wider}}{pivot\_wider}}\label{pivot_wider}}

Como veremos en ejemplos posteriores, a veces es útil convertir datos \emph{tidy} en datos anchos para fines de \emph{wrangling} de datos. A menudo usamos esto como un paso intermedio para convertir los datos en formato \emph{tidy}. La función \texttt{pivot\_wider} es básicamente la inversa de \texttt{pivot\_longer}. El primer argumento es para los datos, pero como estamos usando el \emph{pipe}, no lo mostramos. El argumento \texttt{names\_from} le dice a \texttt{pivot\_longer} qué variable usar como nombre de columna. El argumento \texttt{names\_to} especifica qué variable usar para completar las celdas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_wide\_data }\OtherTok{\textless{}{-}}\NormalTok{ new\_tidy\_data }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ year, }\AttributeTok{values\_from =}\NormalTok{ fertility)}
\FunctionTok{select}\NormalTok{(new\_wide\_data, country, }\StringTok{\textasciigrave{}}\AttributeTok{1960}\StringTok{\textasciigrave{}}\SpecialCharTok{:}\StringTok{\textasciigrave{}}\AttributeTok{1967}\StringTok{\textasciigrave{}}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 9}
\CommentTok{\#\textgreater{}   country     \textasciigrave{}1960\textasciigrave{} \textasciigrave{}1961\textasciigrave{} \textasciigrave{}1962\textasciigrave{} \textasciigrave{}1963\textasciigrave{} \textasciigrave{}1964\textasciigrave{} \textasciigrave{}1965\textasciigrave{} \textasciigrave{}1966\textasciigrave{} \textasciigrave{}1967\textasciigrave{}}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}        \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany       2.41   2.44   2.47   2.49   2.49   2.48   2.44   2.37}
\CommentTok{\#\textgreater{} 2 South Korea   6.16   5.99   5.79   5.57   5.36   5.16   4.99   4.85}
\end{Highlighting}
\end{Shaded}

Similar a \texttt{pivot\_wider}, \texttt{names\_from} y \texttt{values\_from} son \texttt{name} and \texttt{value} por defecto.

\hypertarget{separate}{%
\section{\texorpdfstring{\texttt{separate}}{separate}}\label{separate}}

El \emph{wrangling} de datos que mostramos arriba es sencillo en comparación con lo que generalmente se requiere. En nuestros archivos de hoja de cálculo que usamos como ejemplo, incluimos una ilustración que es un poco más complicada. Contiene dos variables: esperanza de vida y fertilidad. Sin embargo, la forma en que se almacena no es \emph{tidy} y, como explicaremos, no es óptima.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}

\NormalTok{filename }\OtherTok{\textless{}{-}} \StringTok{"life{-}expectancy{-}and{-}fertility{-}two{-}countries{-}example.csv"}
\NormalTok{filename }\OtherTok{\textless{}{-}} \FunctionTok{file.path}\NormalTok{(path, filename)}

\NormalTok{raw\_dat }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(filename)}
\FunctionTok{select}\NormalTok{(raw\_dat, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 5}
\CommentTok{\#\textgreater{}   country     \textasciigrave{}1960\_fertility\textasciigrave{} \textasciigrave{}1960\_life\_expectancy\textasciigrave{} \textasciigrave{}1961\_fertility\textasciigrave{}}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                  \textless{}dbl\textgreater{}                  \textless{}dbl\textgreater{}            \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany                 2.41                   69.3             2.44}
\CommentTok{\#\textgreater{} 2 South Korea             6.16                   53.0             5.99}
\CommentTok{\#\textgreater{} \# ... with 1 more variable: 1961\_life\_expectancy \textless{}dbl\textgreater{}}
\end{Highlighting}
\end{Shaded}

Primero, tengan en cuenta que los datos están en formato ancho. Además, observen que esta tabla incluye valores para dos variables, fertilidad y esperanza de vida, con el nombre (en inglés) de la columna codificando qué columna representa qué variable. No recomendamos codificar la información en los nombres de las columnas, pero, desafortunadamente, es algo bastante común. Usaremos nuestras habilidades de \emph{wrangling} para extraer esta información y almacenarla de manera \emph{tidy}.

Podemos comenzar el \emph{wrangling} de datos con la función \texttt{pivot\_longer}, pero ya no deberíamos usar el nombre de la columna \texttt{year} para la nueva columna, dado que también contiene el tipo de variable. La nombraremos \texttt{name}, el valor predeterminado, por ahora:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ raw\_dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{country)}
\FunctionTok{head}\NormalTok{(dat)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 3}
\CommentTok{\#\textgreater{}   country name                 value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{}                \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960\_fertility        2.41}
\CommentTok{\#\textgreater{} 2 Germany 1960\_life\_expectancy 69.3 }
\CommentTok{\#\textgreater{} 3 Germany 1961\_fertility        2.44}
\CommentTok{\#\textgreater{} 4 Germany 1961\_life\_expectancy 69.8 }
\CommentTok{\#\textgreater{} 5 Germany 1962\_fertility        2.47}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

El resultado no es exactamente lo que llamamos \emph{tidy} ya que cada observación está asociada con dos filas en vez de una. Queremos tener los valores de las dos variables, \texttt{fertility} y \texttt{life\_expectancy}, en dos columnas separadas. El primer reto para lograr esto es separar la columna \texttt{name} en año y tipo de variable. Observen que las entradas en esta columna separan el año del nombre de la variable con una barra baja:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\SpecialCharTok{$}\NormalTok{name[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "1960\_fertility"       "1960\_life\_expectancy" "1961\_fertility"      }
\CommentTok{\#\textgreater{} [4] "1961\_life\_expectancy" "1962\_fertility"}
\end{Highlighting}
\end{Shaded}

Codificar múltiples variables en el nombre de una columna es un problema tan común que el paquete \textbf{readr} incluye una función para separar estas columnas en dos o más. Aparte de los datos, la función \texttt{separate} toma tres argumentos: el nombre de la columna que se separará, los nombres que se utilizarán para las nuevas columnas y el carácter que separa las variables. Entonces, un primer intento de hacer esto es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(name, }\FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"name"}\NormalTok{), }\StringTok{"\_"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{separate} supone por defecto que\texttt{\_} es el separador y, por eso, no tenemos que incluirlo en el código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(name, }\FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"name"}\NormalTok{))}
\CommentTok{\#\textgreater{} Warning: Expected 2 pieces. Additional pieces discarded in 112 rows [2,}
\CommentTok{\#\textgreater{} 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,}
\CommentTok{\#\textgreater{} 40, ...].}
\CommentTok{\#\textgreater{} \# A tibble: 224 x 4}
\CommentTok{\#\textgreater{}   country year  name      value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{} \textless{}chr\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960  fertility  2.41}
\CommentTok{\#\textgreater{} 2 Germany 1960  life      69.3 }
\CommentTok{\#\textgreater{} 3 Germany 1961  fertility  2.44}
\CommentTok{\#\textgreater{} 4 Germany 1961  life      69.8 }
\CommentTok{\#\textgreater{} 5 Germany 1962  fertility  2.47}
\CommentTok{\#\textgreater{} \# ... with 219 more rows}
\end{Highlighting}
\end{Shaded}

La función separa los valores, pero nos encontramos con un nuevo problema. Recibimos la advertencia \texttt{Too\ many\ values\ at\ 112\ locations:} y la variable \texttt{life\_expectancy} se corta a \texttt{life}. Esto es porque el \texttt{\_} se usa para separar \texttt{life} y \texttt{expectancy}, no solo el año y el nombre de la variable. Podríamos añadir una tercera columna para guardar esto y dejar que la función \texttt{separate} sepa cual columna \emph{llenar} con los valores faltantes, \texttt{NA}, cuando no hay un tercer valor. Aquí le decimos que llene la columna de la derecha:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_names }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"first\_variable\_name"}\NormalTok{, }\StringTok{"second\_variable\_name"}\NormalTok{)}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(name, var\_names, }\AttributeTok{fill =} \StringTok{"right"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 224 x 5}
\CommentTok{\#\textgreater{}   country year  first\_variable\_name second\_variable\_name value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{} \textless{}chr\textgreater{}               \textless{}chr\textgreater{}                \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960  fertility           \textless{}NA\textgreater{}                  2.41}
\CommentTok{\#\textgreater{} 2 Germany 1960  life                expectancy           69.3 }
\CommentTok{\#\textgreater{} 3 Germany 1961  fertility           \textless{}NA\textgreater{}                  2.44}
\CommentTok{\#\textgreater{} 4 Germany 1961  life                expectancy           69.8 }
\CommentTok{\#\textgreater{} 5 Germany 1962  fertility           \textless{}NA\textgreater{}                  2.47}
\CommentTok{\#\textgreater{} \# ... with 219 more rows}
\end{Highlighting}
\end{Shaded}

Sin embargo, si leemos el archivo de ayuda de \texttt{separate}, encontramos que un mejor enfoque es fusionar las dos últimas variables cuando hay una separación adicional:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(name, }\FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"name"}\NormalTok{), }\AttributeTok{extra =} \StringTok{"merge"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 224 x 4}
\CommentTok{\#\textgreater{}   country year  name            value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{} \textless{}chr\textgreater{}           \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960  fertility        2.41}
\CommentTok{\#\textgreater{} 2 Germany 1960  life\_expectancy 69.3 }
\CommentTok{\#\textgreater{} 3 Germany 1961  fertility        2.44}
\CommentTok{\#\textgreater{} 4 Germany 1961  life\_expectancy 69.8 }
\CommentTok{\#\textgreater{} 5 Germany 1962  fertility        2.47}
\CommentTok{\#\textgreater{} \# ... with 219 more rows}
\end{Highlighting}
\end{Shaded}

Esto logra la separación que queríamos. Sin embargo, aún no hemos terminado. Necesitamos crear una columna para cada variable. Como aprendimos, la función \texttt{pivot\_wider} hace eso:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{separate}\NormalTok{(name, }\FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"name"}\NormalTok{), }\AttributeTok{extra =} \StringTok{"merge"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{()}
\CommentTok{\#\textgreater{} \# A tibble: 112 x 4}
\CommentTok{\#\textgreater{}   country year  fertility life\_expectancy}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{}     \textless{}dbl\textgreater{}           \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960       2.41            69.3}
\CommentTok{\#\textgreater{} 2 Germany 1961       2.44            69.8}
\CommentTok{\#\textgreater{} 3 Germany 1962       2.47            70.0}
\CommentTok{\#\textgreater{} 4 Germany 1963       2.49            70.1}
\CommentTok{\#\textgreater{} 5 Germany 1964       2.49            70.7}
\CommentTok{\#\textgreater{} \# ... with 107 more rows}
\end{Highlighting}
\end{Shaded}

Los datos ahora están en formato \emph{tidy} con una fila para cada observación con tres variables: año, fertilidad y esperanza de vida.

\hypertarget{unite}{%
\section{\texorpdfstring{\texttt{unite}}{unite}}\label{unite}}

A veces es útil hacer el inverso de \texttt{separate}, es decir, unir dos columnas en una. Para demostrar cómo usar \texttt{unite}, mostramos un código que, aunque \emph{no} es el acercamiento óptimo, sirve como ilustración. Supongan que no supiéramos sobre \texttt{extra} y usáramos este comando para separar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_names }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"first\_variable\_name"}\NormalTok{, }\StringTok{"second\_variable\_name"}\NormalTok{)}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{separate}\NormalTok{(name, var\_names, }\AttributeTok{fill =} \StringTok{"right"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 224 x 5}
\CommentTok{\#\textgreater{}   country year  first\_variable\_name second\_variable\_name value}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{} \textless{}chr\textgreater{}               \textless{}chr\textgreater{}                \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960  fertility           \textless{}NA\textgreater{}                  2.41}
\CommentTok{\#\textgreater{} 2 Germany 1960  life                expectancy           69.3 }
\CommentTok{\#\textgreater{} 3 Germany 1961  fertility           \textless{}NA\textgreater{}                  2.44}
\CommentTok{\#\textgreater{} 4 Germany 1961  life                expectancy           69.8 }
\CommentTok{\#\textgreater{} 5 Germany 1962  fertility           \textless{}NA\textgreater{}                  2.47}
\CommentTok{\#\textgreater{} \# ... with 219 more rows}
\end{Highlighting}
\end{Shaded}

Podemos lograr el mismo resultado final uniendo las segunda y tercera columnas, luego esparciendo las columnas usando \texttt{pivot\_wider} y renombrando \texttt{fertility\_NA} a \texttt{fertility}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{separate}\NormalTok{(name, var\_names, }\AttributeTok{fill =} \StringTok{"right"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unite}\NormalTok{(name, first\_variable\_name, second\_variable\_name) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{fertility =}\NormalTok{ fertility\_NA)}
\CommentTok{\#\textgreater{} \# A tibble: 112 x 4}
\CommentTok{\#\textgreater{}   country year  fertility life\_expectancy}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{}     \textless{}dbl\textgreater{}           \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Germany 1960       2.41            69.3}
\CommentTok{\#\textgreater{} 2 Germany 1961       2.44            69.8}
\CommentTok{\#\textgreater{} 3 Germany 1962       2.47            70.0}
\CommentTok{\#\textgreater{} 4 Germany 1963       2.49            70.1}
\CommentTok{\#\textgreater{} 5 Germany 1964       2.49            70.7}
\CommentTok{\#\textgreater{} \# ... with 107 more rows}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-38}{%
\section{Ejercicios}\label{ejercicios-38}}

1. Ejecute el siguiente comando para definir el objeto \texttt{co2\_wide}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{co2\_wide }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(co2, }\AttributeTok{ncol =} \DecValTok{12}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{12}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \FunctionTok{as.character}\NormalTok{(}\DecValTok{1959}\SpecialCharTok{:}\DecValTok{1997}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Utilice la función \texttt{pivot\_longer} para \emph{wrangle} esto en un set de datos \emph{tidy}. Nombre a la columna con las mediciones de CO2 \texttt{co2} y nombre a la columna de mes \texttt{month}. Nombre al objeto resultante \texttt{co2\_tidy}.

2. Grafique CO2 versus mes con una curva diferente para cada año usando este código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{co2\_tidy }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(month, co2, }\AttributeTok{color =}\NormalTok{ year)) }\SpecialCharTok{+} \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Si no se realiza el gráfico esperado, probablemente es porque \texttt{co2\_tidy\$month} no es numérico:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(co2\_tidy}\SpecialCharTok{$}\NormalTok{month)}
\end{Highlighting}
\end{Shaded}

Reescriba el código y que asegúrese que la columna de mes será numérica. Luego haga el gráfico

3. ¿Qué aprendemos de este gráfico?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Las medidas de CO2 aumentan monotónicamente de 1959 a 1997.
\item
  Las medidas de CO2 son más altas en el verano y el promedio anual aumentó de 1959 a 1997.
\item
  Las medidas de CO2 parecen constantes y la variabilidad aleatoria explica las diferencias.
\item
  Las medidas de CO2 no tienen una tendencia estacional.
\end{enumerate}

4. Ahora cargue el set de datos \texttt{admissions}, que contiene información de admisión para hombres y mujeres en seis concentraciones y mantenga solo la columna de porcentaje admitido:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(admissions)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ admissions }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{applicants)}
\end{Highlighting}
\end{Shaded}

Si pensamos en una observación como una concentración, y que cada observación tiene dos variables (porcentaje de hombres admitidos y porcentaje de mujeres admitidas), entonces esto no es \emph{tidy}. Utilice la función \texttt{pivot\_wider} para \emph{wrangle} en la forma \emph{tidy} que queremos: una fila para cada concentración.

5. Ahora intentaremos un reto más avanzado de \emph{wrangling}. Queremos \emph{wrangle} los datos de admisión para cada concentración para tener 4 observaciones: \texttt{admitted\_men}, \texttt{admitted\_women}, \texttt{applicants\_men} y \texttt{applicants\_women}. El ``truco'' que hacemos aquí es realmente bastante común: primero usamos \texttt{pivot\_longer} para generar un \emph{data frame} intermedio y luego usamos \texttt{pivot\_wider} para obtener los datos \emph{tidy} que queremos. Iremos paso a paso en este y en los próximos dos ejercicios.

Utilice la función \texttt{pivot\_longer} para crear un \emph{data frame} \texttt{tmp} con una columna que contiene el tipo de observación \texttt{admitted} o \texttt{applicants}. Nombre a las nuevas columnas \texttt{name} y \texttt{value}.

6. Ahora tiene un objeto \texttt{tmp} con columnas \texttt{major}, \texttt{gender}, \texttt{name} y \texttt{value}. Tenga en cuenta que si combina \texttt{name} y \texttt{gender}, se obtienen los nombres de columna que queremos: \texttt{admitted\_men}, \texttt{admitted\_women}, \texttt{applicants\_men} y \texttt{applicants\_women}. Use la función \texttt{unite} para crear una nueva columna llamada \texttt{column\_name}.

7. Ahora use la función \texttt{pivot\_wider} para generar los datos \emph{tidy} con cuatro variables para cada concentración.

8. Ahora use el \emph{pipe} para escribir una línea de código que convierta \texttt{admissions} en la tabla producida en el ejercicio anterior.

\hypertarget{unir-tablas}{%
\chapter{Unir tablas}\label{unir-tablas}}

Es posible que la información que necesitamos para un análisis no esté en solo en una tabla. Por ejemplo, cuando pronosticamos elecciones usamos la función \texttt{left\_join} para combinar la información de dos tablas. Aquí usamos un ejemplo más sencillo para ilustrar el desafío general de combinar tablas.

Supongan que queremos explorar la relación entre el tamaño de la población de los estados de EE. UU. y los votos electorales. Tenemos el tamaño de la población en esta tabla:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\FunctionTok{head}\NormalTok{(murders)}
\CommentTok{\#\textgreater{}        state abb region population total}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65}
\end{Highlighting}
\end{Shaded}

y los votos electorales en esta:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(polls\_us\_election\_2016)}
\FunctionTok{head}\NormalTok{(results\_us\_election\_2016)}
\CommentTok{\#\textgreater{}          state electoral\_votes clinton trump others}
\CommentTok{\#\textgreater{} 1   California              55    61.7  31.6    6.7}
\CommentTok{\#\textgreater{} 2        Texas              38    43.2  52.2    4.5}
\CommentTok{\#\textgreater{} 3      Florida              29    47.8  49.0    3.2}
\CommentTok{\#\textgreater{} 4     New York              29    59.0  36.5    4.5}
\CommentTok{\#\textgreater{} 5     Illinois              20    55.8  38.8    5.4}
\CommentTok{\#\textgreater{} 6 Pennsylvania              20    47.9  48.6    3.6}
\end{Highlighting}
\end{Shaded}

Simplemente concatenar estas dos tablas no funcionará ya que el orden de los estados no es el mismo.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{identical}\NormalTok{(results\_us\_election\_2016}\SpecialCharTok{$}\NormalTok{state, murders}\SpecialCharTok{$}\NormalTok{state)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

Las funciones que usamos para unir (\emph{join} en inglés), descritas a continuación, están diseñadas para manejar este desafío.

\hypertarget{joins}{%
\section{Funciones para unir}\label{joins}}

Las funciones para unir del paquete \textbf{dplyr} aseguran que las tablas se combinen de tal forma que las filas equivalentes estén juntas. Si conocen SQL, verán que el acercamiento y la sintaxis son muy similares. La idea general es que uno necesita identificar una o más columnas que servirán para emparejar las dos tablas. Entonces se devuelve una nueva tabla con la información combinada. Observen lo que sucede si unimos las dos tablas anteriores por estado usando \texttt{left\_join} (eliminaremos la columna \texttt{others} y renombraremos \texttt{electoral\_votes} para que las tablas quepen en la página):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{left\_join}\NormalTok{(murders, results\_us\_election\_2016, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{others) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{rename}\NormalTok{(}\AttributeTok{ev =}\NormalTok{ electoral\_votes)}
\FunctionTok{head}\NormalTok{(tab)}
\CommentTok{\#\textgreater{}        state abb region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135  9    34.4  62.1}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19  3    36.6  51.3}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232 11    45.1  48.7}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93  6    33.7  60.6}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257 55    61.7  31.6}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65  9    48.2  43.3}
\end{Highlighting}
\end{Shaded}

Los datos se han unido exitosamente y ahora podemos, por ejemplo, hacer un diagrama para explorar la relación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggrepel)}
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(population}\SpecialCharTok{/}\DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}\NormalTok{, ev, }\AttributeTok{label =}\NormalTok{ abb)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_text\_repel}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_x\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{trans =} \StringTok{"log2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{, }\AttributeTok{se =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ev-vs-population-1} \end{center}

Vemos que la relación es casi lineal con aproximadamente dos votos electorales para cada millón de personas, pero con estados muy pequeños obteniendo proporciones más altas.

En la práctica, no siempre ocurre que cada fila de una tabla tiene una fila correspondiente en la otra. Por esta razón, tenemos varias versiones de \emph{join}. Para ilustrar este reto, tomaremos subconjuntos de las tablas anteriores. Creamos las tablas \texttt{tab1} y \texttt{tab2} para que tengan algunos estados en común pero no todos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}} \FunctionTok{slice}\NormalTok{(murders, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(state, population)}
\NormalTok{tab\_1}
\CommentTok{\#\textgreater{}        state population}
\CommentTok{\#\textgreater{} 1    Alabama    4779736}
\CommentTok{\#\textgreater{} 2     Alaska     710231}
\CommentTok{\#\textgreater{} 3    Arizona    6392017}
\CommentTok{\#\textgreater{} 4   Arkansas    2915918}
\CommentTok{\#\textgreater{} 5 California   37253956}
\CommentTok{\#\textgreater{} 6   Colorado    5029196}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ results\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(state}\SpecialCharTok{\%in\%}\FunctionTok{c}\NormalTok{(}\StringTok{"Alabama"}\NormalTok{, }\StringTok{"Alaska"}\NormalTok{, }\StringTok{"Arizona"}\NormalTok{,}
                    \StringTok{"California"}\NormalTok{, }\StringTok{"Connecticut"}\NormalTok{, }\StringTok{"Delaware"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(state, electoral\_votes) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{rename}\NormalTok{(}\AttributeTok{ev =}\NormalTok{ electoral\_votes)}
\NormalTok{tab\_2}
\CommentTok{\#\textgreater{}         state ev}
\CommentTok{\#\textgreater{} 1  California 55}
\CommentTok{\#\textgreater{} 2     Arizona 11}
\CommentTok{\#\textgreater{} 3     Alabama  9}
\CommentTok{\#\textgreater{} 4 Connecticut  7}
\CommentTok{\#\textgreater{} 5      Alaska  3}
\CommentTok{\#\textgreater{} 6    Delaware  3}
\end{Highlighting}
\end{Shaded}

Utilizaremos estas dos tablas como ejemplos en las siguientes secciones.

\hypertarget{left-join}{%
\subsection{Left join}\label{left-join}}

Supongan que queremos una tabla como \texttt{tab\_1}, pero agregando votos electorales a cualquier estado que tengamos disponible. Para esto, usamos \texttt{left\_join} con \texttt{tab\_1} como el primer argumento. Especificamos qué columna usar para que coincida con el argumento \texttt{by}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{left\_join}\NormalTok{(tab\_1, tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}        state population ev}
\CommentTok{\#\textgreater{} 1    Alabama    4779736  9}
\CommentTok{\#\textgreater{} 2     Alaska     710231  3}
\CommentTok{\#\textgreater{} 3    Arizona    6392017 11}
\CommentTok{\#\textgreater{} 4   Arkansas    2915918 NA}
\CommentTok{\#\textgreater{} 5 California   37253956 55}
\CommentTok{\#\textgreater{} 6   Colorado    5029196 NA}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que \texttt{NA}s se agregan a los dos estados que no aparecen en \texttt{tab\_2}. Además, observen que esta función, así como todas las otras \emph{joins}, pueden recibir los primeros argumentos a través del \emph{pipe}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{left\_join}\NormalTok{(tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{right-join}{%
\subsection{Right join}\label{right-join}}

Si en lugar de una tabla con las mismas filas que la primera tabla, queremos una con las mismas filas que la segunda tabla, podemos usar \texttt{right\_join}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{right\_join}\NormalTok{(tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}         state population ev}
\CommentTok{\#\textgreater{} 1     Alabama    4779736  9}
\CommentTok{\#\textgreater{} 2      Alaska     710231  3}
\CommentTok{\#\textgreater{} 3     Arizona    6392017 11}
\CommentTok{\#\textgreater{} 4  California   37253956 55}
\CommentTok{\#\textgreater{} 5 Connecticut         NA  7}
\CommentTok{\#\textgreater{} 6    Delaware         NA  3}
\end{Highlighting}
\end{Shaded}

Ahora los \texttt{NA}s están en la columna de \texttt{tab\_1}.

\hypertarget{inner-join}{%
\subsection{Inner join}\label{inner-join}}

Si queremos mantener solo las filas que tienen información en ambas tablas, usamos \texttt{inner\_join}. Pueden pensar en esto como una intersección:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{inner\_join}\NormalTok{(tab\_1, tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}        state population ev}
\CommentTok{\#\textgreater{} 1    Alabama    4779736  9}
\CommentTok{\#\textgreater{} 2     Alaska     710231  3}
\CommentTok{\#\textgreater{} 3    Arizona    6392017 11}
\CommentTok{\#\textgreater{} 4 California   37253956 55}
\end{Highlighting}
\end{Shaded}

\hypertarget{full-join}{%
\subsection{Full join}\label{full-join}}

Si queremos mantener todas las filas y llenar las partes faltantes con \texttt{NA}s, podemos usar \texttt{full\_join}. Pueden pensar en esto como una unión:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{full\_join}\NormalTok{(tab\_1, tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}         state population ev}
\CommentTok{\#\textgreater{} 1     Alabama    4779736  9}
\CommentTok{\#\textgreater{} 2      Alaska     710231  3}
\CommentTok{\#\textgreater{} 3     Arizona    6392017 11}
\CommentTok{\#\textgreater{} 4    Arkansas    2915918 NA}
\CommentTok{\#\textgreater{} 5  California   37253956 55}
\CommentTok{\#\textgreater{} 6    Colorado    5029196 NA}
\CommentTok{\#\textgreater{} 7 Connecticut         NA  7}
\CommentTok{\#\textgreater{} 8    Delaware         NA  3}
\end{Highlighting}
\end{Shaded}

\hypertarget{semi-join}{%
\subsection{Semi join}\label{semi-join}}

La función \texttt{semi\_join} nos permite mantener la parte de la primera tabla para la cual tenemos información en la segunda. No agrega las columnas de la segunda:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{semi\_join}\NormalTok{(tab\_1, tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}        state population}
\CommentTok{\#\textgreater{} 1    Alabama    4779736}
\CommentTok{\#\textgreater{} 2     Alaska     710231}
\CommentTok{\#\textgreater{} 3    Arizona    6392017}
\CommentTok{\#\textgreater{} 4 California   37253956}
\end{Highlighting}
\end{Shaded}

\hypertarget{anti-join}{%
\subsection{Anti join}\label{anti-join}}

La función \texttt{anti\_join} es la opuesta de \texttt{semi\_join}. Mantiene los elementos de la primera tabla para los que no hay información en la segunda:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{anti\_join}\NormalTok{(tab\_1, tab\_2, }\AttributeTok{by =} \StringTok{"state"}\NormalTok{)}
\CommentTok{\#\textgreater{}      state population}
\CommentTok{\#\textgreater{} 1 Arkansas    2915918}
\CommentTok{\#\textgreater{} 2 Colorado    5029196}
\end{Highlighting}
\end{Shaded}

El siguiente diagrama resume las funciones \emph{join}:

\begin{center}\includegraphics[width=0.4\linewidth]{wrangling/img/joins} \end{center}

(Imagen cortesía de RStudio\footnote{\url{https://github.com/rstudio/cheatsheets}}. Licencia CC-BY-4.0\footnote{\url{https://github.com/rstudio/cheatsheets/blob/master/LICENSE}}. Recortada del original.)

\hypertarget{binding}{%
\section{Binding}\label{binding}}

Aunque todavía no lo hemos usado en este libro, otra forma común en la que se combinan los sets de datos es \emph{pegándolos} (\emph{binding} en inglés). A diferencia de las funciones \emph{join}, las funciones \emph{binding} no intentan coincidir con una variable, sino que simplemente combinan sets de datos. Si los sets de datos no coinciden con las dimensiones apropiadas, se obtiene un error.

\hypertarget{pegando-columnas}{%
\subsection{Pegando columnas}\label{pegando-columnas}}

La función \texttt{bind\_cols} de \textbf{dplyr} pega dos objetos convirtiéndolos en columnas en un \emph{tibble}. Por ejemplo, queremos crear rápidamente un \emph{data frame} que consiste de números que podemos usar.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bind\_cols}\NormalTok{(}\AttributeTok{a =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\AttributeTok{b =} \DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 2}
\CommentTok{\#\textgreater{}       a     b}
\CommentTok{\#\textgreater{}   \textless{}int\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     4}
\CommentTok{\#\textgreater{} 2     2     5}
\CommentTok{\#\textgreater{} 3     3     6}
\end{Highlighting}
\end{Shaded}

Esta función requiere que asignemos nombres a las columnas. Aquí elegimos \texttt{a} y \texttt{b}.

Noten que hay una función de R, \texttt{cbind}, con exactamente la misma funcionalidad. Una diferencia importante es que \texttt{cbind} puede crear diferentes tipos de objetos, mientras \texttt{bind\_cols} siempre produce un \emph{data frame}.

\texttt{bind\_cols} también puede pegar dos \emph{data frames} diferentes. Por ejemplo, aquí separamos el \emph{data frame} \texttt{tab} en tres \emph{data frames} y luego volvemos a pegarlos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[, }\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{]}
\NormalTok{tab\_3 }\OtherTok{\textless{}{-}}\NormalTok{ tab[, }\DecValTok{7}\SpecialCharTok{:}\DecValTok{8}\NormalTok{]}
\NormalTok{new\_tab }\OtherTok{\textless{}{-}} \FunctionTok{bind\_cols}\NormalTok{(tab\_1, tab\_2, tab\_3)}
\FunctionTok{head}\NormalTok{(new\_tab)}
\CommentTok{\#\textgreater{}        state abb region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1    Alabama  AL  South    4779736   135  9    34.4  62.1}
\CommentTok{\#\textgreater{} 2     Alaska  AK   West     710231    19  3    36.6  51.3}
\CommentTok{\#\textgreater{} 3    Arizona  AZ   West    6392017   232 11    45.1  48.7}
\CommentTok{\#\textgreater{} 4   Arkansas  AR  South    2915918    93  6    33.7  60.6}
\CommentTok{\#\textgreater{} 5 California  CA   West   37253956  1257 55    61.7  31.6}
\CommentTok{\#\textgreater{} 6   Colorado  CO   West    5029196    65  9    48.2  43.3}
\end{Highlighting}
\end{Shaded}

\hypertarget{pegando-filas}{%
\subsection{Pegando filas}\label{pegando-filas}}

La función \texttt{bind\_rows} es similar a \texttt{bind\_cols}, pero pega filas en lugar de columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{,]}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{4}\NormalTok{,]}
\FunctionTok{bind\_rows}\NormalTok{(tab\_1, tab\_2)}
\CommentTok{\#\textgreater{}      state abb region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1  Alabama  AL  South    4779736   135  9    34.4  62.1}
\CommentTok{\#\textgreater{} 2   Alaska  AK   West     710231    19  3    36.6  51.3}
\CommentTok{\#\textgreater{} 3  Arizona  AZ   West    6392017   232 11    45.1  48.7}
\CommentTok{\#\textgreater{} 4 Arkansas  AR  South    2915918    93  6    33.7  60.6}
\end{Highlighting}
\end{Shaded}

Esto se basa en la función \texttt{rbind} de R.

\hypertarget{operadores-de-sets}{%
\section{Operadores de sets}\label{operadores-de-sets}}

Otro conjunto de comandos útiles para combinar sets de datos son los operadores de sets. Cuando se aplican a los vectores, estos se comportan como lo sugieren sus nombres. Ejemplos son \texttt{intersect}, \texttt{union}, \texttt{setdiff} y \texttt{setequal}. Sin embargo, si se carga el \textbf{tidyverse}, o más específicamente \textbf{dplyr}, estas funciones se pueden usar en \emph{data frames} en lugar de solo en vectores.

\hypertarget{intersecar}{%
\subsection{Intersecar}\label{intersecar}}

Pueden tomar intersecciones de vectores de cualquier tipo, como numéricos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{intersect}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{6}\SpecialCharTok{:}\DecValTok{15}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

o caracteres:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{intersect}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\StringTok{"b"}\NormalTok{,}\StringTok{"c"}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{,}\StringTok{"c"}\NormalTok{,}\StringTok{"d"}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] "b" "c"}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{dplyr} incluye una función \texttt{intersect} que se puede aplicar a tablas con los mismos nombres de columna. Esta función devuelve las filas en común entre dos tablas. Para asegurarnos de que usamos la versión de \textbf{dplyr} de \texttt{intersect} en lugar de la versión del paquete base, podemos usar \texttt{dplyr::intersect} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,]}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{7}\NormalTok{,]}
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{intersect}\NormalTok{(tab\_1, tab\_2)}
\CommentTok{\#\textgreater{}        state abb region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1    Arizona  AZ   West    6392017   232 11    45.1  48.7}
\CommentTok{\#\textgreater{} 2   Arkansas  AR  South    2915918    93  6    33.7  60.6}
\CommentTok{\#\textgreater{} 3 California  CA   West   37253956  1257 55    61.7  31.6}
\end{Highlighting}
\end{Shaded}

\hypertarget{uniuxf3n}{%
\subsection{Unión}\label{uniuxf3n}}

Del mismo modo, \texttt{union} toma la unión de vectores. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{union}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{6}\SpecialCharTok{:}\DecValTok{15}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15}
\FunctionTok{union}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\StringTok{"b"}\NormalTok{,}\StringTok{"c"}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{,}\StringTok{"c"}\NormalTok{,}\StringTok{"d"}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] "a" "b" "c" "d"}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{dplyr} incluye una versión de \texttt{union} que combina todas las filas de dos tablas con los mismos nombres de columna.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,]}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{7}\NormalTok{,]}
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{union}\NormalTok{(tab\_1, tab\_2)}
\CommentTok{\#\textgreater{}         state abb    region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1     Alabama  AL     South    4779736   135  9    34.4  62.1}
\CommentTok{\#\textgreater{} 2      Alaska  AK      West     710231    19  3    36.6  51.3}
\CommentTok{\#\textgreater{} 3     Arizona  AZ      West    6392017   232 11    45.1  48.7}
\CommentTok{\#\textgreater{} 4    Arkansas  AR     South    2915918    93  6    33.7  60.6}
\CommentTok{\#\textgreater{} 5  California  CA      West   37253956  1257 55    61.7  31.6}
\CommentTok{\#\textgreater{} 6    Colorado  CO      West    5029196    65  9    48.2  43.3}
\CommentTok{\#\textgreater{} 7 Connecticut  CT Northeast    3574097    97  7    54.6  40.9}
\end{Highlighting}
\end{Shaded}

\hypertarget{setdiff}{%
\subsection{\texorpdfstring{\texttt{setdiff}}{setdiff}}\label{setdiff}}

La diferencia establecida entre un primer y un segundo argumento se puede obtener con \texttt{setdiff}. A diferencia de \texttt{intersect} y \texttt{union}, esta función no es simétrica:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{6}\SpecialCharTok{:}\DecValTok{15}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5}
\FunctionTok{setdiff}\NormalTok{(}\DecValTok{6}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 11 12 13 14 15}
\end{Highlighting}
\end{Shaded}

Al igual que con las funciones que se muestran arriba, \textbf{dplyr} tiene una versión para \emph{data frames}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,]}
\NormalTok{tab\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{7}\NormalTok{,]}
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{setdiff}\NormalTok{(tab\_1, tab\_2)}
\CommentTok{\#\textgreater{}     state abb region population total ev clinton trump}
\CommentTok{\#\textgreater{} 1 Alabama  AL  South    4779736   135  9    34.4  62.1}
\CommentTok{\#\textgreater{} 2  Alaska  AK   West     710231    19  3    36.6  51.3}
\end{Highlighting}
\end{Shaded}

\hypertarget{setequal}{%
\subsection{\texorpdfstring{\texttt{setequal}}{setequal}}\label{setequal}}

Finalmente, la función \texttt{setequal} nos dice si dos sets son iguales, independientemente del orden. Noten que:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setequal}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

pero:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setequal}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{5}\SpecialCharTok{:}\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

Cuando se aplica a \emph{data frames} que no son iguales, independientemente del orden, la versión \textbf{dplyr} ofrece un mensaje útil que nos permite saber cómo los sets son diferentes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\SpecialCharTok{::}\FunctionTok{setequal}\NormalTok{(tab\_1, tab\_2)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-39}{%
\section{Ejercicios}\label{ejercicios-39}}

1. Instale y cargue la biblioteca \textbf{Lahman}. Esta base de datos incluye datos relacionados a equipos de béisbol. Incluya estadísticas sobre cómo se desempeñaron los jugadores ofensiva y defensivamente durante varios años. También incluye información personal sobre los jugadores.

El \emph{data frame} \texttt{Batting} contiene las estadísticas ofensivas de todos los jugadores durante muchos años. Puede ver, por ejemplo, los 10 mejores bateadores ejecutando este código:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(Lahman)}

\NormalTok{top }\OtherTok{\textless{}{-}}\NormalTok{ Batting }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(yearID }\SpecialCharTok{==} \DecValTok{2016}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(HR)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}

\NormalTok{top }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

¿Pero quiénes son estos jugadores? Vemos una identificación, pero no los nombres. Los nombres de los jugadores están en esta tabla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Master }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Podemos ver los nombres de las columnas \texttt{nameFirst} y \texttt{nameLast}. Utilice la función \texttt{left\_join} para crear una tabla de los mejores bateadores de cuadrangulares. La tabla debe tener \texttt{playerID}, nombre, apellido y número de cuandrangulares (HR). Reescriba el objeto \texttt{top} con esta nueva tabla.

2. Ahora use el \emph{data frame} \texttt{Salaries} para añadir el salario de cada jugador a la tabla que creó en el ejercicio 1. Note que los salarios son diferentes cada año, así que asegúrese de filtrar para el año 2016, luego use \texttt{right\_join}. Esta vez muestre el nombre, apellido, equipo, HR y salario.

3. En un ejercicio anterior, creamos una versión ordenada del set de datos \texttt{co2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{co2\_wide }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(co2, }\AttributeTok{ncol =} \DecValTok{12}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{12}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{year =} \DecValTok{1959}\SpecialCharTok{:}\DecValTok{1997}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{year, }\AttributeTok{names\_to =} \StringTok{"month"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"co2"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =} \FunctionTok{as.numeric}\NormalTok{(month))}
\end{Highlighting}
\end{Shaded}

Queremos ver si la tendencia mensual está cambiando, por lo que eliminaremos los efectos del año y luego graficaremos los resultados. Primero, calcularemos los promedios del año. Utilice \texttt{group\_by} y \texttt{summarize} para calcular el CO2 promedio de cada año. Guárdelo en un objeto llamado \texttt{yearly\_avg}.

4. Ahora use la función \texttt{left\_join} para agregar el promedio anual al set de datos \texttt{co2\_wide}. Entonces calcule los residuos: medida de CO2 observada - promedio anual.

5. Haga un diagrama de las tendencias estacionales por año, pero solo después de eliminar el efecto del año.

\hypertarget{extracciuxf3n-de-la-web}{%
\chapter{Extracción de la web}\label{extracciuxf3n-de-la-web}}

Los datos que necesitamos para responder a una pregunta no siempre están en una hoja de cálculo lista para leer. Por ejemplo, el set de datos sobre asesinatos de EE.UU. que utilizamos en el Capítulo ``Lo básico de R'' proviene originalmente de esta página de Wikipedia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"https://en.wikipedia.org/w/index.php?title="}\NormalTok{,}
              \StringTok{"Gun\_violence\_in\_the\_United\_States\_by\_state"}\NormalTok{,}
              \StringTok{"\&direction=prev\&oldid=810166167"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pueden ver la tabla de datos en la página web:

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//murders-data-wiki-page} \end{center}

(Página web cortesía de Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=Gun_violence_in_the_United_States_by_state\&direction=prev\&oldid=810166167}}. Licencia CC-BY-SA-3.0)\footnote{\url{https://en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License}}.

Desafortunadamente, no hay un enlace a un archivo de datos. Para crear el \emph{data frame} que se carga cuando escribimos \texttt{data(murders)}, tuvimos que hacer un poco de \emph{extracción de la web} (\emph{web scraping} o \emph{web harvesting} en inglés).

\emph{Extracción de la web} es el término que se usa para describir el proceso de extracción de datos de un sitio web. La razón por la que podemos hacer esto es porque la información utilizada por un navegador para representar páginas web se recibe como un archivo de texto de un servidor. El texto es un código escrito en lenguaje de marcado de hipertexto (\emph{hyper text markup language} o HTML por sus siglas en inglés). Todos los navegadores tienen una manera de mostrar el código HTML de una página, cada uno diferente. En Chrome, pueden usar Control-U en una PC y comando + alt + U en una Mac. Verán algo como esto:

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//html-code} \end{center}

\hypertarget{html}{%
\section{HTML}\label{html}}

Debido a que este código es accesible, podemos descargar el archivo HTML, importarlo a R y luego escribir programas para extraer la información que necesitamos de la página. Sin embargo, al ver el código HTML, esto puede parecer una tarea desalentadora. Pero le mostraremos algunas herramientas convenientes para facilitar el proceso. Para tener una idea de cómo funciona, aquí hay unas líneas de código de la página de Wikipedia que proveen los datos de asesinatos en Estados Unidos:

\begin{verbatim}
<table class="wikitable sortable">
<tr>
<th>State</th>
<th><a href="/wiki/List_of_U.S._states_and_territories_by_population"
title="List of U.S. states and territories by population">Population</a><br/>
<small>(total inhabitants)</small><br/>
<small>(2015)</small> <sup id="cite_ref-1" class="reference">
<a href="#cite_note-1">[1]</a></sup></th>
<th>Murders and Nonnegligent
<p>Manslaughter<br/>
<small>(total deaths)</small><br/>
<small>(2015)</small> <sup id="cite_ref-2" class="reference">
<a href="#cite_note-2">[2]</a></sup></p>
</th>
<th>Murder and Nonnegligent
<p>Manslaughter Rate<br/>
<small>(per 100,000 inhabitants)</small><br/>
<small>(2015)</small></p>
</th>
</tr>
<tr>
<td><a href="/wiki/Alabama" title="Alabama">Alabama</a></td>
<td>4,853,875</td>
<td>348</td>
<td>7.2</td>
</tr>
<tr>
<td><a href="/wiki/Alaska" title="Alaska">Alaska</a></td>
<td>737,709</td>
<td>59</td>
<td>8.0</td>
</tr>
<tr>
\end{verbatim}

Pueden ver los datos, excepto que los valores de datos están rodeados por un código HTML como \texttt{\textless{}td\textgreater{}}. También podemos ver un patrón de cómo se almacenan. Si conocen HTML, pueden escribir programas que aprovechan el conocimiento de estos patrones para extraer lo que queremos. Además, nos aprovechamos de \emph{Cascading Style Sheets} (CSS), un lenguaje ampliamente utilizado para hacer que las páginas web se vean ``bonitas''. Discutimos más sobre esto en la Sección \ref{css-selectors}.

Aunque ofrecemos herramientas que permiten extraer datos sin conocer HTML, como científicos de datos es bastante útil aprender algo de HTML y CSS. Esto no solo mejora sus habilidades de extracción, sino que puede ser útil si están creando una página web para exhibir su trabajo. Hay muchos cursos y tutoriales en línea para aprenderlos, como Codeacademy\footnote{\url{https://www.codecademy.com/learn/learn-html}} y W3schools\footnote{\url{https://www.w3schools.com/}}.

\hypertarget{el-paquete-rvest}{%
\section{\texorpdfstring{El paquete \textbf{rvest}}{El paquete rvest}}\label{el-paquete-rvest}}

El \textbf{tidyverse} provee un paquete de extracción de la web llamado \textbf{rvest}. El primer paso para usar este paquete es importar la página web a R. El paquete lo hace bastante fácil:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(rvest)}
\NormalTok{h }\OtherTok{\textless{}{-}} \FunctionTok{read\_html}\NormalTok{(url)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que la página entera de Wikipedia \emph{Gun violence in the United States} ahora está contenida en \texttt{h}. La clase de este objeto es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(h)}
\CommentTok{\#\textgreater{} [1] "xml\_document" "xml\_node"}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{rvest} es más general; maneja documentos XML. XML es un lenguaje de marcado general (ML siendo las iniciales de \emph{markup language}) que se puede usar para representar cualquier tipo de datos. HTML es un tipo específico de XML desarrollado específicamente para representar páginas web. Aquí nos concentramos en documentos HTML.

Ahora, ¿cómo extraemos la tabla del objeto \texttt{h}? Si imprimimos \texttt{h}, realmente no vemos mucho:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h}
\CommentTok{\#\textgreater{} \{html\_document\}}
\CommentTok{\#\textgreater{} \textless{}html class="client{-}nojs" lang="en" dir="ltr"\textgreater{}}
\CommentTok{\#\textgreater{} [1] \textless{}head\textgreater{}\textbackslash{}n\textless{}meta http{-}equiv="Content{-}Type" content="text/html; chars ...}
\CommentTok{\#\textgreater{} [2] \textless{}body class="mediawiki ltr sitedir{-}ltr mw{-}hide{-}empty{-}elt ns{-}0 ns{-} ...}
\end{Highlighting}
\end{Shaded}

Podemos ver todo el código que define la página web descargada usando la función \texttt{html\_text} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{html\_text}\NormalTok{(h)}
\end{Highlighting}
\end{Shaded}

No mostramos el \emph{output} aquí porque incluye miles de caracteres, pero si lo miramos, podemos ver que los datos que buscamos se almacenan en una tabla HTML. Pueden ver esto en esta línea del código HTML anterior: \texttt{\textless{}table\ class="wikitable\ sortable"\textgreater{}}. Las diferentes partes de un documento HTML, a menudo definidas con un mensaje entre \texttt{\textless{}} y \texttt{\textgreater{}}, se conocen como \emph{nodos} (\emph{nodes} en inglés). El paquete \textbf{rvest} incluye funciones para extraer nodos de un documento HTML: \texttt{html\_nodes} extrae todos los nodos de diferentes tipos y \texttt{html\_node} extrae el primero. Para extraer las tablas del código HTML usamos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}}\NormalTok{ h }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{html\_nodes}\NormalTok{(}\StringTok{"table"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora, en lugar de toda la página web, solo tenemos el código HTML para las tablas de la página:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab}
\CommentTok{\#\textgreater{} \{xml\_nodeset (2)\}}
\CommentTok{\#\textgreater{} [1] \textless{}table class="wikitable sortable"\textgreater{}\textless{}tbody\textgreater{}\textbackslash{}n\textless{}tr\textgreater{}\textbackslash{}n\textless{}th\textgreater{}State\textbackslash{}n\textless{}/th\textgreater{} ...}
\CommentTok{\#\textgreater{} [2] \textless{}table class="nowraplinks hlist mw{-}collapsible mw{-}collapsed navbo ...}
\end{Highlighting}
\end{Shaded}

La tabla que nos interesa es la primera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{\#\textgreater{} \{html\_node\}}
\CommentTok{\#\textgreater{} \textless{}table class="wikitable sortable"\textgreater{}}
\CommentTok{\#\textgreater{} [1] \textless{}tbody\textgreater{}\textbackslash{}n\textless{}tr\textgreater{}\textbackslash{}n\textless{}th\textgreater{}State\textbackslash{}n\textless{}/th\textgreater{}\textbackslash{}n\textless{}th\textgreater{}\textbackslash{}n\textless{}a href="/wiki/List\_of\_U.S ...}
\end{Highlighting}
\end{Shaded}

Esto claramente no es un set de datos \emph{tidy}, ni siquiera un \emph{data frame}. En el código anterior, podemos ver un patrón y es muy factible escribir código para extraer solo los datos. De hecho, \textbf{rvest} incluye una función solo para convertir tablas HTML en \emph{data frames}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}}\NormalTok{ tab[[}\DecValTok{1}\NormalTok{]] }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ html\_table}
\FunctionTok{class}\NormalTok{(tab)}
\CommentTok{\#\textgreater{} [1] "tbl\_df"     "tbl"        "data.frame"}
\end{Highlighting}
\end{Shaded}

Ahora estamos mucho más cerca de tener una tabla de datos utilizables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}}\NormalTok{ tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"state"}\NormalTok{, }\StringTok{"population"}\NormalTok{, }\StringTok{"total"}\NormalTok{, }\StringTok{"murder\_rate"}\NormalTok{))}
\FunctionTok{head}\NormalTok{(tab)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 4}
\CommentTok{\#\textgreater{}   state      population total murder\_rate}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}      \textless{}chr\textgreater{}      \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Alabama    4,853,875  348           7.2}
\CommentTok{\#\textgreater{} 2 Alaska     737,709    59            8  }
\CommentTok{\#\textgreater{} 3 Arizona    6,817,565  309           4.5}
\CommentTok{\#\textgreater{} 4 Arkansas   2,977,853  181           6.1}
\CommentTok{\#\textgreater{} 5 California 38,993,940 1,861         4.8}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

Todavía tenemos que hacer un poco de \emph{wrangling}. Por ejemplo, necesitamos eliminar las comas y convertir los caracteres en números. Antes de continuar con esto, aprenderemos un acercamiento más general para extraer información de sitios web.

\hypertarget{css-selectors}{%
\section{Selectores CSS}\label{css-selectors}}

El aspecto por defecto de una página web hecha con el HTML más básico es poco atractivo. Las páginas estéticamente agradables que vemos hoy usan CSS para definir su aspecto y estilo. El hecho de que todas las páginas de una empresa tienen el mismo estilo generalmente resulta del uso del mismo archivo CSS para definir el estilo. La forma general en que funcionan estos archivos CSS es determinando cómo se verá cada uno de los elementos de una página web. El título, los encabezados, las listas detalladas, las tablas y los enlaces, por ejemplo, reciben cada uno su propio estilo, que incluye la fuente, el color, el tamaño y la distancia del margen. CSS hace esto aprovechando los patrones utilizados para definir estos elementos, denominados \emph{selectores}. Un ejemplo de dicho patrón, que utilizamos anteriormente, es \texttt{table}, pero hay muchos más.

Si queremos obtener datos de una página web y conocemos un selector que es único para la parte de la página que contiene estos datos, podemos usar la función \texttt{html\_nodes}. Sin embargo, saber qué selector puede ser bastante complicado.
De hecho, la complejidad de las páginas web ha aumentado a medida que se vuelven más sofisticadas. Para algunas de las más avanzadas, parece casi imposible encontrar los nodos que definen un dato en particular. Sin embargo, SelectorGadget lo hace posible.

SelectorGadget\footnote{\url{http://selectorgadget.com/}} es un software que les permite determinar de manera interactiva qué selector CSS necesita para extraer componentes específicos de la página web. Si van a extraer datos que no son tablas de páginas HTML, les recomendamos que lo instalen. Chrome tiene una extensión que les permite encender el \emph{gadget} y luego, al hacer clic en la página, resalta partes y les muestra el selector que necesitan para extraer estas partes. Hay varias demostraciones de cómo hacer esto, incluyendo este artículo de \textbf{rvest}\footnote{\url{https://rvest.tidyverse.org/articles/selectorgadget.html}} y otros tutoriales basados en esa vignette\footnote{\url{https://stat4701.github.io/edav/2015/04/02/rvest_tutorial/}} \footnote{\url{https://www.analyticsvidhya.com/blog/2017/03/beginners-guide-on-web-scraping-in-r-using-rvest-with-hands-on-knowledge/}}.

\hypertarget{json}{%
\section{JSON}\label{json}}

Compartir datos en Internet se ha vuelto cada vez más común. Desafortunadamente, los proveedores usan diferentes formatos, lo que añade dificultad para los científicos de datos reorganizar los datos en R. Sin embargo, hay algunos estándares que también se están volviendo más comunes. Actualmente, un formato que se está adoptando ampliamente es la Notación de Objetos JavaScript (\emph{JavaScript Object Notation} o JSON por sus siglas en inglés). Debido a que este formato es muy general, no se parece en nada a una hoja de cálculo. Este archivo JSON se parece más al código que usamos para definir una lista. Aquí un ejemplo de información almacenada en formato JSON:

\begin{verbatim}
#> 
#> Attaching package: 'jsonlite'
#> The following object is masked from 'package:purrr':
#> 
#>     flatten
#> [
#>   {
#>     "name": "Miguel",
#>     "student_id": 1,
#>     "exam_1": 85,
#>     "exam_2": 86
#>   },
#>   {
#>     "name": "Sofia",
#>     "student_id": 2,
#>     "exam_1": 94,
#>     "exam_2": 93
#>   },
#>   {
#>     "name": "Aya",
#>     "student_id": 3,
#>     "exam_1": 87,
#>     "exam_2": 88
#>   },
#>   {
#>     "name": "Cheng",
#>     "student_id": 4,
#>     "exam_1": 90,
#>     "exam_2": 91
#>   }
#> ]
\end{verbatim}

El archivo anterior representa un \emph{data frame}. Para leerlo, podemos usar la función \texttt{fromJSON} del paquete \textbf{jsonlite}. Noten que los archivos JSON a menudo están disponibles a través de Internet. Varias organizaciones proveen una API JSON o un servicio web al que pueden conectarse directamente y obtener datos. Aquí un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(jsonlite)}
\NormalTok{citi\_bike }\OtherTok{\textless{}{-}} \FunctionTok{fromJSON}\NormalTok{(}\StringTok{"http://citibikenyc.com/stations/json"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Esto descarga una lista. El primer argumento les dice cuando lo descargaron:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{citi\_bike}\SpecialCharTok{$}\NormalTok{executionTime}
\end{Highlighting}
\end{Shaded}

y el segundo es una tabla de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{citi\_bike}\SpecialCharTok{$}\NormalTok{stationBeanList }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Pueden aprender mucho más examinando tutoriales y archivos de ayuda del paquete \textbf{jsonlite}. Este paquete está destinado a tareas relativamente sencillas, como convertir datos en tablas. Para mayor flexibilidad, recomendamos \texttt{rjson}.

\hypertarget{ejercicios-40}{%
\section{Ejercicios}\label{ejercicios-40}}

1. Visite la siguiente página web:

\url{https://web.archive.org/web/20181024132313/http://www.stevetheump.com/Payrolls.htm}

Observe que hay varias tablas. Digamos que estamos interesados en comparar las nóminas de los equipos a lo largo de los años. Los siguientes ejercicios nos lleva por lo pasos necesarios para hacer esto.

Comience aplicando lo que aprendió e importe el sitio web a un objeto llamado \texttt{h}.

2. Tenga en cuenta que, aunque no es muy útil, podemos ver el contenido de la página escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{html\_text}\NormalTok{(h)}
\end{Highlighting}
\end{Shaded}

El siguiente paso es extraer las tablas. Para esto, podemos usar la función \texttt{html\_nodes}. Aprendimos que las tablas en HTML están asociadas con el nodo \texttt{table}. Utilice la función \texttt{html\_nodes} y el nodo \texttt{table} para extraer la primera tabla. Almacénela en un objeto \texttt{nodes}.

3. La función \texttt{html\_nodes} devuelve una lista de objetos de clase \texttt{xml\_node}. Podemos ver el contenido de cada uno usando, por ejemplo, la función \texttt{html\_text}. Puede ver el contenido de un componente elegido arbitrariamente así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{html\_text}\NormalTok{(nodes[[}\DecValTok{8}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

Si el contenido de este objeto es una tabla HTML, podemos usar la función \texttt{html\_table} para convertirlo en un \emph{data frame}. Utilice la función \texttt{html\_table} para convertir la octava entrada de \texttt{nodes} en una tabla.

4. Repita lo anterior para los primeros 4 componentes de \texttt{nodes}. ¿Cuáles de las siguientes son tablas de cálculo de nómina?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Todas.
\item
  1
\item
  2
\item
  2-4
\end{enumerate}

5. Repita lo anterior para los 3 \textbf{últimos} componentes de \texttt{nodes}. ¿Cuál de los siguientes es cierto?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  La última entrada en \texttt{nodes} muestra el promedio de todos los equipos a lo largo del tiempo, no la nómina por equipo.
\item
  Las tres son tablas de cálculo de nómina por equipo.
\item
  Las tres son como la primera entrada, no una tabla de cálculo de nómina.
\item
  Todas las anteriores.
\end{enumerate}

6. Hemos aprendido que la primera y la última entrada de \texttt{nodes} no son tablas de cálculo de nómina. Redefina \texttt{nodes} para que estas dos se eliminen.

7. Vimos en el análisis anterior que el primer nodo de la tabla realmente no es una tabla. Esto sucede a veces en HTML porque las tablas se usan para hacer que el texto se vea de cierta manera, en lugar de almacenar valores numéricos. Elimine el primer componente y luego use \texttt{sapply} y \texttt{html\_table} para convertir cada nodo en \texttt{nodes} en una tabla. Tenga en cuenta que en este caso \texttt{sapply} devolverá una lista de tablas. También puede usar \texttt{lapply} para asegurar que se aplique una lista.

8. Mire las tablas resultantes. ¿Son todas iguales? ¿Podríamos unirlas con \texttt{bind\_rows}?

9. Cree dos tablas utilizando las entradas 10 y 19. Llámelas \texttt{tab\_1} y \texttt{tab\_2}.

10. Utilice una función \texttt{full\_join} para combinar estas dos tablas. Antes de hacer esto, corrija el problema del encabezado que falta y haga que los nombres coincidan.

11. Después de unir las tablas, verá varias \texttt{NA}s. Esto se debe a que algunos equipos están en una tabla y no en la otra. Utilice la función \texttt{anti\_join} para tener una mejor idea de por qué sucede esto.

12. Vemos que uno de los problemas es que los Yankees figuran como \emph{N.Y. Yankees} y \emph{NY Yankees}. En la siguiente sección, aprenderemos enfoques eficientes para solucionar problemas como este. Aquí podemos hacerlo ``a mano'' de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab\_1 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{Team =} \FunctionTok{ifelse}\NormalTok{(Team }\SpecialCharTok{==} \StringTok{"N.Y. Yankees"}\NormalTok{, }\StringTok{"NY Yankees"}\NormalTok{, Team))}
\end{Highlighting}
\end{Shaded}

Ahora una las tablas y muestre solo Oakland y los Yankees y las columnas de cálculo de nómina.

13. \textbf{Avanzado}: Extraiga los títulos de las películas que ganaron el premio de \emph{Best Picture} de este sitio web: \url{https://m.imdb.com/chart/bestpicture/}

\hypertarget{procesamiento-de-cadenas}{%
\chapter{Procesamiento de cadenas}\label{procesamiento-de-cadenas}}

Uno de los desafíos más comunes del \emph{wrangling} de datos consiste en extraer datos numéricos contenidos en cadenas de caracteres y convertirlos en las representaciones numéricas requeridas para hacer gráficos, calcular resúmenes o ajustar modelos en R. También, es común tener que procesar texto no organizado y convertirlo en nombres de variables entendibles o variables categóricas. Muchos de los desafíos de procesamiento de cadenas que enfrentan los científicos de datos son únicos y a menudo inesperados. Por lo tanto, es bastante ambicioso escribir una sección completa sobre este tema. Aquí usamos una serie de estudios de casos que nos ayudan a demostrar cómo el procesamiento de cadenas es un paso necesario para muchos desafíos de disputas de datos. Específicamente, para los ejemplos \texttt{murders}, \texttt{heights} y \texttt{research\_funding\_rates}, describimos el proceso de convertir los datos sin procesar originales, que aún no hemos mostrados, en los \emph{data frames} que hemos estudiado en este libro.

Al repasar estos estudios de caso, cubriremos algunas de las tareas más comunes en el procesamiento de cadenas, incluyendo cómo extraer números de cadenas, eliminar caracteres no deseados del texto, encontrar y reemplazar caracteres, extraer partes específicas de cadenas, convertir texto de forma libre a formatos más uniformes y dividir cadenas en múltiples valores.

Base R incluye funciones para realizar todas estas tareas. Sin embargo, no siguen una convención unificadora, lo que las hace un poco difíciles de memorizar y usar. El paquete \textbf{stringr} reempaqueta esta funcionalidad, pero utiliza un enfoque más consistente de nombrar funciones y ordenar sus argumentos. Por ejemplo, en \textbf{stringr}, todas las funciones de procesamiento de cadenas comienzan con \texttt{str\_}. Esto significa que si escriben \texttt{str\_} y presionan \emph{tab}, R se completará automáticamente y mostrará todas las funciones disponibles. Como resultado, no tenemos que memorizar todos los nombres de las funciones. Otra ventaja es que en las funciones de este paquete, la cadena que se procesa siempre es el primer argumento, que significa que podemos usar el \emph{pipe} más fácilmente. Por lo tanto, comenzaremos describiendo cómo usar las funciones en el paquete \textbf{stringr}.

La mayoría de los ejemplos provendrán del segundo estudio de caso que trata sobre las alturas autoreportadas por los estudiantes y la mayor parte del capítulo se dedica al aprendizaje de expresiones regulares (\emph{regular expressions} o \emph{regex} en inglés) y funciones en el paquete \textbf{stringr}.

\hypertarget{stringr}{%
\section{El paquete stringr}\label{stringr}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(stringr)}
\end{Highlighting}
\end{Shaded}

En general, las tareas de procesamiento de cadenas se pueden dividir en \textbf{detectar}, \textbf{localizar}, \textbf{extraer} o \textbf{reemplazar} patrones en cadenas. Veremos varios ejemplos. La siguiente tabla incluye las funciones disponibles en el paquete \textbf{stringr}. Las dividimos por tarea. También incluimos el equivalente de base R cuando está disponible.

Todas estas funciones toman un vector de caracteres como primer argumento. Además, para cada función, las operaciones se vectorizan: la operación se aplica a cada cadena en el vector.

Finalmente, tengan en cuenta que en esta tabla mencionamos \emph{groups}. Estos se explicarán en la Sección \ref{groups}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.20}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.13}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.50}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.17}}@{}}
\toprule
stringr & Tarea & Descripción & Base R \\
\midrule
\endhead
\texttt{str\_detect} & Detectar & ¿El patrón está en la cadena? & \texttt{grepl} \\
\texttt{str\_which} & Detectar & Devuelve el índice de entradas que contienen el patrón. & \texttt{grep} \\
\texttt{str\_subset} & Detectar & Devuelve el subconjunto de cadenas que contienen el patrón. & \texttt{grep} con \texttt{value\ =\ TRUE} \\
\texttt{str\_locate} & Localizar & Devuelve las posiciones de la primera aparición del patrón en una cadena. & \texttt{regexpr} \\
\texttt{str\_locate\_all} & Localizar & Devuelve la posición de todas las apariciones del patrón en una cadena. & \texttt{gregexpr} \\
\texttt{str\_view} & Localizar & Muestra la primera parte de la cadena que corresponde con el patrón. & \\
\texttt{str\_view\_all} & Localizar & Muestra todas las partes de la cadena que corresponden con el patrón. & \\
\texttt{str\_extract} & Extraer & Extrae la primera parte de la cadena que corresponde con el patrón. & \\
\texttt{str\_extract\_all} & Extraer & Extrae todas las partes de la cadena que corresponden con el patrón. & \\
\texttt{str\_match} & Extraer & Extrae la primera parte de la cadena que corresponde con los grupos y los patrones definidos por los grupos. & \\
\texttt{str\_match\_all} & Extraer & Extrae todas las partes de la cadena que corresponden con los grupos y los patrones definidos por los grupos. & \\
\texttt{str\_sub} & Extraer & Extrae una subcadena. & \texttt{substring} \\
\texttt{str\_split} & Extraer & Divide una cadena en una lista con partes separadas por patrón. & \texttt{strsplit} \\
\texttt{str\_split\_fixed} & Extraer & Divide una cadena en una matriz con partes separadas por patrón. & \texttt{strsplit} con \texttt{fixed\ =\ TRUE} \\
\texttt{str\_count} & Describir & Cuenta el número de veces que aparece un patrón en una cadena. & \\
\texttt{str\_length} & Describir & Número de caracteres en la cadena. & \texttt{nchar} \\
\texttt{str\_replace} & Reemplazar & Reemplaza la primera parte de una cadena que corresponde con un patrón con otro patrón. & \\
\texttt{str\_replace\_all} & Reemplazar & Reemplaza todas las partes de una cadena que corresponden con un patrón con otro patrón. & \texttt{gsub} \\
\texttt{str\_to\_upper} & Reemplazar & Cambia todos los caracteres a mayúsculas. & \texttt{toupper} \\
\texttt{str\_to\_lower} & Reemplazar & Cambia todos los caracteres a minúsculas. & \texttt{tolower} \\
\texttt{str\_to\_title} & Reemplazar & Cambia el primer carácter a mayúscula y el resto a minúscula. & \\
\texttt{str\_replace\_na} & Reemplazar & Reemplaza todo los \texttt{NA}s con un nuevo valor. & \\
\texttt{str\_trim} & Reemplazar & Elimina el espacio en blanco del inicio y del final de la cadena. & \\
\texttt{str\_c} & Manipular & Une múltiples cadenas. & \texttt{paste0} \\
\texttt{str\_conv} & Manipular & Cambia la codificación de la cadena. & \\
\texttt{str\_sort} & Manipular & Pone el vector en orden alfabético. & \texttt{sort} \\
\texttt{str\_order} & Manipular & Índice necesario para ordenar el vector alfabéticamente. & \texttt{order} \\
\texttt{str\_trunc} & Manipular & Trunca una cadena a un tamaño fijo. & \\
\texttt{str\_pad} & Manipular & Agrega espacio en blanco a la cadena para que tenga un tamaño fijo. & \\
\texttt{str\_dup} & Manipular & Repite una cadena. & \texttt{rep} luego \texttt{paste} \\
\texttt{str\_wrap} & Manipular & Pone la cadena en párrafos formateados. & \\
\texttt{str\_interp} & Manipular & Interpolación de cadenas. & \texttt{sprintf} \\
\bottomrule
\end{longtable}

\hypertarget{estudio-de-caso-1-datos-de-asesinatos-en-ee.-uu.}{%
\section{Estudio de caso 1: datos de asesinatos en EE. UU.}\label{estudio-de-caso-1-datos-de-asesinatos-en-ee.-uu.}}

En esta sección presentamos algunos de los desafíos más sencillos de procesamiento de cadenas, con los siguientes sets de datos como ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(rvest)}
\NormalTok{url }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"https://en.wikipedia.org/w/index.php?title="}\NormalTok{,}
              \StringTok{"Gun\_violence\_in\_the\_United\_States\_by\_state"}\NormalTok{,}
              \StringTok{"\&direction=prev\&oldid=810166167"}\NormalTok{)}
\NormalTok{murders\_raw }\OtherTok{\textless{}{-}} \FunctionTok{read\_html}\NormalTok{(url) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{html\_node}\NormalTok{(}\StringTok{"table"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{html\_table}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"state"}\NormalTok{, }\StringTok{"population"}\NormalTok{, }\StringTok{"total"}\NormalTok{, }\StringTok{"murder\_rate"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

El código anterior muestra el primer paso para construir el set de datos,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

de los datos sin procesar, que se extrajeron de una página de Wikipedia.

En general, el procesamiento de cadenas implica una cadena y un patrón. En R, generalmente almacenamos cadenas en un vector de caracteres como \texttt{murders\$population}. Las primeras tres cadenas en este vector definidas por la variable de población son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders\_raw}\SpecialCharTok{$}\NormalTok{population[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "4,853,875" "737,709"   "6,817,565"}
\end{Highlighting}
\end{Shaded}

Forzar una conversión usando \texttt{as.numeric} no funciona aquí:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(murders\_raw}\SpecialCharTok{$}\NormalTok{population[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{])}
\CommentTok{\#\textgreater{} Warning: NAs introducidos por coerción}
\CommentTok{\#\textgreater{} [1] NA NA NA}
\end{Highlighting}
\end{Shaded}

Esto se debe a las comas \texttt{,}. El procesamiento de cadenas que queremos hacer aquí es eliminar el \textbf{patrón} " \texttt{,}" de las \textbf{cadenas} en \texttt{murders\_raw\$population} y luego forzar una conversión de los números.

Podemos usar la función \texttt{str\_detect} para ver que dos de las tres columnas tienen comas en las entradas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{commas }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{any}\NormalTok{(}\FunctionTok{str\_detect}\NormalTok{(x, }\StringTok{","}\NormalTok{))}
\NormalTok{murders\_raw }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize\_all}\NormalTok{(commas)}
\CommentTok{\#\textgreater{} \# A tibble: 1 x 4}
\CommentTok{\#\textgreater{}   state population total murder\_rate}
\CommentTok{\#\textgreater{}   \textless{}lgl\textgreater{} \textless{}lgl\textgreater{}      \textless{}lgl\textgreater{} \textless{}lgl\textgreater{}      }
\CommentTok{\#\textgreater{} 1 FALSE TRUE       TRUE  FALSE}
\end{Highlighting}
\end{Shaded}

Entonces podemos usar la función \texttt{str\_replace\_all} para eliminarlas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_1 }\OtherTok{\textless{}{-}} \FunctionTok{str\_replace\_all}\NormalTok{(murders\_raw}\SpecialCharTok{$}\NormalTok{population, }\StringTok{","}\NormalTok{, }\StringTok{""}\NormalTok{)}
\NormalTok{test\_1 }\OtherTok{\textless{}{-}} \FunctionTok{as.numeric}\NormalTok{(test\_1)}
\end{Highlighting}
\end{Shaded}

De ahí podemos usar \texttt{mutate\_all} para aplicar esta operación a cada columna, ya que no afectará a las columnas sin comas.

Resulta que esta operación es tan común que \texttt{readr} incluye la función \texttt{parse\_number} específicamente para eliminar caracteres no numéricos antes de forzar una conversión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_2 }\OtherTok{\textless{}{-}} \FunctionTok{parse\_number}\NormalTok{(murders\_raw}\SpecialCharTok{$}\NormalTok{population)}
\FunctionTok{identical}\NormalTok{(test\_1, test\_2)}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

Entonces podemos obtener nuestra tabla deseada usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders\_new }\OtherTok{\textless{}{-}}\NormalTok{ murders\_raw }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate\_at}\NormalTok{(}\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, parse\_number)}
\FunctionTok{head}\NormalTok{(murders\_new)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 4}
\CommentTok{\#\textgreater{}   state      population total murder\_rate}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}           \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Alabama       4853875   348         7.2}
\CommentTok{\#\textgreater{} 2 Alaska         737709    59         8  }
\CommentTok{\#\textgreater{} 3 Arizona       6817565   309         4.5}
\CommentTok{\#\textgreater{} 4 Arkansas      2977853   181         6.1}
\CommentTok{\#\textgreater{} 5 California   38993940  1861         4.8}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

Este caso es relativamente sencillo en comparación con los desafíos de procesamiento de cadenas que normalmente enfrentamos en la ciencia de datos. El siguiente ejemplo es bastante complejo y ofrece varios retos que nos permitirán aprender muchas técnicas de procesamiento de cadenas.

\hypertarget{estudio-de-caso-2-alturas-autoreportadas}{%
\section{Estudio de caso 2: alturas autoreportadas}\label{estudio-de-caso-2-alturas-autoreportadas}}

El paquete \textbf{dslabs} incluye el set de datos sin procesar del cual se obtuvo el set de datos de alturas. Pueden cargarlo así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(reported\_heights)}
\end{Highlighting}
\end{Shaded}

Estas alturas se obtuvieron mediante un formulario web en el que se les pidió a estudiantes que ingresaran sus alturas. Podían ingresar cualquier cosa, pero las instrucciones pedían \emph{altura en pulgadas}, un número. Recopilamos 1,095 respuestas, pero desafortunadamente el vector de columna con las alturas reportadas tenía varias entradas no numéricas y como resultado se convirtió en un vector de caracteres:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

Si intentamos analizarlo en números, recibimos una advertencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{as.numeric}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height)}
\CommentTok{\#\textgreater{} Warning: NAs introducidos por coerción}
\end{Highlighting}
\end{Shaded}

Aunque la mayoría de los valores parecen ser la altura en pulgadas según lo solicitado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 75 70 68 74 61 65}
\end{Highlighting}
\end{Shaded}

terminamos con muchos \texttt{NA}s:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(x))}
\CommentTok{\#\textgreater{} [1] 81}
\end{Highlighting}
\end{Shaded}

Podemos ver algunas de las entradas que no se convierten correctamente utilizando \texttt{filter} para mantener solo las entradas que resultan en \texttt{NA}s:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{new\_height =} \FunctionTok{as.numeric}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(new\_height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{(}\AttributeTok{n=}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{}             time\_stamp    sex                 height new\_height}
\CommentTok{\#\textgreater{} 1  2014{-}09{-}02 15:16:28   Male                  5\textquotesingle{} 4"         NA}
\CommentTok{\#\textgreater{} 2  2014{-}09{-}02 15:16:37 Female                  165cm         NA}
\CommentTok{\#\textgreater{} 3  2014{-}09{-}02 15:16:52   Male                    5\textquotesingle{}7         NA}
\CommentTok{\#\textgreater{} 4  2014{-}09{-}02 15:16:56   Male                  \textgreater{}9000         NA}
\CommentTok{\#\textgreater{} 5  2014{-}09{-}02 15:16:56   Male                   5\textquotesingle{}7"         NA}
\CommentTok{\#\textgreater{} 6  2014{-}09{-}02 15:17:09 Female                   5\textquotesingle{}3"         NA}
\CommentTok{\#\textgreater{} 7  2014{-}09{-}02 15:18:00   Male 5 feet and 8.11 inches         NA}
\CommentTok{\#\textgreater{} 8  2014{-}09{-}02 15:19:48   Male                   5\textquotesingle{}11         NA}
\CommentTok{\#\textgreater{} 9  2014{-}09{-}04 00:46:45   Male                  5\textquotesingle{}9\textquotesingle{}\textquotesingle{}         NA}
\CommentTok{\#\textgreater{} 10 2014{-}09{-}04 10:29:44   Male                 5\textquotesingle{}10\textquotesingle{}\textquotesingle{}         NA}
\end{Highlighting}
\end{Shaded}

Inmediatamente vemos lo que está sucediendo. Algunos de los estudiantes no reportaron sus alturas en pulgadas según lo solicitado. Podríamos descartar estos datos y continuar. Sin embargo, muchas de las entradas siguen patrones que, en principio, podemos convertir fácilmente a pulgadas. Por ejemplo, en el resultado anterior, vemos varios casos que usan el formato \texttt{x\textquotesingle{}y\textquotesingle{}\textquotesingle{}} con \texttt{x} e \texttt{y} representando pies y pulgadas, respectivamente. Cada uno de estos casos puede ser leído y convertido a pulgadas por un humano, por ejemplo \texttt{5\textquotesingle{}4\textquotesingle{}\textquotesingle{}} es \texttt{5*12\ +\ 4\ =\ 64}. Entonces podríamos arreglar todas las entradas problemáticas \emph{a mano}. Sin embargo, los humanos son propensos a cometer errores, por lo que es preferible un enfoque automatizado. Además, debido a que planeamos continuar recolectando datos, será conveniente escribir código que lo haga automáticamente.

Un primer paso en este tipo de tarea es examinar las entradas problemáticas e intentar definir patrones específicos seguidos por un gran grupo de entradas. Cuanto más grandes sean estos grupos, más entradas podremos arreglar con un solo enfoque programático. Queremos encontrar patrones que puedan describirse con precisión con una regla, como ``un dígito, seguido por un símbolo de pie, seguido por uno o dos dígitos, seguido por un símbolo de pulgadas''.

Para buscar dichos patrones, es útil eliminar las entradas que son consistentes con estar en pulgadas y ver solo las entradas problemáticas. Por lo tanto, escribimos una función para hacer esto automáticamente. Mantenemos entradas que resultan en \texttt{NA}s al aplicar \texttt{as.numeric} o que están fuera de un rango de alturas plausibles. Permitimos un rango que cubre aproximadamente el 99.9999\% de la población adulta. También usamos \texttt{suppressWarnings} para evitar el mensaje de advertencia que sabemos que \texttt{as.numeric} nos da.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{not\_inches }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{smallest =} \DecValTok{50}\NormalTok{, }\AttributeTok{tallest =} \DecValTok{84}\NormalTok{)\{}
\NormalTok{  inches }\OtherTok{\textless{}{-}} \FunctionTok{suppressWarnings}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(x))}
\NormalTok{  ind }\OtherTok{\textless{}{-}} \FunctionTok{is.na}\NormalTok{(inches) }\SpecialCharTok{|}\NormalTok{ inches }\SpecialCharTok{\textless{}}\NormalTok{ smallest }\SpecialCharTok{|}\NormalTok{ inches }\SpecialCharTok{\textgreater{}}\NormalTok{ tallest}
\NormalTok{  ind}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aplicamos esta función y encontramos el número de entradas problemáticas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{problems }\OtherTok{\textless{}{-}}\NormalTok{ reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{not\_inches}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(height)}
\FunctionTok{length}\NormalTok{(problems)}
\CommentTok{\#\textgreater{} [1] 292}
\end{Highlighting}
\end{Shaded}

Ahora podemos ver todos los casos simplemente imprimiéndolos. No hacemos eso aquí porque hay \texttt{length(problems)}, pero después de examinarlos cuidadosamente, vemos que podemos usar tres patrones para definir tres grandes grupos dentro de estas excepciones.

1. Un patrón de la forma \texttt{x\textquotesingle{}y} o \texttt{x\textquotesingle{}\ y\textquotesingle{}\textquotesingle{}} o \texttt{x\textquotesingle{}y"} con \texttt{x} e \texttt{y} representando pies y pulgadas, respectivamente. Aquí hay diez ejemplos:

\begin{verbatim}
#> 5' 4" 5'7 5'7" 5'3" 5'11 5'9'' 5'10'' 5' 10 5'5" 5'2"
\end{verbatim}

2. Un patrón de la forma \texttt{x.y} o \texttt{x,y} con \texttt{x} pies y \texttt{y} pulgadas. Aquí hay diez ejemplos:

\begin{verbatim}
#> 5.3 5.5 6.5 5.8 5.6 5,3 5.9 6,8 5.5 6.2
\end{verbatim}

3. Entradas en centímetros en vez de pulgadas. Aquí hay diez ejemplos:

\begin{verbatim}
#> 150 175 177 178 163 175 178 165 165 180
\end{verbatim}

Una vez que veamos que estos grupos grandes siguen patrones específicos, podemos desarrollar un plan de ataque. Recuerden que raras veces hay una sola forma de realizar estas tareas. Aquí elegimos una que nos ayuda a enseñar varias técnicas útiles, aunque seguramente hay una forma más eficiente de realizar la tarea.

\textbf{Plan de ataque}: convertiremos las entradas que siguen a los dos primeros patrones en una estandarizada. Luego, aprovecharemos la estandarización para extraer los pies y pulgadas y convertirlos a pulgadas. Entonces, definiremos un procedimiento para identificar entradas que están en centímetros y convertirlas a pulgadas. Después de aplicar estos pasos, verificaremos nuevamente para ver qué entradas no se corrigieron y ver si podemos ajustar nuestro enfoque para que sea más completo.

Al final, esperamos tener un \emph{script} que haga que los métodos de recolección de datos basados en la web sean robustos para los errores más comunes de los usuarios.

Para lograr nuestro objetivo, utilizaremos una técnica que nos permite detectar con precisión patrones y extraer las partes que queremos: expresiones regulares. Pero primero, describimos rápidamente cómo \emph{escaparse} (``escapar'' viene de la tecla \emph{esc} o \emph{escape}) de la función de ciertos caracteres para que se puedan incluir en cadenas.

\hypertarget{cuxf3mo-escapar-al-definir-cadenas}{%
\section{\texorpdfstring{Cómo \emph{escapar} al definir cadenas}{Cómo escapar al definir cadenas}}\label{cuxf3mo-escapar-al-definir-cadenas}}

Para definir cadenas en R, podemos usar comillas dobles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"Hello!"}
\end{Highlighting}
\end{Shaded}

o comillas simples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}Hello!\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Asegúrense de elegir la comilla simple correcta, ya que usar la comilla inversa le dará un error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{\textasciigrave{}}\AttributeTok{Hello}\StringTok{\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: object 'Hello' not found
\end{verbatim}

Ahora, ¿qué sucede si la cadena que queremos definir incluye comillas dobles? Por ejemplo, si queremos escribir 10 pulgadas así: \texttt{10"}?
En este caso no pueden usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"10""}
\end{Highlighting}
\end{Shaded}

porque esto es solo la cadena \texttt{10} seguido por una comilla doble. Si escriben esto en R, obtendrán un error porque tiene comillas doble sin cerrar. Para evitar esto, podemos usar las comillas simples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}10"\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Si imprimimos \texttt{s}, vemos que escapamos las comillas dobles con la barra diagonal inversa \texttt{\textbackslash{}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s}
\CommentTok{\#\textgreater{} [1] "10\textbackslash{}""}
\end{Highlighting}
\end{Shaded}

De hecho, escapar con la barra diagonal inversa ofrece una forma de definir la cadena y a la vez seguir utilizando las comillas dobles para definir cadenas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"10}\SpecialCharTok{\textbackslash{}"}\StringTok{"}
\end{Highlighting}
\end{Shaded}

En R, la función \texttt{cat} nos permite ver como se ve la cadena:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(s)}
\CommentTok{\#\textgreater{} 10"}
\end{Highlighting}
\end{Shaded}

Ahora, ¿qué pasa si queremos que nuestra cadena sea de 5 pies escrita así: \texttt{5\textquotesingle{}}? En ese caso, podemos usar las comillas dobles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"5\textquotesingle{}"}
\FunctionTok{cat}\NormalTok{(s)}
\CommentTok{\#\textgreater{} 5\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Así que hemos aprendido a escribir 5 pies y 10 pulgadas por separado, pero ¿qué pasa si queremos escribirlos juntos para representar \emph{5 pies y 10 pulgadas} así: \texttt{5\textquotesingle{}10"}? En este caso, ni las comillas simples ni las dobles funcionarán. Esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}5\textquotesingle{}}\DecValTok{10}\StringTok{"\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

cierra la cadena después de 5 y esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"5\textquotesingle{}10""}
\end{Highlighting}
\end{Shaded}

cierra la cadena después de 10. Tengan en cuenta que si escribimos uno de los fragmentos de código anteriores en R, se atascará esperando que cierren la comilla abierta y tendrán que salir de la ejecución con la tecla \emph{esc}.

En esta situación, necesitamos escapar de la función de las comillas con la barra diagonal inversa \texttt{\textbackslash{}}. Pueden escapar cualquiera de los dos de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}5}\SpecialCharTok{\textbackslash{}\textquotesingle{}}\StringTok{10"\textquotesingle{}}
\FunctionTok{cat}\NormalTok{(s)}
\CommentTok{\#\textgreater{} 5\textquotesingle{}10"}
\end{Highlighting}
\end{Shaded}

o así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"5\textquotesingle{}10}\SpecialCharTok{\textbackslash{}"}\StringTok{"}
\FunctionTok{cat}\NormalTok{(s)}
\CommentTok{\#\textgreater{} 5\textquotesingle{}10"}
\end{Highlighting}
\end{Shaded}

Los caracteres de escape son algo que a menudo tenemos que usar al procesar cadenas.

\hypertarget{expresiones-regulares}{%
\section{Expresiones regulares}\label{expresiones-regulares}}

Las expresiones regulares (\emph{regex}) son una forma de describir patrones específicos de caracteres de texto. Se pueden usar para determinar si una cadena dada corresponde con el patrón. Se ha definido un conjunto de reglas para hacer esto de manera eficiente y precisa y aquí mostramos algunos ejemplos. Podemos aprender más sobre estas reglas leyendo tutoriales detallados\footnote{\url{https://www.regular-expressions.info/tutorial.html}} \footnote{\url{http://r4ds.had.co.nz/strings.html\#matching-patrones-con-expresiones-regulares}}. La hoja de referencia de RStudio también es muy útil\footnote{\url{https://github.com/rstudio/cheatsheets/raw/master/translations/spanish/strings_Spanish.pdf}}.

Los patrones suministrados a las funciones \textbf{stringr} pueden ser una expresión regular en lugar de una cadena estándar. Aprenderemos cómo funciona esto a través de una serie de ejemplos.

A lo largo de esta sección, verán que creamos cadenas para probar nuestra expresión regular. Para hacer esto, definimos patrones que sabemos deben corresponder y también patrones que sabemos no deben corresponder. Los llamaremos \texttt{yes} y \texttt{no}, respectivamente. Esto nos permite verificar los dos tipos de errores: no corresponder o corresponder incorrectamente.

\hypertarget{las-cadenas-son-expresiones-regulares}{%
\subsection{Las cadenas son expresiones regulares}\label{las-cadenas-son-expresiones-regulares}}

Técnicamente, cualquier cadena es una expresión regular, quizás el ejemplo más simple es un solo carácter. Entonces la coma \texttt{,} usada en el siguiente ejemplo de código, es un ejemplo sencillo de una búsqueda con expresiones regulares.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{","}
\FunctionTok{str\_detect}\NormalTok{(murders\_raw}\SpecialCharTok{$}\NormalTok{total, pattern)}
\end{Highlighting}
\end{Shaded}

Suprimimos el \emph{output} que es un vector lógico que nos dice qué entradas tienen comas.

Arriba, notamos que una entrada incluía un \texttt{cm}. Este es también un ejemplo simple de una expresión regular. Podemos mostrar todas las entradas que usaron \texttt{cm} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(reported\_heights}\SpecialCharTok{$}\NormalTok{height, }\StringTok{"cm"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "165cm"  "170 cm"}
\end{Highlighting}
\end{Shaded}

\hypertarget{caracteres-especiales}{%
\subsection{Caracteres especiales}\label{caracteres-especiales}}

Ahora consideremos un ejemplo un poco más complicado. ¿Cuál de las siguientes cadenas contiene el patrón \texttt{cm} o \texttt{inches}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"180 cm"}\NormalTok{, }\StringTok{"70 inches"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"180"}\NormalTok{, }\StringTok{"70\textquotesingle{}\textquotesingle{}"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_detect}\NormalTok{(s, }\StringTok{"cm"}\NormalTok{) }\SpecialCharTok{|} \FunctionTok{str\_detect}\NormalTok{(s, }\StringTok{"inches"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Sin embargo, no necesitamos hacer esto. La característica principal que distingue el lenguaje de las expresiones regulares de cadenas es que podemos usar caracteres especiales. Estos son caracteres con un significado. Comenzamos presentando \texttt{\textbar{}} que significa \emph{o}. Entonces, si queremos saber si \texttt{cm} o \texttt{inches} aparece en las cadenas, podemos usar la expresión regular \texttt{cm\textbar{}inches}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_detect}\NormalTok{(s, }\StringTok{"cm|inches"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

y obtener la respuesta correcta.

Otro carácter especial que será útil para identificar valores de pies y pulgadas es \texttt{\textbackslash{}d} que significa cualquier dígito: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. La barra inversa se utiliza para distinguirlo del carácter \texttt{d}. En R, tenemos que escapar de la barra inversa \texttt{\textbackslash{}} así que tenemos que usar \texttt{\textbackslash{}\textbackslash{}d} para representar dígitos. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5"}\NormalTok{, }\StringTok{"6"}\NormalTok{, }\StringTok{"5\textquotesingle{}10"}\NormalTok{, }\StringTok{"5 feet"}\NormalTok{, }\StringTok{"4\textquotesingle{}11"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{""}\NormalTok{, }\StringTok{"."}\NormalTok{, }\StringTok{"Five"}\NormalTok{, }\StringTok{"six"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d"}
\FunctionTok{str\_detect}\NormalTok{(s, pattern)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Aprovechamos esta oportunidad para presentar la función \texttt{str\_view}, que es útil para la solución de problemas ya que nos muestra la primera ocurrencia que corresponde exactamente para cada cadena:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_view}\NormalTok{(s, pattern)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-1} \end{center}

y \texttt{str\_view\_all} nos muestra todos los patrones que corresponden. Entonces, \texttt{3\textquotesingle{}2} tiene dos equivalencias y \texttt{5\textquotesingle{}10} tiene tres.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_view\_all}\NormalTok{(s, pattern)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-2} \end{center}

Hay muchos otros caracteres especiales. Aprenderemos algunos mas a continuación, pero pueden ver la mayoría o todos en la hoja de referencia mencionada anteriormente\footnote{\url{https://github.com/rstudio/cheatsheets/raw/master/translations/spanish/strings_Spanish.pdf}}.

\hypertarget{clases-de-caracteres}{%
\subsection{Clases de caracteres}\label{clases-de-caracteres}}

Las clases de caracteres se utilizan para definir una serie de caracteres que pueden corresponder. Definimos clases de caracteres entre corchetes \texttt{{[}\ {]}}. Entonces, por ejemplo, si queremos que el patrón corresponda solo si tenemos un \texttt{5} o un \texttt{6}, usamos la expresión regular \texttt{{[}56{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_view}\NormalTok{(s, }\StringTok{"[56]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-3} \end{center}

Supongan que queremos unir valores entre 4 y 7. Una forma común de definir clases de caracteres es con rangos. Así por ejemplo, \texttt{{[}0-9{]}} es equivalente a \texttt{\textbackslash{}\textbackslash{}d}. El patrón que queremos entonces es \texttt{{[}4-7{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(}\DecValTok{4}\SpecialCharTok{:}\DecValTok{7}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_detect}\NormalTok{(s, }\StringTok{"[4{-}7]"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Sin embargo, es importante saber que en \emph{regex} todo es un carácter; no hay números. Por eso \texttt{4} es el carácter \texttt{4} y no el número cuatro. Noten, por ejemplo, que \texttt{{[}1-20{]}} \textbf{no} significa 1 a 20, significa los caracteres 1 a 2 o el carácter 0. Entonces \texttt{{[}1-20{]}} simplemente significa la clase de caracteres compuesta por 0, 1 y 2.

Tengan en cuenta que los caracteres tienen un orden y los dígitos siguen el orden numérico. Entonces \texttt{0} viene antes de \texttt{1} que viene antes de \texttt{2} y así. Por la misma razón, podemos definir letras minúsculas como \texttt{{[}a-z{]}}, letras mayúsculas como \texttt{{[}A-Z{]}} y \texttt{{[}a-zA-z{]}} como ambas.

\hypertarget{anclas}{%
\subsection{Anclas}\label{anclas}}

¿Y si queremos una correspondencia cuando tenemos exactamente 1 dígito? Esto será útil en nuestro estudio de caso, ya que los pies nunca tienen más de 1 dígito, por lo que esta restricción nos ayudará. Una forma de hacer esto con \emph{regex} es usando \emph{anclas} (\emph{anchors} en inglés), que nos permiten definir patrones que deben comenzar o terminar en un lugar específico. Las dos anclas más comunes son
\texttt{\^{}} y \texttt{\$} que representan el comienzo y el final de una cadena, respectivamente. Entonces el patrón \texttt{\^{}\textbackslash{}\textbackslash{}d\$} se lee como ``inicio de la cadena seguido por un dígito seguido por el final de la cadena''.

Este patrón ahora solo detecta las cadenas con exactamente un dígito:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d$"}
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"5"}\NormalTok{, }\StringTok{"9"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"12"}\NormalTok{, }\StringTok{"123"}\NormalTok{, }\StringTok{" 1"}\NormalTok{, }\StringTok{"a4"}\NormalTok{, }\StringTok{"b"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_view\_all}\NormalTok{(s, pattern)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-4} \end{center}

El \texttt{1} no corresponde porque no comienza con el dígito sino con un espacio, que no es fácil de ver.

\hypertarget{cuantificadores}{%
\subsection{Cuantificadores}\label{cuantificadores}}

Para la parte de pulgadas, podemos tener uno o dos dígitos. Esto se puede especificar en \emph{regex} con \emph{cuantificadores} (\emph{quantifiers} en inglés). Esto se hace siguiendo el patrón con la cantidad de veces que se puede repetir cerrada por llaves. Usemos un ejemplo para ilustrar. El patrón para uno o dos dígitos es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}$"}
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"5"}\NormalTok{, }\StringTok{"9"}\NormalTok{, }\StringTok{"12"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"123"}\NormalTok{, }\StringTok{"a4"}\NormalTok{, }\StringTok{"b"}\NormalTok{)}
\FunctionTok{str\_view}\NormalTok{(}\FunctionTok{c}\NormalTok{(yes, no), pattern)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-5} \end{center}

En este caso, \texttt{123} \textbf{no} corresponde, pero \texttt{12} sí. Entonces, para buscar nuestro patrón de pies y pulgadas, podemos agregar los símbolos para pies \texttt{\textquotesingle{}} y pulgadas \texttt{"} después de los dígitos.

Con lo que hemos aprendido, ahora podemos construir un ejemplo para el patrón \texttt{x\textquotesingle{}y\textbackslash{}"} con \texttt{x} pies y \texttt{y} pulgadas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}}\SpecialCharTok{\textbackslash{}"}\StringTok{$"}
\end{Highlighting}
\end{Shaded}

El patrón ahora se está volviendo complejo, pero pueden mirarlo cuidadosamente y desglosarlo:

\begin{itemize}
\tightlist
\item
  \texttt{\^{}} = inicio de la cadena
\item
  \texttt{{[}4-7{]}} = un dígito, ya sea 4, 5, 6 o 7
\item
  \texttt{\textquotesingle{}} = símbolo de pies
\item
  \texttt{\textbackslash{}\textbackslash{}d\{1,2\}} = uno o dos dígitos
\item
  \texttt{\textbackslash{}"} = símbolo de pulgadas
\item
  \texttt{\$} = final de la cadena
\end{itemize}

Probémoslo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}7}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{"6\textquotesingle{}2}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{"5\textquotesingle{}12}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"6,2}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{"6.2}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{,}\StringTok{"I am 5\textquotesingle{}11}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{"3\textquotesingle{}2}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{"64"}\NormalTok{)}
\FunctionTok{str\_detect}\NormalTok{(yes, pattern)}
\CommentTok{\#\textgreater{} [1] TRUE TRUE TRUE}
\FunctionTok{str\_detect}\NormalTok{(no, pattern)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Por ahora, estamos permitiendo que las pulgadas sean 12 o más grandes. Agregaremos una restricción más tarde ya que la expresión regular para esto es un poco más compleja de lo que estamos preparados para mostrar.

\hypertarget{espacio-en-blanco-s}{%
\subsection{\texorpdfstring{Espacio en blanco \texttt{\textbackslash{}s}}{Espacio en blanco \textbackslash s}}\label{espacio-en-blanco-s}}

Otro problema que tenemos son los espacios. Por ejemplo, nuestro patrón no corresponde con \texttt{5\textquotesingle{}\ 4"} porque hay un espacio entre \texttt{\textquotesingle{}} y \texttt{4}, que nuestro patrón no permite. Los espacios son caracteres y R no los ignora:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{identical}\NormalTok{(}\StringTok{"Hi"}\NormalTok{, }\StringTok{"Hi "}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

En \emph{regex}, \texttt{\textbackslash{}s} representa el espacio en blanco. Para encontrar patrones como \texttt{5\textquotesingle{}\ 4}, podemos cambiar nuestro patrón a:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern\_2 }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}}\SpecialCharTok{\textbackslash{}"}\StringTok{$"}
\FunctionTok{str\_subset}\NormalTok{(problems, pattern\_2)}
\CommentTok{\#\textgreater{} [1] "5\textquotesingle{} 4\textbackslash{}""  "5\textquotesingle{} 11\textbackslash{}"" "5\textquotesingle{} 7\textbackslash{}""}
\end{Highlighting}
\end{Shaded}

Sin embargo, esto no encontrará equivalencia con los patrones sin espacio. Entonces, ¿necesitamos más de un patrón \emph{regex}? Resulta que también podemos usar un cuantificador para esto.

\hypertarget{cuantificadores-1}{%
\subsection{\texorpdfstring{Cuantificadores: \texttt{*}, \texttt{?}, \texttt{+}}{Cuantificadores: *, ?, +}}\label{cuantificadores-1}}

Queremos que el patrón permita espacios pero que no los requiera. Incluso si hay varios espacios, como en este ejemplo \texttt{5\textquotesingle{}\ 4}, todavía queremos que corresponda. Hay un cuantificador para exactamente este propósito. En \emph{regex}, el carácter \texttt{*} significa cero o más instancias del carácter anterior. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"AB"}\NormalTok{, }\StringTok{"A1B"}\NormalTok{, }\StringTok{"A11B"}\NormalTok{, }\StringTok{"A111B"}\NormalTok{, }\StringTok{"A1111B"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"A2B"}\NormalTok{, }\StringTok{"A21B"}\NormalTok{)}
\FunctionTok{str\_detect}\NormalTok{(yes, }\StringTok{"A1*B"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] TRUE TRUE TRUE TRUE TRUE}
\FunctionTok{str\_detect}\NormalTok{(no, }\StringTok{"A1*B"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE}
\end{Highlighting}
\end{Shaded}

El patrón anterior encuentra correspondencia con la primera cadena, que tiene cero 1s, y todas las cadenas con un o más 1. Entonces podemos mejorar nuestro patrón agregando el \texttt{*} después del carácter espacial \texttt{\textbackslash{}s}.

Hay otros dos cuantificadores similares. Para ninguno o una vez, podemos usar \texttt{?}, y para uno o más, podemos usar \texttt{+}. Pueden ver cómo difieren con este ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{string =} \FunctionTok{c}\NormalTok{(}\StringTok{"AB"}\NormalTok{, }\StringTok{"A1B"}\NormalTok{, }\StringTok{"A11B"}\NormalTok{, }\StringTok{"A111B"}\NormalTok{, }\StringTok{"A1111B"}\NormalTok{),}
           \AttributeTok{none\_or\_more =} \FunctionTok{str\_detect}\NormalTok{(yes, }\StringTok{"A1*B"}\NormalTok{),}
           \AttributeTok{nore\_or\_once =} \FunctionTok{str\_detect}\NormalTok{(yes, }\StringTok{"A1?B"}\NormalTok{),}
           \AttributeTok{once\_or\_more =} \FunctionTok{str\_detect}\NormalTok{(yes, }\StringTok{"A1+B"}\NormalTok{))}
\CommentTok{\#\textgreater{}   string none\_or\_more nore\_or\_once once\_or\_more}
\CommentTok{\#\textgreater{} 1     AB         TRUE         TRUE        FALSE}
\CommentTok{\#\textgreater{} 2    A1B         TRUE         TRUE         TRUE}
\CommentTok{\#\textgreater{} 3   A11B         TRUE        FALSE         TRUE}
\CommentTok{\#\textgreater{} 4  A111B         TRUE        FALSE         TRUE}
\CommentTok{\#\textgreater{} 5 A1111B         TRUE        FALSE         TRUE}
\end{Highlighting}
\end{Shaded}

Usaremos los tres en nuestro ejemplo de alturas reportadas, pero los veremos en una sección posterior.

\hypertarget{todo-excepto}{%
\subsection{Todo excepto}\label{todo-excepto}}

Para especificar patrones que \textbf{no} queremos detectar, podemos usar el símbolo \texttt{\^{}} pero solo \textbf{dentro} de corchetes. Recuerden que fuera del corchete \texttt{\^{}} significa el inicio de la cadena. Entonces, por ejemplo, si queremos detectar dígitos precedidos por algo que no sea una letra, podemos hacer lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"[\^{}a{-}zA{-}Z]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d"}
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{".3"}\NormalTok{, }\StringTok{"+2"}\NormalTok{, }\StringTok{"{-}0"}\NormalTok{,}\StringTok{"*4"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"A3"}\NormalTok{, }\StringTok{"B2"}\NormalTok{, }\StringTok{"C0"}\NormalTok{, }\StringTok{"E4"}\NormalTok{)}
\FunctionTok{str\_detect}\NormalTok{(yes, pattern)}
\CommentTok{\#\textgreater{} [1] TRUE TRUE TRUE TRUE}
\FunctionTok{str\_detect}\NormalTok{(no, pattern)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Otra forma de generar un patrón que busca \emph{todo excepto} es usar la mayúscula del carácter especial. Por ejemplo \texttt{\textbackslash{}\textbackslash{}D} significa cualquier cosa que no sea un dígito, \texttt{\textbackslash{}\textbackslash{}S} significa cualquier cosa excepto un espacio y así sucesivamente.

\hypertarget{groups}{%
\subsection{Grupos}\label{groups}}

Los \emph{grupos} son un elemento muy útil de la expresiones regulares que permiten la extracción de valores. Los grupos se definen usando paréntesis. No afectan las equivalencias de patrones. En cambio, permiten que las herramientas identifiquen partes específicas del patrón para que podamos extraerlas.

Queremos cambiar las alturas escritas como \texttt{5.6} a \texttt{5\textquotesingle{}6}.

Para evitar cambiar patrones como \texttt{70.2}, requeriremos que el primer dígito esté entre 4 y 7 \texttt{{[}4-7{]}} y que el segundo sea ninguno o uno o más dígitos \texttt{\textbackslash{}\textbackslash{}d*}. Comencemos definiendo un patrón sencillo que corresponda con lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern\_without\_groups }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7],}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*$"}
\end{Highlighting}
\end{Shaded}

Queremos extraer los dígitos para poder formar la nueva versión usando un punto. Estos son nuestros dos grupos, por lo que los encapsulamos con paréntesis:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern\_with\_groups }\OtherTok{\textless{}{-}} \StringTok{"\^{}([4{-}7]),(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}
\end{Highlighting}
\end{Shaded}

Encapsulamos la parte del patrón que corresponde con las partes que queremos conservar para su uso posterior. Agregar grupos no afecta la detección, ya que solo indica que queremos guardar lo que capturan los grupos. Tengan en cuenta que ambos patrones devuelven el mismo resultado cuando se usa \texttt{str\_detect}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5,9"}\NormalTok{, }\StringTok{"5,11"}\NormalTok{, }\StringTok{"6,"}\NormalTok{, }\StringTok{"6,1"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}9"}\NormalTok{, }\StringTok{","}\NormalTok{, }\StringTok{"2,8"}\NormalTok{, }\StringTok{"6.1.1"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_detect}\NormalTok{(s, pattern\_without\_groups)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE}
\FunctionTok{str\_detect}\NormalTok{(s, pattern\_with\_groups)}
\CommentTok{\#\textgreater{} [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Una vez que hayamos definido los grupos, podemos usar la función \texttt{str\_match} para extraer los valores que definen estos grupos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_match}\NormalTok{(s, pattern\_with\_groups)}
\CommentTok{\#\textgreater{}      [,1]   [,2] [,3]}
\CommentTok{\#\textgreater{} [1,] "5,9"  "5"  "9" }
\CommentTok{\#\textgreater{} [2,] "5,11" "5"  "11"}
\CommentTok{\#\textgreater{} [3,] "6,"   "6"  ""  }
\CommentTok{\#\textgreater{} [4,] "6,1"  "6"  "1" }
\CommentTok{\#\textgreater{} [5,] NA     NA   NA  }
\CommentTok{\#\textgreater{} [6,] NA     NA   NA  }
\CommentTok{\#\textgreater{} [7,] NA     NA   NA  }
\CommentTok{\#\textgreater{} [8,] NA     NA   NA}
\end{Highlighting}
\end{Shaded}

Observen que las segunda y tercera columnas contienen pies y pulgadas, respectivamente. La primera columna es la parte de la cadena que corresponde con el patrón. Si no se encuentra una equivalencia, vemos un \texttt{NA}.

Ahora podemos entender la diferencia entre las funciones \texttt{str\_extract} y \texttt{str\_match}. \texttt{str\_extract} extrae solo cadenas que corresponden con un patrón, no los valores definidos por grupos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_extract}\NormalTok{(s, pattern\_with\_groups)}
\CommentTok{\#\textgreater{} [1] "5,9"  "5,11" "6,"   "6,1"  NA     NA     NA     NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{buscar-y-reemplazar-con-expresiones-regulares}{%
\section{Buscar y reemplazar con expresiones regulares}\label{buscar-y-reemplazar-con-expresiones-regulares}}

Anteriormente definimos el objeto \texttt{problems} que contiene las cadenas que no parecen estar en pulgadas. Podemos ver que pocas de nuestras cadenas problemáticas corresponden con el patrón:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}}\SpecialCharTok{\textbackslash{}"}\StringTok{$"}
\FunctionTok{sum}\NormalTok{(}\FunctionTok{str\_detect}\NormalTok{(problems, pattern))}
\CommentTok{\#\textgreater{} [1] 14}
\end{Highlighting}
\end{Shaded}

Para ver por qué esto es así, mostramos algunos ejemplos que ilustran por qué no tenemos más equivalencias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{problems[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{15}\NormalTok{)] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_view}\NormalTok{(pattern)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{wrangling/img//str_view-6} \end{center}

Un problema inicial que vemos de inmediato es que algunos estudiantes escribieron las palabras ``feet'' e ``inches''. Podemos ver las entradas que hicieron esto con la función \texttt{str\_subset}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(problems, }\StringTok{"inches"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "5 feet and 8.11 inches" "Five foot eight inches"}
\CommentTok{\#\textgreater{} [3] "5 feet 7inches"         "5ft 9 inches"          }
\CommentTok{\#\textgreater{} [5] "5 ft 9 inches"          "5 feet 6 inches"}
\end{Highlighting}
\end{Shaded}

También vemos que algunas entradas usan dos comillas simples \texttt{\textquotesingle{}\textquotesingle{}} en lugar de una comilla doble \texttt{"}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(problems, }\StringTok{"\textquotesingle{}\textquotesingle{}"}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1] "5\textquotesingle{}9\textquotesingle{}\textquotesingle{}"   "5\textquotesingle{}10\textquotesingle{}\textquotesingle{}"  "5\textquotesingle{}10\textquotesingle{}\textquotesingle{}"  "5\textquotesingle{}3\textquotesingle{}\textquotesingle{}"   "5\textquotesingle{}7\textquotesingle{}\textquotesingle{}"   "5\textquotesingle{}6\textquotesingle{}\textquotesingle{}"  }
\CommentTok{\#\textgreater{}  [7] "5\textquotesingle{}7.5\textquotesingle{}\textquotesingle{}" "5\textquotesingle{}7.5\textquotesingle{}\textquotesingle{}" "5\textquotesingle{}10\textquotesingle{}\textquotesingle{}"  "5\textquotesingle{}11\textquotesingle{}\textquotesingle{}"  "5\textquotesingle{}10\textquotesingle{}\textquotesingle{}"  "5\textquotesingle{}5\textquotesingle{}\textquotesingle{}"}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}$"}
\end{Highlighting}
\end{Shaded}

Si hacemos este reemplazo antes de buscar equivalencias, obtendremos muchas más equivalencias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{problems }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"feet|ft|foot"}\NormalTok{, }\StringTok{"\textquotesingle{}"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# replace feet, ft, foot with \textquotesingle{}}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"inches|in|\textquotesingle{}\textquotesingle{}|}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{""}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# remove all inches symbols}
  \FunctionTok{str\_detect}\NormalTok{(pattern) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sum}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 48}
\end{Highlighting}
\end{Shaded}

Sin embargo, todavía nos faltan muchos casos.

Noten que en el código anterior, aprovechamos la consistencia de \textbf{stringr} y usamos el \emph{pipe}.

Por ahora, mejoramos nuestro patrón agregando \texttt{\textbackslash{}\textbackslash{}s*} delante y después del símbolo de los pies \texttt{\textquotesingle{}} para permitir espacio entre el símbolo de los pies y los números. Ahora encontraremos más equivalencias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}$"}
\NormalTok{problems }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"feet|ft|foot"}\NormalTok{, }\StringTok{"\textquotesingle{}"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# replace feet, ft, foot with \textquotesingle{}}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"inches|in|\textquotesingle{}\textquotesingle{}|}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{""}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# remove all inches symbols}
  \FunctionTok{str\_detect}\NormalTok{(pattern) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  sum}
\CommentTok{\#\textgreater{} [1] 53}
\end{Highlighting}
\end{Shaded}

Podríamos estar tentados a evitar esto eliminando todos los espacios con \texttt{str\_replace\_all}. Sin embargo, al hacer una operación de este tipo, debemos asegurarnos de evitar efectos indeseados. En nuestros ejemplos de alturas autoreportadas, esto será un problema porque algunas entradas tienen la forma \texttt{x\ y} con espacio separando los pies de las pulgadas. Si eliminamos todos los espacios, cambiaríamos incorrectamente \texttt{x\ y} a \texttt{xy} lo que implica que un \texttt{6\ 1} se convertiría en \texttt{61} pulgadas en vez de \texttt{73} pulgadas.

El segundo grupo grande de entradas problemáticas tienen las formas \texttt{x.y}, \texttt{x,y} o \texttt{x\ y}. Queremos cambiar todo esto a nuestro formato común \texttt{x\textquotesingle{}y}. Pero no podemos simplemente buscar y reemplazar porque cambiaríamos valores como \texttt{70.5} a \texttt{70\textquotesingle{}5}. Por lo tanto, nuestra estrategia será buscar un patrón muy específico que nos asegure que se devuelvan pies y pulgadas y luego, para aquellos que correspondan, se reemplazcan adecuadamente.

\hypertarget{buscar-y-reemplazar-usando-grupos}{%
\subsection{Buscar y reemplazar usando grupos}\label{buscar-y-reemplazar-usando-grupos}}

Otro aspecto útil de los grupos es que uno puede hacer referencia a los valores extraídos en una expresión regular cuando busca y reemplaza.

El carácter especial \emph{regex} para el grupo en el lugar \texttt{i} es \texttt{\textbackslash{}\textbackslash{}i}. Entonces \texttt{\textbackslash{}\textbackslash{}1} es el valor extraído del primer grupo, \texttt{\textbackslash{}\textbackslash{}2} el valor del segundo y así sucesivamente. Como un ejemplo sencillo, noten que el siguiente código reemplazará una coma con un punto, pero solo si está entre dos dígitos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern\_with\_groups }\OtherTok{\textless{}{-}} \StringTok{"\^{}([4{-}7]),(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5,9"}\NormalTok{, }\StringTok{"5,11"}\NormalTok{, }\StringTok{"6,"}\NormalTok{, }\StringTok{"6,1"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}9"}\NormalTok{, }\StringTok{","}\NormalTok{, }\StringTok{"2,8"}\NormalTok{, }\StringTok{"6.1.1"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_replace}\NormalTok{(s, pattern\_with\_groups, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "5\textquotesingle{}9"   "5\textquotesingle{}11"  "6\textquotesingle{}"    "6\textquotesingle{}1"   "5\textquotesingle{}9"   ","     "2,8"   "6.1.1"}
\end{Highlighting}
\end{Shaded}

Podemos usar esto para convertir casos en nuestras alturas reportadas.

Ahora estamos listos para definir un patrón que nos ayudará a convertir todos los \texttt{x.y}, \texttt{x,y} y \texttt{x\ y} a nuestro formato preferido. Necesitamos adaptar \texttt{pattern\_with\_groups} para que sea un poco más flexible y capture todos los casos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern\_with\_groups }\OtherTok{\textless{}{-}}\StringTok{"\^{}([4{-}7])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*[,}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}
\end{Highlighting}
\end{Shaded}

Examinemos este patrón \emph{regex}:

\begin{itemize}
\tightlist
\item
  \texttt{\^{}} = inicio de la cadena
\item
  \texttt{{[}4-7{]}} = un dígito, ya sea 4, 5, 6 o 7
\item
  \texttt{\textbackslash{}\textbackslash{}s*} = ninguno o más espacios en blanco
\item
  \texttt{{[},\textbackslash{}\textbackslash{}.\textbackslash{}\textbackslash{}s+{]}} = el símbolo de pies es \texttt{,}, \texttt{.} o al menos un espacio
\item
  \texttt{\textbackslash{}\textbackslash{}s*} = ninguno o más espacios en blanco
\item
  \texttt{\textbackslash{}\textbackslash{}d*} = ninguno o más dígitos
\item
  \texttt{\$} = final de la cadena
\end{itemize}

Podemos ver que parece estar funcionando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(problems, pattern\_with\_groups) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "5.3"  "5.25" "5.5"  "6.5"  "5.8"  "5.6"}
\end{Highlighting}
\end{Shaded}

Ahora usamos esto para buscar y reemplazar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(problems, pattern\_with\_groups) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace}\NormalTok{(pattern\_with\_groups, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ head}
\CommentTok{\#\textgreater{} [1] "5\textquotesingle{}3"  "5\textquotesingle{}25" "5\textquotesingle{}5"  "6\textquotesingle{}5"  "5\textquotesingle{}8"  "5\textquotesingle{}6"}
\end{Highlighting}
\end{Shaded}

Lidiaremos con el desafío de ``pulgadas más grandes que doce'' más tarde.

\hypertarget{probar-y-mejorar}{%
\section{Probar y mejorar}\label{probar-y-mejorar}}

Desarrollar expresiones regulares correctas en el primer intento a menudo es difícil. Probar y mejorar es un enfoque común para encontrar el patrón de expresiones regulares que satisface todas las condiciones deseadas. En las secciones anteriores, hemos desarrollado una potente técnica de procesamiento de cadenas que puede ayudarnos a detectar muchas de las entradas problemáticas. Aquí probaremos nuestro enfoque, buscaremos más problemas y modificaremos nuestro enfoque para posibles mejoras. Escribamos una función que identifique todas las entradas que no se pueden convertir en números, recordando que algunas están en centímetros (nos encargaremos de arreglar esas más adelante):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{not\_inches\_or\_cm }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{smallest =} \DecValTok{50}\NormalTok{, }\AttributeTok{tallest =} \DecValTok{84}\NormalTok{)\{}
\NormalTok{  inches }\OtherTok{\textless{}{-}} \FunctionTok{suppressWarnings}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(x))}
\NormalTok{  ind }\OtherTok{\textless{}{-}} \SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(inches) }\SpecialCharTok{\&}
\NormalTok{    ((inches }\SpecialCharTok{\textgreater{}=}\NormalTok{ smallest }\SpecialCharTok{\&}\NormalTok{ inches }\SpecialCharTok{\textless{}=}\NormalTok{ tallest) }\SpecialCharTok{|}
\NormalTok{       (inches}\SpecialCharTok{/}\FloatTok{2.54} \SpecialCharTok{\textgreater{}=}\NormalTok{ smallest }\SpecialCharTok{\&}\NormalTok{ inches}\SpecialCharTok{/}\FloatTok{2.54} \SpecialCharTok{\textless{}=}\NormalTok{ tallest))}
  \SpecialCharTok{!}\NormalTok{ind}
\NormalTok{\}}

\NormalTok{problems }\OtherTok{\textless{}{-}}\NormalTok{ reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{not\_inches\_or\_cm}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(height)}
\FunctionTok{length}\NormalTok{(problems)}
\CommentTok{\#\textgreater{} [1] 200}
\end{Highlighting}
\end{Shaded}

Veamos qué proporción de estas se ajusta a nuestro patrón después de los pasos de procesamiento que desarrollamos anteriormente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{converted }\OtherTok{\textless{}{-}}\NormalTok{ problems }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"feet|foot|ft"}\NormalTok{, }\StringTok{"\textquotesingle{}"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# convert feet symbols to \textquotesingle{}}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"inches|in|\textquotesingle{}\textquotesingle{}|}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{""}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \CommentTok{\# remove inches symbols}
  \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"\^{}([4{-}7])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*[,}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{)}\CommentTok{\# change format}

\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\}$"}
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{str\_detect}\NormalTok{(converted, pattern)}
\FunctionTok{mean}\NormalTok{(index)}
\CommentTok{\#\textgreater{} [1] 0.615}
\end{Highlighting}
\end{Shaded}

Observen cómo aprovechamos el \emph{pipe}, una de las ventajas de usar \textbf{stringr}. Este último fragmento de código muestra que encontramos equivalencias en más de la mitad de las cadenas. Examinemos los casos restantes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{converted[}\SpecialCharTok{!}\NormalTok{index]}
\CommentTok{\#\textgreater{}  [1] "6"             "165cm"         "511"           "6"            }
\CommentTok{\#\textgreater{}  [5] "2"             "\textgreater{}9000"         "5 \textquotesingle{} and 8.11 " "11111"        }
\CommentTok{\#\textgreater{}  [9] "6"             "103.2"         "19"            "5"            }
\CommentTok{\#\textgreater{} [13] "300"           "6\textquotesingle{}"            "6"             "Five \textquotesingle{} eight "}
\CommentTok{\#\textgreater{} [17] "7"             "214"           "6"             "0.7"          }
\CommentTok{\#\textgreater{} [21] "6"             "2\textquotesingle{}33"          "612"           "1,70"         }
\CommentTok{\#\textgreater{} [25] "87"            "5\textquotesingle{}7.5"         "5\textquotesingle{}7.5"         "111"          }
\CommentTok{\#\textgreater{} [29] "5\textquotesingle{} 7.78"       "12"            "6"             "yyy"          }
\CommentTok{\#\textgreater{} [33] "89"            "34"            "25"            "6"            }
\CommentTok{\#\textgreater{} [37] "6"             "22"            "684"           "6"            }
\CommentTok{\#\textgreater{} [41] "1"             "1"             "6*12"          "87"           }
\CommentTok{\#\textgreater{} [45] "6"             "1.6"           "120"           "120"          }
\CommentTok{\#\textgreater{} [49] "23"            "1.7"           "6"             "5"            }
\CommentTok{\#\textgreater{} [53] "69"            "5\textquotesingle{} 9 "         "5 \textquotesingle{} 9 "        "6"            }
\CommentTok{\#\textgreater{} [57] "6"             "86"            "708,661"       "5 \textquotesingle{} 6 "       }
\CommentTok{\#\textgreater{} [61] "6"             "649,606"       "10000"         "1"            }
\CommentTok{\#\textgreater{} [65] "728,346"       "0"             "6"             "6"            }
\CommentTok{\#\textgreater{} [69] "6"             "100"           "88"            "6"            }
\CommentTok{\#\textgreater{} [73] "170 cm"        "7,283,465"     "5"             "5"            }
\CommentTok{\#\textgreater{} [77] "34"}
\end{Highlighting}
\end{Shaded}

Surgen cuatro patrones claros:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Muchos estudiantes que miden exactamente 5 o 6 pies no ingresaron ninguna pulgada, por ejemplo \texttt{6\textquotesingle{}}, y nuestro patrón requiere que se incluyan pulgadas.
\item
  Algunos estudiantes que miden exactamente 5 o 6 pies ingresaron solo ese número.
\item
  Algunas de las pulgadas se ingresaron con puntos decimales. Por ejemplo \texttt{5\textquotesingle{}7.5\textquotesingle{}\textquotesingle{}}. Nuestro patrón solo busca dos dígitos.
\item
  Algunas entradas tienen espacios al final, por ejemplo \texttt{5\ \textquotesingle{}\ 9} .
\end{enumerate}

Aunque no es tan común, también vemos los siguientes problemas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Algunas entradas están en metros y algunas usan formatos europeos: \texttt{1.6}, \texttt{1,70}.
\item
  Dos estudiantes añadieron \texttt{cm}.
\item
  Un estudiante deletreó los números: \texttt{Five\ foot\ eight\ inches}.
\end{enumerate}

No está claro que valga la pena escribir código para manejar estos últimos tres casos, ya que son bastante raros. Sin embargo, algunos de ellos nos brindan la oportunidad de aprender algunas técnicas más de expresiones regulares, por lo que crearemos una solución.

Para el caso 1, si agregamos un \texttt{\textquotesingle{}0} después del primer dígito, por ejemplo, convertir todo \texttt{6} a \texttt{6\textquotesingle{}0}, entonces nuestro patrón previamente definido correspondará. Esto se puede hacer usando grupos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5"}\NormalTok{, }\StringTok{"6"}\NormalTok{, }\StringTok{"5"}\NormalTok{)}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}"}\NormalTok{, }\StringTok{"5\textquotesingle{}\textquotesingle{}"}\NormalTok{, }\StringTok{"5\textquotesingle{}4"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_replace}\NormalTok{(s, }\StringTok{"\^{}([4{-}7])$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}0"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "5\textquotesingle{}0" "6\textquotesingle{}0" "5\textquotesingle{}0" "5\textquotesingle{}"  "5\textquotesingle{}\textquotesingle{}" "5\textquotesingle{}4"}
\end{Highlighting}
\end{Shaded}

El patrón dice que tiene que comenzar (\texttt{\^{}}) con un dígito entre 4 y 7 y terminar ahí (\texttt{\$}). El paréntesis define el grupo que pasamos como \texttt{\textbackslash{}\textbackslash{}1} para generar la cadena \emph{regex} que usamos para el reemplazo.

Podemos adaptar este código ligeramente para manejar también el caso 2, que cubre la entrada \texttt{5\textquotesingle{}}. Noten que \texttt{5\textquotesingle{}} se deja intacto. Esto es porque el extra \texttt{\textquotesingle{}} hace que el patrón no corresponda ya que tenemos que terminar con un 5 o 6. Queremos permitir que el 5 o 6 sea seguido por un signo de 0 o 1 pie. Entonces podemos simplemente agregar \texttt{\textquotesingle{}\{0,1\}} después de la \texttt{\textquotesingle{}} para hacer esto. Sin embargo, podemos usar el carácter especial, \texttt{?}, que significa ninguna o una vez. Como vimos anteriormente, esto es diferente a \texttt{*}, que significa ninguna o más. Ahora vemos que el cuarto caso también se convierte:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_replace}\NormalTok{(s, }\StringTok{"\^{}([56])\textquotesingle{}?$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}0"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "5\textquotesingle{}0" "6\textquotesingle{}0" "5\textquotesingle{}0" "5\textquotesingle{}0" "5\textquotesingle{}\textquotesingle{}" "5\textquotesingle{}4"}
\end{Highlighting}
\end{Shaded}

Aquí solo permitimos 5 y 6, pero no 4 y 7. Esto se debe a que medir 5 y 6 pies de altura es bastante común, por lo que suponemos que aquellos que escribieron 5 o 6 realmente querían decir \texttt{60} o \texttt{72} pulgadas. Sin embargo, medir 4 y 7 pies de altura es tan raro que, aunque aceptamos \texttt{84} como una entrada válida, suponemos que \texttt{7} fue ingresado por error.

Podemos usar cuantificadores para tratar el caso 3. Estas entradas no corresponden porque las pulgadas incluyen decimales y nuestro patrón no lo permite. Necesitamos permitir que el segundo grupo incluya decimales, no solo dígitos. Esto significa que debemos permitir cero o un punto \texttt{.}, entonces cero o más dígitos. Por eso, usaremos ambos \texttt{?} y \texttt{*}. También recuerden que, para este caso particular, el punto debe escaparse ya que es un carácter especial (significa cualquier carácter excepto el salto de línea). Aquí hay un ejemplo sencillo de cómo podemos usar \texttt{*}.

Entonces podemos adaptar nuestro patrón, que actualmente es \texttt{\^{}{[}4-7{]}\textbackslash{}\textbackslash{}s*\textquotesingle{}\textbackslash{}\textbackslash{}s*\textbackslash{}\textbackslash{}d\{1,2\}\$} para permitir un decimal al final:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.?}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}
\end{Highlighting}
\end{Shaded}

Podemos tratar el caso 4, metros usando comas, de manera similar a cómo convertimos el \texttt{x.y} a \texttt{x\textquotesingle{}y}. Una diferencia es que requerimos que el primer dígito sea 1 o 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1,7"}\NormalTok{, }\StringTok{"1, 8"}\NormalTok{, }\StringTok{"2, "}\NormalTok{ )}
\NormalTok{no }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5,8"}\NormalTok{, }\StringTok{"5,3,2"}\NormalTok{, }\StringTok{"1.7"}\NormalTok{)}
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(yes, no)}
\FunctionTok{str\_replace}\NormalTok{(s, }\StringTok{"\^{}([12])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*,}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "1.7"   "1.8"   "2."    "5,8"   "5,3,2" "1.7"}
\end{Highlighting}
\end{Shaded}

Luego verificaremos si las entradas son metros utilizando sus valores numéricos. Regresaremos al estudio de caso después de presentar dos funciones ampliamente utilizadas en el procesamiento de cadenas que serán útiles al desarrollar nuestra solución final para las alturas autoreportadas.

\hypertarget{podar}{%
\section{Podar}\label{podar}}

En general, los espacios al principio o al final de la cadena no son informativos.
Estos pueden ser particularmente engañosos porque a veces pueden ser difíciles de ver:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \StringTok{"Hi "}
\FunctionTok{cat}\NormalTok{(s)}
\CommentTok{\#\textgreater{} Hi}
\FunctionTok{identical}\NormalTok{(s, }\StringTok{"Hi"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] FALSE}
\end{Highlighting}
\end{Shaded}

Este es un problema lo suficientemente general como para que haya una función dedicada a eliminarlos: \texttt{str\_trim}. El nombre viene de \emph{trim} o podar en inglés.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_trim}\NormalTok{(}\StringTok{"5 \textquotesingle{} 9 "}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "5 \textquotesingle{} 9"}
\end{Highlighting}
\end{Shaded}

\hypertarget{cuxf3mo-cambiar-de-mayuxfasculas-o-minuxfasculas}{%
\section{Cómo cambiar de mayúsculas o minúsculas}\label{cuxf3mo-cambiar-de-mayuxfasculas-o-minuxfasculas}}

Tengan en cuenta que \emph{regex} distingue entre mayúsculas y minúsculas. A menudo queremos encontrar una equivalencia de palabra independientemente de si es mayúscula o minúscula. Un acercamiento para hacer esto es primero cambiar todo a minúsculas y luego continuar ignorando mayúsculas y minúsculas. Como ejemplo, noten que una de las entradas escribe números como palabras \texttt{Five\ foot\ eight\ inches}. Aunque no es eficiente, podríamos agregar 13 llamadas adicionales a \texttt{str\_replace} para convertir \texttt{zero} a \texttt{0}, \texttt{one} a \texttt{1}, y así. Para no tener que escribir dos operaciones separadas para \texttt{Zero} y \texttt{zero}, \texttt{One} y \texttt{one}, etc., podemos usar la función \texttt{str\_to\_lower} para convertir todas las letras a minúsculas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Five feet eight inches"}\NormalTok{)}
\FunctionTok{str\_to\_lower}\NormalTok{(s)}
\CommentTok{\#\textgreater{} [1] "five feet eight inches"}
\end{Highlighting}
\end{Shaded}

Otras funciones relacionadas son \texttt{str\_to\_upper} y \texttt{str\_to\_title}. Ahora estamos listos para definir un procedimiento que convierta todos los casos problemáticos a pulgadas.

\hypertarget{estudio-de-caso-2-alturas-autoreportadas-continuaciuxf3n}{%
\section{Estudio de caso 2: alturas autoreportadas (continuación)}\label{estudio-de-caso-2-alturas-autoreportadas-continuaciuxf3n}}

Ahora ponemos todo lo que hemos aprendido en una función que toma un vector de cadena e intenta convertir todas las cadenas posibles a un formato. Escribimos una función que reúne lo que hemos hecho anteriormente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{convert\_format }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(s)\{}
\NormalTok{  s }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"feet|foot|ft"}\NormalTok{, }\StringTok{"\textquotesingle{}"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_replace\_all}\NormalTok{(}\StringTok{"inches|in|\textquotesingle{}\textquotesingle{}|}\SpecialCharTok{\textbackslash{}"}\StringTok{|cm|and"}\NormalTok{, }\StringTok{""}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"\^{}([4{-}7])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*[,}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"\^{}([56])\textquotesingle{}?$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1\textquotesingle{}0"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_replace}\NormalTok{(}\StringTok{"\^{}([12])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*,}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}\NormalTok{, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{1}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_trim}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

También podemos escribir una función que convierta palabras en números:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(english)}
\NormalTok{words\_to\_numbers }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(s)\{}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{str\_to\_lower}\NormalTok{(s)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{11}\NormalTok{)}
\NormalTok{    s }\OtherTok{\textless{}{-}} \FunctionTok{str\_replace\_all}\NormalTok{(s, }\FunctionTok{words}\NormalTok{(i), }\FunctionTok{as.character}\NormalTok{(i))}
\NormalTok{  s}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que podemos realizar la operación anterior de manera más eficiente con la función \texttt{recode}, que estudiaremos en la Sección \ref{recode}.
Ahora podemos ver qué entradas problemáticas permanecen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{converted }\OtherTok{\textless{}{-}}\NormalTok{ problems }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{words\_to\_numbers}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{convert\_format}\NormalTok{()}
\NormalTok{remaining\_problems }\OtherTok{\textless{}{-}}\NormalTok{ converted[}\FunctionTok{not\_inches\_or\_cm}\NormalTok{(converted)]}
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}[4{-}7]}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.?}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*$"}
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{str\_detect}\NormalTok{(remaining\_problems, pattern)}
\NormalTok{remaining\_problems[}\SpecialCharTok{!}\NormalTok{index]}
\CommentTok{\#\textgreater{}  [1] "511"       "2"         "\textgreater{}9000"     "11111"     "103.2"    }
\CommentTok{\#\textgreater{}  [6] "19"        "300"       "7"         "214"       "0.7"      }
\CommentTok{\#\textgreater{} [11] "2\textquotesingle{}33"      "612"       "1.70"      "87"        "111"      }
\CommentTok{\#\textgreater{} [16] "12"        "yyy"       "89"        "34"        "25"       }
\CommentTok{\#\textgreater{} [21] "22"        "684"       "1"         "1"         "6*12"     }
\CommentTok{\#\textgreater{} [26] "87"        "1.6"       "120"       "120"       "23"       }
\CommentTok{\#\textgreater{} [31] "1.7"       "86"        "708,661"   "649,606"   "10000"    }
\CommentTok{\#\textgreater{} [36] "1"         "728,346"   "0"         "100"       "88"       }
\CommentTok{\#\textgreater{} [41] "7,283,465" "34"}
\end{Highlighting}
\end{Shaded}

Además de los casos ingresados como metros, que solucionaremos a continuación, todos parecen ser casos imposibles de resolver.

\hypertarget{la-funciuxf3n-extract}{%
\subsection{\texorpdfstring{La función \texttt{extract}}{La función extract}}\label{la-funciuxf3n-extract}}

La función \texttt{extract} de \textbf{tidyverse} es util para el procesamiento de cadenas que usaremos en nuestra solución final y, por ende, la presentamos aquí. En una sección anterior, construimos una expresión regular que nos permite identificar qué elementos de un vector de caracteres corresponden con el patrón de pies y pulgadas. Sin embargo, queremos hacer más. Queremos extraer y guardar los pies y los valores numéricos para poder convertirlos en pulgadas cuando sea apropiado.

Consideremos este ejemplo sencillo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}10"}\NormalTok{, }\StringTok{"6\textquotesingle{}1"}\NormalTok{)}
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ s)}
\end{Highlighting}
\end{Shaded}

En la Sección \ref{separate}, aprendimos sobre la función \texttt{separate}, que se puede utilizar para lograr nuestro objetivo actual:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(x, }\FunctionTok{c}\NormalTok{(}\StringTok{"feet"}\NormalTok{, }\StringTok{"inches"}\NormalTok{), }\AttributeTok{sep =} \StringTok{"\textquotesingle{}"}\NormalTok{)}
\CommentTok{\#\textgreater{}   feet inches}
\CommentTok{\#\textgreater{} 1    5     10}
\CommentTok{\#\textgreater{} 2    6      1}
\end{Highlighting}
\end{Shaded}

La función \texttt{extract} del paquete \textbf{tidyr} nos permite usar grupos \emph{regex} para extraer los valores deseados. Aquí está el equivalente al código anterior que usa \texttt{separate}, pero ahora usando \texttt{extract}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyr)}
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{extract}\NormalTok{(x, }\FunctionTok{c}\NormalTok{(}\StringTok{"feet"}\NormalTok{, }\StringTok{"inches"}\NormalTok{), }\AttributeTok{regex =} \StringTok{"(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d)\textquotesingle{}(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\})"}\NormalTok{)}
\CommentTok{\#\textgreater{}   feet inches}
\CommentTok{\#\textgreater{} 1    5     10}
\CommentTok{\#\textgreater{} 2    6      1}
\end{Highlighting}
\end{Shaded}

Entonces, ¿por qué necesitamos la nueva función \texttt{extract}? Hemos visto cómo pequeños cambios pueden conducir a no tener equivalencias exactas. Los grupos en \emph{regex} nos dan más flexibilidad. Por ejemplo, si definimos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"5\textquotesingle{}10"}\NormalTok{, }\StringTok{"6\textquotesingle{}1}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\NormalTok{,}\StringTok{"5\textquotesingle{}8inches"}\NormalTok{)}
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ s)}
\end{Highlighting}
\end{Shaded}

y solo queremos los números, \texttt{separate} no lo logra:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{separate}\NormalTok{(x, }\FunctionTok{c}\NormalTok{(}\StringTok{"feet"}\NormalTok{,}\StringTok{"inches"}\NormalTok{), }\AttributeTok{sep =} \StringTok{"\textquotesingle{}"}\NormalTok{, }\AttributeTok{fill =} \StringTok{"right"}\NormalTok{)}
\CommentTok{\#\textgreater{}   feet  inches}
\CommentTok{\#\textgreater{} 1    5      10}
\CommentTok{\#\textgreater{} 2    6      1"}
\CommentTok{\#\textgreater{} 3    5 8inches}
\end{Highlighting}
\end{Shaded}

Sin embargo, podemos usar \texttt{extract}. La \emph{regex} aquí es un poco más complicada ya que tenemos que permitir \texttt{\textquotesingle{}} con espacios y \texttt{feet}. Tampoco queremos el \texttt{"} incluido en el valor, por lo que no lo incluimos en el grupo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{extract}\NormalTok{(x, }\FunctionTok{c}\NormalTok{(}\StringTok{"feet"}\NormalTok{, }\StringTok{"inches"}\NormalTok{), }\AttributeTok{regex =} \StringTok{"(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d)\textquotesingle{}(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d\{1,2\})"}\NormalTok{)}
\CommentTok{\#\textgreater{}   feet inches}
\CommentTok{\#\textgreater{} 1    5     10}
\CommentTok{\#\textgreater{} 2    6      1}
\CommentTok{\#\textgreater{} 3    5      8}
\end{Highlighting}
\end{Shaded}

\hypertarget{juntando-todas-la-piezas}{%
\subsection{Juntando todas la piezas}\label{juntando-todas-la-piezas}}

Ahora estamos listos para juntar todas las piezas y discutir nuestros datos de alturas reportados para tratar de recuperar todas las alturas posibles. El código es complejo, pero lo dividiremos en partes.

Comenzamos limpiando la columna \texttt{height} para que las alturas estén más cerca de un formato de pulgadas y pies. Agregamos una columna con las alturas originales para luego poder comparar.

Ahora estamos listos para \emph{wrangle} nuestro set de datos de alturas reportadas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pattern }\OtherTok{\textless{}{-}} \StringTok{"\^{}([4{-}7])}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*\textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s*(}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{.?}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d*)$"}

\NormalTok{smallest }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{tallest }\OtherTok{\textless{}{-}} \DecValTok{84}
\NormalTok{new\_heights }\OtherTok{\textless{}{-}}\NormalTok{ reported\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{original =}\NormalTok{ height,}
         \AttributeTok{height =} \FunctionTok{words\_to\_numbers}\NormalTok{(height) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{convert\_format}\NormalTok{()) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{extract}\NormalTok{(height, }\FunctionTok{c}\NormalTok{(}\StringTok{"feet"}\NormalTok{, }\StringTok{"inches"}\NormalTok{), }\AttributeTok{regex =}\NormalTok{ pattern, }\AttributeTok{remove =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate\_at}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"height"}\NormalTok{, }\StringTok{"feet"}\NormalTok{, }\StringTok{"inches"}\NormalTok{), as.numeric) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{guess =} \DecValTok{12} \SpecialCharTok{*}\NormalTok{ feet }\SpecialCharTok{+}\NormalTok{ inches) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{height =} \FunctionTok{case\_when}\NormalTok{(}
    \FunctionTok{is.na}\NormalTok{(height) }\SpecialCharTok{\textasciitilde{}} \FunctionTok{as.numeric}\NormalTok{(}\ConstantTok{NA}\NormalTok{),}
    \FunctionTok{between}\NormalTok{(height, smallest, tallest) }\SpecialCharTok{\textasciitilde{}}\NormalTok{ height, }\CommentTok{\#inches}
    \FunctionTok{between}\NormalTok{(height}\SpecialCharTok{/}\FloatTok{2.54}\NormalTok{, smallest, tallest) }\SpecialCharTok{\textasciitilde{}}\NormalTok{ height}\SpecialCharTok{/}\FloatTok{2.54}\NormalTok{, }\CommentTok{\#cm}
    \FunctionTok{between}\NormalTok{(height}\SpecialCharTok{*}\DecValTok{100}\SpecialCharTok{/}\FloatTok{2.54}\NormalTok{, smallest, tallest) }\SpecialCharTok{\textasciitilde{}}\NormalTok{ height}\SpecialCharTok{*}\DecValTok{100}\SpecialCharTok{/}\FloatTok{2.54}\NormalTok{, }\CommentTok{\#meters}
    \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}} \FunctionTok{as.numeric}\NormalTok{(}\ConstantTok{NA}\NormalTok{))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{height =} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(height) }\SpecialCharTok{\&}
\NormalTok{                           inches }\SpecialCharTok{\textless{}} \DecValTok{12} \SpecialCharTok{\&} \FunctionTok{between}\NormalTok{(guess, smallest, tallest),}
\NormalTok{                         guess, height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{guess)}
\end{Highlighting}
\end{Shaded}

Podemos verificar todas las entradas que convertimos al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{not\_inches}\NormalTok{(original)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(original, height) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(height) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{View}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Una observación final es que si miramos a los estudiantes más bajos de nuestro curso:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(height) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{(}\AttributeTok{n=}\DecValTok{7}\NormalTok{)}
\CommentTok{\#\textgreater{}            time\_stamp    sex height feet inches original}
\CommentTok{\#\textgreater{} 1 2017{-}07{-}04 01:30:25   Male   50.0   NA     NA       50}
\CommentTok{\#\textgreater{} 2 2017{-}09{-}07 10:40:35   Male   50.0   NA     NA       50}
\CommentTok{\#\textgreater{} 3 2014{-}09{-}02 15:18:30 Female   51.0   NA     NA       51}
\CommentTok{\#\textgreater{} 4 2016{-}06{-}05 14:07:20 Female   52.0   NA     NA       52}
\CommentTok{\#\textgreater{} 5 2016{-}06{-}05 14:07:38 Female   52.0   NA     NA       52}
\CommentTok{\#\textgreater{} 6 2014{-}09{-}23 03:39:56 Female   53.0   NA     NA       53}
\CommentTok{\#\textgreater{} 7 2015{-}01{-}07 08:57:29   Male   53.8   NA     NA    53.77}
\end{Highlighting}
\end{Shaded}

Vemos alturas de \texttt{51}, \texttt{52} y \texttt{53}. Estas alturas tan bajas son raras y es probable que los estudiantes realmente querían escribir \texttt{5\textquotesingle{}1}, \texttt{5\textquotesingle{}2} y \texttt{5\textquotesingle{}3}. Debido a que no estamos completamente seguros, los dejaremos como se reportaron. El objeto \texttt{new\_heights} contiene nuestra solución final para este caso de estudio.

\hypertarget{divisiuxf3n-de-cadenas}{%
\section{División de cadenas}\label{divisiuxf3n-de-cadenas}}

Otra operación de \emph{wrangling} de datos muy común es la división de cadenas. Para ilustrar cómo surge esto, comenzaremos con un ejemplo ilustrativo. Supongan que no tenemos la función \texttt{read\_csv} o \texttt{read.csv} disponible. En cambio, tenemos que leer un archivo csv usando la función de base R \texttt{readLines} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filename }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata/murders.csv"}\NormalTok{, }\AttributeTok{package =} \StringTok{"dslabs"}\NormalTok{)}
\NormalTok{lines }\OtherTok{\textless{}{-}} \FunctionTok{readLines}\NormalTok{(filename)}
\end{Highlighting}
\end{Shaded}

Esta función lee los datos línea por línea para crear un vector de cadenas. En este caso, una cadena para cada fila en la hoja de cálculo. Las primeras seis líneas son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lines }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "state,abb,region,population,total"}
\CommentTok{\#\textgreater{} [2] "Alabama,AL,South,4779736,135"     }
\CommentTok{\#\textgreater{} [3] "Alaska,AK,West,710231,19"         }
\CommentTok{\#\textgreater{} [4] "Arizona,AZ,West,6392017,232"      }
\CommentTok{\#\textgreater{} [5] "Arkansas,AR,South,2915918,93"     }
\CommentTok{\#\textgreater{} [6] "California,CA,West,37253956,1257"}
\end{Highlighting}
\end{Shaded}

Queremos extraer los valores que están separados por una coma para cada cadena en el vector. El comando \texttt{str\_split} hace exactamente esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{str\_split}\NormalTok{(lines, }\StringTok{","}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [[1]]}
\CommentTok{\#\textgreater{} [1] "state"      "abb"        "region"     "population" "total"     }
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]]}
\CommentTok{\#\textgreater{} [1] "Alabama" "AL"      "South"   "4779736" "135"}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que la primera entrada representa el nombre de las columnas, por lo que podemos separarlas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{col\_names }\OtherTok{\textless{}{-}}\NormalTok{ x[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Para convertir nuestra lista en un \emph{data frame}, podemos usar un atajo ofrecido por la función \texttt{map} en el paquete \textbf{purrr}. La función \texttt{map} aplica la misma función a cada elemento en una lista. Entonces, si queremos extraer la primera entrada de cada elemento en \texttt{x}, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(purrr)}
\FunctionTok{map}\NormalTok{(x, }\ControlFlowTok{function}\NormalTok{(y) y[}\DecValTok{1}\NormalTok{]) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [[1]]}
\CommentTok{\#\textgreater{} [1] "Alabama"}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]]}
\CommentTok{\#\textgreater{} [1] "Alaska"}
\end{Highlighting}
\end{Shaded}

Sin embargo, debido a que esta es una tarea tan común, \textbf{purrr} provee un atajo. Si el segundo argumento recibe un número entero en lugar de una función, supondrá que queremos esa entrada. Entonces, el código anterior se puede escribir de manera más eficiente así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map}\NormalTok{(x, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para forzar \texttt{map} a devolver un vector de caracteres en lugar de una lista, podemos usar \texttt{map\_chr}. Asimismo, \texttt{map\_int} devuelve enteros. Entonces, para crear nuestro \emph{data frame}, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\FunctionTok{map\_chr}\NormalTok{(x, }\DecValTok{1}\NormalTok{),}
              \FunctionTok{map\_chr}\NormalTok{(x, }\DecValTok{2}\NormalTok{),}
              \FunctionTok{map\_chr}\NormalTok{(x, }\DecValTok{3}\NormalTok{),}
              \FunctionTok{map\_chr}\NormalTok{(x, }\DecValTok{4}\NormalTok{),}
              \FunctionTok{map\_chr}\NormalTok{(x, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate\_all}\NormalTok{(parse\_guess) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(col\_names)}
\NormalTok{dat }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ head}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 5}
\CommentTok{\#\textgreater{}   state      abb   region population total}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}      \textless{}chr\textgreater{} \textless{}chr\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Alabama    AL    South     4779736   135}
\CommentTok{\#\textgreater{} 2 Alaska     AK    West       710231    19}
\CommentTok{\#\textgreater{} 3 Arizona    AZ    West      6392017   232}
\CommentTok{\#\textgreater{} 4 Arkansas   AR    South     2915918    93}
\CommentTok{\#\textgreater{} 5 California CA    West     37253956  1257}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

Si exploran el paquete \textbf{purrr}, aprenderán que es posible realizar lo anterior con el siguiente código, que es más eficiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{transpose}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{map}\NormalTok{( }\SpecialCharTok{\textasciitilde{}} \FunctionTok{parse\_guess}\NormalTok{(}\FunctionTok{unlist}\NormalTok{(.))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(col\_names) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{as\_tibble}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Resulta que podemos evitar todo el trabajo que mostramos arriba después de la llamada a \texttt{str\_split}. Específicamente, si sabemos que los datos que estamos extrayendo se pueden representar como una tabla, podemos usar el argumento \texttt{simplify=TRUE} y \texttt{str\_split} devuelve una matriz en lugar de una lista:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{str\_split}\NormalTok{(lines, }\StringTok{","}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{col\_names }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{1}\NormalTok{,]}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,]}
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}}\NormalTok{ col\_names}
\NormalTok{x }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate\_all}\NormalTok{(parse\_guess) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{head}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 5}
\CommentTok{\#\textgreater{}   state      abb   region population total}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}      \textless{}chr\textgreater{} \textless{}chr\textgreater{}       \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Alabama    AL    South     4779736   135}
\CommentTok{\#\textgreater{} 2 Alaska     AK    West       710231    19}
\CommentTok{\#\textgreater{} 3 Arizona    AZ    West      6392017   232}
\CommentTok{\#\textgreater{} 4 Arkansas   AR    South     2915918    93}
\CommentTok{\#\textgreater{} 5 California CA    West     37253956  1257}
\end{Highlighting}
\end{Shaded}

\hypertarget{estudio-de-caso-3-extracciuxf3n-de-tablas-de-un-pdf}{%
\section{Estudio de caso 3: extracción de tablas de un PDF}\label{estudio-de-caso-3-extracciuxf3n-de-tablas-de-un-pdf}}

Uno de los sets de datos de \textbf{dslabs} muestra las tasas de financiación científica por género en los Países Bajos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"research\_funding\_rates"}\NormalTok{)}
\NormalTok{research\_funding\_rates }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(}\StringTok{"discipline"}\NormalTok{, }\StringTok{"success\_rates\_men"}\NormalTok{, }\StringTok{"success\_rates\_women"}\NormalTok{)}
\CommentTok{\#\textgreater{}            discipline success\_rates\_men success\_rates\_women}
\CommentTok{\#\textgreater{} 1   Chemical sciences              26.5                25.6}
\CommentTok{\#\textgreater{} 2   Physical sciences              19.3                23.1}
\CommentTok{\#\textgreater{} 3             Physics              26.9                22.2}
\CommentTok{\#\textgreater{} 4          Humanities              14.3                19.3}
\CommentTok{\#\textgreater{} 5  Technical sciences              15.9                21.0}
\CommentTok{\#\textgreater{} 6   Interdisciplinary              11.4                21.8}
\CommentTok{\#\textgreater{} 7 Earth/life sciences              24.4                14.3}
\CommentTok{\#\textgreater{} 8     Social sciences              15.3                11.5}
\CommentTok{\#\textgreater{} 9    Medical sciences              18.8                11.2}
\end{Highlighting}
\end{Shaded}

Los datos provienen de un artículo publicado en \emph{Proceedings of the National Academy of Science} (PNAS)\footnote{\url{http://www.pnas.org/content/112/40/12349.abstract}}, una revista científica ampliamente leída. Sin embargo, los datos no se proveen en una hoja de cálculo, sino en una tabla en un documento PDF. Aquí hay una captura de pantalla de la tabla:

\begin{center}\includegraphics[width=0.6\linewidth]{wrangling/img//pnas-table-s1} \end{center}

(Fuente: Romy van der Lee y Naomi Ellemers, PNAS 2015 112 (40) 12349-12353\footnote{\url{http://www.pnas.org/content/112/40/12349}}.)

Podríamos extraer los números a mano, pero esto podría conducir a errores humanos. En cambio, podemos intentar cambiar los datos con R. Comenzamos descargando el documento PDF y luego importándolo a R:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"pdftools"}\NormalTok{)}
\NormalTok{temp\_file }\OtherTok{\textless{}{-}} \FunctionTok{tempfile}\NormalTok{()}
\NormalTok{url }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"https://www.pnas.org/content/suppl/2015/09/16/"}\NormalTok{,}
              \StringTok{"1510159112.DCSupplemental/pnas.201510159SI.pdf"}\NormalTok{)}
\FunctionTok{download.file}\NormalTok{(url, temp\_file)}
\NormalTok{txt }\OtherTok{\textless{}{-}} \FunctionTok{pdf\_text}\NormalTok{(temp\_file)}
\FunctionTok{file.remove}\NormalTok{(temp\_file)}
\end{Highlighting}
\end{Shaded}

Si examinamos el objeto \texttt{txt}, notamos que es un vector de caracteres con una entrada para cada página. Entonces mantenemos la página que queremos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{raw\_data\_research\_funding\_rates }\OtherTok{\textless{}{-}}\NormalTok{ txt[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Los pasos anteriores se pueden omitir porque también incluimos estos datos sin procesar en el paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"raw\_data\_research\_funding\_rates"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Al examinar el objeto \texttt{raw\_data\_research\_funding\_rates}, vemos que es una cadena larga y cada línea de la página, incluyendo las filas de la tabla, están separadas por el símbolo de nueva línea: \texttt{\textbackslash{}n}. Por lo tanto, podemos crear una lista con las líneas del texto como elementos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{str\_split}\NormalTok{(raw\_data\_research\_funding\_rates, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Debido a que comenzamos con solo un elemento en la cadena, terminamos con una lista con solo una entrada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}}\NormalTok{ tab[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Al examinar \texttt{tab}, vemos que la información para los nombres de columna son la tercera y cuarta entrada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the\_names\_1 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{3}\NormalTok{]}
\NormalTok{the\_names\_2 }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

La primera de estas filas se ve así:

\begin{verbatim}
#>                                                       Applications, n
#>                   Awards, n                      Success rates, %
\end{verbatim}

Queremos crear un vector con un nombre para cada columna. Podemos hacerlo usando algunas de las funciones que acabamos de aprender. Empecemos con \texttt{the\_names\_1}, que mostramos arriba. Queremos eliminar el espacio inicial y todo lo que sigue a la coma. Utilizamos \emph{regex} para este último. Entonces podemos obtener los elementos dividiendo cadenas separadas por espacio. Queremos dividir solo cuando hay 2 o más espacios para no dividir \texttt{Success\ rates}. Para esto usamos la expresión regular \texttt{\textbackslash{}\textbackslash{}s\{2,\}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the\_names\_1 }\OtherTok{\textless{}{-}}\NormalTok{ the\_names\_1 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_trim}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace\_all}\NormalTok{(}\StringTok{",}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s."}\NormalTok{, }\StringTok{""}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_split}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s\{2,\}"}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{the\_names\_1}
\CommentTok{\#\textgreater{}      [,1]           [,2]     [,3]           }
\CommentTok{\#\textgreater{} [1,] "Applications" "Awards" "Success rates"}
\end{Highlighting}
\end{Shaded}

Ahora examinaremos \texttt{the\_names\_2}:

\begin{verbatim}
#>                         Discipline              Total     Men      Women
#> n         Total    Men       Women          Total    Men      Women
\end{verbatim}

Aquí queremos podar el espacio inicial y buscar usar espacios para dividir las cadenas como lo hicimos para la primera línea:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the\_names\_2 }\OtherTok{\textless{}{-}}\NormalTok{ the\_names\_2 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_trim}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_split}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+"}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{the\_names\_2}
\CommentTok{\#\textgreater{}      [,1]         [,2]    [,3]  [,4]    [,5]    [,6]  [,7]    [,8]   }
\CommentTok{\#\textgreater{} [1,] "Discipline" "Total" "Men" "Women" "Total" "Men" "Women" "Total"}
\CommentTok{\#\textgreater{}      [,9]  [,10]  }
\CommentTok{\#\textgreater{} [1,] "Men" "Women"}
\end{Highlighting}
\end{Shaded}

Entonces podemos unirlos para generar un nombre para cada columna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp\_names }\OtherTok{\textless{}{-}} \FunctionTok{str\_c}\NormalTok{(}\FunctionTok{rep}\NormalTok{(the\_names\_1, }\AttributeTok{each =} \DecValTok{3}\NormalTok{), the\_names\_2[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{], }\AttributeTok{sep =} \StringTok{"\_"}\NormalTok{)}
\NormalTok{the\_names }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(the\_names\_2[}\DecValTok{1}\NormalTok{], tmp\_names) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_to\_lower}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_replace\_all}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s"}\NormalTok{, }\StringTok{"\_"}\NormalTok{)}
\NormalTok{the\_names}
\CommentTok{\#\textgreater{}  [1] "discipline"          "applications\_total"  "applications\_men"   }
\CommentTok{\#\textgreater{}  [4] "applications\_women"  "awards\_total"        "awards\_men"         }
\CommentTok{\#\textgreater{}  [7] "awards\_women"        "success\_rates\_total" "success\_rates\_men"  }
\CommentTok{\#\textgreater{} [10] "success\_rates\_women"}
\end{Highlighting}
\end{Shaded}

Ahora estamos listos para obtener los datos reales. Al examinar el objeto \texttt{tab}, notamos que la información está en las líneas 6 a 14. Podemos usar \texttt{str\_split} de nuevo para lograr nuestro objetivo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_research\_funding\_rates }\OtherTok{\textless{}{-}}\NormalTok{ tab[}\DecValTok{6}\SpecialCharTok{:}\DecValTok{14}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  str\_trim }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{str\_split}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s\{2,\}"}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{setNames}\NormalTok{(the\_names) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate\_at}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, parse\_number)}
\NormalTok{new\_research\_funding\_rates }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\CommentTok{\#\textgreater{} \# A tibble: 9 x 10}
\CommentTok{\#\textgreater{}   discipline       applications\_total applications\_men applications\_wom\textasciitilde{}}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                         \textless{}dbl\textgreater{}            \textless{}dbl\textgreater{}             \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Chemical scienc\textasciitilde{}                122               83                39}
\CommentTok{\#\textgreater{} 2 Physical scienc\textasciitilde{}                174              135                39}
\CommentTok{\#\textgreater{} 3 Physics                          76               67                 9}
\CommentTok{\#\textgreater{} 4 Humanities                      396              230               166}
\CommentTok{\#\textgreater{} 5 Technical scien\textasciitilde{}                251              189                62}
\CommentTok{\#\textgreater{} \# ... with 4 more rows, and 6 more variables: awards\_total \textless{}dbl\textgreater{},}
\CommentTok{\#\textgreater{} \#   awards\_men \textless{}dbl\textgreater{}, awards\_women \textless{}dbl\textgreater{}, success\_rates\_total \textless{}dbl\textgreater{},}
\CommentTok{\#\textgreater{} \#   success\_rates\_men \textless{}dbl\textgreater{}, success\_rates\_women \textless{}dbl\textgreater{}}
\end{Highlighting}
\end{Shaded}

Podemos ver que los objetos son idénticos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{identical}\NormalTok{(research\_funding\_rates, new\_research\_funding\_rates)}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{recode}{%
\section{Recodificación}\label{recode}}

Otra operación común que involucra cadenas es recodificar los nombres de variables categóricas. Supongan que tienen nombres largos para sus niveles y los mostrarán en gráficos. Es posible que quieran utilizar versiones más cortas de estos nombres. Por ejemplo, en los vectores de caracteres con nombres de países, es posible que quieran cambiar ``Estados Unidos de América'' a ``Estados Unidos'', ``Reino Unido'' a ``RU'' y así sucesivamente. Podemos hacer esto con \texttt{case\_when}, aunque \textbf{tidyverse} ofrece una opción específicamente diseñada para esta tarea: la función \texttt{recode}.

Aquí hay un ejemplo que muestra cómo cambiar el nombre de los países con nombres largos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"gapminder"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Imaginen que queremos mostrar series temporales de esperanza de vida por país para el Caribe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(region }\SpecialCharTok{==} \StringTok{"Caribbean"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, life\_expectancy, }\AttributeTok{color =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/caribbean-1} \end{center}

El gráfico es lo que queremos, pero gran parte del espacio se desperdicia para acomodar algunos de los nombres largos de los países.
Tenemos cuatro países con nombres de más de 12 caracteres. Estos nombres aparecen una vez por cada año en el set de datos Gapminder. Una vez que elegimos los apodos, debemos cambiarlos todos de manera consistente. La función \texttt{recode} se puede utilizar para hacer esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gapminder }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(region}\SpecialCharTok{==}\StringTok{"Caribbean"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{country =} \FunctionTok{recode}\NormalTok{(country,}
                          \StringTok{\textasciigrave{}}\AttributeTok{Antigua and Barbuda}\StringTok{\textasciigrave{}} \OtherTok{=} \StringTok{"Barbuda"}\NormalTok{,}
                          \StringTok{\textasciigrave{}}\AttributeTok{Dominican Republic}\StringTok{\textasciigrave{}} \OtherTok{=} \StringTok{"DR"}\NormalTok{,}
                          \StringTok{\textasciigrave{}}\AttributeTok{St. Vincent and the Grenadines}\StringTok{\textasciigrave{}} \OtherTok{=} \StringTok{"St. Vincent"}\NormalTok{,}
                          \StringTok{\textasciigrave{}}\AttributeTok{Trinidad and Tobago}\StringTok{\textasciigrave{}} \OtherTok{=} \StringTok{"Trinidad"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(year, life\_expectancy, }\AttributeTok{color =}\NormalTok{ country)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/caribbean-with-nicknames-1} \end{center}

Hay otras funciones similares en otros paquetes de R, como \texttt{recode\_factor} y \texttt{fct\_recoder} en el paquete \textbf{forcats}.

\hypertarget{ejercicios-41}{%
\section{Ejercicios}\label{ejercicios-41}}

1. Complete todas las lecciones y ejercicios en el tutorial interactivo en línea \url{https://regexone.com/}.

2. En el directorio \texttt{extdata} del paquete \textbf{dslabs}, encontrará un archivo PDF que contiene datos de mortalidad diaria para Puerto Rico del 1 de enero de 2015 al 31 de mayo de 2018. Puede encontrar el archivo así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fn }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\StringTok{"RD{-}Mortality{-}Report\_2015{-}18{-}180531.pdf"}\NormalTok{,}
                  \AttributeTok{package=}\StringTok{"dslabs"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system2}\NormalTok{(}\StringTok{"open"}\NormalTok{, }\AttributeTok{args =}\NormalTok{ fn)}
\end{Highlighting}
\end{Shaded}

y en Windows, puede escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system}\NormalTok{(}\StringTok{"cmd.exe"}\NormalTok{, }\AttributeTok{input =} \FunctionTok{paste}\NormalTok{(}\StringTok{"start"}\NormalTok{, fn))}
\end{Highlighting}
\end{Shaded}

¿Cuál de las siguientes opciones describe mejor este archivo?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Es una tabla. Extraer los datos será fácil.
\item
  Es un informe escrito en prosa. Extraer los datos será imposible.
\item
  Es un informe que combina gráficos y tablas. Extraer los datos parece posible.
\item
  Muestra gráficos de los datos. Extraer los datos será difícil.
\end{enumerate}

3. Vamos a crear un set de datos ordenado con cada fila representando una observación. Las variables en este set de datos serán año, mes, día y muertes.
Comience instalando y cargando el paquete \textbf{pdftools}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"pdftools"}\NormalTok{)}
\FunctionTok{library}\NormalTok{(pdftools)}
\end{Highlighting}
\end{Shaded}

Ahora lean \texttt{fn} utilizando la función \texttt{pdf\_text} y almacene los resultados en un objeto llamado \texttt{txt}. ¿Cuál de las siguientes opciones describe mejor lo que ve en \texttt{txt}?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Una tabla con los datos de mortalidad.
\item
  Una cadena de caracteres de longitud 12. Cada entrada representa el texto en cada página. Los datos de mortalidad están ahí en alguna parte.
\item
  Una cadena de caracteres con una entrada que contiene toda la información en el archivo PDF.
\item
  Un documento HTML.
\end{enumerate}

4. Extraiga la novena página del archivo PDF del objeto \texttt{txt}. Luego, use \texttt{str\_split} del paquete \textbf{stringr} para que cada línea esté en una entrada diferente. Llame a este vector de cadena \texttt{s}. Entonces mire el resultado y elija el que mejor describa lo que ve.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Es una cadena vacía.
\item
  Puedo ver la figura que se muestra en la página 1.
\item
  Es una tabla \emph{tidy}.
\item
  ¡Puedo ver la tabla! Pero hay muchas otras cosas de las que debemos deshacernos.
\end{enumerate}

5. ¿Qué tipo de objeto es \texttt{s} y cuántas entradas tiene?

6. Vemos que el \emph{output} es una lista con un componente. Redefina \texttt{s} para que sea la primera entrada de la lista. ¿Qué tipo de objeto es \texttt{s} y cuántas entradas tiene?

7. Al inspeccionar la cadena que obtuvimos anteriormente, vemos un problema común: espacios en blanco antes y después de los otros caracteres. Podar es un primer paso común en el procesamiento de cadenas. Estos espacios adicionales eventualmente complicarán dividir las cadenas, por lo que comenzamos por eliminarlos. Aprendimos sobre el comando \texttt{str\_trim} que elimina espacios al principio o al final de las cadenas. Use esta función para podar \texttt{s}.

8. Queremos extraer los números de las cadenas almacenadas en \texttt{s}. Sin embargo, hay muchos caracteres no numéricos que se interpondrán en el camino. Podemos eliminarlos, pero antes de hacerlo queremos preservar la cadena con el encabezado de la columna, que incluye la abreviatura del mes.
Utilice la función \texttt{str\_which} para encontrar las filas con un encabezado. Guarde estos resultados en \texttt{header\_index}. Sugerencia: encuentre la primera cadena que corresponda con el patrón \texttt{2015} utilizando la función \texttt{str\_which}.

9. Ahora vamos a definir dos objetos: \texttt{month} almacenará el mes y \texttt{header} almacenará los nombres de columna. Identifique qué fila contiene el encabezado de la tabla. Guarde el contenido de la fila en un objeto llamado \texttt{header}. Luego, use \texttt{str\_split} para ayudar a definir los dos objetos que necesitamos. Sugerencias: el separador aquí es uno o más espacios. Además, considere usar el argumento \texttt{simplify}.

10. Observe que hacia el final de la página verá una fila \emph{totals} seguida de filas con otras estadísticas de resumen. Cree un objeto llamado \texttt{tail\_index} con el índice de la entrada \emph{totals}.

11. Debido a que nuestra página PDF incluye gráficos con números, algunas de nuestras filas tienen solo un número (desde el eje-y del gráfico). Utilice la función \texttt{str\_count} para crear un objeto \texttt{n} con el número de números en cada fila. Sugerencia: escriba una expresión regular para un número como este \texttt{\textbackslash{}\textbackslash{}d+}.

12. Ahora estamos listos para eliminar entradas de filas que sabemos que no necesitamos. La entrada \texttt{header\_index} y todo lo que viene antes se debe eliminar. Entradas para las cuales \texttt{n} es 1 también deben eliminarse. Finalmente, se debe eliminar la entrada \texttt{tail\_index} y todo lo que viene después.

13. Ahora estamos listos para eliminar todas las entradas no numéricas. Haga esto usando \emph{regex} y la función \texttt{str\_remove\_all}. Sugerencia: recuerde que en \emph{regex}, usar la versión en mayúscula de un carácter especial generalmente significa lo contrario. Entonces \texttt{\textbackslash{}\textbackslash{}D} significa ``no un dígito''. Recuerde que también quiere mantener espacios.

14. Para convertir las cadenas en una tabla, use la función \texttt{str\_split\_fixed}. Convierta \texttt{s} en una matriz de datos con solo la fecha y los datos con los números de muertes. Sugerencias: recuerde que el patrón que separa los valores es ``uno o más espacios''. Utilice el argumento \texttt{n} de la función \texttt{str\_split\_fixed} para asegurarse de que la matriz de datos tenga las columnas necesarias para contener la información que queremos conservar y una columna más para capturar todo lo que no queremos. Finalmente, conserve sólo las columnas que necesita.

15. Ahora ya casi ha terminado. Agregue nombres de columna a la matriz, incluyendo uno llamado \texttt{day}. Además, agregue una columna con el mes. Llame al objeto resultante \texttt{dat}. Finalmente, asegúrese de que el día es un número entero, no un carácter. Sugerencia: use solo las primeras cinco columnas.

16. Ahora termine convirtiendo \texttt{tab} a formato \emph{tidy} con la función \texttt{pivot\_longer}.

17. Haga un diagrama de muertes versus día con color para indicar el año. Excluya 2018 ya que no tenemos datos para todo el año.

18. Ahora que hemos \emph{wrangled} estos datos paso a paso, póngalos todos juntos en un programa de R, usando el \emph{pipe} lo mas posible. Sugerencia: primero defina los índices, luego escriba una línea de código que realice todo el procesamiento de la cadena.

19. Avanzado: volvamos al ejemplo de la nómina MLB de la sección ``Extracción de la web''. Use lo que aprendió en los capítulos de extracción de la web y procesamiento de cadenas para extraer la nómina de los Yankees de Nueva York, las Medias Rojas de Boston y los Atléticos de Oakland y grafíquelos como una función del tiempo.

\hypertarget{cuxf3mo-leer-y-procesar-fechas-y-horas}{%
\chapter{Cómo leer y procesar fechas y horas}\label{cuxf3mo-leer-y-procesar-fechas-y-horas}}

\hypertarget{datos-tioo-fecha}{%
\section{Datos tioo fecha}\label{datos-tioo-fecha}}

Hemos descrito tres tipos principales de vectores: numéricos, de caracteres y lógicos. En proyectos de ciencia de datos, a menudo encontramos variables que son fechas. Aunque podemos representar una fecha con una cadena, por ejemplo \texttt{November\ 2,\ 2017}, una vez que elegimos un día de referencia, conocido como la \emph{época Unix} (\emph{epoch} en inglés), se pueden convertir en números calculando el número de días desde la época Unix. Los lenguajes de computadora usualmente usan el 1 de enero de 1970 como la época Unix. Entonces, por ejemplo, el 2 de enero de 2017 es el día 1, el 31 de diciembre de 1969 es el día -1 y el 2 de noviembre de 2017 es el día 17,204.

Ahora, ¿cómo debemos representar fechas y horas al analizar los datos en R? Podríamos usar días desde la \emph{época Unix}, pero es casi imposible de interpretar. Si les digo que es el 2 de noviembre de 2017, saben lo que esto significa inmediatamente. Si les digo que es el día 17,204, estarán bastante confundidos. Problemas similares surgen con la hora e incluso pueden aparecer más complicaciones debido a las zonas horarias.

Por esta razón, R define un tipo de datos solo para fechas y horas. Vimos un ejemplo en los datos de las encuestas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_us\_election\_2016"}\NormalTok{)}
\NormalTok{polls\_us\_election\_2016}\SpecialCharTok{$}\NormalTok{startdate }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ head}
\CommentTok{\#\textgreater{} [1] "2016{-}11{-}03" "2016{-}11{-}01" "2016{-}11{-}02" "2016{-}11{-}04" "2016{-}11{-}03"}
\CommentTok{\#\textgreater{} [6] "2016{-}11{-}03"}
\end{Highlighting}
\end{Shaded}

Estas parecen cadenas, pero no lo son:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(polls\_us\_election\_2016}\SpecialCharTok{$}\NormalTok{startdate)}
\CommentTok{\#\textgreater{} [1] "Date"}
\end{Highlighting}
\end{Shaded}

Miren lo que sucede cuando los convertimos en números:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(polls\_us\_election\_2016}\SpecialCharTok{$}\NormalTok{startdate) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ head}
\CommentTok{\#\textgreater{} [1] 17108 17106 17107 17109 17108 17108}
\end{Highlighting}
\end{Shaded}

Los convierte en días desde la época Unix. La función \texttt{as.Date} puede convertir un carácter en una fecha. Entonces, para ver que la época Unix es el día 0, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.Date}\NormalTok{(}\StringTok{"1970{-}01{-}01"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ as.numeric}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

Funciones que grafican, como las de \textbf{ggplot2}, conocen el formato de fecha. Esto significa que, por ejemplo, un diagrama de dispersión puede usar la representación numérica para decidir la posición del punto, pero incluir la cadena en las etiquetas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(pollster }\SpecialCharTok{==} \StringTok{"Ipsos"} \SpecialCharTok{\&}\NormalTok{ state }\SpecialCharTok{==} \StringTok{"U.S."}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(startdate, rawpoll\_trump)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/rawpolls-vs-time-1} \end{center}

Noten que se muestran los nombres de los meses, una característica muy conveniente.

\hypertarget{lubridate}{%
\section{El paquete lubridate}\label{lubridate}}

El \textbf{tidyverse} incluye funcionalidad para manejar fechas a través del paquete \textbf{lubridate}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(lubridate)}
\end{Highlighting}
\end{Shaded}

Tomaremos una muestra aleatoria de fechas para mostrar algunas de las cosas útiles que uno puede hacer:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2002}\NormalTok{)}
\NormalTok{dates }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(polls\_us\_election\_2016}\SpecialCharTok{$}\NormalTok{startdate, }\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ sort}
\NormalTok{dates}
\CommentTok{\#\textgreater{}  [1] "2016{-}05{-}31" "2016{-}08{-}08" "2016{-}08{-}19" "2016{-}09{-}22" "2016{-}09{-}27"}
\CommentTok{\#\textgreater{}  [6] "2016{-}10{-}12" "2016{-}10{-}24" "2016{-}10{-}26" "2016{-}10{-}29" "2016{-}10{-}30"}
\end{Highlighting}
\end{Shaded}

Las funciones \texttt{year}, \texttt{month} y \texttt{day} extraen esos valores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{date =}\NormalTok{ dates,}
       \AttributeTok{month =} \FunctionTok{month}\NormalTok{(dates),}
       \AttributeTok{day =} \FunctionTok{day}\NormalTok{(dates),}
       \AttributeTok{year =} \FunctionTok{year}\NormalTok{(dates))}
\CommentTok{\#\textgreater{} \# A tibble: 10 x 4}
\CommentTok{\#\textgreater{}   date       month   day  year}
\CommentTok{\#\textgreater{}   \textless{}date\textgreater{}     \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 2016{-}05{-}31     5    31  2016}
\CommentTok{\#\textgreater{} 2 2016{-}08{-}08     8     8  2016}
\CommentTok{\#\textgreater{} 3 2016{-}08{-}19     8    19  2016}
\CommentTok{\#\textgreater{} 4 2016{-}09{-}22     9    22  2016}
\CommentTok{\#\textgreater{} 5 2016{-}09{-}27     9    27  2016}
\CommentTok{\#\textgreater{} \# ... with 5 more rows}
\end{Highlighting}
\end{Shaded}

También podemos extraer las etiquetas del mes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{month}\NormalTok{(dates, }\AttributeTok{label =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1] may ago ago sep sep oct oct oct oct oct}
\CommentTok{\#\textgreater{} 12 Levels: ene \textless{} feb \textless{} mar \textless{} abr \textless{} may \textless{} jun \textless{} jul \textless{} ago \textless{} ... \textless{} dic}
\end{Highlighting}
\end{Shaded}

Otro conjunto útil de funciones son las que convierten cadenas en fechas. La función \texttt{ymd} supone que las fechas están en el formato AAAA-MM-DD e intenta leer y procesar (\emph{parse} en inglés) lo mejor posible.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{20090101}\NormalTok{, }\StringTok{"2009{-}01{-}02"}\NormalTok{, }\StringTok{"2009 01 03"}\NormalTok{, }\StringTok{"2009{-}1{-}4"}\NormalTok{,}
       \StringTok{"2009{-}1, 5"}\NormalTok{, }\StringTok{"Created on 2009 1 6"}\NormalTok{, }\StringTok{"200901 !!! 07"}\NormalTok{)}
\FunctionTok{ymd}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2009{-}01{-}01" "2009{-}01{-}02" "2009{-}01{-}03" "2009{-}01{-}04" "2009{-}01{-}05"}
\CommentTok{\#\textgreater{} [6] "2009{-}01{-}06" "2009{-}01{-}07"}
\end{Highlighting}
\end{Shaded}

Otra complicación proviene del hecho de que las fechas a menudo vienen en diferentes formatos donde el orden de año, mes y día son diferentes. El formato preferido es mostrar año (con los cuatro dígitos), mes (dos dígitos) y luego día (dos dígitos), o lo que se llama ISO 8601. Específicamente, usamos AAAA-MM-DD para que si ordenamos la cadena, estará ordenado por fecha. Pueden ver que la función \texttt{ymd} las devuelve en este formato.

Pero, ¿qué pasa si encuentran fechas como ``01/09/02''? Esto podría ser el 1 de septiembre de 2002 o el 2 de enero de 2009 o el 9 de enero de 2002. En estos casos, examinar todo el vector de fechas los ayudará a determinar qué formato es por proceso de eliminación. Una vez que sepan, pueden usar las muchas funciones ofrecidas por \textbf{lubridate}.

Por ejemplo, si la cadena es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \StringTok{"09/01/02"}
\end{Highlighting}
\end{Shaded}

La función \texttt{ymd} supone que la primera entrada es el año, la segunda es el mes y la tercera es el día, por lo que la convierte a:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ymd}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2009{-}01{-}02"}
\end{Highlighting}
\end{Shaded}

La función \texttt{mdy} supone que la primera entrada es el mes, luego el día y entonces el año:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mdy}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2002{-}09{-}01"}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{lubridate} ofrece una función para cada posibilidad:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ydm}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2009{-}02{-}01"}
\FunctionTok{myd}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2001{-}09{-}02"}
\FunctionTok{dmy}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2002{-}01{-}09"}
\FunctionTok{dym}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2001{-}02{-}09"}
\end{Highlighting}
\end{Shaded}

El paquete \textbf{lubridate} también es útil para lidiar con los tiempos. En base R, pueden obtener la hora actual escribiendo \texttt{Sys.time()}. El paquete \textbf{lubridate} ofrece una función un poco más avanzada, \texttt{now}, que les permite definir la zona horaria:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{now}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] "2021{-}05{-}24 08:09:06 EDT"}
\FunctionTok{now}\NormalTok{(}\StringTok{"GMT"}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "2021{-}05{-}24 12:09:06 GMT"}
\end{Highlighting}
\end{Shaded}

Pueden ver todas las zonas horarias disponibles con la función \texttt{OlsonNames()}.

También podemos extraer horas, minutos y segundos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{now}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{hour}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 8}
\FunctionTok{now}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{minute}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 9}
\FunctionTok{now}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{second}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 6.67}
\end{Highlighting}
\end{Shaded}

El paquete también incluye una función para convertir cadenas en horas del día, así como funciones que convierten objetos que representan horas del día, que además incluyen las fechas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"12:34:56"}\NormalTok{)}
\FunctionTok{hms}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "12H 34M 56S"}
\NormalTok{x }\OtherTok{\textless{}{-}} \StringTok{"Nov/2/2012 12:34:56"}
\FunctionTok{mdy\_hms}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "2012{-}11{-}02 12:34:56 UTC"}
\end{Highlighting}
\end{Shaded}

Este paquete tiene muchas otras funciones útiles. Aquí describimos dos que consideramos particularmente útiles.

La función \texttt{make\_date} se puede utilizar para rápidamente crear un objeto de fecha. Por ejemplo, para crear un objeto de fecha que represente el 6 de julio de 2019, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make\_date}\NormalTok{(}\DecValTok{2019}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] "2019{-}07{-}06"}
\end{Highlighting}
\end{Shaded}

Para hacer un vector del 1 de enero para los años 80 escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make\_date}\NormalTok{(}\DecValTok{1980}\SpecialCharTok{:}\DecValTok{1989}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1] "1980{-}01{-}01" "1981{-}01{-}01" "1982{-}01{-}01" "1983{-}01{-}01" "1984{-}01{-}01"}
\CommentTok{\#\textgreater{}  [6] "1985{-}01{-}01" "1986{-}01{-}01" "1987{-}01{-}01" "1988{-}01{-}01" "1989{-}01{-}01"}
\end{Highlighting}
\end{Shaded}

Otra función muy útil es \texttt{round\_date}. Se puede utilizar para redondear las fechas al año, trimestre, mes, semana, día, hora, minutos o segundos más cercanos. Entonces, si queremos agrupar todas las encuestas por semana del año, podemos hacer lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_us\_election\_2016 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{week =} \FunctionTok{round\_date}\NormalTok{(startdate, }\StringTok{"week"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(week) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{margin =} \FunctionTok{mean}\NormalTok{(rawpoll\_clinton }\SpecialCharTok{{-}}\NormalTok{ rawpoll\_trump)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{qplot}\NormalTok{(week, margin, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/poll-margin-versus-week-1} \end{center}

\hypertarget{ejercicios-42}{%
\section{Ejercicios}\label{ejercicios-42}}

En la sección de ejercicios anterior, depuramos datos de un archivo PDF que contiene estadísticas vitales de Puerto Rico. Hicimos esto para el mes de septiembre. A continuación incluimos un código que lo hace durante los 12 meses.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(lubridate)}
\FunctionTok{library}\NormalTok{(purrr)}
\FunctionTok{library}\NormalTok{(pdftools)}
\FunctionTok{library}\NormalTok{(dslabs)}

\NormalTok{fn }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\StringTok{"RD{-}Mortality{-}Report\_2015{-}18{-}180531.pdf"}\NormalTok{,}
                  \AttributeTok{package=}\StringTok{"dslabs"}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(}\FunctionTok{str\_split}\NormalTok{(}\FunctionTok{pdf\_text}\NormalTok{(fn), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(s)\{}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{str\_trim}\NormalTok{(s)}
\NormalTok{  header\_index }\OtherTok{\textless{}{-}} \FunctionTok{str\_which}\NormalTok{(s, }\StringTok{"2015"}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
\NormalTok{  tmp }\OtherTok{\textless{}{-}} \FunctionTok{str\_split}\NormalTok{(s[header\_index], }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+"}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  month }\OtherTok{\textless{}{-}}\NormalTok{ tmp[}\DecValTok{1}\NormalTok{]}
\NormalTok{  header }\OtherTok{\textless{}{-}}\NormalTok{ tmp[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]}
\NormalTok{  tail\_index  }\OtherTok{\textless{}{-}} \FunctionTok{str\_which}\NormalTok{(s, }\StringTok{"Total"}\NormalTok{)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{str\_count}\NormalTok{(s, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+"}\NormalTok{)}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{header\_index, }\FunctionTok{which}\NormalTok{(n }\SpecialCharTok{==} \DecValTok{1}\NormalTok{), }
           \FunctionTok{which}\NormalTok{(n }\SpecialCharTok{\textgreater{}=} \DecValTok{28}\NormalTok{), tail\_index}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(s))}
\NormalTok{  s[}\SpecialCharTok{{-}}\NormalTok{out] }\SpecialCharTok{\%\textgreater{}\%}  \FunctionTok{str\_remove\_all}\NormalTok{(}\StringTok{"[\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s]"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_trim}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_split\_fixed}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+"}\NormalTok{, }\AttributeTok{n =} \DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"day"}\NormalTok{, header)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =}\NormalTok{ month, }\AttributeTok{day =} \FunctionTok{as.numeric}\NormalTok{(day)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(day, month), }\AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"deaths"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{deaths =} \FunctionTok{as.numeric}\NormalTok{(deaths))}
\NormalTok{\}) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =} \FunctionTok{recode}\NormalTok{(month, }
                        \StringTok{"JAN"} \OtherTok{=} \DecValTok{1}\NormalTok{, }\StringTok{"FEB"} \OtherTok{=} \DecValTok{2}\NormalTok{, }\StringTok{"MAR"} \OtherTok{=} \DecValTok{3}\NormalTok{, }
                        \StringTok{"APR"} \OtherTok{=} \DecValTok{4}\NormalTok{, }\StringTok{"MAY"} \OtherTok{=} \DecValTok{5}\NormalTok{, }\StringTok{"JUN"} \OtherTok{=} \DecValTok{6}\NormalTok{, }
                        \StringTok{"JUL"} \OtherTok{=} \DecValTok{7}\NormalTok{, }\StringTok{"AGO"} \OtherTok{=} \DecValTok{8}\NormalTok{, }\StringTok{"SEP"} \OtherTok{=} \DecValTok{9}\NormalTok{, }
                        \StringTok{"OCT"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"NOV"} \OtherTok{=} \DecValTok{11}\NormalTok{, }\StringTok{"DEC"} \OtherTok{=} \DecValTok{12}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{date =} \FunctionTok{make\_date}\NormalTok{(year, month, day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(date }\SpecialCharTok{\textless{}=} \StringTok{"2018{-}05{-}01"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

1. Queremos hacer un gráfico de recuentos de muertes versus fecha. Un primer paso es convertir la variable del mes de caracteres a números. Tenga en cuenta que las abreviaturas de los meses están en espanglés. Utilice la función \texttt{recode} para convertir meses en números y redefinir \texttt{tab}.

2. Cree una nueva columna \texttt{date} con la fecha de cada observación. Sugerencia: use la función \texttt{make\_date}.

3. Grafique muertes versus fecha.

4. Noten que después del 31 de mayo de 2018, las muertes son todas 0. Los datos probablemente aún no se han ingresado. También vemos una caída a partir del 1 de mayo. Redefina \texttt{tab} para excluir observaciones tomadas a partir del 1 de mayo de 2018. Luego, rehaga el gráfico.

5. Vuelva a hacer el gráfico anterior, pero esta vez grafique las muertes versus el día del año; por ejemplo, 12 de enero de 2016 y 12 de enero de 2017, son ambos el día 12. Use el color para indicar los diferentes años. Sugerencia: use la función \texttt{yday} de \textbf{lubridate} .

6. Vuelva a hacer el gráfico anterior pero, esta vez, use dos colores diferentes para antes y después del 20 de septiembre de 2017.

7. Avanzado: rehaga el gráfico anterior, pero esta vez muestre el mes en el eje-x. Sugerencia: cree una variable con la fecha de un año determinado. Luego, use la función \texttt{scale\_x\_date} para mostrar solo los meses.

8. Rehaga las muertes versus el día pero con promedios semanales. Sugerencia: use la función \texttt{round\_date}.

9. Rehaga el gráfico pero con promedios mensuales. Sugerencia: use la función \texttt{round\_date} de nuevo.

\hypertarget{mineruxeda-de-textos}{%
\chapter{Minería de textos}\label{mineruxeda-de-textos}}

Con la excepción de las etiquetas utilizadas para representar datos categóricos, nos hemos enfocado en los datos numéricos. Pero en muchas aplicaciones, los datos comienzan como texto. Ejemplos bien conocidos son el filtrado de spam, la prevención del delito cibernético, la lucha contra el terrorismo y el análisis de sentimiento (también conocido como minería de opinión). En todos estos casos, los datos sin procesar se componen de texto de forma libre. Nuestra tarea es extraer información de estos datos. En esta sección, aprendemos cómo generar resúmenes numéricos útiles a partir de datos de texto a los que podemos aplicar algunas de las poderosas técnicas de visualización y análisis de datos que hemos aprendido.

\hypertarget{estudio-de-caso-tuits-de-trump}{%
\section{Estudio de caso: tuits de Trump}\label{estudio-de-caso-tuits-de-trump}}

Durante las elecciones presidenciales estadounidenses de 2016, el candidato Donald J. Trump usó su cuenta de Twitter como una manera de comunicarse con los posibles votantes. El 6 de agosto de 2016, Todd Vaziri tuiteó sobre Trump y declaró que ``Cada tweet no hiperbólico es de iPhone (su personal). Cada tweet hiperbólico es de Android (de él)''\footnote{\url{https://twitter.com/tvaziri/status/762005541388378112/photo/1}}. El científico de datos David Robinson realizó un análisis para determinar si los datos respaldan esta afirmación\footnote{\url{http://varianceexplained.org/r/trump-tweets/}}. Aquí, revisamos el análisis de David para aprender algunos de los conceptos básicos de la minería de textos. Para obtener más información sobre la minería de textos en R, recomendamos el libro \emph{Text Mining with R} de Julia Silge y David Robinson\footnote{\url{https://www.tidytextmining.com/}}.

Utilizaremos los siguientes paquetes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(lubridate)}
\FunctionTok{library}\NormalTok{(scales)}
\end{Highlighting}
\end{Shaded}

En general, podemos extraer datos directamente de Twitter usando el paquete \textbf{rtweet}. Sin embargo, en este caso, un grupo ya ha compilado datos para nosotros y los ha puesto a disposición en: \url{https://www.thetrumparchive.com}. Podemos obtener los datos de su API JSON usando un \emph{script} como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}http://www.trumptwitterarchive.com/data/realdonaldtrump/\%s.json\textquotesingle{}}
\NormalTok{trump\_tweets }\OtherTok{\textless{}{-}} \FunctionTok{map}\NormalTok{(}\DecValTok{2009}\SpecialCharTok{:}\DecValTok{2017}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\FunctionTok{sprintf}\NormalTok{(url, .x)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{map\_df}\NormalTok{(jsonlite}\SpecialCharTok{::}\NormalTok{fromJSON, }\AttributeTok{simplifyDataFrame =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{is\_retweet }\SpecialCharTok{\&} \SpecialCharTok{!}\FunctionTok{str\_detect}\NormalTok{(text, }\StringTok{\textquotesingle{}\^{}"\textquotesingle{}}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{created\_at =} \FunctionTok{parse\_date\_time}\NormalTok{(created\_at,}
                                      \AttributeTok{orders =} \StringTok{"a b! d! H!:M!:S! z!* Y!"}\NormalTok{,}
                                      \AttributeTok{tz=}\StringTok{"EST"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Para facilitar el análisis, incluimos el resultado del código anterior en el paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"trump\_tweets"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pueden ver el \emph{data frame} con información sobre los tuits al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(trump\_tweets)}
\end{Highlighting}
\end{Shaded}

con las siguientes variables incluidas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(trump\_tweets)}
\CommentTok{\#\textgreater{} [1] "source"                  "id\_str"                 }
\CommentTok{\#\textgreater{} [3] "text"                    "created\_at"             }
\CommentTok{\#\textgreater{} [5] "retweet\_count"           "in\_reply\_to\_user\_id\_str"}
\CommentTok{\#\textgreater{} [7] "favorite\_count"          "is\_retweet"}
\end{Highlighting}
\end{Shaded}

El archivo de ayuda \texttt{?trump\_tweets} provee detalles sobre lo que representa cada variable. Los tuits están representados por el variable \texttt{text}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trump\_tweets}\SpecialCharTok{$}\NormalTok{text[}\DecValTok{16413}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_wrap}\NormalTok{(}\AttributeTok{width =} \FunctionTok{options}\NormalTok{()}\SpecialCharTok{$}\NormalTok{width) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ cat}
\CommentTok{\#\textgreater{} Great to be back in Iowa! \#TBT with @JerryJrFalwell joining me in}
\CommentTok{\#\textgreater{} Davenport{-} this past winter. \#MAGA https://t.co/A5IF0QHnic}
\end{Highlighting}
\end{Shaded}

y la variable \texttt{source} nos dice qué dispositivo se usó para componer y cargar cada tuit:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trump\_tweets }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{count}\NormalTok{(source) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(n)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{}                source     n}
\CommentTok{\#\textgreater{} 1  Twitter Web Client 10718}
\CommentTok{\#\textgreater{} 2 Twitter for Android  4652}
\CommentTok{\#\textgreater{} 3  Twitter for iPhone  3962}
\CommentTok{\#\textgreater{} 4           TweetDeck   468}
\CommentTok{\#\textgreater{} 5     TwitLonger Beta   288}
\end{Highlighting}
\end{Shaded}

Estamos interesados en lo que sucedió durante la campaña, por lo que para este análisis nos enfocaremos en lo que se tuiteó entre el día en que Trump anunció su campaña y el día de las elecciones. Definimos la siguiente tabla que contiene solo los tuits de ese período de tiempo. Tengan en cuenta que usamos \texttt{extract} para eliminar la parte \texttt{Twitter\ for} de \texttt{source} y filtrar los \emph{retweets}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{campaign\_tweets }\OtherTok{\textless{}{-}}\NormalTok{ trump\_tweets }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{extract}\NormalTok{(source, }\StringTok{"source"}\NormalTok{, }\StringTok{"Twitter for (.*)"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(source }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Android"}\NormalTok{, }\StringTok{"iPhone"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{           created\_at }\SpecialCharTok{\textgreater{}=} \FunctionTok{ymd}\NormalTok{(}\StringTok{"2015{-}06{-}17"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{           created\_at }\SpecialCharTok{\textless{}} \FunctionTok{ymd}\NormalTok{(}\StringTok{"2016{-}11{-}08"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{is\_retweet) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(created\_at)  }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{as\_tibble}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Ahora podemos usar la visualización de datos para explorar la posibilidad de que dos grupos diferentes hayan escrito los mensajes desde estos dispositivos. Para cada tuit, extraeremos la hora en que se publicó (hora de la costa este de EE.UU. o EST por sus siglas en inglés), y luego calcularemos la proporción de tuits tuiteada a cada hora para cada dispositivo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{campaign\_tweets }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{hour =} \FunctionTok{hour}\NormalTok{(}\FunctionTok{with\_tz}\NormalTok{(created\_at, }\StringTok{"EST"}\NormalTok{))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(source, hour) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(source) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{percent =}\NormalTok{ n}\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(n)) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  ungroup }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(hour, percent, }\AttributeTok{color =}\NormalTok{ source)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_y\_continuous}\NormalTok{(}\AttributeTok{labels =} \FunctionTok{percent\_format}\NormalTok{()) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{x =} \StringTok{"Hour of day (EST)"}\NormalTok{, }\AttributeTok{y =} \StringTok{"\% of tweets"}\NormalTok{, }\AttributeTok{color =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/tweets-by-time-by-device-1} \end{center}

Notamos un gran pico para Android en las primeras horas de la mañana, entre las 6 y las 8 de la mañana. Parece haber una clara diferencia en estos patrones. Por lo tanto, suponemos que dos entidades diferentes están utilizando estos dos dispositivos.

Ahora estudiaremos cómo difieren los tuits cuando comparamos Android con iPhone. Para hacer esto, utilizaremos el paquete \textbf{tidytext}.

\hypertarget{texto-como-datos}{%
\section{Texto como datos}\label{texto-como-datos}}

El paquete \textbf{tidytext} nos ayuda a convertir texto de forma libre en una tabla ordenada. Tener los datos en este formato facilita enormemente la visualización de datos y el uso de técnicas estadísticas.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidytext)}
\end{Highlighting}
\end{Shaded}

La función principal necesaria para lograr esto es \texttt{unnest\_tokens}. Un \emph{token} se refiere a una unidad que consideramos como un punto de datos. Los \emph{tokens} más comunes son las palabras, pero también pueden ser caracteres individuales, \emph{ngrams}, oraciones, líneas o un patrón definido por una expresión regular. Las funciones tomarán un vector de cadenas y extraerán los \emph{tokens} para que cada uno obtenga una fila en la nueva tabla. Aquí hay un ejemplo sencillo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poem }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Roses are red,"}\NormalTok{, }\StringTok{"Violets are blue,"}\NormalTok{,}
          \StringTok{"Sugar is sweet,"}\NormalTok{, }\StringTok{"And so are you."}\NormalTok{)}
\NormalTok{example }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\AttributeTok{line =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{),}
                  \AttributeTok{text =}\NormalTok{ poem)}
\NormalTok{example}
\CommentTok{\#\textgreater{} \# A tibble: 4 x 2}
\CommentTok{\#\textgreater{}    line text             }
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}chr\textgreater{}            }
\CommentTok{\#\textgreater{} 1     1 Roses are red,   }
\CommentTok{\#\textgreater{} 2     2 Violets are blue,}
\CommentTok{\#\textgreater{} 3     3 Sugar is sweet,  }
\CommentTok{\#\textgreater{} 4     4 And so are you.}
\NormalTok{example }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{unnest\_tokens}\NormalTok{(word, text)}
\CommentTok{\#\textgreater{} \# A tibble: 13 x 2}
\CommentTok{\#\textgreater{}    line word   }
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}chr\textgreater{}  }
\CommentTok{\#\textgreater{} 1     1 roses  }
\CommentTok{\#\textgreater{} 2     1 are    }
\CommentTok{\#\textgreater{} 3     1 red    }
\CommentTok{\#\textgreater{} 4     2 violets}
\CommentTok{\#\textgreater{} 5     2 are    }
\CommentTok{\#\textgreater{} \# ... with 8 more rows}
\end{Highlighting}
\end{Shaded}

Ahora consideremos un ejemplo de los tuits. Miren el tuit número 3008 porque luego nos permitirá ilustrar un par de puntos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i }\OtherTok{\textless{}{-}} \DecValTok{3008}
\NormalTok{campaign\_tweets}\SpecialCharTok{$}\NormalTok{text[i] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_wrap}\NormalTok{(}\AttributeTok{width =} \DecValTok{65}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{cat}\NormalTok{()}
\CommentTok{\#\textgreater{} Great to be back in Iowa! \#TBT with @JerryJrFalwell joining me in}
\CommentTok{\#\textgreater{} Davenport{-} this past winter. \#MAGA https://t.co/A5IF0QHnic}
\NormalTok{campaign\_tweets[i,] }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(word)}
\CommentTok{\#\textgreater{}  [1] "great"          "to"             "be"             "back"          }
\CommentTok{\#\textgreater{}  [5] "in"             "iowa"           "tbt"            "with"          }
\CommentTok{\#\textgreater{}  [9] "jerryjrfalwell" "joining"        "me"             "in"            }
\CommentTok{\#\textgreater{} [13] "davenport"      "this"           "past"           "winter"        }
\CommentTok{\#\textgreater{} [17] "maga"           "https"          "t.co"           "a5if0qhnic"}
\end{Highlighting}
\end{Shaded}

Noten que la función intenta convertir \emph{tokens} en palabras. Para hacer esto, sin embargo, elimina los caracteres que son importantes en el contexto de Twitter. Específicamente, la función elimina todos los \texttt{\#} y \texttt{@}. Un \emph{token} en el contexto de Twitter no es lo mismo que en el contexto del inglés hablado o escrito. Por esta razón, en lugar de usar el valor predeterminado, \texttt{words}, usamos el \emph{token} \texttt{tweets} que incluye patrones que comienzan con \texttt{@} y \texttt{\#}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{campaign\_tweets[i,] }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text, }\AttributeTok{token =} \StringTok{"tweets"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(word)}
\CommentTok{\#\textgreater{}  [1] "great"                   "to"                     }
\CommentTok{\#\textgreater{}  [3] "be"                      "back"                   }
\CommentTok{\#\textgreater{}  [5] "in"                      "iowa"                   }
\CommentTok{\#\textgreater{}  [7] "\#tbt"                    "with"                   }
\CommentTok{\#\textgreater{}  [9] "@jerryjrfalwell"         "joining"                }
\CommentTok{\#\textgreater{} [11] "me"                      "in"                     }
\CommentTok{\#\textgreater{} [13] "davenport"               "this"                   }
\CommentTok{\#\textgreater{} [15] "past"                    "winter"                 }
\CommentTok{\#\textgreater{} [17] "\#maga"                   "https://t.co/a5if0qhnic"}
\end{Highlighting}
\end{Shaded}

Otro ajuste menor que queremos hacer es eliminar los enlaces a las imágenes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{links }\OtherTok{\textless{}{-}} \StringTok{"https://t.co/[A{-}Za{-}z}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d]+|\&amp;"}
\NormalTok{campaign\_tweets[i,] }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{text =} \FunctionTok{str\_replace\_all}\NormalTok{(text, links, }\StringTok{""}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text, }\AttributeTok{token =} \StringTok{"tweets"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(word)}
\CommentTok{\#\textgreater{}  [1] "great"           "to"              "be"             }
\CommentTok{\#\textgreater{}  [4] "back"            "in"              "iowa"           }
\CommentTok{\#\textgreater{}  [7] "\#tbt"            "with"            "@jerryjrfalwell"}
\CommentTok{\#\textgreater{} [10] "joining"         "me"              "in"             }
\CommentTok{\#\textgreater{} [13] "davenport"       "this"            "past"           }
\CommentTok{\#\textgreater{} [16] "winter"          "\#maga"}
\end{Highlighting}
\end{Shaded}

Ya estamos listos para extraer las palabras de todos nuestros tuits.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\OtherTok{\textless{}{-}}\NormalTok{ campaign\_tweets }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{text =} \FunctionTok{str\_replace\_all}\NormalTok{(text, links, }\StringTok{""}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text, }\AttributeTok{token =} \StringTok{"tweets"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Y ahora podemos responder a preguntas como ``¿cuáles son las palabras más utilizadas?'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(word) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(n)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 10 x 2}
\CommentTok{\#\textgreater{}   word      n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 the    2329}
\CommentTok{\#\textgreater{} 2 to     1410}
\CommentTok{\#\textgreater{} 3 and    1239}
\CommentTok{\#\textgreater{} 4 in     1185}
\CommentTok{\#\textgreater{} 5 i      1143}
\CommentTok{\#\textgreater{} \# ... with 5 more rows}
\end{Highlighting}
\end{Shaded}

No es sorprendente que estas sean las palabras principales. Las palabras principales no son informativas. El paquete \emph{tidytext} tiene una base de datos de estas palabras de uso común, denominadas palabras \emph{stop}, en la minería de textos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stop\_words}
\CommentTok{\#\textgreater{} \# A tibble: 1,149 x 2}
\CommentTok{\#\textgreater{}   word  lexicon}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{} \textless{}chr\textgreater{}  }
\CommentTok{\#\textgreater{} 1 a     SMART  }
\CommentTok{\#\textgreater{} 2 a\textquotesingle{}s   SMART  }
\CommentTok{\#\textgreater{} 3 able  SMART  }
\CommentTok{\#\textgreater{} 4 about SMART  }
\CommentTok{\#\textgreater{} 5 above SMART  }
\CommentTok{\#\textgreater{} \# ... with 1,144 more rows}
\end{Highlighting}
\end{Shaded}

Si filtramos las filas que representan las palabras \emph{stop} con \texttt{filter(!word\ \%in\%\ stop\_words\$word)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\OtherTok{\textless{}{-}}\NormalTok{ campaign\_tweets }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{text =} \FunctionTok{str\_replace\_all}\NormalTok{(text, links, }\StringTok{""}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text, }\AttributeTok{token =} \StringTok{"tweets"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{word }\SpecialCharTok{\%in\%}\NormalTok{ stop\_words}\SpecialCharTok{$}\NormalTok{word )}
\end{Highlighting}
\end{Shaded}

terminamos con un conjunto mucho más informativo de las 10 palabras más tuiteadas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(word) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{top\_n}\NormalTok{(}\DecValTok{10}\NormalTok{, n) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{word =} \FunctionTok{reorder}\NormalTok{(word, n)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(n))}
\CommentTok{\#\textgreater{} \# A tibble: 10 x 2}
\CommentTok{\#\textgreater{}   word                       n}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}                  \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 \#trump2016               414}
\CommentTok{\#\textgreater{} 2 hillary                  405}
\CommentTok{\#\textgreater{} 3 people                   303}
\CommentTok{\#\textgreater{} 4 \#makeamericagreatagain   294}
\CommentTok{\#\textgreater{} 5 america                  254}
\CommentTok{\#\textgreater{} \# ... with 5 more rows}
\end{Highlighting}
\end{Shaded}

Una exploración de las palabras resultantes (que no se muestran aquí) revela un par de características no deseadas en nuestros \emph{tokens}. Primero, algunos de nuestros \emph{tokens} son solo números (años, por ejemplo). Queremos eliminarlos y podemos encontrarlos usando la expresión regular \texttt{\^{}\textbackslash{}d+\$}. Segundo, algunos de nuestros \emph{tokens} provienen de una cita y comienzan con \texttt{\textquotesingle{}}. Queremos eliminar el \texttt{\textquotesingle{}} cuando está al comienzo de una palabra, así que simplemente usamos \texttt{str\_replace}. Agregamos estas dos líneas al código anterior para generar nuestra tabla final:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\OtherTok{\textless{}{-}}\NormalTok{ campaign\_tweets }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{text =} \FunctionTok{str\_replace\_all}\NormalTok{(text, links, }\StringTok{""}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unnest\_tokens}\NormalTok{(word, text, }\AttributeTok{token =} \StringTok{"tweets"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\NormalTok{word }\SpecialCharTok{\%in\%}\NormalTok{ stop\_words}\SpecialCharTok{$}\NormalTok{word }\SpecialCharTok{\&}
           \SpecialCharTok{!}\FunctionTok{str\_detect}\NormalTok{(word, }\StringTok{"\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+$"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{word =} \FunctionTok{str\_replace}\NormalTok{(word, }\StringTok{"\^{}\textquotesingle{}"}\NormalTok{, }\StringTok{""}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Ahora que tenemos las palabras en una tabla e información sobre qué dispositivo se usó para componer el tuit, podemos comenzar a explorar qué palabras son más comunes al comparar Android con iPhone.

Para cada palabra, queremos saber si es más probable que provenga de un tuit de Android o un tuit de iPhone. En la Sección \ref{association-tests}, discutimos el \emph{riesgo relativo} (\emph{odds ratio} en inglés) como un resumen estadístico útil para cuantificar estas diferencias. Para cada dispositivo y una palabra dada, llamémosla \texttt{y}, calculamos el riesgo relativo. Aquí tendremos muchas proporciones que son 0, así que usamos la corrección 0.5 descrita en la Sección \ref{association-tests}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\OtherTok{\textless{}{-}}\NormalTok{ tweet\_words }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(word, source) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =} \StringTok{"source"}\NormalTok{, }\AttributeTok{values\_from =} \StringTok{"n"}\NormalTok{, }\AttributeTok{values\_fill =} \DecValTok{0}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{or =}\NormalTok{ (Android }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(Android) }\SpecialCharTok{{-}}\NormalTok{ Android }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{/} 
\NormalTok{           ( (iPhone }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{) }\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(iPhone) }\SpecialCharTok{{-}}\NormalTok{ iPhone }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Aquí están los riesgos relativos más altos para Android:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(or))}
\CommentTok{\#\textgreater{} \# A tibble: 5,914 x 4}
\CommentTok{\#\textgreater{}   word      Android iPhone    or}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}       \textless{}int\textgreater{}  \textless{}int\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 poor           13      0  23.1}
\CommentTok{\#\textgreater{} 2 poorly         12      0  21.4}
\CommentTok{\#\textgreater{} 3 turnberry      11      0  19.7}
\CommentTok{\#\textgreater{} 4 @cbsnews       10      0  18.0}
\CommentTok{\#\textgreater{} 5 angry          10      0  18.0}
\CommentTok{\#\textgreater{} \# ... with 5,909 more rows}
\end{Highlighting}
\end{Shaded}

y los más altos para iPhone:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(or)}
\CommentTok{\#\textgreater{} \# A tibble: 5,914 x 4}
\CommentTok{\#\textgreater{}   word                   Android iPhone      or}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                    \textless{}int\textgreater{}  \textless{}int\textgreater{}   \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 \#makeamericagreatagain       0    294 0.00142}
\CommentTok{\#\textgreater{} 2 \#americafirst                0     71 0.00595}
\CommentTok{\#\textgreater{} 3 \#draintheswamp               0     63 0.00670}
\CommentTok{\#\textgreater{} 4 \#trump2016                   3    411 0.00706}
\CommentTok{\#\textgreater{} 5 \#votetrump                   0     56 0.00753}
\CommentTok{\#\textgreater{} \# ... with 5,909 more rows}
\end{Highlighting}
\end{Shaded}

Dado que varias de estas palabras son palabras generales de baja frecuencia, podemos imponer un filtro basado en la frecuencia total así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(Android}\SpecialCharTok{+}\NormalTok{iPhone }\SpecialCharTok{\textgreater{}} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(or))}
\CommentTok{\#\textgreater{} \# A tibble: 30 x 4}
\CommentTok{\#\textgreater{}   word        Android iPhone    or}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}         \textless{}int\textgreater{}  \textless{}int\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 @cnn             90     17  4.44}
\CommentTok{\#\textgreater{} 2 bad             104     26  3.39}
\CommentTok{\#\textgreater{} 3 crooked         156     49  2.72}
\CommentTok{\#\textgreater{} 4 interviewed      76     25  2.57}
\CommentTok{\#\textgreater{} 5 media            76     25  2.57}
\CommentTok{\#\textgreater{} \# ... with 25 more rows}

\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{filter}\NormalTok{(Android}\SpecialCharTok{+}\NormalTok{iPhone }\SpecialCharTok{\textgreater{}} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(or)}
\CommentTok{\#\textgreater{} \# A tibble: 30 x 4}
\CommentTok{\#\textgreater{}   word                   Android iPhone      or}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}                    \textless{}int\textgreater{}  \textless{}int\textgreater{}   \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 \#makeamericagreatagain       0    294 0.00142}
\CommentTok{\#\textgreater{} 2 \#trump2016                   3    411 0.00706}
\CommentTok{\#\textgreater{} 3 join                         1    157 0.00805}
\CommentTok{\#\textgreater{} 4 tomorrow                    24     99 0.209  }
\CommentTok{\#\textgreater{} 5 vote                        46     67 0.588  }
\CommentTok{\#\textgreater{} \# ... with 25 more rows}
\end{Highlighting}
\end{Shaded}

Ya vemos un patrón en los tipos de palabras que se tuitean más desde un dispositivo que desde otro. Sin embargo, no estamos interesados en palabras específicas sino en el tono. La afirmación de Vaziri es que los tuits de Android son más hiperbólicos. Entonces, ¿cómo podemos verificar esto con datos? \emph{Hipérbole} es un sentimiento difícil de extraer de las palabras, ya que se basa en la interpretación de frases. No obstante, las palabras pueden asociarse con sentimientos más básicos como la ira, el miedo, la alegría y la sorpresa. En la siguiente sección, demostramos el análisis básico de sentimientos.

\hypertarget{anuxe1lisis-de-sentimiento}{%
\section{Análisis de sentimiento}\label{anuxe1lisis-de-sentimiento}}

En el análisis de sentimiento, asignamos una palabra a uno o más ``sentimientos''. Aunque este enfoque no siempre indentificará sentimientos que dependen del contexto, como el sarcasmo, cuando se realiza en grandes cantidades de palabras, los resúmenes pueden ofrecer información.

El primer paso en el análisis de sentimiento es asignar un sentimiento a cada palabra. Como demostramos, el paquete \textbf{tidytext} incluye varios mapas o léxicos. También usaremos el paquete \textbf{textdata}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidytext)}
\FunctionTok{library}\NormalTok{(textdata)}
\end{Highlighting}
\end{Shaded}

El léxico \texttt{bing} divide las palabras en sentimientos \texttt{positive} y \texttt{negative}. Podemos ver esto usando la función \texttt{get\_sentiments} de \textbf{tidytext}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_sentiments}\NormalTok{(}\StringTok{"bing"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

El léxico \texttt{AFINN} asigna una puntuación entre -5 y 5, con -5 el más negativo y 5 el más positivo. Tengan en cuenta que este léxico debe descargarse la primera vez que llamen a la función \texttt{get\_sentiment}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_sentiments}\NormalTok{(}\StringTok{"afinn"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Los léxicos \texttt{loughran} y \texttt{nrc} ofrecen varios sentimientos diferentes. Noten que estos también deben descargarse la primera vez que los usen.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_sentiments}\NormalTok{(}\StringTok{"loughran"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{count}\NormalTok{(sentiment)}
\CommentTok{\#\textgreater{} \# A tibble: 6 x 2}
\CommentTok{\#\textgreater{}   sentiment        n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}        \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 constraining   184}
\CommentTok{\#\textgreater{} 2 litigious      904}
\CommentTok{\#\textgreater{} 3 negative      2355}
\CommentTok{\#\textgreater{} 4 positive       354}
\CommentTok{\#\textgreater{} 5 superfluous     56}
\CommentTok{\#\textgreater{} \# ... with 1 more row}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_sentiments}\NormalTok{(}\StringTok{"nrc"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{count}\NormalTok{(sentiment)}
\CommentTok{\#\textgreater{} \# A tibble: 10 x 2}
\CommentTok{\#\textgreater{}   sentiment        n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}        \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 anger         1247}
\CommentTok{\#\textgreater{} 2 anticipation   839}
\CommentTok{\#\textgreater{} 3 disgust       1058}
\CommentTok{\#\textgreater{} 4 fear          1476}
\CommentTok{\#\textgreater{} 5 joy            689}
\CommentTok{\#\textgreater{} \# ... with 5 more rows}
\end{Highlighting}
\end{Shaded}

Para nuestro análisis, estamos interesados en explorar los diferentes sentimientos de cada tuit, por lo que utilizaremos el léxico \texttt{nrc}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nrc }\OtherTok{\textless{}{-}} \FunctionTok{get\_sentiments}\NormalTok{(}\StringTok{"nrc"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(word, sentiment)}
\end{Highlighting}
\end{Shaded}

Podemos combinar las palabras y los sentimientos usando \texttt{inner\_join}, que solo mantendrá palabras asociadas con un sentimiento. Aquí tenemos 10 palabras aleatorias extraídas de los tuits:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet\_words }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{inner\_join}\NormalTok{(nrc, }\AttributeTok{by =} \StringTok{"word"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(source, word, sentiment) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 3}
\CommentTok{\#\textgreater{}   source  word     sentiment   }
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}   \textless{}chr\textgreater{}    \textless{}chr\textgreater{}       }
\CommentTok{\#\textgreater{} 1 iPhone  failing  fear        }
\CommentTok{\#\textgreater{} 2 Android proud    trust       }
\CommentTok{\#\textgreater{} 3 Android time     anticipation}
\CommentTok{\#\textgreater{} 4 iPhone  horrible disgust     }
\CommentTok{\#\textgreater{} 5 Android failing  anger}
\end{Highlighting}
\end{Shaded}

Ahora estamos listos para realizar un análisis cuantitativo comparando los sentimientos de los tuits publicados desde cada dispositivo. Podríamos realizar un análisis tuit por tuit, asignando un sentimiento a cada tuit. Sin embargo, esto sería un desafío ya que cada tuit tendrá varios sentimientos adjuntos, uno para cada palabra que aparezca en el léxico. Con fines ilustrativos, realizaremos un análisis mucho más sencillo: contaremos y compararemos las frecuencias de cada sentimiento que aparece en cada dispositivo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sentiment\_counts }\OtherTok{\textless{}{-}}\NormalTok{ tweet\_words }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(nrc, }\AttributeTok{by =} \StringTok{"word"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(source, sentiment) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =} \StringTok{"source"}\NormalTok{, }\AttributeTok{values\_from =} \StringTok{"n"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sentiment =} \FunctionTok{replace\_na}\NormalTok{(sentiment, }\AttributeTok{replace =} \StringTok{"none"}\NormalTok{))}
\NormalTok{sentiment\_counts}
\CommentTok{\#\textgreater{} \# A tibble: 11 x 3}
\CommentTok{\#\textgreater{}   sentiment    Android iPhone}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}          \textless{}int\textgreater{}  \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 anger            958    528}
\CommentTok{\#\textgreater{} 2 anticipation     910    715}
\CommentTok{\#\textgreater{} 3 disgust          638    322}
\CommentTok{\#\textgreater{} 4 fear             795    486}
\CommentTok{\#\textgreater{} 5 joy              688    535}
\CommentTok{\#\textgreater{} \# ... with 6 more rows}
\end{Highlighting}
\end{Shaded}

Para cada sentimiento, podemos calcular las probabilidades de estar en el dispositivo: proporción de palabras con sentimiento versus proporción de palabras sin. Entonces calculamos el riesgo relativo comparando los dos dispositivos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sentiment\_counts }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{Android =}\NormalTok{ Android}\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(Android) }\SpecialCharTok{{-}}\NormalTok{ Android) ,}
         \AttributeTok{iPhone =}\NormalTok{ iPhone}\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(iPhone) }\SpecialCharTok{{-}}\NormalTok{ iPhone),}
         \AttributeTok{or =}\NormalTok{ Android}\SpecialCharTok{/}\NormalTok{iPhone) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(or))}
\CommentTok{\#\textgreater{} \# A tibble: 11 x 4}
\CommentTok{\#\textgreater{}   sentiment Android iPhone    or}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 disgust    0.0299 0.0186  1.61}
\CommentTok{\#\textgreater{} 2 anger      0.0456 0.0309  1.47}
\CommentTok{\#\textgreater{} 3 negative   0.0807 0.0556  1.45}
\CommentTok{\#\textgreater{} 4 sadness    0.0424 0.0301  1.41}
\CommentTok{\#\textgreater{} 5 fear       0.0375 0.0284  1.32}
\CommentTok{\#\textgreater{} \# ... with 6 more rows}
\end{Highlighting}
\end{Shaded}

Sí vemos algunas diferencias y el orden es particularmente interesante: ¡los tres sentimientos más grandes son el asco, la ira y lo negativo! ¿Pero estas diferencias son solo por casualidad? ¿Cómo se compara esto si solo estamos asignando sentimientos al azar? A fin de responder a esta pregunta, para cada sentimiento podemos calcular un riesgo relativo y un intervalo de confianza, como se definen en la Sección \ref{association-tests}. Agregaremos los dos valores que necesitamos para formar una tabla de dos por dos y el riesgo relativo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(broom)}
\NormalTok{log\_or }\OtherTok{\textless{}{-}}\NormalTok{ sentiment\_counts }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{log\_or =} \FunctionTok{log}\NormalTok{((Android}\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(Android) }\SpecialCharTok{{-}}\NormalTok{ Android))}\SpecialCharTok{/}
\NormalTok{                        (iPhone}\SpecialCharTok{/}\NormalTok{ (}\FunctionTok{sum}\NormalTok{(iPhone) }\SpecialCharTok{{-}}\NormalTok{ iPhone))),}
         \AttributeTok{se =} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{Android }\SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{sum}\NormalTok{(Android) }\SpecialCharTok{{-}}\NormalTok{ Android) }\SpecialCharTok{+}
                     \DecValTok{1}\SpecialCharTok{/}\NormalTok{iPhone }\SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{sum}\NormalTok{(iPhone) }\SpecialCharTok{{-}}\NormalTok{ iPhone)),}
         \AttributeTok{conf.low =}\NormalTok{ log\_or }\SpecialCharTok{{-}} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}\SpecialCharTok{*}\NormalTok{se,}
         \AttributeTok{conf.high =}\NormalTok{ log\_or }\SpecialCharTok{+} \FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}\SpecialCharTok{*}\NormalTok{se) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(log\_or))}

\NormalTok{log\_or}
\CommentTok{\#\textgreater{} \# A tibble: 11 x 7}
\CommentTok{\#\textgreater{}   sentiment Android iPhone log\_or     se conf.low conf.high}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}       \textless{}int\textgreater{}  \textless{}int\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}    \textless{}dbl\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 disgust       638    322  0.474 0.0691    0.338     0.609}
\CommentTok{\#\textgreater{} 2 anger         958    528  0.389 0.0552    0.281     0.497}
\CommentTok{\#\textgreater{} 3 negative     1641    929  0.371 0.0424    0.288     0.454}
\CommentTok{\#\textgreater{} 4 sadness       894    515  0.342 0.0563    0.232     0.452}
\CommentTok{\#\textgreater{} 5 fear          795    486  0.280 0.0585    0.165     0.394}
\CommentTok{\#\textgreater{} \# ... with 6 more rows}
\end{Highlighting}
\end{Shaded}

Una visualización gráfica muestra algunos sentimientos que están claramente sobrerrepresentados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log\_or }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sentiment =} \FunctionTok{reorder}\NormalTok{(sentiment, log\_or)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ sentiment, }\AttributeTok{ymin =}\NormalTok{ conf.low, }\AttributeTok{ymax =}\NormalTok{ conf.high)) }\SpecialCharTok{+}
  \FunctionTok{geom\_errorbar}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(sentiment, log\_or)) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Log odds ratio for association between Android and sentiment"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{coord\_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/tweets-log-odds-ratio-1} \end{center}

Vemos que el disgusto, la ira, los sentimientos negativos, la tristeza y el miedo están asociados con el Android de una manera que es difícil de explicar solo por casualidad. Las palabras no asociadas con un sentimiento estaban fuertemente asociadas con el iPhone, que está de acuerdo con la afirmación original sobre los tuits hiperbólicos.

Si estamos interesados en explorar qué palabras específicas están impulsando estas diferencias, podemos referirnos a nuestro objeto \texttt{android\_iphone\_or}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{inner\_join}\NormalTok{(nrc) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(sentiment }\SpecialCharTok{==} \StringTok{"disgust"} \SpecialCharTok{\&}\NormalTok{ Android }\SpecialCharTok{+}\NormalTok{ iPhone }\SpecialCharTok{\textgreater{}} \DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(or))}
\CommentTok{\#\textgreater{} Joining, by = "word"}
\CommentTok{\#\textgreater{} \# A tibble: 20 x 5}
\CommentTok{\#\textgreater{}   word     Android iPhone    or sentiment}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}      \textless{}int\textgreater{}  \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}chr\textgreater{}    }
\CommentTok{\#\textgreater{} 1 mess          13      2  4.62 disgust  }
\CommentTok{\#\textgreater{} 2 finally       12      2  4.28 disgust  }
\CommentTok{\#\textgreater{} 3 unfair        12      2  4.28 disgust  }
\CommentTok{\#\textgreater{} 4 bad          104     26  3.39 disgust  }
\CommentTok{\#\textgreater{} 5 terrible      31      8  3.17 disgust  }
\CommentTok{\#\textgreater{} \# ... with 15 more rows}
\end{Highlighting}
\end{Shaded}

y hacer un gráfico:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{android\_iphone\_or }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{inner\_join}\NormalTok{(nrc, }\AttributeTok{by =} \StringTok{"word"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sentiment =} \FunctionTok{factor}\NormalTok{(sentiment, }\AttributeTok{levels =}\NormalTok{ log\_or}\SpecialCharTok{$}\NormalTok{sentiment)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{log\_or =} \FunctionTok{log}\NormalTok{(or)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(Android }\SpecialCharTok{+}\NormalTok{ iPhone }\SpecialCharTok{\textgreater{}} \DecValTok{10} \SpecialCharTok{\&} \FunctionTok{abs}\NormalTok{(log\_or)}\SpecialCharTok{\textgreater{}}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{word =} \FunctionTok{reorder}\NormalTok{(word, log\_or)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(word, log\_or, }\AttributeTok{fill =}\NormalTok{ log\_or }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{sentiment, }\AttributeTok{scales =} \StringTok{"free\_x"}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat=}\StringTok{"identity"}\NormalTok{, }\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{angle =} \DecValTok{90}\NormalTok{, }\AttributeTok{hjust =} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/log-odds-by-word-1} \end{center}

Este es solo un ejemplo sencillo de los muchos análisis que uno puede realizar con \textbf{tidytext}.
Para obtener más información, nuevamente recomendamos el libro \emph{Tidy Text Mining}\footnote{\url{https://www.tidytextmining.com/}}.

\hypertarget{ejercicios-43}{%
\section{Ejercicios}\label{ejercicios-43}}

\emph{Project Gutenberg} es un archivo digital de libros de dominio público. El paquete \textbf{gutenbergr} de R facilita la importación de estos textos en R. Puede instalar y cargarlo escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"gutenbergr"}\NormalTok{)}
\FunctionTok{library}\NormalTok{(gutenbergr)}
\end{Highlighting}
\end{Shaded}

Los libros disponibles se pueden ver así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gutenberg\_metadata}
\end{Highlighting}
\end{Shaded}

1. Utilice \texttt{str\_detect} para encontrar la identificación de la novela \emph{Pride and Prejudice}.

2. Observe que hay varias versiones. La función \texttt{gutenberg\_works()}filtra esta tabla para eliminar réplicas e incluye solo trabajos en inglés. Lea el archivo de ayuda y use esta función para encontrar la identificación de \emph{Pride and Prejudice}.

3. Utilice la función \texttt{gutenberg\_download} para descargar el texto de \emph{Pride and Prejudice}. Guárdelo en un objeto llamado \texttt{book}.

4. Use el paquete \textbf{tidytext} para crear una tabla ordenada con todas las palabras en el texto. Guarde la tabla en un objeto llamado \texttt{words}.

5. Más adelante haremos un gráfico de sentimiento versus ubicación en el libro. Para esto, será útil agregar una columna a la tabla con el número de palabra.

6. Elimine las palabras \emph{stop} y los números del objeto \texttt{words}. Sugerencia: use \texttt{anti\_join}.

7. Ahora use el léxico \texttt{AFINN} para asignar un valor de sentimiento a cada palabra.

8. Haga un gráfico de puntuación de sentimiento versus ubicación en el libro y agregue un suavizador.

9. Suponga que hay 300 palabras por página. Convierta las ubicaciones en páginas y luego calcule el sentimiento promedio en cada página. Grafique esa puntuación promedio por página. Agregue un suavizador que pase por los datos.

\hypertarget{part-machine-learning}{%
\part{Machine Learning}\label{part-machine-learning}}

\hypertarget{introducciuxf3n-a-machine-learning}{%
\chapter{\texorpdfstring{Introducción a \emph{machine learning}}{Introducción a machine learning}}\label{introducciuxf3n-a-machine-learning}}

Quizás las metodologías de ciencia de datos más populares provienen del campo de \emph{machine learning}. Las historias de éxito de \emph{machine learning} incluyen lectores de códigos postales escritos a mano implementados por el servicio postal, tecnología de reconocimiento de voz como Siri de Apple, sistemas de recomendación de películas, detectores de spam y \emph{malware}, automóviles sin conductor y predictores de precios de viviendas. Aunque hoy en día los términos Inteligencia Artificial y \emph{machine learning} se usan indistintamente, hacemos la siguiente distinción: mientras que los primeros algoritmos de inteligencia artificial, como esos utilizados por las máquinas de ajedrez, implementaron la toma de decisiones según reglas programables derivadas de la teoría o de los primeros principios, en \emph{machine learning} las decisiones de aprendizaje se basan en algoritmos \textbf{que se construyen con datos}.

\hypertarget{notaciuxf3n-1}{%
\section{Notación}\label{notaciuxf3n-1}}

En \emph{machine learning}, los datos se presentan en forma de:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  el \emph{resultado} (\emph{outcome} en inglés) que queremos predecir y
\item
  los \emph{atributos} (\emph{features} en inglés) que usaremos para predecir el resultado.
\end{enumerate}

Queremos construir un algoritmo que tome los valores de los atributos como entrada y devuelva una predicción para el resultado cuando no sabemos el resultado. El enfoque de \emph{machine learning} consiste en \emph{entrenar} un algoritmo utilizando un set de datos para el cual conocemos el resultado y luego usar este algoritmo en el futuro para hacer una predicción cuando no sabemos el resultado.

Aquí usaremos \(Y\) para denotar el resultado y \(X_1, \dots, X_p\) para denotar atributos. Tengan en cuenta que los atributos a veces se denominan \emph{predictores} o \emph{covariables}. Consideramos estos sinónimos.

Los problemas de predicción se pueden dividir en resultados categóricos y continuos. Para resultados categóricos, \(Y\) puede ser cualquiera de \(K\) clases. El número de clases puede variar mucho entre distintas aplicaciones. Por ejemplo, en los datos del lector de dígitos, \(K=10\) con las clases representando los dígitos 0, 1, 2, 3, 4, 5, 6, 7, 8 y 9. En el reconocimiento de voz, los resultados son todas las palabras o frases posibles que estamos tratando de detectar. La detección de spam tiene dos resultados: spam o no spam. En este libro, denotamos las categorías \(K\) con índices \(k=1,\dots,K\). Sin embargo, para datos binarios usaremos \(k=0,1\) para conveniencias matemáticas que demostraremos más adelante.

La configuración general es la siguiente. Tenemos una serie de características y un resultado desconocido que queremos predecir:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{cccccc}
\toprule
outcome & feature 1 & feature 2 & feature 3 & feature 4 & feature 5\\
\midrule
? & $X_1$ & $X_2$ & $X_3$ & $X_4$ & $X_5$\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Para \emph{construir un modelo} que provee una predicción para cualquier conjunto de valores observados \(X_1=x_1,X_2=x_2,\dots X_5=x_5\), recolectamos datos para los cuales conocemos el resultado:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{llllll}
\toprule
outcome & feature 1 & feature 2 & feature 3 & feature 4 & feature 5\\
\midrule
$y_{1}$ & $x_{1,1}$ & $x_{1,2}$ & $x_{1,3}$ & $x_{1,4}$ & $x_{1,5}$\\
$y_{2}$ & $x_{2,1}$ & $x_{2,2}$ & $x_{2,3}$ & $x_{2,4}$ & $x_{2,5}$\\
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$\\
$y_n$ & $x_{n,1}$ & $x_{n,2}$ & $x_{n,3}$ & $x_{n,4}$ & $x_{n,5}$\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Cuando el resultado es continuo, nos referimos a la tarea de \emph{machine learning} como \emph{predicción}. El resultado principal del modelo es una función \(f\) que produce automáticamente una predicción, denotada con \(\hat{y}\), para cualquier conjunto de predictores: \(\hat{y} = f(x_1, x_2, \dots, x_p)\). Usamos el término \emph{resultado real} (\emph{actual outcome} en inglés) para denotar lo que acabamos observando. Entonces queremos que la predicción \(\hat{y}\) coincida con resultado real \(y\) lo mejor posible. Debido a que nuestro resultado es continuo, nuestras predicciones \(\hat{y}\) no serán exactamente correctas o incorrectas, sino que determinaremos un \emph{error} definido como la diferencia entre la predicción y el resultado real \(y - \hat{y}\).

Cuando el resultado es categórico, nos referimos a la tarea de \emph{machine learning} como \emph{clasificación}. El resultado principal de este modelo será una \emph{regla de decisión} (\emph{decision rule} en inglés) que determina cuál de las \(K\) clases debemos predecir. En esta situación, la mayoría de los modelos provee funciones de los predictores para cada clase \(k\), \(f_k(x_1, x_2, \dots, x_p)\), que se utilizan para tomar esta decisión. Cuando los datos son binarios, una regla de decisión típica sería algo como: si \(f_1(x_1, x_2, \dots, x_p) > C\), pronostique la categoría 1, si no, pronostique la otra categoría, con \(C\) un umbral predeterminado. Debido a que los resultados son categóricos, nuestras predicciones serán correctas o incorrectas.

Tengan en cuenta que estos términos varían entre cursos, libros de texto y otras publicaciones. A menudo, el término \emph{predicción} se usa tanto para resultados categóricos como continuos y el término \emph{regresión} puede usarse para el caso continuo. Aquí no usamos el término \emph{regresión} para evitar confusión con nuestro uso previo del término \emph{regresión lineal}. En la mayoría de los casos, estará claro si nuestros resultados son categóricos o continuos, por lo que evitaremos usar estos términos cuando sea posible.

\hypertarget{un-ejemplo}{%
\section{Un ejemplo}\label{un-ejemplo}}

Consideremos el ejemplo del lector de código postal. El primer paso para manejar el correo en la oficina de correos es organizar las cartas por código postal:

\begin{center}\includegraphics[width=0.4\linewidth]{ml/img//how-to-write-a-address-on-an-envelope-how-to-write-the-address-on-an-envelope-write-address-on-envelope-india-finishedenvelope-x69070} \end{center}

Originalmente, los humanos tenían que clasificarlos a mano. Para hacer esto, tuvieron que leer los códigos postales de cada sobre. Hoy, gracias a los algoritmos de \emph{machine learning}, una computadora puede leer códigos postales y luego un robot clasifica las cartas. En esta parte del libro, aprenderemos cómo construir algoritmos que puedan leer un dígito.

El primer paso para construir un algoritmo es entender cuáles son los resultados y los atributos. A continuación hay tres imágenes de dígitos escritos. Estos ya han sido leídos por un humano y se les ha asignado un resultado \(Y\). Por lo tanto, se consideran conocidos y sirven como set de entrenamiento.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/digit-images-example-1} \end{center}

Las imágenes se convierten en \(28 \times 28 = 784\) píxeles y, para cada píxel, obtenemos una intensidad de escala de grises entre 0 (blanco) y 255 (negro), que consideramos continua por ahora. El siguiente gráfico muestra los atributos individuales de cada imagen:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/example-images-1} \end{center}

Para cada imagen digitalizada \(i\), tenemos un resultado categórico \(Y_i\) que puede ser uno de los 10 valores (\(0,1,2,3,4,5,6,7,8,9\)) y atributos \(X_{i,1}, \dots, X_{i,784}\). Usamos negrilla \(\mathbf{X}_i = (X_{i,1}, \dots, X_{i,784})\) para distinguir el vector de predictores de los predictores individuales. Cuando nos referimos a un conjunto arbitrario de atributos en lugar de una imagen específica en nuestro set de datos, descartamos el índice \(i\) y usamos \(Y\) y \(\mathbf{X} = (X_{1}, \dots, X_{784})\). Utilizamos variables en mayúsculas porque, en general, pensamos en los predictores como variables aleatorias. Usamos minúsculas, por ejemplo \(\mathbf{X} = \mathbf{x}\), para denotar valores observados. Cuando codificamos usamos minúsculas.

La tarea de \emph{machine learning} es construir un algoritmo que devuelva una predicción para cualquiera de los posibles valores de los atributos. Aquí, aprenderemos varios enfoques para construir estos algoritmos. Aunque en este momento puede parecer imposible lograr esto, comenzaremos con ejemplos sencillos y desarrollaremos nuestro conocimiento hasta que podamos atacar algunos más complejos. De hecho, comenzamos con un ejemplo artificialmente sencillo con un solo predictor y luego pasamos a un ejemplo un poco más realista con dos predictores. Una vez que comprendamos estos, atacaremos algunos retos de \emph{machine learning} del mundo real que involucran muchos predictores.

\hypertarget{ejercicios-44}{%
\section{Ejercicios}\label{ejercicios-44}}

1. Para cada uno de los siguientes ejemplos, determine si el resultado es continuo o categórico:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Lector de dígitos
\item
  Recomendaciones de películas
\item
  Filtro de spam
\item
  Hospitalizaciones
\item
  Siri (reconocimiento de voz)
\end{enumerate}

2. ¿Cuántas funciones tenemos disponibles para la predicción en el set de datos de dígitos?

3. En el ejemplo del lector de dígitos, los resultados se almacenan aquí:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels}
\end{Highlighting}
\end{Shaded}

¿Las siguientes operaciones tienen un significado práctico?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[}\DecValTok{5}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ y[}\DecValTok{6}\NormalTok{]}
\NormalTok{y[}\DecValTok{5}\NormalTok{] }\SpecialCharTok{\textgreater{}}\NormalTok{ y[}\DecValTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Eliga la mejor respuesta:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Sí, porque \(9 + 2 = 11\) y \(9 > 2\).
\item
  No, porque \texttt{y} no es un vector numérico.
\item
  No, porque 11 no es un dígito. Son dos dígitos.
\item
  No, porque estas son etiquetas que representan una categoría, no un número. Un \texttt{9} representa una clase, no el número 9.
\end{enumerate}

\hypertarget{muxe9tricas-de-evaluaciuxf3n}{%
\section{Métricas de evaluación}\label{muxe9tricas-de-evaluaciuxf3n}}

Antes de comenzar a describir enfoques para optimizar la forma en que construimos algoritmos, primero debemos definir a qué nos referimos cuando decimos que un enfoque es mejor que otro. En esta sección, nos centramos en describir las formas en que se evalúan los algoritmos de \emph{machine learning}. Específicamente, necesitamos cuantificar lo que queremos decir con ``mejor''.

Para nuestra primera introducción a los conceptos de \emph{machine learning}, comenzaremos con un ejemplo aburrido y sencillo: cómo predecir sexo basado en altura. A medida que explicamos \emph{machine learning} paso a paso, este ejemplo nos permitirá establecer el primer componente básico. Muy pronto, estaremos atacando desafíos más interesantes. Utilizamos el paquete \textbf{caret}, que tiene varias funciones útiles para construir y evaluar métodos de \emph{machine learning}. Presentamos los detalles de este paquete en el Capítulo \ref{caret}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(caret)}
\end{Highlighting}
\end{Shaded}

Como primer ejemplo, usamos los datos de altura en \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(heights)}
\end{Highlighting}
\end{Shaded}

Comenzamos definiendo el resultado y los predictores.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{sex}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height}
\end{Highlighting}
\end{Shaded}

En este caso, solo tenemos un predictor, altura, mientras que \texttt{y} es claramente un resultado categórico ya que los valores observados son \texttt{Male} o \texttt{Female}. Sabemos que no podremos predecir \(Y\) de forma precisa basado en \(X\) porque las alturas promedio masculinas y femeninas no son tan diferentes en relación con la variabilidad dentro del grupo. ¿Pero podemos hacerlo mejor que con simplemente adivinar? Para responder a esta pregunta, necesitamos una definición cuantitativa de ``mejor''.

\hypertarget{training-test}{%
\subsection{Sets de entrenamiento y de evaluación}\label{training-test}}

En última instancia, un algoritmo de \emph{machine learning} se evalúa basado en cómo funciona en el mundo real con sets de datos completamente nuevos. Sin embargo, cuando desarrollamos un algoritmo, generalmente tenemos un set de datos para el cual conocemos los resultados, como lo hacemos con las alturas: sabemos el sexo de cada estudiante en nuestro set de datos. Por lo tanto, para imitar el proceso de evaluación final, generalmente dividimos los datos en dos partes y actuamos como si no supiéramos el resultado de una de estas. Dejamos de fingir que no conocemos el resultado para evaluar el algoritmo, pero solo \emph{después} de haber terminado de construirlo. Nos referimos al grupo para el que conocemos el resultado y que usamos para desarrollar el algoritmo como el \emph{set de entrenamiento} (\emph{training set} en inglés). Nos referimos al grupo para el que aparentamos no conocer el resultado como el \emph{set de evaluación} (\emph{test set} en inglés).

Una forma estándar de generar los sets de entrenamiento y de evaluación es dividiendo aleatoriamente los datos. El paquete \textbf{caret} incluye la función \texttt{createDataPartition} que nos ayuda a generar índices para dividir aleatoriamente los datos en sets de entrenamiento y de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2007}\NormalTok{)}
\NormalTok{test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

El argumento \texttt{times} se usa para definir cuántas muestras aleatorias de índices devolver, el argumento \texttt{p} se utiliza para definir qué proporción de los datos está representada por el índice y el argumento \texttt{list} se usa para decidir si queremos que los índices se devuelvan como una lista o no. Podemos usar el resultado de la llamada a la función \texttt{createDataPartition} para definir los sets de entrenamiento y de evaluación de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ heights[test\_index, ]}
\NormalTok{train\_set }\OtherTok{\textless{}{-}}\NormalTok{ heights[}\SpecialCharTok{{-}}\NormalTok{test\_index, ]}
\end{Highlighting}
\end{Shaded}

Ahora desarrollaremos un algoritmo usando \textbf{solo} el set de entrenamiento. Una vez que hayamos terminado de desarrollar el algoritmo, lo \emph{congelaremos} y lo evaluaremos utilizando el set de evaluación. La forma más sencilla de evaluar el algoritmo cuando los resultados son categóricos es simplemente informar la proporción de casos que se predijeron correctamente \textbf{en el set de evaluación}. Esta métrica generalmente se conoce como \emph{exactitud general} (\emph{overall accuracy} en inglés).

\hypertarget{exactitud-general}{%
\subsection{Exactitud general}\label{exactitud-general}}

Para demostrar el uso de la exactidud general, crearemos dos algoritmos diferentes y los compararemos.

Comencemos desarrollando el algoritmo más sencillo posible: adivinar el resultado.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{), }\FunctionTok{length}\NormalTok{(test\_index), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que estamos ignorando completamente el predictor y simplemente adivinando el sexo.

En las aplicaciones de \emph{machine learning}, es útil usar factores para representar los resultados categóricos porque las funciones de R desarrolladas para \emph{machine learning}, como las del paquete \textbf{caret}, requieren o recomiendan que los resultados categóricos se codifiquen como factores. Para convertir \texttt{y\_hat} en factores podemos usar la función \texttt{factor}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{), }\FunctionTok{length}\NormalTok{(test\_index), }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\end{Highlighting}
\end{Shaded}

La \emph{exactidud general} se define simplemente como la proporción general que se predice correctamente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(y\_hat }\SpecialCharTok{==}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{} [1] 0.51}
\end{Highlighting}
\end{Shaded}

No es sorprendente que nuestra exactidud sea 50\%. ¡Estamos adivinando!

¿Podemos mejorarla? El análisis de datos exploratorios sugiere que sí porque, en promedio, los hombres son un poco más altos que las mujeres:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{group\_by}\NormalTok{(sex) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\FunctionTok{mean}\NormalTok{(height), }\FunctionTok{sd}\NormalTok{(height))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 3}
\CommentTok{\#\textgreater{}   sex    \textasciigrave{}mean(height)\textasciigrave{} \textasciigrave{}sd(height)\textasciigrave{}}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}           \textless{}dbl\textgreater{}        \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Female           64.9         3.76}
\CommentTok{\#\textgreater{} 2 Male             69.3         3.61}
\end{Highlighting}
\end{Shaded}

Pero, ¿cómo usamos esta información? Probemos con otro enfoque sencillo: predecir \texttt{Male} si la altura está dentro de dos desviaciones estándar del hombre promedio.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(x }\SpecialCharTok{\textgreater{}} \DecValTok{62}\NormalTok{, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\end{Highlighting}
\end{Shaded}

La exactidud aumenta de 0.50 a aproximadamente 0.80:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(y }\SpecialCharTok{==}\NormalTok{ y\_hat)}
\CommentTok{\#\textgreater{} [1] 0.793}
\end{Highlighting}
\end{Shaded}

¿Pero podemos mejorarla aún más? En el ejemplo anterior, utilizamos un umbral de 62, pero podemos examinar la exactidud obtenida para otros umbrales y luego elegir el valor que provee los mejores resultados. Sin embargo, recuerden que \textbf{es importante que optimicemos el umbral utilizando solo el set de entrenamiento}: el set de evaluación es solo para evaluación. Aunque para este ejemplo sencillo no es un problema, más adelante aprenderemos que evaluar un algoritmo en el set de entrenamiento puede resultar en un \emph{sobreajuste} (\emph{overfitting} en inglés), que a menudo resulta en evaluaciones peligrosamente sobre optimistas.

Aquí examinamos la exactidud de 10 umbrales diferentes y elegimos el que produce el mejor resultado:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cutoff }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{61}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\NormalTok{accuracy }\OtherTok{\textless{}{-}} \FunctionTok{map\_dbl}\NormalTok{(cutoff, }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{height }\SpecialCharTok{\textgreater{}}\NormalTok{ x, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
  \FunctionTok{mean}\NormalTok{(y\_hat }\SpecialCharTok{==}\NormalTok{ train\_set}\SpecialCharTok{$}\NormalTok{sex)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Podemos hacer un gráfico que muestra la exactitud obtenida en el set de entrenamiento para hombres y mujeres:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/accuracy-vs-cutoff-1} \end{center}

Vemos que el valor máximo es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(accuracy)}
\CommentTok{\#\textgreater{} [1] 0.85}
\end{Highlighting}
\end{Shaded}

que es mucho más grande que 0.5. El umbral que resulta en esta exactitud es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{best\_cutoff }\OtherTok{\textless{}{-}}\NormalTok{ cutoff[}\FunctionTok{which.max}\NormalTok{(accuracy)]}
\NormalTok{best\_cutoff}
\CommentTok{\#\textgreater{} [1] 64}
\end{Highlighting}
\end{Shaded}

Ahora podemos evaluar el uso de este umbral en nuestro set de evaluaciones para asegurarnos de que nuestra exactitud no sea demasiado optimista:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{height }\SpecialCharTok{\textgreater{}}\NormalTok{ best\_cutoff, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(y\_hat)}
\FunctionTok{mean}\NormalTok{(y\_hat }\SpecialCharTok{==}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{} [1] 0.804}
\end{Highlighting}
\end{Shaded}

Vemos que es un poco más baja que la exactitud observada para el set de entrenamiento, pero aún es mejor que adivinar. Y al probar en un set de datos en el que no entrenamos, sabemos que nuestro resultado no se debe a que se haya elegido para dar un buen resultado en el set de evaluación.

\hypertarget{matriz-de-confusiuxf3n}{%
\subsection{Matriz de confusión}\label{matriz-de-confusiuxf3n}}

La regla de predicción que desarrollamos en la sección anterior predice \texttt{Male} si el alumno es más alto que 64 pulgadas. Dado que la mujer promedio es aproximadamente 64 pulgadas, esta regla de predicción parece incorrecta. ¿Que pasó? Si la altura de un estudiante es la de la mujer promedio, ¿no deberíamos predecir \texttt{Female}?

En términos generales, la exactitud general puede ser una medida engañosa. Para ver esto, comenzaremos construyendo lo que se conoce como \emph{matriz de confusión} (\emph{confusion matrix} en inglés), que básicamente tabula cada combinación de predicción y valor real. Podemos hacer esto en R usando la función \texttt{table}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(}\AttributeTok{predicted =}\NormalTok{ y\_hat, }\AttributeTok{actual =}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{}          actual}
\CommentTok{\#\textgreater{} predicted Female Male}
\CommentTok{\#\textgreater{}    Female     48   32}
\CommentTok{\#\textgreater{}    Male       71  374}
\end{Highlighting}
\end{Shaded}

Si estudiamos esta tabla detenidamente, revela un problema. Si calculamos la exactitud por separado para cada sexo, obtenemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y\_hat =}\NormalTok{ y\_hat) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(sex) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{accuracy =} \FunctionTok{mean}\NormalTok{(y\_hat }\SpecialCharTok{==}\NormalTok{ sex))}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 2}
\CommentTok{\#\textgreater{}   sex    accuracy}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}     \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Female    0.403}
\CommentTok{\#\textgreater{} 2 Male      0.921}
\end{Highlighting}
\end{Shaded}

Hay un desequilibrio en la exactitud para hombres y mujeres: se predice que demasiadas mujeres son hombres. ¡Estamos prediciendo que casi la mitad de las mujeres son hombres! ¿Cómo es que nuestra exactitud general sea tan alta? Esto se debe a que la \emph{prevalencia} de los hombres en este set de datos es alta. Estas alturas se obtuvieron de tres cursos de ciencias de datos, dos de los cuales tenían más hombres matriculados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prev }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(y }\SpecialCharTok{==} \StringTok{"Male"}\NormalTok{)}
\NormalTok{prev}
\CommentTok{\#\textgreater{} [1] 0.773}
\end{Highlighting}
\end{Shaded}

Entonces, al calcular la exactitud general, el alto porcentaje de errores cometidos prediciendo cuales son mujeres se ve superado por las ganancias en las predicciones acertadas para los hombres. \textbf{Esto puede ser un gran problema en \emph{machine learning}.} Si sus datos de entrenamiento están sesgados de alguna manera, es probable que también desarrolle algoritmos sesgados. El hecho de que hayamos utilizado un set de evaluación no importa porque también se deriva del set de datos sesgado original. Esta es una de las razones por las que observamos métricas distintas de la exactitud general al evaluar un algoritmo de \emph{machine learning}.

Hay varias métricas que podemos usar para evaluar un algoritmo de manera que la prevalencia no afecte nuestra evaluación y todas estas pueden derivarse de la matriz de confusión. Una forma general de mejorar el uso de la exactitud general es estudiar la \emph{sensibilidad} y la \emph{especificidad} por separado.

\hypertarget{sensibilidad-y-especificidad}{%
\subsection{Sensibilidad y especificidad}\label{sensibilidad-y-especificidad}}

Para definir la sensibilidad y la especificidad, necesitamos un resultado binario. Cuando los resultados son categóricos, podemos definir estos términos para una categoría específica. En el ejemplo de dígitos, podemos pedir la especificidad en el caso de predecir correctamente 2 en lugar de algún otro dígito. Una vez que especifiquemos una categoría de interés, podemos hablar sobre resultados positivos, \(Y=1\), y resultados negativos, \(Y=0\).

En general, la \emph{sensibilidad} se define como la capacidad de un algoritmo para predecir un resultado positivo cuando el resultado real es positivo: \(\hat{Y}=1\) cuando \(Y=1\). Un algoritmo que predice que todo es positivo (\(\hat{Y}=1\) pase lo que pase) tiene una sensibilidad perfecta, pero esta métrica por sí sola no es suficiente para evaluar un algoritmo. Por esta razón, también examinamos la \emph{especificidad}, que generalmente se define como la capacidad de un algoritmo para no predecir un resultado positivo \(\hat{Y}=0\) cuando el resultado real no es positivo \(Y=0\). Podemos resumir de la siguiente manera:

\begin{itemize}
\tightlist
\item
  Alta sensibilidad: \(Y=1 \implies \hat{Y}=1\)
\item
  Alta especificidad: \(Y=0 \implies \hat{Y} = 0\)
\end{itemize}

Aunque lo anterior a menudo se considera la definición de especificidad, otra forma de pensar en la especificidad es por la proporción de predicciones positivas que realmente son positivas:

\begin{itemize}
\tightlist
\item
  Alta especificidad: \(\hat{Y}=1 \implies Y=1\).
\end{itemize}

Para ofrecer definiciones precisas, nombramos las cuatro entradas de la matriz de confusión:

\begin{table}[!h]
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lll}
\toprule
  & Actually Positive & Actually Negative\\
\midrule
Predicted positive & True positives (TP) & False positives (FP)\\
Predicted negative & False negatives (FN) & True negatives (TN)\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Típicamente, la sensibilidad se cuantifica con \(TP/(TP+FN)\), la proporción de positivos verdaderos (la primera columna = \(TP+FN\)) que se predicen ser positivos (\(TP\)). Esta cantidad se conoce como la \emph{tasa de positivos verdaderos} (\emph{true positive rate} o TPR por sus siglas en inglés) o \emph{recall}.

La especificidad se define como \(TN/(TN+FP)\) o la proporción de negativos (la segunda columna = \(FP+TN\)) que se predicen ser negativos (\(TN\)). Esta cantidad también se denomina la \emph{tasa de falsos positivos} (\emph{true negative rate} o TNR por sus siglas en inglés). Hay otra forma de cuantificar la especificidad que es \(TP/(TP+FP)\) o la proporción de resultados que se predicen ser positivos (la primera fila o \(TP+FP\)) que realmente son positivos (\(TP\)). Esta cantidad se conoce como \emph{valor predictivo positivo} (\emph{positive predictive value} o PPV por sus siglas en inglés) y también como \emph{precisión}. Tengan en cuenta que, a diferencia de TPR y TNR, la precisión depende de la prevalencia. Por ejemplo, una mayor prevalencia implica que se puede obtener una precisión alta aun cuando están adivinando.

Los diferentes nombres pueden ser confusos, por lo que incluimos una tabla para ayudarnos a recordar los términos. La tabla incluye una columna que muestra la definición si pensamos en las proporciones como probabilidades.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.18}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.10}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.20}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.16}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.36}}@{}}
\toprule
Medida de & Nombre 1 & Nombre 2 & Definición & Representación de probabilidad \\
\midrule
\endhead
sensibilidad & TPR & Recall & \(\frac{\mbox{TP}}{\mbox{TP} + \mbox{FN}}\) & \(\mbox{Pr}(\hat{Y}=1 \mid Y=1)\) \\
especificidad & TNR & 1-FPR & \(\frac{\mbox{TN}}{\mbox{TN}+\mbox{FP}}\) & \(\mbox{Pr}(\hat{Y}=0 \mid Y=0)\) \\
especificidad & PPV & Precisión & \(\frac{\mbox{TP}}{\mbox{TP}+\mbox{FP}}\) & \(\mbox{Pr}(Y=1 \mid \hat{Y}=1)\) \\
\bottomrule
\end{longtable}

Aquí, TPR es la tasa de positivos verdaderos, FPR es la tasa de falsos positivos y PPV es el valor predictivo positivo. La función \texttt{confusionMatrix} del paquete \textbf{caret} calcula todas estas métricas para nosotros una vez que definamos qué categoría es ``positiva''. La función espera factores como entrada y el primer nivel se considera el resultado positivo o \(Y=1\). En nuestro ejemplo, \texttt{Female} es el primer nivel porque viene antes de \texttt{Male} alfabéticamente. Si escriben esto en R, verán varias métricas que incluyen exactitud, sensibilidad, especificidad y PPV.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cm }\OtherTok{\textless{}{-}} \FunctionTok{confusionMatrix}\NormalTok{(}\AttributeTok{data =}\NormalTok{ y\_hat, }\AttributeTok{reference =}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\end{Highlighting}
\end{Shaded}

Pueden acceder a estos directamente, por ejemplo, así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cm}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.804}
\NormalTok{cm}\SpecialCharTok{$}\NormalTok{byClass[}\FunctionTok{c}\NormalTok{(}\StringTok{"Sensitivity"}\NormalTok{,}\StringTok{"Specificity"}\NormalTok{, }\StringTok{"Prevalence"}\NormalTok{)]}
\CommentTok{\#\textgreater{} Sensitivity Specificity  Prevalence }
\CommentTok{\#\textgreater{}       0.403       0.921       0.227}
\end{Highlighting}
\end{Shaded}

Podemos ver que la alta exactitud general es posible a pesar de la sensibilidad relativamente baja. Como sugerimos anteriormente, la razón por la que esto sucede es debido a la baja prevalencia (0.23): la proporción de mujeres es baja. Como la prevalencia es baja, no predecir mujeres reales como mujeres (baja sensibilidad) no disminuye la exactitud tanto como no predecir hombres reales como hombres (baja especificidad). Este es un ejemplo de por qué es importante examinar la sensibilidad y la especificidad y no solo la exactitud. Antes de aplicar este algoritmo a sets de datos generales, debemos preguntarnos si la prevalencia será la misma.

\hypertarget{exactitud-equilibrada-y-medida-f_1}{%
\subsection{\texorpdfstring{Exactitud equilibrada y medida \(F_1\)}{Exactitud equilibrada y medida F\_1}}\label{exactitud-equilibrada-y-medida-f_1}}

Aunque generalmente recomendamos estudiar tanto la especificidad como la sensibilidad, a menudo es útil tener un resumen de un número, por ejemplo, para fines de optimización. Una medida que se prefiere sobre la exactitud general es el promedio de especificidad y de sensibilidad, conocida como \emph{exactitud equilibrada} (\emph{balanced accuracy} en inglés). Debido a que la especificidad y la sensibilidad son tasas, es más apropiado calcular la \emph{media armónica} (\emph{harmonic average} en inglés). De hecho, la \emph{medida \(F_1\)} (\emph{\(F_1\)-score} en inglés), un resumen de un número ampliamente utilizado, es la media armónica de precisión y \emph{recall}:

\[
\frac{1}{\frac{1}{2}\left(\frac{1}{\mbox{recall}} +
\frac{1}{\mbox{precision}}\right) }
\]

Dado que es más fácil de escribir, a menudo se ve esta media armónica reescrita como:

\[
2 \times \frac{\mbox{precision} \cdot \mbox{recall}}
{\mbox{precision} + \mbox{recall}}
\]

cuando se define \(F_1\).

Recuerden que, según el contexto, algunos tipos de errores son más costosos que otros. Por ejemplo, en el caso de la seguridad de los aviones, es mucho más importante maximizar la sensibilidad sobre la especificidad: no predecir el mal funcionamiento de un avión antes de que se estrelle es un error mucho más costoso que impedir que vuela un avión cuando el avión está en perfectas condiciones. En un caso criminal de asesinato, lo contrario es cierto ya que un falso positivo puede resultar en la ejecución de una persona inocente. La medida \(F_1\) se puede adaptar para pesar la especificidad y la sensibilidad de manera diferente. Para hacer esto, definimos \(\beta\) para representar cuánto más importante es la sensibilidad en comparación con la especificidad y consideramos una media armónica ponderada:

\[
\frac{1}{\frac{\beta^2}{1+\beta^2}\frac{1}{\mbox{recall}} +
\frac{1}{1+\beta^2}\frac{1}{\mbox{precision}} }
\]

La función \texttt{F\_meas} en el paquete \textbf{caret} calcula este resumen con un valor de \texttt{beta} igual a 1 por defecto.

Reconstruyamos nuestro algoritmo de predicción, pero esta vez maximizando la medida F en lugar de la exactitud general:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cutoff }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{61}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\NormalTok{F\_1 }\OtherTok{\textless{}{-}} \FunctionTok{map\_dbl}\NormalTok{(cutoff, }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{height }\SpecialCharTok{\textgreater{}}\NormalTok{ x, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
  \FunctionTok{F\_meas}\NormalTok{(}\AttributeTok{data =}\NormalTok{ y\_hat, }\AttributeTok{reference =} \FunctionTok{factor}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{sex))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Como antes, podemos trazar estas medidas \(F_1\) versus los umbrales:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/f_1-vs-cutoff-1} \end{center}

Vemos que el maximo de la medida \(F_1\) es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(F\_1)}
\CommentTok{\#\textgreater{} [1] 0.647}
\end{Highlighting}
\end{Shaded}

Este máximo se logra cuando usamos el siguiente umbral:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{best\_cutoff }\OtherTok{\textless{}{-}}\NormalTok{ cutoff[}\FunctionTok{which.max}\NormalTok{(F\_1)]}
\NormalTok{best\_cutoff}
\CommentTok{\#\textgreater{} [1] 66}
\end{Highlighting}
\end{Shaded}

Un umbral de 66 tiene más sentido que de 64. Además, equilibra la especificidad y la sensibilidad de nuestra matriz de confusión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{height }\SpecialCharTok{\textgreater{}}\NormalTok{ best\_cutoff, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\FunctionTok{sensitivity}\NormalTok{(}\AttributeTok{data =}\NormalTok{ y\_hat, }\AttributeTok{reference =}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{} [1] 0.63}
\FunctionTok{specificity}\NormalTok{(}\AttributeTok{data =}\NormalTok{ y\_hat, }\AttributeTok{reference =}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{} [1] 0.833}
\end{Highlighting}
\end{Shaded}

Ahora vemos que obtenemos mejores resultados que adivinando, que tanto la sensibilidad como la especificidad son relativamente altas y que hemos construido nuestro primer algoritmo de \emph{machine learning}. Este toma altura como predictor y predice mujeres si la persona mide 65 pulgadas o menos.

\hypertarget{la-prevalencia-importa-en-la-pruxe1ctica}{%
\subsection{La prevalencia importa en la práctica}\label{la-prevalencia-importa-en-la-pruxe1ctica}}

Un algoritmo de \emph{machine learning} con sensibilidad y especificidad muy altas puede ser inútil en la práctica cuando la prevalencia se acerca a 0 o 1. Para ver esto, consideren el caso de una doctora que se especializa en una enfermedad rara y que está interesada en desarrollar un algoritmo para predecir quién tiene la enfermedad. La doctora comparte los datos con ustedes, que entonces desarrollan un algoritmo con una sensibilidad muy alta. Explican que esto significa que si un paciente tiene la enfermedad, es muy probable que el algoritmo prediga correctamente. También le dicen a la doctora que están preocupados porque, según el set de datos que analizaron, la mitad de los pacientes tienen la enfermedad: \(\mbox{Pr}(\hat{Y}=1)\). La doctora no está preocupada ni impresionada y explica que lo importante es la precisión de la evaluación: \(\mbox{Pr}(Y=1 | \hat{Y}=1)\). Usando el teorema de Bayes, podemos conectar las dos medidas:

\[ \mbox{Pr}(Y = 1\mid \hat{Y}=1) = \mbox{Pr}(\hat{Y}=1 \mid Y=1) \frac{\mbox{Pr}(Y=1)}{\mbox{Pr}(\hat{Y}=1)}\]

La doctora sabe que la prevalencia de la enfermedad es de 5 en 1,000, lo que implica que \(\mbox{Pr}(Y=1) \,/ \,\mbox{Pr}(\hat{Y}=1) = 1/100\) y, por lo tanto, la precisión de su algoritmo es inferior a 0.01. La doctora no tiene mucho uso para su algoritmo.

\hypertarget{curvas-roc-y-precision-recall}{%
\subsection{Curvas ROC y precision-recall}\label{curvas-roc-y-precision-recall}}

Al comparar los dos métodos (adivinar versus usar un umbral de altura), comparamos la exactitud y \(F_1\). El segundo método claramente superó al primero. Sin embargo, si bien consideramos varios umbrales para el segundo método, para el primero solo consideramos un enfoque: adivinar con igual probabilidad. Noten que adivinar \texttt{Male} con mayor probabilidad nos daría una mayor exactitud debido al sesgo en la muestra:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FloatTok{0.9}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(test\_index)}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(p, }\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{levels}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\FunctionTok{mean}\NormalTok{(y\_hat }\SpecialCharTok{==}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{sex)}
\CommentTok{\#\textgreater{} [1] 0.739}
\end{Highlighting}
\end{Shaded}

Pero, como se describió anteriormente, esto tendría el costo de una menor sensibilidad. Las curvas que describimos en esta sección nos ayudarán a ver esto.

Recuerden que para cada uno de estos parámetros, podemos obtener una sensibilidad y especificidad diferente. Por esta razón, un enfoque muy común para evaluar métodos es compararlos gráficamente trazando ambos.

Un gráfico ampliamente utilizado que hace esto es la curva \emph{característica operativa del receptor} (\emph{Receiver Operating Characteristic} o ROC por sus siglas en inglés). Para aprender más sobre el origen del nombre, pueden consultar la página de Wikipedia Curva ROC\footnote{\url{https://es.wikipedia.org/wiki/Curva_ROC}}.

La curva ROC representa la sensibilidad (TPR) frente a la especificidad 1 o la tasa de falsos positivos (FPR). Aquí calculamos el TPR y el FPR necesarios para diferentes probabilidades de adivinar \texttt{Male}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{probs }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{10}\NormalTok{)}
\NormalTok{guessing }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(probs, }\ControlFlowTok{function}\NormalTok{(p)\{}
\NormalTok{  y\_hat }\OtherTok{\textless{}{-}}
    \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{), n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{prob=}\FunctionTok{c}\NormalTok{(p, }\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{factor}\NormalTok{(}\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{))}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{method =} \StringTok{"Guessing"}\NormalTok{,}
       \AttributeTok{FPR =} \DecValTok{1} \SpecialCharTok{{-}} \FunctionTok{specificity}\NormalTok{(y\_hat, test\_set}\SpecialCharTok{$}\NormalTok{sex),}
       \AttributeTok{TPR =} \FunctionTok{sensitivity}\NormalTok{(y\_hat, test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Podemos usar un código similar para calcular estos valores para nuestro segundo enfoque. Al graficar ambas curvas juntas, podemos comparar la sensibilidad para diferentes valores de especificidad:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/roc-3-1} \end{center}

Vemos que obtenemos una mayor sensibilidad con este enfoque para todos los valores de especificidad, lo que implica que es un método mejor. Tengan en cuenta que si simplemente adivinamos, las curvas ROC caen en la línea de identidad. También noten que cuando hacemos curvas ROC, a veces ayuda agregar el umbral asociado con cada punto al gráfico.

Los paquetes \textbf{pROC} y \textbf{plotROC} son útiles para generar estos gráficos.

Las curvas ROC tienen una debilidad y es que ninguna de las medidas graficadas depende de la prevalencia. En los casos en que la prevalencia es importante, en su lugar podemos hacer un gráfico \emph{precision-recall}. La idea es similar, pero en cambio graficamos la precisión versus el \emph{recall}:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/precision-recall-1-1} \end{center}

En este gráfico inmediatamente vemos que la precisión de adivinar no es alta. Esto se debe a que la prevalencia es baja. También vemos que si cambiamos los positivos para que representen ``Male'' en lugar de ``Female'', la curva ROC permanece igual, pero el gráfico \emph{precision-recall} cambia.

\hypertarget{loss-function}{%
\subsection{Función de pérdida}\label{loss-function}}

Hasta ahora hemos descrito métricas de evaluación que se aplican exclusivamente a datos categóricos. Específicamente, para los resultados binarios, hemos descrito cómo la sensibilidad, especificidad, exactitud y \(F_1\) se pueden utilizar como cuantificación. Sin embargo, estas métricas no son útiles para resultados continuos. En esta sección, describimos cómo el enfoque general para definir ``mejor'' en \emph{machine learning} es definir una \emph{función de pérdida} (\emph{loss function} en inglés), que puede aplicarse tanto a datos categóricos como continuos.

La función de pérdida más utilizada es la función de pérdida al cuadrado. Si \(\hat{y}\) es nuestro predictor e \(y\) es el resultado observado, la función de pérdida al cuadrado es simplemente:

\[
(\hat{y} - y)^2
\]

Debido a que frecuentemente tenemos un set de evaluaciones con muchas observaciones, digamos \(N\), usamos el \emph{error cuadrático medio} (\emph{mean squared error} o MSE por sus siglas en inglés):

\[
\mbox{MSE} = \frac{1}{N} \mbox{RSS} = \frac{1}{N}\sum_{i=1}^N (\hat{y}_i - y_i)^2
\]

En la práctica, a menudo indicamos la \emph{raiz de la desviación cuadrática media} (\emph{root mean squared error} o RMSE por sus siglas en inglés), que es \(\sqrt{\mbox{MSE}}\), porque está en las mismas unidades que los resultados. Pero hacer las matemáticas muchas veces es más fácil con el MSE y, por lo tanto, se usa más en los libros de texto, ya que estos generalmente describen las propiedades teóricas de los algoritmos.

Si los resultados son binarios, tanto RMSE como MSE son equivalentes a la exactitud menos uno, ya que \((\hat{y} - y)^2\) es 0 si la predicción fue correcta y 1 en caso contrario. En general, nuestro objetivo es construir un algoritmo que minimice la pérdida para que esté lo más cerca posible a 0.

Debido a que nuestros datos son generalmente una muestra aleatoria, podemos pensar en el MSE como una variable aleatoria y el MSE observado puede considerarse como una estimación del MSE esperado, que en notación matemática escribimos así:

\[
\mbox{E}\left\{ \frac{1}{N}\sum_{i=1}^N (\hat{Y}_i - Y_i)^2 \right\}
\]

Este es un concepto teórico porque en la práctica solo tenemos un set de datos con el cual trabajar. Una forma de pensar en lo que es esta expectativa teórica es la siguiente: tomamos un gran número (llámelo \(B\)) de muestras aleatorias, aplicamos nuestro algoritmo a cada muestra aleatoria, calculamos el MSE observado y tomamos el promedio. Podemos escribir la siguiente fórmula para esta cantidad:

\[
\frac{1}{B} \sum_{b=1}^B \frac{1}{N}\sum_{i=1}^N \left(\hat{y}_i^b - y_i^b\right)^2
\]

con \(y_{i}^b\) denotando la observación \(i\) en la muestra aleatoria \(b\) e \(\hat{y}_i^b\) denotando la predicción resultante obtenida de aplicar exactamente el mismo algoritmo a la muestra aleatoria \(b\). De nuevo, en la práctica solo observamos una muestra aleatoria, por lo que el MSE esperado es solo teórico. Sin embargo, en el Capítulo \ref{cross-validation}, describimos un enfoque para estimar el MSE que trata de imitar esta cantidad teórica.

Tengan en cuenta que hay funciones de pérdida distintas de la función de pérdida cuadrática. Por ejemplo, el \emph{error medio absoluto} (\emph{mean absolute error} en inglés) utiliza valores absolutos, \(|\hat{Y}_i - Y_i|\) en lugar de cuadrar los errores
\((\hat{Y}_i - Y_i)^2\). Sin embargo, en este libro nos enfocamos en minimizar la función de pérdida cuadrática ya que es la más utilizada.

\hypertarget{ejercicios-45}{%
\section{Ejercicios}\label{ejercicios-45}}

Los sets de datos \texttt{reported\_height} y \texttt{height} se recopilaron de tres clases impartidas en los Departamentos de Ciencias Computacionales y Bioestadística, así como de forma remota a través de la Escuela de Extensión. La clase de bioestadística se impartió en 2016 junto con una versión en línea ofrecida por la Escuela de Extensión. El 25 de enero de 2016 a las 8:15 a.m., durante una de las clases, los instructores le pidieron a los estudiantes que completaran el cuestionario de sexo y altura que poblaba el set de datos \texttt{reported\_height}. Los estudiantes en línea completaron la encuesta durante los próximos días, después de que la conferencia se publicara en línea. Podemos usar esta información para definir una variable, llamarla \texttt{type}, para denotar el tipo de estudiante: \texttt{inclass} (presenciales) o \texttt{online} (en línea):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(lubridate)}
\FunctionTok{data}\NormalTok{(}\StringTok{"reported\_heights"}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(reported\_heights, }\AttributeTok{date\_time =} \FunctionTok{ymd\_hms}\NormalTok{(time\_stamp)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(date\_time }\SpecialCharTok{\textgreater{}=} \FunctionTok{make\_date}\NormalTok{(}\DecValTok{2016}\NormalTok{, }\DecValTok{01}\NormalTok{, }\DecValTok{25}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{           date\_time }\SpecialCharTok{\textless{}} \FunctionTok{make\_date}\NormalTok{(}\DecValTok{2016}\NormalTok{, }\DecValTok{02}\NormalTok{, }\DecValTok{1}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{type =} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{day}\NormalTok{(date\_time) }\SpecialCharTok{==} \DecValTok{25} \SpecialCharTok{\&} \FunctionTok{hour}\NormalTok{(date\_time) }\SpecialCharTok{==} \DecValTok{8} \SpecialCharTok{\&}
                         \FunctionTok{between}\NormalTok{(}\FunctionTok{minute}\NormalTok{(date\_time), }\DecValTok{15}\NormalTok{, }\DecValTok{30}\NormalTok{),}
                       \StringTok{"inclass"}\NormalTok{, }\StringTok{"online"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{select}\NormalTok{(sex, type)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ dat}\SpecialCharTok{$}\NormalTok{type}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{sex, }\FunctionTok{c}\NormalTok{(}\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

1. Muestre estadísticas de resumen que indican que el \texttt{type} es predictivo del sexo.

2. En lugar de usar la altura para predecir el sexo, use la variable \texttt{type}.

3. Muestre la matriz de confusión.

4. Utilice la función \texttt{confusionMatrix} en el paquete \textbf{caret} para indicar la exactitud.

5. Ahora use las funciones \texttt{sensitivity} y \texttt{specificity} para indicar especificidad y sensibilidad.

6. ¿Cuál es la prevalencia (\% de mujeres) en el set de datos \texttt{dat} definido anteriormente?

\hypertarget{probabilidades-y-expectativas-condicionales}{%
\section{Probabilidades y expectativas condicionales}\label{probabilidades-y-expectativas-condicionales}}

En las aplicaciones de \emph{machine learning}, rara vez podemos predecir los resultados perfectamente. Por ejemplo, los detectores de spam a menudo no detectan correos electrónicos que son claramente spam, Siri no siempre entiende las palabras que estamos diciendo y su banco a veces piensa que su tarjeta fue robada cuando no fue así. La razón más común para no poder construir algoritmos perfectos es que es imposible. Para entender esto, noten que la mayoría de los sets de datos incluirán grupos de observaciones con los mismos valores exactos observados para todos los predictores, pero con diferentes resultados. Debido a que nuestras reglas de predicción son funciones, entradas iguales (los predictores) implican que los resultados (los atributos/las predicciones) tienen que ser iguales. Por lo tanto, para un set de datos en el que los mismos predictores se asocian con diferentes resultados en diferentes observaciones individuales, es imposible predecir correctamente para todos estos casos. Vimos un ejemplo sencillo de esto en la sección anterior: para cualquier altura dada \(x\), tendrán hombres y mujeres que son \(x\) pulgadas de alto.

Sin embargo, nada de esto significa que no podamos construir algoritmos útiles que sean mucho mejores que adivinar y que en algunos casos sean mejores que las opiniones de expertos. Para lograr esto de manera óptima, hacemos uso de representaciones probabilísticas del problema basadas en las ideas presentadas en la Sección \ref{conditional-expectation}. Las observaciones con los mismos valores observados para los predictores pueden ser desiguales, pero podemos suponer que todas tienen la misma probabilidad de esta clase o de esa clase. Escribiremos esta idea matemáticamente para el caso de datos categóricos.

\hypertarget{probabilidades-condicionales-1}{%
\subsection{Probabilidades condicionales}\label{probabilidades-condicionales-1}}

Usamos la notación \((X_1 = x_1,\dots,X_p=x_p)\) para representar el hecho de que hemos observado valores \(x_1, \dots ,x_p\) para covariables \(X_1, \dots, X_p\). Esto no implica que el resultado \(Y\) tomará un valor específico. En cambio, implica una probabilidad específica. En particular, denotamos las \emph{probabilidades condicionales} para cada clase \(k\):

\[
\mbox{Pr}(Y=k \mid X_1 = x_1,\dots,X_p=x_p), \, \mbox{for}\,k=1,\dots,K
\]

Para evitar escribir todos los predictores, utilizamos letras en negrilla así: \(\mathbf{X} \equiv (X_1,\dots,X_p)\) y \(\mathbf{x} \equiv (x_1,\dots,x_p)\). También usaremos la siguiente notación para la probabilidad condicional de ser clase \(k\):

\[
p_k(\mathbf{x}) = \mbox{Pr}(Y=k \mid \mathbf{X}=\mathbf{x}), \, \mbox{for}\, k=1,\dots,K
\]

\textbf{Ojo}: Utilizaremos la notación \(p(x)\) para representar probabilidades condicionales como funciones de los predictores. No lo confundan con el \(p\) que representa el número de predictores.

Estas probabilidades guían la construcción de un algoritmo que mejora la predicción: para cualquier \(\mathbf{x}\), vamos a predecir la clase \(k\) con la mayor probabilidad entre \(p_1(x),p_2(x),\dots p_K(x)\). En notación matemática, lo escribimos así: \(\hat{Y}=\max_k p_k(\mathbf{x})\).

En \emph{machine learning}, nos referimos a esto como la \emph{Regla de Bayes}. Pero recuerden que esta es una regla teórica ya que en la práctica no sabemos \(p_k(\mathbf{x}),k=1,\dots,K\). De hecho, estimar estas probabilidades condicionales puede considerarse como el principal desafío de \emph{machine learning}. Cuanto mejores sean nuestros estimadores de la probabilidad \(\hat{p}_k(\mathbf{x})\), mejor será nuestro predictor:

\[\hat{Y} = \max_k \hat{p}_k(\mathbf{x})\]

Entonces, lo que predeciremos depende de dos cosas: 1) cuán cerca están las \(\max_k p_k(\mathbf{x})\) a 1 o 0 (certeza perfecta)
y 2) cuán cerca están nuestros estimadores de \(\hat{p}_k(\mathbf{x})\) a \(p_k(\mathbf{x})\). No podemos hacer nada con respecto a la primera restricción, ya que está determinada por la naturaleza del problema y, por lo tanto, nos dedicaremos a encontrar buenas formas de estimar las probabilidades condicionales. La primera restricción implica que tenemos límites en cuanto a cuán bien puede funcionar hasta el mejor algoritmo posible. Deberían acostumbrarse a la idea de que, si bien en algunos retos podremos lograr una exactitud casi perfecta, por ejemplo con lectores de dígitos, en otros nuestro éxito está restringido por la aleatoriedad del proceso, como con recomendaciones de películas.

Antes de continuar, es importante recordar que definir nuestra predicción maximizando la probabilidad no siempre es óptimo en la práctica y depende del contexto. Como se discutió anteriormente, la sensibilidad y la especificidad pueden diferir en importancia. Pero incluso en estos casos, tener un buen estimador de la \(p_k(x), k=1,\dots,K\) nos bastará para construir modelos de predicción óptimos, ya que podemos controlar el equilibrio entre especificidad y sensibilidad como queramos. Por ejemplo, simplemente podemos cambiar los umbrales utilizados para predecir un resultado u otro. En el ejemplo del avión, podemos evitar que vuela un avión en cualquier momento en que la probabilidad de mal funcionamiento sea superior a 1 en un millón, en lugar del 1/2 predeterminado que se usa cuando los tipos de error son igualmente indeseados.

\hypertarget{expectativas-condicionales}{%
\subsection{Expectativas condicionales}\label{expectativas-condicionales}}

Para datos binarios, pueden pensar en la probabilidad \(\mbox{Pr}(Y=1 \mid \mathbf{X}=\mathbf{x})\) como la proporción de 1s en el estrato de la población para la cual \(\mathbf{X}=\mathbf{x}\). Muchos de los algoritmos que aprenderemos se pueden aplicar tanto a datos categóricos como continuos debido a la conexión entre las \emph{probabilidades condicionales} y las \emph{expectativas condicionales}.

Porque la expectativa es el promedio de los valores \(y_1,\dots,y_n\) en la población, en el caso en que las \(y\)s son 0 o 1, la expectativa es equivalente a la probabilidad de elegir aleatoriamente un 1 ya que el promedio es simplemente la proporción de 1s:

\[
\mbox{E}(Y \mid \mathbf{X}=\mathbf{x})=\mbox{Pr}(Y=1 \mid \mathbf{X}=\mathbf{x}).
\]

Como resultado, a menudo solo usamos la expectativa para denotar tanto la probabilidad condicional como la expectativa condicional.

Al igual que con los resultados categóricos, en la mayoría de las aplicaciones, los mismos predictores observados no garantizan los mismos resultados continuos. En cambio, suponemos que el resultado sigue la misma distribución condicional. Ahora explicaremos por qué usamos la expectativa condicional para definir nuestros predictores.

\hypertarget{la-expectativa-condicional-minimiza-la-funciuxf3n-de-puxe9rdida-cuadruxe1tica}{%
\subsection{La expectativa condicional minimiza la función de pérdida cuadrática}\label{la-expectativa-condicional-minimiza-la-funciuxf3n-de-puxe9rdida-cuadruxe1tica}}

¿Por qué nos importa la expectativa condicional en \emph{machine learning}? Se debe a que el valor esperado tiene una propiedad matemática atractiva: minimiza el MSE. Específicamente, de todas las posibles predicciones \(\hat{Y}\),

\[
\hat{Y} = \mbox{E}(Y \mid \mathbf{X}=\mathbf{x}) \, \mbox{ minimizes } \, \mbox{E}\{ (\hat{Y} - Y)^2 \mid \mathbf{X}=\mathbf{x} \}
\]

Debido a esta propiedad, una descripción sucinta de la tarea principal de \emph{machine learning} es que utilizamos datos para estimar:

\[
f(\mathbf{x}) \equiv \mbox{E}( Y \mid \mathbf{X}=\mathbf{x} )
\]

para cualquier conjunto de características \(\mathbf{x} = (x_1, \dots, x_p)\). Por supuesto, esto es más fácil decirlo que hacerlo, ya que esta función puede tomar cualquier forma y \(p\) puede ser muy grande. Consideren un caso en el que solo tenemos un predictor \(x\). La expectativa \(\mbox{E}\{ Y \mid X=x \}\) puede ser cualquier función de \(x\): una línea, una parábola, una onda sinusoidal, una función escalón, etc. Se vuelve aún más complicado cuando consideramos instancias con grandes \(p\), en cual caso \(f(\mathbf{x})\) es una función de un vector multidimensional \(\mathbf{x}\). ¡Por ejemplo, en nuestro ejemplo de lector de dígitos \(p = 784\)! \textbf{La principal forma en que los algoritmos competitivos de \emph{machine learning} difieren es en su enfoque para estimar esta expectativa. }

\hypertarget{ejercicios-46}{%
\section{Ejercicios}\label{ejercicios-46}}

1. Calcule las probabilidades condicionales de ser hombre para el set the datos \texttt{heights}. Redondee las alturas a la pulgada más cercana. Grafique la probabilidad condicional estimada \(P(x) = \mbox{Pr}(\mbox{Male} | \mbox{height}=x)\) para cada \(x\).

2. En el gráfico que acabamos de hacer, vemos una gran variabilidad para valores bajos de altura. Esto se debe a que tenemos pocos puntos de datos en estos estratos. Use la función \texttt{quantile} para cuantiles \(0.1,0.2,\dots,0.9\) y la función \texttt{cut} para asegurar que cada grupo tenga el mismo número de puntos. Sugerencia: para cualquier vector numérico \texttt{x}, puede crear grupos basados en cuantiles como este:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cut}\NormalTok{(x, }\FunctionTok{quantile}\NormalTok{(x, }\FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.1}\NormalTok{)), }\AttributeTok{include.lowest =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

3. Genere datos a partir de una distribución normal de dos variables utilizando el paquete \textbf{MASS} como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \DecValTok{9}\SpecialCharTok{*}\FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\FloatTok{0.5}\NormalTok{,}\FloatTok{0.5}\NormalTok{,}\DecValTok{1}\NormalTok{), }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(}\AttributeTok{n =} \DecValTok{10000}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{69}\NormalTok{, }\DecValTok{69}\NormalTok{), Sigma) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Pueden hacer un gráfico rápido de los datos usando \texttt{plot(dat)}. Use un enfoque similar al ejercicio anterior para estimar las expectativas condicionales y haga un gráfico.

\hypertarget{two-or-seven}{%
\section{Estudio de caso: ¿es un 2 o un 7?}\label{two-or-seven}}

En los dos ejemplos anteriores, solo teníamos un predictor. Realmente no consideramos estos retos de \emph{machine learning}, que se caracterizan por casos con muchos predictores. Volvamos al ejemplo de dígitos en el que teníamos 784 predictores. Para fines ilustrativos, comenzaremos simplificando este problema a uno con dos predictores y dos clases. Específicamente, definimos el desafío como construir un algoritmo que pueda determinar si un dígito es un 2 o 7 de los predictores. No estamos del todo listos para construir algoritmos con 784 predictores, por lo que extraeremos dos predictores sencillos de los 784: la proporción de píxeles oscuros que están en el cuadrante superior izquierdo (\(X_1\)) y el cuadrante inferior derecho (\(X_2\)).

Entonces seleccionamos una muestra aleatoria de 1,000 dígitos, 500 en el set de entrenamiento y 500 en el set de evaluación. Proveemos este set de datos en el paquete \texttt{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos explorar los datos graficando los dos predictores y usando colores para denotar las etiquetas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{color =}\NormalTok{ y)) }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/two-or-seven-scatter-1} \end{center}

Inmediatamente vemos algunos patrones. Por ejemplo, si \(X_1\) (el panel superior izquierdo) es muy grande, entonces el dígito es probablemente un 7. Además, para valores más pequeños de \(X_1\), los 2s parecen estar en los valores de rango medio de \(X_2\).

Para ilustrar como interpretar \(X_1\) y \(X_2\), incluimos cuatro imágenes como ejemplo. A la izquierda están las imágenes originales de los dos dígitos con los valores más grandes y más pequeños para \(X_1\) y a la derecha tenemos las imágenes correspondientes a los valores más grandes y más pequeños de \(X_2\):

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/two-or-seven-images-large-x1-1} \end{center}

Comenzamos a tener una idea de por qué estos predictores son útiles, pero también por qué el problema será algo desafiante.

Realmente no hemos aprendido ningún algoritmo todavía, así que intentemos construir un algoritmo usando regresión. El modelo es simplemente:

\[
p(x_1, x_2) = \mbox{Pr}(Y=1 \mid X_1=x_1 , X_2 = x_2) =
\beta_0 + \beta_1 x_1 + \beta_2 x_2
\]

Lo ajustamos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{ifelse}\NormalTok{(y}\SpecialCharTok{==}\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x\_1 }\SpecialCharTok{+}\NormalTok{ x\_2, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

Ahora podemos construir una regla de decisión basada en el estimador \(\hat{p}(x_1, x_2)\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{p\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, }\AttributeTok{newdata =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{test)}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{ifelse}\NormalTok{(p\_hat }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.75}
\end{Highlighting}
\end{Shaded}

Obtenemos una exactidud muy superior al 50\%. No está mal para nuestro primer intento. ¿Pero podemos mejorar?

Como construimos el ejemplo \texttt{mnist\_27} y tuvimos a nuestra disposición 60,000 dígitos solo en el set de datos MNIST, lo usamos para construir la distribución condicional \emph{verdadera} \(p(x_1, x_2)\). Recuerden que esto es algo a lo que no tenemos acceso en la práctica, pero lo incluimos en este ejemplo porque permite comparar \(\hat{p}(x_1, x_2)\) con la verdadera \(p(x_1, x_2)\). Esta comparación nos enseña las limitaciones de diferentes algoritmos. Hagamos eso aquí. Hemos almacenado el verdadero \(p(x_1,x_2)\) en el objeto \texttt{mnist\_27} y podemos graficar la imagen usando la función \texttt{geom\_raster()} de \textbf{ggplot2} . Elegimos mejores colores y usamos la función \texttt{stat\_contour} para dibujar una curva que separa pares \((x_1,x_2)\) para cual \(p(x_1,x_2) > 0.5\) y pares para cual \(p(x_1,x_2) < 0.5\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{true\_p }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{z =}\NormalTok{ p, }\AttributeTok{fill =}\NormalTok{ p)) }\SpecialCharTok{+}
  \FunctionTok{geom\_raster}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_gradientn}\NormalTok{(}\AttributeTok{colors=}\FunctionTok{c}\NormalTok{(}\StringTok{"\#F8766D"}\NormalTok{, }\StringTok{"white"}\NormalTok{, }\StringTok{"\#00BFC4"}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{stat\_contour}\NormalTok{(}\AttributeTok{breaks=}\FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{), }\AttributeTok{color=}\StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/true-p-better-colors-1} \end{center}

Arriba vemos un gráfico del verdadero \(p(x,y)\). Para comenzar a entender las limitaciones de la regresión logística aquí, primero tengan en cuenta que con la regresión logística \(\hat{p}(x,y)\) tiene que ser un plano y, como resultado, el umbral definido por la regla de decisión lo da:
\(\hat{p}(x,y) = 0.5\), lo que implica que el umbral no puede ser otra cosa que una línea recta:

\[
\hat{\beta}_0 + \hat{\beta}_1 x_1 + \hat{\beta}_2 x_2 = 0.5 \implies
\hat{\beta}_0 + \hat{\beta}_1 x_1 + \hat{\beta}_2 x_2 = 0.5 \implies
x_2 = (0.5-\hat{\beta}_0)/\hat{\beta}_2 -\hat{\beta}_1/\hat{\beta}_2 x_1
\]

Noten que, para este umbral, \(x_2\) es una función lineal de \(x_1\). Esto implica que nuestro enfoque de regresión logística no tiene posibilidades de capturar la naturaleza no lineal de la verdadera \(p(x_1,x_2)\). A continuación se muestra una representación visual de \(\hat{p}(x_1, x_2)\). Utilizamos la función \texttt{squish} del paquete \textbf{scales} para restringir los estimados entre 0 y 1. Podemos ver dónde se cometieron los errores al mostrar también los datos y el umbral. Principalmente provienen de valores bajos \(x_1\) que tienen un valor alto o bajo de \(x_2\). La regresión no puede detectar esto.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/regression-p-hat-1} \end{center}

Necesitamos algo más flexible: un método que permita estimadores con formas distintas a un plano.

Vamos a aprender algunos algoritmos nuevos basados en diferentes ideas y conceptos. Pero lo que todos tienen en común es que permiten enfoques más flexibles. Comenzaremos describiendo alogoritmos basados en \emph{nearest neighbor} o \emph{kernels}. Para introducir los conceptos detrás de estos enfoques, comenzaremos nuevamente con un ejemplo unidimensional sencillo y describiremos el concepto de \emph{suavización} (\emph{smoothing} en inglés).

\hypertarget{suavizaciuxf3n}{%
\chapter{Suavización}\label{suavizaciuxf3n}}

Antes de continuar aprendiendo sobre algoritmos de \emph{machine learning}, presentamos el importante concepto de \emph{suavización} (\emph{smoothing} en inglés). La suavización es una técnica muy poderosa comúnmente usada en el análisis de datos. Otros nombres dados a esta técnica son \emph{ajustamiento de curvas} y \emph{filtro de paso bajo} (\emph{curve fitting} y \emph{low pass filtering} en inglés). La suavización está diseñada para detectar tendencias en presencia de datos ruidosos cuando se desconoce la forma real de la tendencia. El nombre \emph{suavización} proviene del hecho de que para lograr esta hazaña, suponemos que la tendencia es \emph{suave}, como una superficie lisa. En cambio, el ruido (\emph{noise} en inglés), o la desviación de la tendencia, es impredeciblemente ondulante:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/signal-plus-noise-example-1} \end{center}

Parte de lo que explicamos en esta sección son los supuestos que nos permiten extraer la tendencia del ruido.

Para entender por qué cubrimos este tema, recuerden que los conceptos detrás de las técnicas de suavización son extremadamente útiles en \emph{machine learning} porque las expectativas/probabilidades condicionales que necesitamos estimar pueden considerarse como tendencias de formas desconocidas afectadas por incertidumbre.

Para explicar estos conceptos, nos enfocaremos primero en un problema con un solo predictor. Específicamente, tratamos de estimar la tendencia temporal en el margen de la encuesta de votación popular de 2008 en Estados Unidos (la diferencia entre Obama y McCain).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_2008"}\NormalTok{)}
\FunctionTok{qplot}\NormalTok{(day, margin, }\AttributeTok{data =}\NormalTok{ polls\_2008)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-data-1} \end{center}

Para los fines de este ejemplo, no lo piensen como un problema de pronóstico. En cambio, simplemente estamos interesados en entender la forma de la tendencia \emph{después} de que terminen las elecciones.

Suponemos que para cualquier día \(x\), hay una verdadera preferencia entre el electorado \(f(x)\), pero debido a la incertidumbre introducida por el sondeo, cada punto de datos viene con un error \(\varepsilon\). Un modelo matemático para el margen de encuesta observado \(Y_i\) es:

\[
Y_i = f(x_i) + \varepsilon_i
\]

Para pensar en esto como un problema de \emph{machine learning}, recuerden que queremos predecir \(Y\) dado un día \(x\). Si supiéramos la expectativa condicional \(f(x) = \mbox{E}(Y \mid X=x)\), la usaríamos. Pero como no conocemos esta expectativa condicional, tenemos que estimarla. Usemos la regresión, ya que es el único método que hemos aprendido hasta ahora.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/linear-regression-not-flexible-1} \end{center}

La línea que vemos no parece describir muy bien la tendencia. Por ejemplo, el 4 de septiembre (día -62), se celebró la Convención Republicana y los datos sugieren que este evento le dio a John McCain un impulso en las encuestas. Sin embargo, la línea de regresión no captura esta tendencia potencial. Para ver más claramente la \emph{falta de ajuste}, observamos que los puntos por encima de la línea ajustada (azul) y los de abajo (rojo) no se distribuyen uniformemente entre los días. Por lo tanto, necesitamos un enfoque alternativo más flexible.

\hypertarget{suavizaciuxf3n-de-compartimientos}{%
\section{Suavización de compartimientos}\label{suavizaciuxf3n-de-compartimientos}}

La idea general de la suavización es agrupar los puntos de datos en estratos en los que el valor de \(f(x)\) se puede suponer que es constante. Podemos hacer esta suposición porque pensamos que \(f(x)\) cambia lentamente y, como resultado, \(f(x)\) es casi constante en pequeñas ventanas de tiempo. Un ejemplo de esta idea para los datos \texttt{poll\_2008} es suponer que la opinión pública se mantuvo aproximadamente igual en el plazo de una semana. Con este supuesto, tenemos varios puntos de datos con el mismo valor esperado.

Si fijamos un día para estar en el centro de nuestra semana, llámelo \(x_0\), entonces para cualquier otro día \(x\) tal que \(|x - x_0| \leq 3.5\), suponemos que \(f(x)\) es una constante \(f(x) = \mu\). Esta suposición implica que:
\[
E[Y_i | X_i = x_i ] \approx \mu \mbox{ if } |x_i - x_0| \leq 3.5
\]

En la suavización, llamamos el tamaño del intervalo que satisface \(|x_i - x_0| \leq 3.5\), el \emph{tamaño de la ventana}, \emph{parámetro de suavizado} o \emph{span}. Más adelante, aprenderemos como intentamos optimizar este parámetro.

Esta suposición implica que un buen estimador de \(f(x)\) es el promedio de \(Y_i\) valores en la ventana. Si definimos \(A_0\) como el conjunto de índices \(i\) tal que \(|x_i - x_0| \leq 3.5\) y \(N_0\) como el número de índices en \(A_0\), entonces nuestro estimador es:

\[
\hat{f}(x_0) = \frac{1}{N_0} \sum_{i \in A_0} Y_i
\]

La idea detrás de la \emph{suavización de compartimientos} (\emph{bin smoothing} en inglés) es hacer este cálculo con cada valor de \(x\) como el centro. En el ejemplo de la encuesta, para cada día, calcularíamos el promedio de los valores dentro de una semana con ese día en el centro. Aquí hay dos ejemplos: \(x_0 = -125\) y \(x_0 = -55\). El segmento azul representa el promedio resultante.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/binsmoother-expained-1} \end{center}

Al calcular esta media para cada punto, formamos un estimador de la curva subyacente \(f(x)\). A continuación, mostramos el procedimiento que ocurre a medida que avanzamos de -155 a 0. En cada valor de \(x_0\), mantenemos el estimador \(\hat{f}(x_0)\) y continuamos al siguiente punto:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/binsmoother-animation-1} \end{center}

El código final y el estimador resultante se ven así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{span }\OtherTok{\textless{}{-}} \DecValTok{7}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(polls\_2008,}
            \FunctionTok{ksmooth}\NormalTok{(day, margin, }\AttributeTok{kernel =} \StringTok{"box"}\NormalTok{, }\AttributeTok{bandwidth =}\NormalTok{ span))}

\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{smooth =}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{y) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{5}\NormalTok{, }\AttributeTok{color =} \StringTok{"grey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, smooth), }\AttributeTok{color=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/binsmoother-final-1} \end{center}

\hypertarget{kernels}{%
\section{Kernels}\label{kernels}}

El resultado final de la suavización de compartimientos es bastante ondulante. Una de las razones es que cada vez que la ventana se mueve, cambian dos puntos. Podemos atenuar esto algo tomando promedios ponderados que le dan al punto central más peso que a los puntos lejanos, con los dos puntos en los bordes recibiendo muy poco peso.

Pueden pensar en el enfoque de suavización de compartimiento como un promedio ponderado:

\[
\hat{f}(x_0) = \sum_{i=1}^N w_0(x_i) Y_i
\]

en el que cada punto recibe un peso de \(0\) o \(1/N_0\), con \(N_0\) el número de puntos en la semana. En el código anterior, usamos el argumento \texttt{kernel="box"} en nuestra llamada a la función \texttt{ksmooth}. Esto se debe a que la \emph{función de peso} \(w_0(x)\) parece una caja. La función \texttt{ksmooth} ofrece una opción ``más suave'' que utiliza la densidad normal para asignar pesos.

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/gaussian-kernel-1} \end{center}

El código final y el gráfico resultante para el \emph{kernel} normal se ven así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{span }\OtherTok{\textless{}{-}} \DecValTok{7}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(polls\_2008,}
            \FunctionTok{ksmooth}\NormalTok{(day, margin, }\AttributeTok{kernel =} \StringTok{"normal"}\NormalTok{, }\AttributeTok{bandwidth =}\NormalTok{ span))}

\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{smooth =}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{y) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{5}\NormalTok{, }\AttributeTok{color =} \StringTok{"grey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, smooth), }\AttributeTok{color=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/final-ksmooth-normal-kernel-1} \end{center}

Observen que el estimador final ahora se ve más suave.

Hay varias funciones en R que implementan suavizadores de compartimientos. Un ejemplo es \texttt{ksmooth}, que mostramos arriba. En la práctica, sin embargo, generalmente preferimos métodos que usan modelos ligeramente más complejos que ajustar una constante. El resultado final arriba, por ejemplo, todavía es algo ondulante en partes que no esperamos que sea (entre -125 y -75, por ejemplo). Métodos como \texttt{loess}, que explicamos a continuación, mejoran esto.

\hypertarget{regresiuxf3n-ponderada-local-loess}{%
\section{Regresión ponderada local (loess)}\label{regresiuxf3n-ponderada-local-loess}}

Una limitación del enfoque de suavización de compartimientos que acabamos de describir es que necesitamos ventanas pequeñas para que se cumpla el supuesto de que la función es aproximadamente constante. Como resultado, terminamos con un pequeño número de puntos de datos para promediar y obtener estimaciones imprecisas \(\hat{f}(x)\). Aquí describimos cómo la \emph{regresión ponderada local} (loess o \emph{local weighted regression} en inglés) nos permite considerar tamaños de ventana más grandes. Para hacer esto, usaremos un resultado matemático, conocido como el teorema de Taylor, que dice que si examinamos muy de cerca cualquier función suave \(f(x)\), parecerá una línea. Para ver por qué esto tiene sentido, consideren los bordes curvos que hacen los jardineros con palas rectas:

\begin{center}\includegraphics[width=0.7\linewidth]{ml/img//garden} \end{center}

(``Downing Street garden path edge''\footnote{\url{https://www.flickr.com/photos/49707497@N06/7361631644}} del usuario de Flckr Número 10\footnote{\url{https://www.flickr.com/photos/number10gov/}}. Licencia CC-BY 2.0\footnote{\url{https://creativecommons.org/licenses/by/2.0/}}.)

En lugar de suponer que la función es aproximadamente constante en una ventana, suponemos que la función es localmente lineal. Podemos considerar tamaños de ventana más grandes cuando suponemos que la función es localmente lineal que cuando suponemos que es localmente constante. En lugar de la ventana de una semana, consideramos una ventana más grande en la que la tendencia es aproximadamente lineal. Comenzamos con una ventana de tres semanas y luego consideramos y evaluamos otras opciones:

\[
E[Y_i | X_i = x_i ] = \beta_0 + \beta_1 (x_i-x_0) \mbox{ if } |x_i - x_0| \leq 21
\]

Para cada punto \(x_0\), loess define una ventana y ajusta una línea dentro de esa ventana. Aquí hay un ejemplo que muestra los ajustes para \(x_0=-125\) y \(x_0 = -55\):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/loess-1} \end{center}

El valor ajustado en \(x_0\) se convierte en nuestro estimador \(\hat{f}(x_0)\). A continuación, mostramos el procedimiento que ocurre mientras cambiamos de -155 a 0.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/loess-animation-1} \end{center}

El resultado final es un ajuste más suave que ese producido por la suavización de compartimiento porque utilizamos tamaños de muestra más grandes para estimar nuestros parámetros locales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{total\_days }\OtherTok{\textless{}{-}} \FunctionTok{diff}\NormalTok{(}\FunctionTok{range}\NormalTok{(polls\_2008}\SpecialCharTok{$}\NormalTok{day))}
\NormalTok{span }\OtherTok{\textless{}{-}} \DecValTok{21}\SpecialCharTok{/}\NormalTok{total\_days}

\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{loess}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ day, }\AttributeTok{degree=}\DecValTok{1}\NormalTok{, }\AttributeTok{span =}\NormalTok{ span, }\AttributeTok{data=}\NormalTok{polls\_2008)}

\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{smooth =}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{fitted) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{5}\NormalTok{, }\AttributeTok{color =} \StringTok{"grey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, smooth), }\AttributeTok{color=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/final-loess-1} \end{center}

Podemos ver cómo diferentes tamaños de ventanas, \emph{spans}, conducen a diferentes estimadores:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/loess-multi-span-animation-1} \end{center}

Aquí están los estimadores finales:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/loess-final-1} \end{center}

Hay otras tres diferencias entre \texttt{loess} y el típico suavizador de compartimiento.

1. En vez de mantener el tamaño del compartimiento igual, \texttt{loess} mantiene el mismo número de puntos utilizados en el ajuste local. Este número se controla a través del argumento \texttt{span}, que espera una proporción. Por ejemplo, si \texttt{N} es el número de puntos de datos y \texttt{span=0.5}, entonces para un determinado \(x\), \texttt{loess} usará los \texttt{0.5\ *\ N} puntos más cercanos a \(x\) para el ajuste.

2. Al ajustar una línea localmente, \texttt{loess} utiliza un enfoque \emph{ponderado}. Básicamente, en lugar de usar mínimos cuadrados, minimizamos una versión ponderada:

\[
\sum_{i=1}^N w_0(x_i) \left[Y_i - \left\{\beta_0 + \beta_1 (x_i-x_0)\right\}\right]^2
\]

Sin embargo, en lugar del \emph{kernel} gaussiano, loess usa una función llamada el \emph{Tukey tri-weight}:

\[
W(u)= \left( 1 - |u|^3\right)^3 \mbox{ if } |u| \leq 1 \mbox{ and } W(u) = 0 \mbox{ if } |u| > 1
\]

Para definir los pesos, denotamos \(2h\) como el tamaño de la ventana y definimos:

\[
w_0(x_i) = W\left(\frac{x_i - x_0}{h}\right)
\]

Este \emph{kernel} difiere del \emph{kernel} gaussiano en que más puntos obtienen valores más cercanos al máximo:

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/triweight-kernel-1} \end{center}

3. \texttt{loess} tiene la opción de ajustar el modelo local \emph{robustamente}. Se implementa un algoritmo iterativo en el que, después de ajustar un modelo en una iteración, se detectan valores atípicos y se ponderan hacia abajo para la siguiente iteración. Para usar esta opción, usamos el argumento \texttt{family="symmetric"}.

\hypertarget{ajustando-con-paruxe1bolas}{%
\subsection{Ajustando con parábolas}\label{ajustando-con-paruxe1bolas}}

El teorema de Taylor también nos dice que si miramos cualquier función matemática lo suficientemente cerca, parece una parábola. El teorema además establece que no tienen que mirar tan de cerca cuando se aproxima con parábolas como cuando se aproxima con líneas. Esto significa que podemos hacer que nuestras ventanas sean aún más grandes y ajustar parábolas en lugar de líneas.

\[
E[Y_i | X_i = x_i ] = \beta_0 + \beta_1 (x_i-x_0) + \beta_2 (x_i-x_0)^2 \mbox{ if } |x_i - x_0| \leq h
\]

Este es el procedimiento por defecto de la función \texttt{loess}. Es posible que hayan notado que cuando mostramos el código para usar loess, configuramos \texttt{degree\ =\ 1}. Esto le dice a loess que se ajuste a polinomios de grado 1, un nombre elegante para líneas. Si leen la página de ayuda para loess, verán que, para el argumento \texttt{degree}, el valor predeterminado es 2. Por defecto, loess se ajusta a parábolas, no a líneas. Aquí hay una comparación de las líneas de ajuste (guiones rojos) y las parábolas de ajuste (naranja sólido):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{total\_days }\OtherTok{\textless{}{-}} \FunctionTok{diff}\NormalTok{(}\FunctionTok{range}\NormalTok{(polls\_2008}\SpecialCharTok{$}\NormalTok{day))}
\NormalTok{span }\OtherTok{\textless{}{-}} \DecValTok{28}\SpecialCharTok{/}\NormalTok{total\_days}
\NormalTok{fit\_1 }\OtherTok{\textless{}{-}} \FunctionTok{loess}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ day, }\AttributeTok{degree=}\DecValTok{1}\NormalTok{, }\AttributeTok{span =}\NormalTok{ span, }\AttributeTok{data=}\NormalTok{polls\_2008)}

\NormalTok{fit\_2 }\OtherTok{\textless{}{-}} \FunctionTok{loess}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ day, }\AttributeTok{span =}\NormalTok{ span, }\AttributeTok{data=}\NormalTok{polls\_2008)}


\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{smooth\_1 =}\NormalTok{ fit\_1}\SpecialCharTok{$}\NormalTok{fitted, }\AttributeTok{smooth\_2 =}\NormalTok{ fit\_2}\SpecialCharTok{$}\NormalTok{fitted) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{5}\NormalTok{, }\AttributeTok{color =} \StringTok{"grey"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, smooth\_1), }\AttributeTok{color=}\StringTok{"red"}\NormalTok{, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, smooth\_2), }\AttributeTok{color=}\StringTok{"orange"}\NormalTok{, }\AttributeTok{lty =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-parabola-line-loess-1} \end{center}

\texttt{degree\ =\ 2} nos da resultados más ondulantes. Por eso, preferimos \texttt{degree\ =\ 1} ya que es menos propenso a este tipo de ruido.

\hypertarget{cuidado-con-los-paruxe1metros-de-suavizaciuxf3n-predeterminados}{%
\subsection{Cuidado con los parámetros de suavización predeterminados}\label{cuidado-con-los-paruxe1metros-de-suavizaciuxf3n-predeterminados}}

\textbf{ggplot2} utiliza loess en su función \texttt{geom\_smooth}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-loess-default-1} \end{center}

Pero tengan cuidado con los parámetros predeterminados ya que rara vez son óptimos. Afortunadamente, pueden cambiarlos fácilmente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"loess"}\NormalTok{, }\AttributeTok{span =} \FloatTok{0.15}\NormalTok{, }\AttributeTok{method.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{degree=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/ggplot-loess-degree-1-1} \end{center}

\hypertarget{smoothing-ml-connection}{%
\section{\texorpdfstring{Conectando la suavización al \emph{machine learning}}{Conectando la suavización al machine learning}}\label{smoothing-ml-connection}}

Para ver cómo la suavización se relaciona con el \emph{machine learning} usando un ejemplo concreto, consideren nuestro ejemplo introducido en la Sección \ref{two-or-seven}. Si definimos el resultado \(Y = 1\) para dígitos que son siete e \(Y=0\) para dígitos que son 2, entonces estamos interesados en estimar la probabilidad condicional:

\[
p(x_1, x_2) = \mbox{Pr}(Y=1 \mid X_1=x_1 , X_2 = x_2).
\]
con \(X_1\) y \(X_2\) los dos predictores definidos en la Sección \ref{two-or-seven}. En este ejemplo, los 0s y 1s que observamos son ``ruidosos'' porque para algunas regiones las probabilidades \(p(x_1, x_2)\) no están tan cerca de 0 o 1. Por lo tanto, necesitamos estimar \(p(x_1, x_2)\). La suavización es una alternativa para lograr esto. En la Sección \ref{two-or-seven}, vimos que la regresión lineal no era lo suficientemente flexible como para capturar la naturaleza no lineal de \(p(x_1, x_2)\); los enfoques de suavización, por ende, pueden proveer una mejora. En el siguiente capítulo, describimos un algoritmo popular de \emph{machine learning}, \emph{k vecinos más cercanos}, que se basa en la suavización por compartimientos.

\hypertarget{ejercicios-47}{%
\section{Ejercicios}\label{ejercicios-47}}

1. En la parte de \emph{wrangling} de este libro, utilizamos el siguiente código para obtener recuentos de mortalidad para Puerto Rico para 2015-2018.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(lubridate)}
\FunctionTok{library}\NormalTok{(purrr)}
\FunctionTok{library}\NormalTok{(pdftools)}
\FunctionTok{library}\NormalTok{(dslabs)}

\NormalTok{fn }\OtherTok{\textless{}{-}} \FunctionTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\StringTok{"RD{-}Mortality{-}Report\_2015{-}18{-}180531.pdf"}\NormalTok{,}
                  \AttributeTok{package=}\StringTok{"dslabs"}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(}\FunctionTok{str\_split}\NormalTok{(}\FunctionTok{pdf\_text}\NormalTok{(fn), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(s)\{}
\NormalTok{  s }\OtherTok{\textless{}{-}} \FunctionTok{str\_trim}\NormalTok{(s)}
\NormalTok{  header\_index }\OtherTok{\textless{}{-}} \FunctionTok{str\_which}\NormalTok{(s, }\StringTok{"2015"}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
\NormalTok{  tmp }\OtherTok{\textless{}{-}} \FunctionTok{str\_split}\NormalTok{(s[header\_index], }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+"}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  month }\OtherTok{\textless{}{-}}\NormalTok{ tmp[}\DecValTok{1}\NormalTok{]}
\NormalTok{  header }\OtherTok{\textless{}{-}}\NormalTok{ tmp[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]}
\NormalTok{  tail\_index  }\OtherTok{\textless{}{-}} \FunctionTok{str\_which}\NormalTok{(s, }\StringTok{"Total"}\NormalTok{)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{str\_count}\NormalTok{(s, }\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d+"}\NormalTok{)}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{header\_index, }\FunctionTok{which}\NormalTok{(n }\SpecialCharTok{==} \DecValTok{1}\NormalTok{), }
           \FunctionTok{which}\NormalTok{(n }\SpecialCharTok{\textgreater{}=} \DecValTok{28}\NormalTok{), tail\_index}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(s))}
\NormalTok{  s[}\SpecialCharTok{{-}}\NormalTok{out] }\SpecialCharTok{\%\textgreater{}\%}  \FunctionTok{str\_remove\_all}\NormalTok{(}\StringTok{"[\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{d}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s]"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_trim}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{str\_split\_fixed}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+"}\NormalTok{, }\AttributeTok{n =} \DecValTok{6}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ .[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"day"}\NormalTok{, header)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =}\NormalTok{ month, }\AttributeTok{day =} \FunctionTok{as.numeric}\NormalTok{(day)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pivot\_longer}\NormalTok{(}\SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(day, month), }\AttributeTok{names\_to =} \StringTok{"year"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"deaths"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{deaths =} \FunctionTok{as.numeric}\NormalTok{(deaths))}
\NormalTok{\}) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =} \FunctionTok{recode}\NormalTok{(month, }
                        \StringTok{"JAN"} \OtherTok{=} \DecValTok{1}\NormalTok{, }\StringTok{"FEB"} \OtherTok{=} \DecValTok{2}\NormalTok{, }\StringTok{"MAR"} \OtherTok{=} \DecValTok{3}\NormalTok{, }
                        \StringTok{"APR"} \OtherTok{=} \DecValTok{4}\NormalTok{, }\StringTok{"MAY"} \OtherTok{=} \DecValTok{5}\NormalTok{, }\StringTok{"JUN"} \OtherTok{=} \DecValTok{6}\NormalTok{, }
                        \StringTok{"JUL"} \OtherTok{=} \DecValTok{7}\NormalTok{, }\StringTok{"AGO"} \OtherTok{=} \DecValTok{8}\NormalTok{, }\StringTok{"SEP"} \OtherTok{=} \DecValTok{9}\NormalTok{, }
                        \StringTok{"OCT"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"NOV"} \OtherTok{=} \DecValTok{11}\NormalTok{, }\StringTok{"DEC"} \OtherTok{=} \DecValTok{12}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{date =} \FunctionTok{make\_date}\NormalTok{(year, month, day)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(date }\SpecialCharTok{\textless{}=} \StringTok{"2018{-}05{-}01"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Utilice la función \texttt{loess} para obtener un estimador uniforme del número esperado de muertes como función de la fecha. Grafique la función suave que resulta. Use un \emph{span} de dos meses.

2. Grafique los estimadores suaves como función del día del año, todas en el mismo gráfico pero con diferentes colores.

3. Suponga que queremos predecir 2s y 7s en nuestro set de datos \texttt{mnist\_27} con solo la segunda covariable. ¿Podemos hacer esto? A primera vista parece que los datos no tienen mucho poder predictivo. De hecho, si ajustamos una regresión logística regular, ¡el coeficiente para \texttt{x\_2} no es significativo!

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(broom)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{glm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x\_2, }\AttributeTok{family =} \StringTok{"binomial"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ .) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{tidy}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Graficar un diagrama de dispersión aquí no es útil ya que \texttt{y} es binario:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x\_2, y, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\end{Highlighting}
\end{Shaded}

Ajuste una línea loess a los datos anteriores y grafique los resultados. Observe que hay poder predictivo, excepto que la probabilidad condicional no es lineal.

\hypertarget{cross-validation}{%
\chapter{Validación cruzada}\label{cross-validation}}

En este capítulo, presentamos la validación cruzada (\emph{cross validation} en inglés), una de las ideas más importantes de \emph{machine learning}. Aquí nos centramos en los aspectos conceptuales y matemáticos. Describiremos cómo implementar la validación cruzada en la práctica con el paquete \textbf{caret} en la Sección \ref{caret-cv} del proximo capitulo. Para motivar el concepto, utilizaremos los dos datos de dígitos predictores presentados en la Sección \ref{two-or-seven} y cubriremos, por primera vez, un algoritmo real de \emph{machine learning}: \emph{k vecinos más cercanos} (kNN o \emph{k-nearest neighbors} en inglés).

\hypertarget{knn-cv-intro}{%
\section{Motivación con k vecinos más cercanos}\label{knn-cv-intro}}

Empecemos cargando los datos y mostrando un gráfico de los predictores con resultados representados con color.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{color =}\NormalTok{ y)) }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-27-data-1} \end{center}

Utilizaremos estos datos para estimar la función de probabilidad condicional:

\[
p(x_1, x_2) = \mbox{Pr}(Y=1 \mid X_1=x_1 , X_2 = x_2)
\]

como se define en la Sección \ref{smoothing-ml-connection}. Con kNN estimamos \(p(x_1, x_2)\) de manera similar a la suavización de compartimientos. Sin embargo, como veremos, kNN es más fácil de adaptar a múltiples dimensiones. Primero, definimos la distancia entre todas las observaciones según los atributos. Entonces, para cualquier punto \((x_1,x_2)\) para el cual queremos un estimador de \(p(x_1, x_2)\), buscamos los \(k\) puntos más cercanos a \((x_1,x_2)\) y calculamos el promedio de los 0s y 1s asociados con estos puntos. Nos referimos al conjunto de puntos utilizados para calcular el promedio como el \emph{vecindario} (\emph{neighborhood} en inglés). Debido a la conexión que describimos anteriormente entre las expectativas condicionales y las probabilidades condicionales, esto nos da un estimador \(\hat{p}(x_1,x_2)\), al igual que el suavizador de compartimiento nos dio un estimador de una tendencia. Como en el caso de los suavizadores de compartimientos, podemos controlar la flexibilidad de nuestro estimador, en este caso a través del parámetro \(k\): \(k\)s más grandes resultan en estimadores más suaves, mientras que \(k\)s más pequeñas resultan en estimadores más flexibles y más ondulados.

Para implementar el algoritmo, podemos usar la función \texttt{knn3} del paquete \textbf{caret}. Mirando el archivo de ayuda para este paquete, vemos que podemos llamarlo de una de dos maneras. Utilizaremos el primero en el que especificamos una \emph{formula} y un \emph{data frame}. El \emph{data frame} contiene todos los datos que se utilizarán. La fórmula tiene la forma \texttt{outcome\ \textasciitilde{}\ predictor\_1\ +\ predictor\_2\ +\ predictor\_3} y así sucesivamente. Por lo tanto, escribiríamos \texttt{y\ \textasciitilde{}\ x\_1\ +\ x\_2}. Si vamos a usar todos los predictores, podemos usar el \texttt{.} así \texttt{y\ \textasciitilde{}\ .}. La llamada final se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{knn\_fit }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\end{Highlighting}
\end{Shaded}

Para esta función, también debemos elegir un parámetro: el número de \emph{vecinos} para incluir. Comencemos con el valor predeterminado \(k=5\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knn\_fit }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{k =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En este caso, dado que nuestro set de datos es equilibrado y nos preocupamos tanto por la sensibilidad como por la especificidad, utilizaremos la exactitud para cuantificar el rendimiento.

La función \texttt{predict} para \texttt{knn} produce una probabilidad para cada clase. Mantenemos la probabilidad de ser un 7 como el estimador \(\hat{p}(x_1, x_2)\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.815}
\end{Highlighting}
\end{Shaded}

En la Sección \ref{two-or-seven}, utilizamos la regresión lineal para generar un estimador.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit\_lm }\OtherTok{\textless{}{-}}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{ifelse}\NormalTok{(y }\SpecialCharTok{==} \DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x\_1 }\SpecialCharTok{+}\NormalTok{ x\_2, }\AttributeTok{data =}\NormalTok{ .)}
\NormalTok{p\_hat\_lm }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_lm, mnist\_27}\SpecialCharTok{$}\NormalTok{test)}
\NormalTok{y\_hat\_lm }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{ifelse}\NormalTok{(p\_hat\_lm }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_lm, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.75}
\end{Highlighting}
\end{Shaded}

Y vemos que kNN, con el parámetro predeterminado, ya supera la regresión. Para ver por qué este es el caso, graficaremos \(\hat{p}(x_1, x_2)\) y lo compararemos con la probabilidad condicional verdadera \(p(x_1, x_2)\):

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/knn-fit-1} \end{center}

Vemos que kNN se adapta mejor a la forma no lineal de \(p(x_1, x_2)\). Sin embargo, nuestro estimador tiene algunas islas de azul en el área roja, lo que intuitivamente no tiene mucho sentido. Esto se debe a lo que llamamos \emph{sobreentrenamiento} (\emph{overtraining} en inglés). Describimos el \emph{sobreentrenamiento} en detalle a continuación. Este es la razón por la que tenemos una mayor exactitud en el set de entrenamiento en comparación con el set de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit, mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.882}

\NormalTok{y\_hat\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.815}
\end{Highlighting}
\end{Shaded}

\hypertarget{sobreentrenamiento}{%
\subsection{Sobreentrenamiento}\label{sobreentrenamiento}}

El \emph{sobreentrenamiento} es peor cuando fijamos \(k=1\). Con \(k=1\), el estimador para cada \((x_1, x_2)\) en el set de entrenamiento se obtiene solo con la \(y\) correspondiente a ese punto. En este caso, si \((x_1, x_2)\) son únicos, obtendremos una exactitud perfecta en el set de entrenamiento porque cada punto se usa para predecirse a sí mismo. Recuerden que si los predictores no son únicos y tienen resultados diferentes para al menos un set de predictores, entonces es imposible predecir perfectamente.

Aquí ajustamos un modelo kNN con \(k=1\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knn\_fit\_1 }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{k =} \DecValTok{1}\NormalTok{)}
\NormalTok{y\_hat\_knn\_1 }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit\_1, mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn\_1, mnist\_27}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.999}
\end{Highlighting}
\end{Shaded}

Sin embargo, la exactitud del set de evaluación es peor que la regresión logística:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_knn\_1 }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit\_1, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn\_1, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.74}
\end{Highlighting}
\end{Shaded}

Podemos ver el problema de sobreajuste en estos gráficos.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/knn-1-overfit-1} \end{center}

Las curvas negras denotan los límites de la regla de decisión.

El estimador \(\hat{p}(x_1, x_2)\) sigue los datos de entrenamiento muy de cerca (izquierda). Pueden ver que en el set de entrenamiento, los límites se han trazado para rodear perfectamente un punto rojo único en un mar azul. Como la mayoría de los puntos \((x_1, x_2)\) son únicos, la predicción es 1 o 0 y la predicción para ese punto es la etiqueta asociada. Sin embargo, tan pronto introducimos el set de entrenamiento (derecha), vemos que muchas de estas pequeñas islas ahora tienen el color opuesto y terminamos haciendo varias predicciones incorrectas.

\hypertarget{sobre-suavizaciuxf3n}{%
\subsection{Sobre-suavización}\label{sobre-suavizaciuxf3n}}

Aunque no tan mal como con los ejemplos anteriores, vimos que con \(k=5\) también hemos sobreentrenado. Por lo tanto, debemos considerar una \(k\) más grande. Probemos, por ejemplo, un número mucho mayor: \(k=401\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knn\_fit\_401 }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{k =} \DecValTok{401}\NormalTok{)}
\NormalTok{y\_hat\_knn\_401 }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(knn\_fit\_401, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn\_401, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.79}
\end{Highlighting}
\end{Shaded}

Esto resulta ser similar a la regresión:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/mnist-27-glm-est-1} \end{center}

Este tamaño de \(k\) es tan grande que no permite suficiente flexibilidad. A esto lo llamamos \emph{sobre-suavización} (\emph{over-smoothing} en inglés).

\hypertarget{escogiendo-la-k-en-knn}{%
\subsection{\texorpdfstring{Escogiendo la \(k\) en kNN}{Escogiendo la k en kNN}}\label{escogiendo-la-k-en-knn}}

Entonces, ¿cómo elegimos \(k\)? En principio, queremos escoger la \(k\) que maximiza la exactitud o minimiza el MSE esperado como se define en la Sección \ref{loss-function}. El objetivo de la validación cruzada es estimar estas cantidades para cualquier algoritmo y escoger un set de parámetros de ajuste como \(k\). Para entender por qué necesitamos un método especial para hacer esto, repetimos lo que hicimos anteriormente pero para diferentes valores de \(k\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ks }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{251}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Hacemos esto usando la función \texttt{map\_df} para repetir lo anterior para cada uno.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(purrr)}
\NormalTok{accuracy }\OtherTok{\textless{}{-}} \FunctionTok{map\_df}\NormalTok{(ks, }\ControlFlowTok{function}\NormalTok{(k)\{}
\NormalTok{  fit }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{k =}\NormalTok{ k)}
  
\NormalTok{  y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\NormalTok{  cm\_train }\OtherTok{\textless{}{-}} \FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y)}
\NormalTok{  train\_error }\OtherTok{\textless{}{-}}\NormalTok{ cm\_train}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
  
\NormalTok{  y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\NormalTok{  cm\_test }\OtherTok{\textless{}{-}} \FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}
\NormalTok{  test\_error }\OtherTok{\textless{}{-}}\NormalTok{ cm\_test}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
  
  \FunctionTok{tibble}\NormalTok{(}\AttributeTok{train =}\NormalTok{ train\_error, }\AttributeTok{test =}\NormalTok{ test\_error)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que estimamos la exactitud utilizando tanto el set de entrenamiento como el set de evaluación. Ahora podemos graficar las estimadores de exactitud para cada valor de \(k\):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/accuracy-vs-k-knn-1} \end{center}

Primero, noten que el estimador obtenido en el set de entrenamiento es generalmente menor que el estimador obtenido con el set de evaluación, con una diferencia mayor para valores más pequeños de \(k\). Esto se debe al sobreentrenamiento. También, observen que el gráfico de exactitud versus \(k\) es bastante irregular. No esperamos esto porque pequeños cambios en \(k\) no deberían afectar demasiado cuán bien predice el algoritmo. La irregularidad se explica por el hecho de que la exactitud se calcula en una muestra y, por lo tanto, es una variable aleatoria. Esto demuestra por qué preferimos minimizar la pérdida esperada en lugar de la pérdida que observamos con un solo set de datos.

Si tuviéramos que usar estos estimadores para elegir la \(k\) que maximiza la exactitud, usaríamos los estimadores basados en los datos de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ks[}\FunctionTok{which.max}\NormalTok{(accuracy}\SpecialCharTok{$}\NormalTok{test)]}
\CommentTok{\#\textgreater{} [1] 41}
\FunctionTok{max}\NormalTok{(accuracy}\SpecialCharTok{$}\NormalTok{test)}
\CommentTok{\#\textgreater{} [1] 0.86}
\end{Highlighting}
\end{Shaded}

Otra razón por la cual necesitamos un mejor estimador de exactitud es que si usamos el set de evaluación para elegir esta \(k\), no debemos esperar que el estimador de exactitud que acompaña se extrapole al mundo real. Esto se debe a que incluso aquí rompimos una regla de oro de \emph{machine learning}: seleccionamos \(k\) utilizando el set de evaluación. La validación cruzada también ofrece un estimador que considera esto.

\hypertarget{descripciuxf3n-matemuxe1tica-de-validaciuxf3n-cruzada}{%
\section{Descripción matemática de validación cruzada}\label{descripciuxf3n-matemuxe1tica-de-validaciuxf3n-cruzada}}

En la Sección \ref{loss-function}, describimos que un objetivo común de \emph{machine learning} es encontrar un algoritmo que produzca predictores \(\hat{Y}\) para un resultado \(Y\) que minimiza el MSE:

\[
\mbox{MSE} = \mbox{E}\left\{ \frac{1}{N}\sum_{i=1}^N (\hat{Y}_i - Y_i)^2 \right\}
\]
Cuando todo lo que tenemos a nuestra disposición es un set de datos, podemos estimar el MSE con el MSE observado de esta manera:

\[
\hat{\mbox{MSE}} = \frac{1}{N}\sum_{i=1}^N (\hat{y}_i - y_i)^2
\]
Estos dos a menudo se conocen como el \emph{error verdadero} y el \emph{error aparente} (\emph{true error} y \emph{apparent error} en inglés), respectivamente.

Hay dos características importantes del error aparente que siempre debemos considerar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Debido a que nuestros datos son aleatorios, el error aparente es una variable aleatoria. Por ejemplo, el set de datos que tenemos puede ser una muestra aleatoria de una población más grande. Un algoritmo puede tener un error aparente menor que otro algoritmo debido a la suerte.
\item
  Si entrenamos un algoritmo en el mismo set de datos que usamos para calcular el error aparente, podríamos estar sobreentrenando. En general, cuando hacemos esto, el error aparente será una subestimación del error verdadero. Veremos un ejemplo extremo de esto con \emph{k vecinos más cercanos}.
\end{enumerate}

La validación cruzada es una técnica que nos permite aliviar estos dos problemas. Para entender la validación cruzada, es útil pensar en el error verdadero, una cantidad teórica, como el promedio de muchos errores aparentes obtenidos al aplicar el algoritmo a \(B\) nuevas muestras aleatorias de los datos, ninguna de ellas utilizada para entrenar el algoritmo. Como se muestra en un capítulo anterior, pensamos en el verdadero error como:

\[
\frac{1}{B} \sum_{b=1}^B \frac{1}{N}\sum_{i=1}^N \left(\hat{y}_i^b - y_i^b\right)^2
\]
con \(B\) un número grande que puede considerarse prácticamente infinito.
Como ya se mencionó, esta es una cantidad teórica porque solo tenemos disponible un set de resultados: \(y_1, \dots, y_n\). La validación cruzada se basa en la idea de imitar la configuración teórica anterior de la mejor manera posible con los datos que tenemos. Para hacer esto, tenemos que generar una serie de diferentes muestras aleatorias. Hay varios enfoques que podemos usar, pero la idea general para todos ellos es generar aleatoriamente sets de datos más pequeños que no se usan para el entrenamiento y, en cambio, se usan para estimar el error verdadero.

\hypertarget{validaciuxf3n-cruzada-k-fold}{%
\section{Validación cruzada K-fold}\label{validaciuxf3n-cruzada-k-fold}}

El primero que vamos a describir es \emph{validación cruzada K-fold} (\emph{K-fold cross validation} en inglés). En términos generales, un desafío de \emph{machine learning} comienza con un set de datos (azul en la imagen a continuación). Necesitamos construir un algoritmo usando este set de datos que eventualmente se usará en sets de datos completamente independientes (amarillo).

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-1} \end{center}

Pero no podemos ver estos sets de datos independientes.

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-2} \end{center}

Entonces, para imitar esta situación, separamos una parte de nuestro set de datos y nos imaginamos que es un set de datos independiente: dividimos el set de datos en un \emph{set de entrenamiento} (azul) y un \emph{set de evaluación} (rojo). Entrenaremos nuestro algoritmo exclusivamente en el set de entrenamiento y usaremos el set de evaluación solo para fines de evaluación.

Por lo general, intentamos seleccionar una pequeña parte del set de datos para tener la mayor cantidad de datos posible para entrenar. Sin embargo, también queremos que el set de evaluación sea grande para que podamos obtener un estimador estable de la pérdida sin ajustar un número poco práctico de modelos. Las opciones típicas son usar del 10\% al 20\% de los datos para la evaluación.

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-3} \end{center}

Queremos reiterar que es indispensable que no usemos el set de evaluación para nada: no para filtrar filas, no para seleccionar características, ¡para nada!

Ahora, esto presenta un nuevo problema porque para la mayoría de los algoritmos de \emph{machine learning}, necesitamos seleccionar parámetros, por ejemplo, el número de vecinos \(k\) en k vecinos más cercanos. Aquí, nos referiremos al set de parámetros como \(\lambda\). Necesitamos optimizar los parámetros del algoritmo sin usar nuestro set de evaluación y sabemos que si optimizamos y evaluamos en el mismo set de datos, sobreentrenaremos. Aquí es donde la validación cruzada es más útil.

Para cada set de parámetros de algoritmo que se considera, queremos un estimador del MSE y luego elegiremos los parámetros con el MSE más pequeño. La validación cruzada nos da este estimador.

Primero, antes de comenzar el procedimiento de validación cruzada, es importante fijar todos los parámetros del algoritmo. Aunque entrenaremos el algoritmo en el conjunto de sets de entrenamiento, los parámetros \(\lambda\) serán los mismos en todos los sets de entrenamiento. Usaremos \(\hat{y}_i(\lambda)\) para denotar los predictores obtenidos cuando usamos parámetros \(\lambda\).

Entonces, si vamos a imitar esta definición:

\[
\mbox{MSE}(\lambda) = \frac{1}{B} \sum_{b=1}^B \frac{1}{N}\sum_{i=1}^N \left(\hat{y}_i^b(\lambda) - y_i^b\right)^2
\]

queremos considerar sets de datos que puedan considerarse una muestra aleatoria independiente y queremos hacerlo varias veces. Con la validación cruzada \emph{K-fold}, lo hacemos \(K\) veces. En los dibujos animados, mostramos un ejemplo que usa \(K=5\).

Eventualmente, terminaremos con \(K\) muestras, pero comencemos describiendo cómo construir la primera: simplemente elegimos \(M=N/K\) observaciones al azar (redondeamos si \(M\) no es un número redondo) y piensen en esto como una muestra aleatoria \(y_1^b, \dots, y_M^b\), con \(b=1\). Llamamos a esto el set de validación:

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-4} \end{center}

Ahora podemos ajustar el modelo en el set de entrenamiento, luego calcular el error aparente en el set independiente:

\[
\hat{\mbox{MSE}}_b(\lambda) = \frac{1}{M}\sum_{i=1}^M \left(\hat{y}_i^b(\lambda) - y_i^b\right)^2
\]

Tengan en cuenta que esta es solo una muestra y, por consiguiente, devolverá un estimador ruidoso del error verdadero. Por eso tomamos \(K\) muestras, no solo una. En la validación cruzada \emph{k-fold}, dividimos aleatoriamente las observaciones en \(K\) sets no superpuestos:

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-5} \end{center}

Ahora repetimos el cálculo anterior para cada uno de estos sets \(b=1,\dots,K\) y obtenemos \(\hat{\mbox{MSE}}_1(\lambda),\dots, \hat{\mbox{MSE}}_K(\lambda)\). Luego, para nuestro estimador final, calculamos el promedio:

\[
\hat{\mbox{MSE}}(\lambda) = \frac{1}{B} \sum_{b=1}^K \hat{\mbox{MSE}}_b(\lambda)
\]

y obtenemos un estimador de nuestra pérdida. Un paso final sería seleccionar el \(\lambda\) que minimiza el MSE.

Hemos descrito cómo usar la validación cruzada para optimizar los parámetros. Sin embargo, ahora tenemos que considerar el hecho de que la optimización se produjo en los datos de entrenamiento y, por lo tanto, necesitamos un estimador de nuestro algoritmo final basado en datos que no se utilizaron para optimizar la elección. Aquí es donde usamos el set de evaluación que separamos al principio:

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-6} \end{center}

Podemos hacer una validación cruzada nuevamente:

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-7} \end{center}

y obtener un estimador final de nuestra pérdida esperada. Sin embargo, noten que esto significa que todo nuestro tiempo de cálculo se multiplica por \(K\). Pronto aprenderán que realizar esta tarea toma tiempo porque estamos realizando muchos cálculos complejos. Por eso, siempre estamos buscando formas de reducir este tiempo. Para la evaluación final, a menudo solo usamos un set de evaluación.

Una vez que estemos satisfechos con este modelo y queramos ponerlo a disposición de otros, podríamos reajustar el modelo en todo el set de datos, sin cambiar los parámetros optimizados.

\begin{center}\includegraphics[width=0.35\linewidth]{ml/img/cv-8} \end{center}

Ahora, ¿cómo elegimos la validación cruzada \(K\)? Grandes valores de \(K\) son preferibles porque los datos de entrenamiento imitan mejor el set de datos original. Sin embargo, lo cálculos para valores más grandes de \(K\) serán mucho más lentos: por ejemplo, la validación cruzada con 100 pliegues (\emph{folds} en inglés) será 10 veces más lenta que la validación cruzada con 10 pliegues. Por esta razón, los valores de \(K=5\) y \(K=10\) son opciones populares.

Una forma de mejorar la varianza de nuestro estimador final es tomar más muestras. Para hacer esto, ya no necesitaríamos que el set de entrenamiento se divida en sets no superpuestos. En cambio, simplemente elegiríamos \(K\) sets de algún tamaño al azar.

Una versión popular de esta técnica selecciona observaciones al azar con reemplazo en cada pliegue (lo que significa que la misma observación puede aparecer dos veces). Este enfoque tiene algunas ventajas (que no se discuten aquí) y generalmente se conoce como el \emph{bootstrap}. De hecho, este es el enfoque predeterminado en el paquete \textbf{caret}. Describimos cómo implementar la validación cruzada con el paquete \textbf{caret} en el próximo capítulo. En la siguiente sección, incluimos una explicación de cómo funciona el \emph{bootstrap} en general.

\hypertarget{ejercicios-48}{%
\section{Ejercicios}\label{ejercicios-48}}

Genere un set de predictores aleatorios y resultados como este:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1996}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{p }\OtherTok{\textless{}{-}} \DecValTok{10000}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(n }\SpecialCharTok{*}\NormalTok{ p), n, p)}
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(x), }\AttributeTok{sep =} \StringTok{"\_"}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(n, }\DecValTok{1}\NormalTok{, }\FloatTok{0.5}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{factor}\NormalTok{()}

\NormalTok{x\_subset }\OtherTok{\textless{}{-}}\NormalTok{ x[ ,}\FunctionTok{sample}\NormalTok{(p, }\DecValTok{100}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

1. Como \texttt{x} e \texttt{y} son completamente independientes, no debemos poder predecir \texttt{y} con \texttt{x} con exactitud mayor que 0.5. Confirme esto ejecutando validación cruzada utilizando regresión logística para ajustar el modelo. Debido a que tenemos tantos predictores, seleccionamos una muestra aleatoria \texttt{x\_subset}. Use el subconjunto cuando entrene el modelo. Sugerencia: use la función \texttt{train} de \textbf{caret}. El componente \texttt{results} de \texttt{train} le muestra la exactitud. Ignore las advertencias.

2. Ahora, en lugar de una selección aleatoria de predictores, vamos a buscar aquellos que sean más predictivos del resultado. Podemos hacer esto comparando los valores para el grupo \(y=1\) con esos en el grupo \(y=0\), para cada predictor, utilizando una prueba t. Puede realizar este paso así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\SpecialCharTok{::}\FunctionTok{install\_bioc}\NormalTok{(}\StringTok{"genefilter"}\NormalTok{)}
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"genefilter"}\NormalTok{)}
\FunctionTok{library}\NormalTok{(genefilter)}
\NormalTok{tt }\OtherTok{\textless{}{-}} \FunctionTok{colttests}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

Cree un vector de los valores-p y llámelo \texttt{pvals}.

3. Cree un índice \texttt{ind} con los números de columna de los predictores que eran ``estadísticamente significativos'' asociados con \texttt{y}. Defina ``estadísticamente significativo'' como un valor-p menor que 0.01. ¿Cuántos predictores sobreviven este umbral?

4. Vuelva a ejecutar la validación cruzada pero después de redefinir \texttt{x\_subset} como el subconjunto de \texttt{x} definido por las columnas que muestran una asociación ``estadísticamente significativa'' con \texttt{y}. ¿Cuál es la exactitud ahora?

5. Vuelva a ejecutar la validación cruzada nuevamente, pero esta vez usando kNN. Pruebe los siguientes parámetros de ajuste: \texttt{k\ =\ seq(101,\ 301,\ 25)}. Haga un gráfico de la exactitud resultante.

6. En los ejercicios 3 y 4, vemos que a pesar del hecho de que \texttt{x} e \texttt{y} son completamente independientes, pudimos predecir \texttt{y} con una exactitud superior al 70\%. Debemos estar haciendo algo mal entonces. ¿Qué es?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  La función \texttt{train} estima la exactitud usando los mismos datos que usa para entrenar el algoritmo.
\item
  Estamos sobreajustando el modelo al incluir 100 predictores.
\item
  Utilizamos todo el set de datos para seleccionar las columnas utilizadas en el modelo. Este paso debe incluirse como parte del algoritmo. La validación cruzada se realizó \textbf{después de} esta selección.
\item
  La alta exactitud se debe solo a la variabilidad aleatoria.
\end{enumerate}

7. \textbf{Avanzado}: Vuelva a realizar la validación cruzada, pero esta vez incluya el paso de selección en la validación cruzada. La exactitud ahora debería estar cerca de 50\%.

8. Cargue el set de datos \texttt{tissue\_gene\_expression}. Utilice la función \texttt{train} para predecir el tejido a partir de la expresión génica. Use kNN. ¿Qué \texttt{k} funciona mejor?

\hypertarget{bootstrap}{%
\section{Bootstrap}\label{bootstrap}}

Supongan que la distribución del ingreso de su población es la siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1995}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{6}
\NormalTok{income }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(n, }\FunctionTok{log10}\NormalTok{(}\DecValTok{45000}\NormalTok{), }\FunctionTok{log10}\NormalTok{(}\DecValTok{3}\NormalTok{)))}
\FunctionTok{qplot}\NormalTok{(}\FunctionTok{log10}\NormalTok{(income), }\AttributeTok{bins =} \DecValTok{30}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/income-distribution-1} \end{center}

La mediana de la población es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{median}\NormalTok{(income)}
\NormalTok{m}
\CommentTok{\#\textgreater{} [1] 44939}
\end{Highlighting}
\end{Shaded}

Supongan que no tenemos acceso a toda la población, pero queremos estimar la mediana \(m\). Tomamos una muestra de 100 y estimamos la mediana de la población \(m\) con la mediana de la muestra \(M\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(income, N)}
\FunctionTok{median}\NormalTok{(X)}
\CommentTok{\#\textgreater{} [1] 38461}
\end{Highlighting}
\end{Shaded}

¿Podemos construir un intervalo de confianza? ¿Cuál es la distribución de \(M\)?

Debido a que estamos simulando los datos, podemos usar una simulación de Monte Carlo para aprender la distribución de \(M\).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(gridExtra)}
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{4}
\NormalTok{M }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  X }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(income, N)}
  \FunctionTok{median}\NormalTok{(X)}
\NormalTok{\})}
\NormalTok{p1 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(M, }\AttributeTok{bins =} \DecValTok{30}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\NormalTok{p2 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(}\AttributeTok{sample =} \FunctionTok{scale}\NormalTok{(M), }\AttributeTok{xlab =} \StringTok{"theoretical"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"sample"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{()}
\FunctionTok{grid.arrange}\NormalTok{(p1, p2, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/median-is-normal-1} \end{center}

Si conocemos esta distribución, podemos construir un intervalo de confianza. El problema aquí es que, como ya hemos descrito, en la práctica no sabemos la distribución. En el pasado, hemos usado el teorema del límite central (CLT), pero el CLT que estudiamos aplica a los promedios y aquí estamos interesados en la mediana. Podemos ver que el intervalo de confianza del 95\% basado en CLT:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{median}\NormalTok{(X) }\SpecialCharTok{+} \FloatTok{1.96} \SpecialCharTok{*} \FunctionTok{sd}\NormalTok{(X)}\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(N) }\SpecialCharTok{*} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 21018 55905}
\end{Highlighting}
\end{Shaded}

es bastante diferente del intervalo de confianza que generaríamos si conocemos la distribución real de \(M\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quantile}\NormalTok{(M, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.025}\NormalTok{, }\FloatTok{0.975}\NormalTok{))}
\CommentTok{\#\textgreater{}  2.5\% 97.5\% }
\CommentTok{\#\textgreater{} 34438 59050}
\end{Highlighting}
\end{Shaded}

El \emph{bootstrap} nos permite aproximar una simulación de Monte Carlo sin tener acceso a toda la distribución. La idea general es relativamente sencilla. Actuamos como si la muestra observada fuera la población. Luego muestreamos, con reemplazo, sets de datos del mismo tamaño de muestra del set de datos original. Entonces calculamos la estadística de resumen, en este caso la mediana, en estas \emph{muestras de bootstrap}.

La teoría nos dice que, en muchas situaciones, la distribución de las estadísticas obtenidas con muestras de \emph{bootstrap} se aproxima a la distribución de nuestra estadística real. Así es como construimos muestras de \emph{bootstrap} y una distribución aproximada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{4}
\NormalTok{M\_star }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(B, \{}
\NormalTok{  X\_star }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(X, N, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{median}\NormalTok{(X\_star)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Noten que un intervalo de confianza construido con \emph{bootstrap} está mucho más cerca a uno construido con la distribución teórica:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quantile}\NormalTok{(M\_star, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.025}\NormalTok{, }\FloatTok{0.975}\NormalTok{))}
\CommentTok{\#\textgreater{}  2.5\% 97.5\% }
\CommentTok{\#\textgreater{} 30253 56909}
\end{Highlighting}
\end{Shaded}

Para obtener más información sobre \emph{bootstrap}, incluyendo las correcciones que se pueden aplicar para mejorar estos intervalos de confianza, consulte el libro \emph{An Introduction to the Bootstrap} de Efron y Tibshirani.

Tengan en cuenta que en la validación cruzada podemos usar ideas similares a las que utilizamos con el bootstrap: en lugar de dividir los datos en particiones iguales, simplemente usamos muestras bootstrap repetidas veces.

\hypertarget{ejercicios-49}{%
\section{Ejercicios}\label{ejercicios-49}}

1. La función \texttt{createResample} se puede utilizar para crear muestras de \emph{bootstrap}. Por ejemplo, podemos crear 10 muestras de \emph{bootstrap} para el set de datos \texttt{mnist\_27} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1995}\NormalTok{)}
\NormalTok{indexes }\OtherTok{\textless{}{-}} \FunctionTok{createResample}\NormalTok{(mnist\_27}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

¿Cuántas veces aparecen \texttt{3}, \texttt{4} y \texttt{7} en el primer índice re-muestrado?

2. Vemos que algunos números aparecen más de una vez y otros no aparecen ninguna vez. Esto tiene que ser así para que cada set de datos sea independiente. Repita el ejercicio para todos los índices re-muestreados.

3. Genere un set de datos aleatorio como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Estime el 75o cuantil, que sabemos es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qnorm}\NormalTok{(}\FloatTok{0.75}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

con el cuantil de muestra:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quantile}\NormalTok{(y, }\FloatTok{0.75}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ejecute una simulación de Monte Carlo para saber el valor esperado y el error estándar de esta variable aleatoria.

4. En la práctica, no podemos ejecutar una simulación de Monte Carlo porque no sabemos si \texttt{rnorm} se está utilizando para simular los datos. Use el \emph{bootstrap} para estimar el error estándar usando solo la muestra inicial \texttt{y}. Use 10 muestras de \emph{bootstrap}.

5. Repita el ejercicio 4, pero con 10,000 muestras de \emph{bootstrap}.

\hypertarget{caret}{%
\chapter{El paquete caret}\label{caret}}

Ya hemos aprendido sobre regresión y kNN como algoritmos \emph{machine learning} y, en secciones posteriores, aprenderemos sobre varios otros. Todos estos son solo un pequeño subconjunto del total de los algoritmos disponibles. Muchos de estos algoritmos se implementan en R. Sin embargo, se distribuyen a través de diferentes paquetes, desarrollados por diferentes autores, y a menudo usan una sintaxis diferente. El paquete \textbf{caret} intenta consolidar estas diferencias y dar consistencia. Actualmente incluye 237 métodos diferentes que se resumen en el manual del paquete \textbf{caret}\footnote{\url{https://topepo.github.io/caret/available-models.html}}. Tengan en cuenta que \textbf{caret} no incluye los paquetes necesarios y, para implementar un paquete a través de \textbf{caret}, tendrán que instalar el paquete. Los paquetes requeridos para cada método se describen en el manual del paquete.

El paquete \textbf{caret} también provee una función que realiza la validación cruzada para nosotros. Aquí oferecemos algunos ejemplos que muestran cómo utilizamos este paquete increíblemente útil. Usaremos el ejemplo ``2 o 7'' para ilustrar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-funciuxf3n-train-de-caret}{%
\section{\texorpdfstring{La función \texttt{train} de caret}{La función train de caret}}\label{la-funciuxf3n-train-de-caret}}

La función \texttt{train} de \textbf{caret} nos permite entrenar diferentes algoritmos utilizando una sintaxis similar. Entonces, por ejemplo, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{train\_glm }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"glm"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\end{Highlighting}
\end{Shaded}

Para hacer predicciones, podemos usar el resultado de esta función directamente sin necesidad de mirar los detalles de \texttt{predict.glm} y \texttt{predict.knn}. En cambio, podemos aprender cómo obtener predicciones de \texttt{predict.train}.

El código se ve igual para ambos métodos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_glm }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(train\_glm, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"raw"}\NormalTok{)}
\NormalTok{y\_hat\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(train\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"raw"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Esto nos permite comparar rápidamente los algoritmos. Por ejemplo, podemos comparar la exactitud de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_glm, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.75}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.84}
\end{Highlighting}
\end{Shaded}

\hypertarget{caret-cv}{%
\section{Validación cruzada}\label{caret-cv}}

Cuando un algoritmo incluye parámetros de ajuste, \texttt{train} automáticamente utiliza la validación cruzada para decidir entre algunos valores predeterminados. Para saber qué parámetro o parámetros están optimizados, pueden leer el manual\footnote{\url{http://topepo.github.io/caret/available-models.html}} o estudiar lo que devuelve:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getModelInfo}\NormalTok{(}\StringTok{"knn"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

También podemos usar una búsqueda rápida como esta:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{modelLookup}\NormalTok{(}\StringTok{"knn"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si lo ejecutamos con valores predeterminados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\end{Highlighting}
\end{Shaded}

pueden ver rápidamente los resultados de la validación cruzada utilizando la función \texttt{ggplot}. El argumento \texttt{highlight} destaca el máximo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(train\_knn, }\AttributeTok{highlight =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/caret-highlight-1} \end{center}

Por defecto, la validación cruzada se realiza tomando 25 muestras de \emph{bootstrap} que comprenden el 25\% de las observaciones. Para el método \texttt{kNN}, por defecto se intenta \(k=5, 7, 9\). Cambiamos esto usando el parámetro \texttt{tuneGrid}. La cuadrícula de valores debe ser suministrada por un \emph{data frame} con los nombres de los parámetros como se especifica en el output de \texttt{modelLookup}.

Aquí, presentamos un ejemplo donde probamos 30 valores entre 9 y 67. Para hacer esto con \textbf{caret}, necesitamos definir una columna llamada \texttt{k} de la siguiente manera: \texttt{data.frame(k\ =\ seq(9,\ 67,\ 2))}.

Noten que al ejecutar este código, estamos ajustando 30 versiones de kNN a 25 muestras de \emph{bootstrap}. Como estamos ajustando \(30 \times 25 = 750\) kNN modelos, ejecutar este código tomará varios segundos. Fijamos la semilla porque la validación cruzada es un procedimiento aleatorio y queremos asegurarnos de que el resultado aquí sea reproducible.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{2008}\NormalTok{)}
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
                   \AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train,}
                   \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{seq}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\FunctionTok{ggplot}\NormalTok{(train\_knn, }\AttributeTok{highlight =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/train-knn-plot-1} \end{center}

Para acceder al parámetro que maximiza la exactitud, pueden usar esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn}\SpecialCharTok{$}\NormalTok{bestTune}
\CommentTok{\#\textgreater{}     k}
\CommentTok{\#\textgreater{} 10 27}
\end{Highlighting}
\end{Shaded}

y para acceder el mejor modelo, pueden usar esto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn}\SpecialCharTok{$}\NormalTok{finalModel}
\CommentTok{\#\textgreater{} 27{-}nearest neighbor model}
\CommentTok{\#\textgreater{} Training set outcome distribution:}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{}   2   7 }
\CommentTok{\#\textgreater{} 379 421}
\end{Highlighting}
\end{Shaded}

La función \texttt{predict} utilizará este modelo de mejor rendimiento. Aquí está la exactitud del mejor modelo cuando se aplica al set de evaluación, que todavía no hemos utilizado porque la validación cruzada se realizó en el set de entrenamiento:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{confusionMatrix}\NormalTok{(}\FunctionTok{predict}\NormalTok{(train\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"raw"}\NormalTok{),}
\NormalTok{                mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.835}
\end{Highlighting}
\end{Shaded}

Si queremos cambiar la forma en que realizamos la validación cruzada, podemos usar la función \texttt{trainControl}. Podemos hacer que el código anterior sea un poco más rápido mediante, por ejemplo, la validación cruzada \emph{10 fold}. Esto significa que tenemos 10 muestras y cada una usa el 10\% de las observaciones. Logramos esto usando el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control }\OtherTok{\textless{}{-}} \FunctionTok{trainControl}\NormalTok{(}\AttributeTok{method =} \StringTok{"cv"}\NormalTok{, }\AttributeTok{number =} \DecValTok{10}\NormalTok{, }\AttributeTok{p =}\NormalTok{ .}\DecValTok{9}\NormalTok{)}
\NormalTok{train\_knn\_cv }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
                      \AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train,}
                      \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{seq}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{2}\NormalTok{)),}
                      \AttributeTok{trControl =}\NormalTok{ control)}
\FunctionTok{ggplot}\NormalTok{(train\_knn\_cv, }\AttributeTok{highlight =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/cv-10-fold-accuracy-estimate-1} \end{center}

Observamos que los estimadores de exactitud son más variables, algo esperado ya que cambiamos el número de muestras utilizadas para estimar la exactitud.

Tengan en cuenta que el componente \texttt{results} de lo que devuelve \texttt{train} incluye varias estadísticas de resumen relacionadas con la variabilidad de los estimadores de validación cruzada:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(train\_knn}\SpecialCharTok{$}\NormalTok{results)}
\CommentTok{\#\textgreater{} [1] "k"          "Accuracy"   "Kappa"      "AccuracySD" "KappaSD"}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejemplo-ajuste-con-loess}{%
\section{Ejemplo: ajuste con loess}\label{ejemplo-ajuste-con-loess}}

El modelo kNN que da el mejor resultado también da una buena aproximación de la probabilidad condicional verdadera:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist27-optimal-knn-fit-1} \end{center}

Sin embargo, sí vemos que la frontera es algo ondulada. Esto se debe a que kNN, igual que el suavizador de compartimiento básico, no utiliza un \emph{kernel}. Para mejorar esto, podríamos tratar loess. Al leer la parte sobre los modelos disponibles en el manual\footnote{\url{https://topepo.github.io/caret/available-models.html}}, vemos que podemos usar el método \texttt{gamLoess}.
En el manual\footnote{\url{https://topepo.github.io/caret/train-models-by-tag.html}}, también vemos que necesitamos instalar el paquete \textbf{gam} si aún no lo hemos hecho:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"gam"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Luego, vemos que tenemos dos parámetros para optimizar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{modelLookup}\NormalTok{(}\StringTok{"gamLoess"}\NormalTok{)}
\CommentTok{\#\textgreater{}      model parameter  label forReg forClass probModel}
\CommentTok{\#\textgreater{} 1 gamLoess      span   Span   TRUE     TRUE      TRUE}
\CommentTok{\#\textgreater{} 2 gamLoess    degree Degree   TRUE     TRUE      TRUE}
\end{Highlighting}
\end{Shaded}

Nos mantendremos en un grado de 1. Pero para intentar diferentes valores para \emph{span}, aún tenemos que incluir una columna en la tabla con el nombre \texttt{degree}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grid }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{span =} \FunctionTok{seq}\NormalTok{(}\FloatTok{0.15}\NormalTok{, }\FloatTok{0.65}\NormalTok{, }\AttributeTok{len =} \DecValTok{10}\NormalTok{), }\AttributeTok{degree =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Utilizaremos los parámetros de control de validación cruzada predeterminados.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_loess }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .,}
                     \AttributeTok{method =} \StringTok{"gamLoess"}\NormalTok{,}
                     \AttributeTok{tuneGrid=}\NormalTok{grid,}
                     \AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\FunctionTok{ggplot}\NormalTok{(train\_loess, }\AttributeTok{highlight =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/loess-accuracy-1} \end{center}

Podemos ver que el método funciona de manera similar a kNN:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{confusionMatrix}\NormalTok{(}\AttributeTok{data =} \FunctionTok{predict}\NormalTok{(train\_loess, mnist\_27}\SpecialCharTok{$}\NormalTok{test),}
                \AttributeTok{reference =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.85}
\end{Highlighting}
\end{Shaded}

y produce un estimador más suave de la probabilidad condicional:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/gam-smooth-1} \end{center}

\hypertarget{ejemplos-de-algoritmos}{%
\chapter{Ejemplos de algoritmos}\label{ejemplos-de-algoritmos}}

Hay docenas de algoritmos de \emph{machine learning}. Aquí ofrecemos algunos ejemplos que abarcan enfoques bastante diferentes. A lo largo del capítulo, usaremos los dos datos de dígitos predictores presentados en la Sección \ref{two-or-seven} para demostrar cómo funcionan los algoritmos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{library}\NormalTok{(caret)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{regresiuxf3n-lineal}{%
\section{Regresión lineal}\label{regresiuxf3n-lineal}}

La regresión lineal puede considerarse un algoritmo de \emph{machine learning}. En la Sección \ref{two-or-seven}, demostramos cómo la regresión lineal a veces es demasiada rígida para ser útil. Esto es generalmente cierto, pero para algunos desafíos funciona bastante bien. También sirve como enfoque de partida: si no podemos mejorarlo con un enfoque más complejo, probablemente querremos continuar con la regresión lineal. Para establecer rápidamente la conexión entre la regresión y el \emph{machine learning}, reformularemos el estudio de Galton con alturas, una variable continua.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(HistData)}

\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1983}\NormalTok{)}
\NormalTok{galton\_heights }\OtherTok{\textless{}{-}}\NormalTok{ GaltonFamilies }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(gender }\SpecialCharTok{==} \StringTok{"male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(family) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(father, childHeight) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{son =}\NormalTok{ childHeight)}
\end{Highlighting}
\end{Shaded}

Supongan que tienen la tarea de construir un algoritmo de \emph{machine learning} que prediga la altura del hijo \(Y\) usando la altura del padre \(X\). Generemos sets de evaluación y de entrenamiento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights}\SpecialCharTok{$}\NormalTok{son}
\NormalTok{test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}

\NormalTok{train\_set }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{test\_index)}
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ galton\_heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(test\_index)}
\end{Highlighting}
\end{Shaded}

En este caso, si solo estuviéramos ignorando la altura del padre y adivinando la altura del hijo, adivinaríamos la altura promedio de los hijos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{son)}
\NormalTok{m}
\CommentTok{\#\textgreater{} [1] 69.2}
\end{Highlighting}
\end{Shaded}

La raíz cuadrada de nuestra perdida cuadrática es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((m }\SpecialCharTok{{-}}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{son)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 2.77}
\end{Highlighting}
\end{Shaded}

¿Podemos mejorar? En el capítulo de regresión, aprendimos que si el par \((X,Y)\) sigue una distribución normal de dos variables, la expectativa condicional (lo que queremos estimar) es equivalente a la línea de regresión:

\[
f(x) = \mbox{E}( Y \mid X= x ) = \beta_0 + \beta_1 x
\]

En la Sección \ref{lse}, presentamos los mínimos cuadrados como método para estimar la pendiente \(\beta_0\) y el intercepto \(\beta_1\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(son }\SpecialCharTok{\textasciitilde{}}\NormalTok{ father, }\AttributeTok{data =}\NormalTok{ train\_set)}
\NormalTok{fit}\SpecialCharTok{$}\NormalTok{coef}
\CommentTok{\#\textgreater{} (Intercept)      father }
\CommentTok{\#\textgreater{}      35.976       0.482}
\end{Highlighting}
\end{Shaded}

Esto nos da una estimador de la expectativa condicional:

\[ \hat{f}(x) = 35 + 0.25 x \]

Podemos ver que esto realmente provee una mejora sobre adivinar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{*}\NormalTok{test\_set}\SpecialCharTok{$}\NormalTok{father}
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((y\_hat }\SpecialCharTok{{-}}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{son)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 2.54}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-funciuxf3n-predict}{%
\subsection{\texorpdfstring{La función \texttt{predict}}{La función predict}}\label{la-funciuxf3n-predict}}

La función \texttt{predict} es muy útil para aplicaciones de \emph{machine learning}. Esta función toma como argumentos el resultado de funciones que ajustan modelos como \texttt{lm} o \texttt{glm} (aprenderemos sobre \texttt{glm} pronto) y un \emph{data frame} con los nuevos predictores para los cuales predecir. Entonces, en nuestro ejemplo actual, usaríamos \texttt{predict} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, test\_set)}
\end{Highlighting}
\end{Shaded}

Utilizando \texttt{predict}, podemos obtener los mismos resultados que obtuvimos anteriormente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, test\_set)}
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((y\_hat }\SpecialCharTok{{-}}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{son)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 2.54}
\end{Highlighting}
\end{Shaded}

\texttt{predict} no siempre devuelve objetos del mismo tipo; depende del tipo de objeto que se le envíe. Para conocer los detalles, deben consultar el archivo de ayuda específico para el tipo de objeto de ajuste. \texttt{predict} es un tipo de función especial en R (denominada \emph{función genérica}) que llama a otras funciones según el tipo de objeto que recibe. Así que si \texttt{predict} recibe un objeto producido por la función \texttt{lm}, llamará \texttt{predict.lm}. Si recibe un objeto producido por la función \texttt{glm}, llamará \texttt{predict.glm}. Estas dos funciones son similares pero con algunas diferencias. Pueden obtener más información sobre las diferencias leyendo los archivos de ayuda:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?predict.lm}
\NormalTok{?predict.glm}
\end{Highlighting}
\end{Shaded}

Hay muchas otras versiones de \texttt{predict} y muchos algoritmos de \emph{machine learning} tienen una función \texttt{predict}.

\hypertarget{ejercicios-50}{%
\section{Ejercicios}\label{ejercicios-50}}

1. Cree un set de datos con el siguiente código.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \DecValTok{9}\SpecialCharTok{*}\FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(}\AttributeTok{n =} \DecValTok{100}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{69}\NormalTok{, }\DecValTok{69}\NormalTok{), Sigma) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Use el paquete \textbf{caret} para dividirlo en un set de evaluación y uno de entrenamiento del mismo tamaño. Entrene un modelo lineal e indique el RMSE. Repita este ejercicio 100 veces y haga un histograma de los RMSE e indique el promedio y la desviación estándar. Sugerencia: adapte el código mostrado anteriormente como demostramos aquí.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ dat}\SpecialCharTok{$}\NormalTok{y}
\NormalTok{test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{train\_set }\OtherTok{\textless{}{-}}\NormalTok{ dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{test\_index)}
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ dat }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(test\_index)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x, }\AttributeTok{data =}\NormalTok{ train\_set)}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{*}\NormalTok{test\_set}\SpecialCharTok{$}\NormalTok{x}
\FunctionTok{mean}\NormalTok{((y\_hat }\SpecialCharTok{{-}}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y póngalo dentro de una llamada a \texttt{replicate}.

2. Ahora repetiremos lo anterior pero usando sets de datos más grandes. Repita el ejercicio 1 pero para sets de datos con \texttt{n\ \textless{}-\ c(100,\ 500,\ 1000,\ 5000,\ 10000)}. Guarde el promedio y la desviación estándar de RMSE de estas 100 repeticiones para cada \texttt{n}. Sugerencia: use las funciones \texttt{sapply} o \texttt{map}.

3. Describa lo que observa con el RMSE a medida que aumenta el tamaño del set de datos.

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  En promedio, el RMSE no cambia mucho ya que \texttt{n} se hace más grande, mientras que la variabilidad de RMSE disminuye.
\item
  Debido a la ley de los grandes números, el RMSE disminuye: más datos significa estimadores más precisos.
\item
  \texttt{n\ =\ 10000} no es lo suficientemente grande. Para ver una disminución en RMSE, necesitamos hacerla más grande.
\item
  El RMSE no es una variable aleatoria.
\end{enumerate}

4. Ahora repita el ejercicio 1, pero esta vez haga la correlación entre \texttt{x} e \texttt{y} más grande cambiando \texttt{Sigma} así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \DecValTok{9}\SpecialCharTok{*}\FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{0.95}\NormalTok{, }\FloatTok{0.95}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(}\AttributeTok{n =} \DecValTok{100}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{69}\NormalTok{, }\DecValTok{69}\NormalTok{), Sigma) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Repita el ejercicio y observe lo que le sucede al RMSE ahora.

5. ¿Cuál de las siguientes explica mejor por qué el RMSE en el ejercicio 4 es mucho más bajo que en el ejercicio 1?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Es solo suerte. Si lo hacemos nuevamente, será más grande.
\item
  El teorema del límite central nos dice que el RMSE es normal.
\item
  Cuando aumentamos la correlación entre \texttt{x} e \texttt{y}, \texttt{x} tiene más poder predictivo y, por lo tanto, provee un mejor estimador de \texttt{y}. Esta correlación tiene un efecto mucho mayor en RMSE que \texttt{n}. \texttt{n} grande simplemente ofrece estimadores más precisos de los coeficientes del modelo lineal.
\item
  Ambos son ejemplos de regresión, por lo que el RMSE tiene que ser el mismo.
\end{enumerate}

6. Cree un set de datos con el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\SpecialCharTok{/}\DecValTok{4}\NormalTok{, }\DecValTok{3}\SpecialCharTok{/}\DecValTok{4}\NormalTok{, }\DecValTok{3}\SpecialCharTok{/}\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{3}\SpecialCharTok{/}\DecValTok{4}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(}\AttributeTok{n =} \DecValTok{100}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), Sigma) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"x\_1"}\NormalTok{, }\StringTok{"x\_2"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Tenga en cuenta que \texttt{y} está correlacionado con ambos \texttt{x\_1} y \texttt{x\_2}, pero los dos predictores son independientes entre sí.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(dat)}
\end{Highlighting}
\end{Shaded}

Use el paquete \textbf{caret} para dividir en un set de evaluación y un set de entrenamiento del mismo tamaño. Compare el RMSE al usar solo \texttt{x\_1}, sólo \texttt{x\_2}, y ambos \texttt{x\_1} y \texttt{x\_2}. Entrene un modelo lineal e indique el RMSE.

7. Repita el ejercicio 6, pero ahora cree un ejemplo en el que \texttt{x\_1} y \texttt{x\_2} están altamente correlacionados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{0.95}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{0.95}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{dat }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(}\AttributeTok{n =} \DecValTok{100}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), Sigma) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{data.frame}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{setNames}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"x\_1"}\NormalTok{, }\StringTok{"x\_2"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Use el paquete \textbf{caret} para dividir en un set de evaluación y uno de entrenamiento del mismo tamaño. Compare el RMSE al usar solo \texttt{x\_1}, sólo \texttt{x\_2} y ambos \texttt{x\_1} y \texttt{x\_2}. Entrene un modelo lineal e indique el RMSE.

8. Compare los resultados del ejercicio 6 y 7 y elija la declaración con la que está de acuerdo:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Agregar predictores adicionales puede mejorar sustancialmente RMSE, pero no cuando están altamente correlacionados con otro predictor.
\item
  Agregar predictores adicionales mejora las predicciones por igual en ambos ejercicios.
\item
  Agregar predictores adicionales da como resultado un ajuste excesivo.
\item
  A menos que incluyamos todos los predictores, no tenemos poder de predicción.
\end{enumerate}

\hypertarget{regresiuxf3n-loguxedstica}{%
\section{Regresión logística}\label{regresiuxf3n-loguxedstica}}

El enfoque de regresión puede extenderse a datos categóricos. En esta sección, primero ilustramos cómo, para datos binarios, simplemente se pueden asignar valores numéricos de 0 y 1 a los resultados \(y\). Entonces, se aplica la regresión como si los datos fueran continuos. Más tarde, señalaremos una limitación de este enfoque y presentaremos la \emph{regresión logística} como una solución. La regresión logística es un caso específico de un set de \emph{modelos lineales generalizados}. Para ilustrar la regresión logística, la aplicaremos a nuestro ejemplo anterior de predicción de sexo basado en altura definido en la Sección \ref{training-test}.

Si definimos el resultado \(Y\) como 1 para mujeres y 0 para hombres, y \(X\) como la altura, nos interesa la probabilidad condicional:

\[
\mbox{Pr}( Y = 1 \mid X = x)
\]

Como ejemplo, ofrecemos una predicción para un estudiante que mide 66 pulgadas de alto. ¿Cuál es la probabilidad condicional de ser mujer si mide 66 pulgadas de alto? En nuestro set de datos, podemos estimar esto redondeando a la pulgada más cercana y calculando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{round}\NormalTok{(height) }\SpecialCharTok{==} \DecValTok{66}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{y\_hat =} \FunctionTok{mean}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Female"}\NormalTok{))}
\CommentTok{\#\textgreater{}   y\_hat}
\CommentTok{\#\textgreater{} 1 0.347}
\end{Highlighting}
\end{Shaded}

Para construir un algoritmo de predicción, queremos estimar la proporción de la población femenina para cualquier altura dada \(X=x\), que escribimos como la probabilidad condicional descrita anteriormente: \(\mbox{Pr}( Y = 1 | X=x)\). Veamos cómo se ve esto para varios valores de \(x\) (eliminaremos estratos de \(x\) con pocos puntos de datos):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{x =} \FunctionTok{round}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(x) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{prop =} \FunctionTok{mean}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, prop)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/height-and-sex-conditional-probabilities-1} \end{center}

Dado que los resultados del gráfico anterior son casi lineal y que es el único enfoque que hemos aprendido hasta ahora, intentaremos la regresión lineal. Suponemos que:

\[p(x) = \mbox{Pr}( Y = 1 | X=x) = \beta_0 + \beta_1 x\]

Noten: como \(p_0(x) = 1 - p_1(x)\), solo estimaremos \(p_1(x)\) y eliminaremos el índice \(_1\).

Si convertimos los factores a 0s y 1s, podemos estimar \(\beta_0\) y \(\beta_1\) usando mínimos cuadrados.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm\_fit }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(train\_set, }\AttributeTok{y =} \FunctionTok{as.numeric}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ height, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

Una vez que tengamos estimadores \(\hat{\beta}_0\) y \(\hat{\beta}_1\), podemos obtener una predicción real. Nuestro estimador de la probabilidad condicional \(p(x)\) es:

\[
\hat{p}(x) = \hat{\beta}_0+ \hat{\beta}_1 x
\]

Para formar una predicción, definimos una \emph{regla de decisión}: predecir mujer si \(\hat{p}(x) > 0.5\). Podemos comparar nuestras predicciones con los resultados usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(lm\_fit, test\_set)}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(p\_hat }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{factor}\NormalTok{()}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, test\_set}\SpecialCharTok{$}\NormalTok{sex)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.798}
\end{Highlighting}
\end{Shaded}

Vemos que este método funciona mucho mejor que adivinar.

\hypertarget{modelos-lineales-generalizados}{%
\subsection{Modelos lineales generalizados}\label{modelos-lineales-generalizados}}

La función \(\beta_0 + \beta_1 x\) puede tomar cualquier valor, incluyendo negativos y valores mayores que 1. De hecho, el estimador \(\hat{p}(x)\) calculado en la sección de regresión lineal se vuelve negativo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heights }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{x =} \FunctionTok{round}\NormalTok{(height)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(x) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{prop =} \FunctionTok{mean}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, prop)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{intercept =}\NormalTok{ lm\_fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{1}\NormalTok{], }\AttributeTok{slope =}\NormalTok{ lm\_fit}\SpecialCharTok{$}\NormalTok{coef[}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/regression-prediction-1} \end{center}

El rango es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{range}\NormalTok{(p\_hat)}
\CommentTok{\#\textgreater{} [1] {-}0.578  1.262}
\end{Highlighting}
\end{Shaded}

Pero estamos estimando una probabilidad: \(\mbox{Pr}( Y = 1 \mid X = x)\) que está restringida entre 0 y 1.

La idea de los \emph{modelos lineales generalizados} (\emph{generalized linear models} o GLM por sus siglas en inglés) es 1) definir una distribución de \(Y\) que sea consistente con sus posibles resultados y
2) encontrar una función \(g\) tal que \(g(\mbox{Pr}( Y = 1 \mid X = x))\) se pueda modelar como una combinación lineal de predictores.
La regresión logística es el GLM más utilizado. Es una extensión de regresión lineal que asegura que el estimador de \(\mbox{Pr}( Y = 1 \mid X = x)\) esté entre 0 y 1. Este enfoque utiliza la transformación \emph{logística} que presentamos en la Sección \ref{logit}:

\[ g(p) = \log \frac{p}{1-p}\]

Esta transformación logística convierte probabilidad en logaritmo del riesgo relativo. Como se discutió en la sección de visualización de datos, el riesgo relativo nos dice cuánto más probable es que algo suceda en comparación con no suceder. \(p=0.5\) significa que las probabilidades son de 1 a 1; por lo tanto, el riesgo relativo es 1. Si \(p=0.75\), las probabilidades son de 3 a 1. Una buena característica de esta transformación es que convierte las probabilidades en simétricas alrededor de 0. Aquí hay un gráfico de \(g(p)\) versus \(p\):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/p-versus-logistic-of-p-1} \end{center}

Con la \emph{regresión logística}, modelamos la probabilidad condicional directamente con:

\[
g\left\{ \mbox{Pr}(Y = 1 \mid X=x) \right\} = \beta_0 + \beta_1 x
\]

Con este modelo, ya no podemos usar mínimos cuadrados. En su lugar, calculamos el \emph{estimador de máxima verosimilitud} (\emph{maximum likelihood estimate} o MLE por sus siglas en inglés). Pueden aprender más sobre este concepto en un libro de texto de teoría estadística\footnote{\url{http://www.amazon.com/Mathematical-Statistics-Analysis-Available-Enhanced/dp/0534399428}}.

En R, podemos ajustar el modelo de regresión logística con la función \texttt{glm}: modelos lineales generalizados. Esta función puede ajustar varios modelos, no solo regresión logística, por lo cual tenemos que especificar el modelo que queremos a través del argumento \texttt{family}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{glm\_fit }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{as.numeric}\NormalTok{(sex }\SpecialCharTok{==} \StringTok{"Female"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{glm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ height, }\AttributeTok{data =}\NormalTok{ ., }\AttributeTok{family =} \StringTok{"binomial"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos obtener predicciones usando la función \texttt{predict}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_hat\_logit }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(glm\_fit, }\AttributeTok{newdata =}\NormalTok{ test\_set, }\AttributeTok{type =} \StringTok{"response"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Cuando usamos \texttt{predict} con un objeto \texttt{glm}, tenemos que especificar que queremos \texttt{type="response"} si queremos las probabilidades condicionales, ya que por defecto la función devuelve los valores luego de la transformación logística.

Este modelo se ajusta a los datos un poco mejor que la línea:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/conditional-prob-glm-fit-1} \end{center}

Como tenemos un estimador \(\hat{p}(x)\), podemos obtener predicciones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_logit }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(p\_hat\_logit }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}\NormalTok{ factor}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_logit, test\_set}\SpecialCharTok{$}\NormalTok{sex)}\SpecialCharTok{$}\NormalTok{overall[[}\StringTok{"Accuracy"}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 0.808}
\end{Highlighting}
\end{Shaded}

Las predicciones resultantes son similares. Esto se debe a que los dos estimadores de \(p(x)\) mayores que 1/2 en aproximadamente la misma región de x:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/glm-prediction-1} \end{center}

Las regresiones lineales y logísticas proveen un estimador de la expectativa condicional:

\[
\mbox{E}(Y \mid X=x)
\]
que en el caso de datos binarios es equivalente a la probabilidad condicional:

\[
\mbox{Pr}(Y = 1 \mid X = x)
\]

\hypertarget{regresiuxf3n-loguxedstica-con-muxe1s-de-un-predictor}{%
\subsection{Regresión logística con más de un predictor}\label{regresiuxf3n-loguxedstica-con-muxe1s-de-un-predictor}}

En esta sección, aplicamos la regresión logística a los datos ``2 o 7'' presentados en la Sección \ref{two-or-seven}. En este caso, estamos interesados en estimar una probabilidad condicional que depende de dos variables. El modelo de regresión logística estándar en este caso supondrá que:

\[
g\{p(x_1, x_2)\}= g\{\mbox{Pr}(Y=1 \mid X_1=x_1 , X_2 = x_2)\} =
\beta_0 + \beta_1 x_1 + \beta_2 x_2
\]
con \(g(p) = \log \frac{p}{1-p}\), la función logística descrita en la sección anterior. Para ajustar el modelo, usamos el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit\_glm }\OtherTok{\textless{}{-}} \FunctionTok{glm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x\_1 }\SpecialCharTok{+}\NormalTok{ x\_2, }\AttributeTok{data=}\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train, }\AttributeTok{family =} \StringTok{"binomial"}\NormalTok{)}
\NormalTok{p\_hat\_glm }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_glm, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"response"}\NormalTok{)}
\NormalTok{y\_hat\_glm }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{ifelse}\NormalTok{(p\_hat\_glm }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_glm, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.75}
\end{Highlighting}
\end{Shaded}

Comparando con los resultados que obtuvimos en la Sección \ref{two-or-seven}, vemos que la regresión logística funciona de manera similar a la regresión. Esto no es sorprendente dado que el estimador de \(\hat{p}(x_1, x_2)\) se ve similar también:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_glm, }\AttributeTok{newdata =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{true\_p, }\AttributeTok{type =} \StringTok{"response"}\NormalTok{)}
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{true\_p }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{p\_hat =}\NormalTok{ p\_hat) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{z=}\NormalTok{p\_hat, }\AttributeTok{fill=}\NormalTok{p\_hat)) }\SpecialCharTok{+}
  \FunctionTok{geom\_raster}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_gradientn}\NormalTok{(}\AttributeTok{colors=}\FunctionTok{c}\NormalTok{(}\StringTok{"\#F8766D"}\NormalTok{,}\StringTok{"white"}\NormalTok{,}\StringTok{"\#00BFC4"}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{stat\_contour}\NormalTok{(}\AttributeTok{breaks=}\FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{), }\AttributeTok{color=}\StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/logistic-p-hat-1} \end{center}

Al igual que con la regresión lineal, la regla de decisión es una línea, un hecho que puede corroborarse matemáticamente ya que:

\[
g^{-1}(\hat{\beta}_0 + \hat{\beta}_1 x_1 + \hat{\beta}_2 x_2) = 0.5 \implies
\hat{\beta}_0 + \hat{\beta}_1 x_1 + \hat{\beta}_2 x_2 = g(0.5) = 0 \implies
x_2 = -\hat{\beta}_0/\hat{\beta}_2 -\hat{\beta}_1/\hat{\beta}_2 x_1
\]

Por eso, \(x_2\) es una función lineal de \(x_1\). Esto implica que, al igual que la regresión, nuestro enfoque de regresión logística no tiene ninguna posibilidad de capturar la naturaleza no lineal de la verdadera \(p(x_1,x_2)\). Una vez que pasemos a ejemplos más complejos, veremos que la regresión lineal y la regresión lineal generalizada son limitadas y no lo suficientemente flexibles como para ser útiles para la mayoría de los desafíos de \emph{machine learning}. Las nuevas técnicas que aprendemos son esencialmente enfoques para estimar la probabilidad condicional de una manera más flexible.

\hypertarget{ejercicios-51}{%
\section{Ejercicios}\label{ejercicios-51}}

1. Defina el siguiente set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{make\_data }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{n =} \DecValTok{1000}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{,}
                      \AttributeTok{mu\_0 =} \DecValTok{0}\NormalTok{, }\AttributeTok{mu\_1 =} \DecValTok{2}\NormalTok{,}
                      \AttributeTok{sigma\_0 =} \DecValTok{1}\NormalTok{, }\AttributeTok{sigma\_1 =} \DecValTok{1}\NormalTok{)\{}
\NormalTok{  y }\OtherTok{\textless{}{-}} \FunctionTok{rbinom}\NormalTok{(n, }\DecValTok{1}\NormalTok{, p)}
\NormalTok{  f\_0 }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(n, mu\_0, sigma\_0)}
\NormalTok{  f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(n, mu\_1, sigma\_1)}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(y }\SpecialCharTok{==} \DecValTok{1}\NormalTok{, f\_1, f\_0)}
\NormalTok{  test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{train =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x, }\AttributeTok{y =} \FunctionTok{as.factor}\NormalTok{(y)) }\SpecialCharTok{\%\textgreater{}\%}
         \FunctionTok{slice}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{test\_index),}
       \AttributeTok{test =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x, }\AttributeTok{y =} \FunctionTok{as.factor}\NormalTok{(y)) }\SpecialCharTok{\%\textgreater{}\%}
         \FunctionTok{slice}\NormalTok{(test\_index))}
\NormalTok{\}}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{make\_data}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Noten que hemos definido una variable \texttt{x} que es predictiva de un resultado binario \texttt{y}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x, }\AttributeTok{color =}\NormalTok{ y)) }\SpecialCharTok{+} \FunctionTok{geom\_density}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Compare la exactitud de la regresión lineal y la regresión logística.

2. Repita la simulación del primer ejercicio 100 veces y compare la exactitud promedio para cada método. Observe como dan prácticamente la misma respuesta.

3. Genere 25 sets de datos diferentes cambiando la diferencia entre las dos clases: \texttt{delta\ \textless{}-\ seq(0,\ 3,\ len\ =\ 25)}. Grafique exactitud versus \texttt{delta}.

\hypertarget{k-vecinos-muxe1s-cercanos-knn}{%
\section{k vecinos más cercanos (kNN)}\label{k-vecinos-muxe1s-cercanos-knn}}

Presentamos el algoritmo kNN en la Sección \ref{knn-cv-intro} y demostramos cómo usamos la validación cruzada para elegir \(k\) en la Sección \ref{caret-cv}. Aquí revisamos rápidamente cómo ajustamos un modelo kNN usando el paquete \textbf{caret}. En la Sección \ref{caret-cv}, presentamos el siguiente código para ajustar un modelo kNN:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
                   \AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train,}
                   \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{seq}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Vimos que el parámetro que maximizaba la exactitud estimada era:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn}\SpecialCharTok{$}\NormalTok{bestTune}
\CommentTok{\#\textgreater{}     k}
\CommentTok{\#\textgreater{} 10 27}
\end{Highlighting}
\end{Shaded}

Este modelo resulta en una exactitud mejor que la de regresión y de regresión logística:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{confusionMatrix}\NormalTok{(}\FunctionTok{predict}\NormalTok{(train\_knn, mnist\_27}\SpecialCharTok{$}\NormalTok{test, }\AttributeTok{type =} \StringTok{"raw"}\NormalTok{),}
\NormalTok{                mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.835}
\end{Highlighting}
\end{Shaded}

Un gráfico de la probabilidad condicional estimada muestra que el estimador de kNN es lo suficientemente flexible para capturar la forma de la probabilidad condicional verdadera.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/best-knn-fit-1} \end{center}

\hypertarget{ejercicios-52}{%
\section{Ejercicios}\label{ejercicios-52}}

1. Anteriormente utilizamos regresión logística para predecir el sexo basado en la altura. Use kNN para hacer lo mismo. Use el código descrito en este capítulo para seleccionar la medida \(F_1\) y graficarla contra \(k\). Compare con el \(F_1\) de aproximadamente 0.6 que obtuvimos con regresión.

2. Cargue el siguiente set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Este set de datos incluye una matriz \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

con la expresión génica medida en 500 genes para 189 muestras biológicas que representan siete tejidos diferentes. El tipo de tejido se almacena en \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

Divida los datos en sets de entrenamiento y de evaluación. Luego, use kNN para predecir el tipo de tejido y ver qué exactitud obtiene. Pruébelo para \(k = 1, 3, \dots, 11\).

\hypertarget{modelos-generativos}{%
\section{Modelos generativos}\label{modelos-generativos}}

Hemos explicado cómo, cuando se usa la función de pérdida cuadrática, las expectativas/probabilidades condicionales ofrecen el mejor enfoque para desarrollar una regla de decisión. En un caso binario, el error verdadero más pequeño que podemos lograr está determinado por la regla de Bayes, que es una regla de decisión basada en la probabilidad condicional verdadera:

\[
p(\mathbf{x}) = \mbox{Pr}(Y=1 \mid \mathbf{X}=\mathbf{x})
\]

Hemos descrito varios enfoques para estimar \(p(\mathbf{x})\). En todos estos, estimamos la probabilidad condicional directamente y no consideramos la distribución de los predictores. En \emph{machine learning}, estos se denominan enfoques \emph{discriminativos}.

Sin embargo, el teorema de Bayes nos dice que conocer la distribución de los predictores \(\mathbf{X}\) puede ser útil. Métodos que modelan la distribución conjunta de \(Y\) y \(\mathbf{X}\) se denominan \emph{modelos generativos} (modelamos cómo todos los datos, \(\mathbf{X}\) e \(Y\), se generan). Comenzamos describiendo el modelo generativo más general, \emph{Naive Bayes}, y luego describimos dos casos específicos: el \emph{análisis discriminante cuadrático} (\emph{quadratic discriminant analysis} o QDA por sus siglas en inglés) y el \emph{análisis discriminante lineal} (\emph{linear discriminant analysis} o LDA por sus siglas en inglés).

\hypertarget{naive-bayes}{%
\subsection{Naive Bayes}\label{naive-bayes}}

Recordemos que la regla de Bayes nos dice que podemos reescribir \(p(\mathbf{x})\) así:

\[
p(\mathbf{x}) = \mbox{Pr}(Y=1|\mathbf{X}=\mathbf{x}) = \frac{f_{\mathbf{X}|Y=1}(\mathbf{x}) \mbox{Pr}(Y=1)}
{ f_{\mathbf{X}|Y=0}(\mathbf{x})\mbox{Pr}(Y=0) + f_{\mathbf{X}|Y=1}(\mathbf{x})\mbox{Pr}(Y=1) }
\]

con \(f_{\mathbf{X}|Y=1}\) y \(f_{\mathbf{X}|Y=0}\) representando las funciones de distribución del predictor \(\mathbf{X}\) para las dos clases \(Y=1\) y \(Y=0\). La fórmula implica que si podemos estimar estas distribuciones condicionales de los predictores, podemos desarrollar una poderosa regla de decisión. Sin embargo, esto es un gran ``si''. A medida que avancemos, encontraremos ejemplos en los que \(\mathbf{X}\) tiene muchas dimensiones y no tenemos mucha información sobre la distribución. En estos casos, \emph{Naive Bayes} será prácticamente imposible de implementar. Sin embargo, hay casos en los que tenemos un pequeño número de predictores (no más de 2) y muchas categorías en las que los modelos generativos pueden ser bastante poderosos. Describimos dos ejemplos específicos y utilizamos nuestros estudios de caso descritos anteriormente para ilustrarlos.

Comencemos con un caso muy sencillo y poco interesante, pero ilustrativo: el ejemplo relacionado con la predicción del sexo basado en la altura.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(caret)}

\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"heights"}\NormalTok{)}

\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ heights}\SpecialCharTok{$}\NormalTok{height}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1995}\NormalTok{)}
\NormalTok{test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{train\_set }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{test\_index)}
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ heights }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{slice}\NormalTok{(test\_index)}
\end{Highlighting}
\end{Shaded}

En este caso, el enfoque \emph{Naive Bayes} es particularmente apropiado porque sabemos que la distribución normal es una buena aproximación para las distribuciones condicionales de altura dado el sexo para ambas clases \(Y=1\) (mujer) y \(Y=0\) (hombre). Esto implica que podemos aproximar las distribuciones condicionales \(f_{X|Y=1}\) y \(f_{X|Y=0}\) al simplemente estimar los promedios y las desviaciones estándar de los datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{params }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(sex) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg =} \FunctionTok{mean}\NormalTok{(height), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(height))}
\NormalTok{params}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 3}
\CommentTok{\#\textgreater{}   sex      avg    sd}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 Female  64.8  4.14}
\CommentTok{\#\textgreater{} 2 Male    69.2  3.57}
\end{Highlighting}
\end{Shaded}

La prevalencia, que denotaremos con \(\pi = \mbox{Pr}(Y=1)\), puede estimarse a partir de los datos con:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{summarize}\NormalTok{(}\AttributeTok{pi=}\FunctionTok{mean}\NormalTok{(sex}\SpecialCharTok{==}\StringTok{"Female"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{pull}\NormalTok{(pi)}
\NormalTok{pi}
\CommentTok{\#\textgreater{} [1] 0.212}
\end{Highlighting}
\end{Shaded}

Ahora podemos usar nuestros estimadores de promedio y desviación estándar para obtener una regla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ test\_set}\SpecialCharTok{$}\NormalTok{height}

\NormalTok{f0 }\OtherTok{\textless{}{-}} \FunctionTok{dnorm}\NormalTok{(x, params}\SpecialCharTok{$}\NormalTok{avg[}\DecValTok{2}\NormalTok{], params}\SpecialCharTok{$}\NormalTok{sd[}\DecValTok{2}\NormalTok{])}
\NormalTok{f1 }\OtherTok{\textless{}{-}} \FunctionTok{dnorm}\NormalTok{(x, params}\SpecialCharTok{$}\NormalTok{avg[}\DecValTok{1}\NormalTok{], params}\SpecialCharTok{$}\NormalTok{sd[}\DecValTok{1}\NormalTok{])}

\NormalTok{p\_hat\_bayes }\OtherTok{\textless{}{-}}\NormalTok{ f1}\SpecialCharTok{*}\NormalTok{pi}\SpecialCharTok{/}\NormalTok{ (f1}\SpecialCharTok{*}\NormalTok{pi }\SpecialCharTok{+}\NormalTok{ f0}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ pi))}
\end{Highlighting}
\end{Shaded}

Nuestro estimador de \emph{Naive Bayes} \(\hat{p}(x)\) se parece mucho a nuestro estimador de regresión logística:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/conditional-prob-glm-fit-2-1} \end{center}

De hecho, podemos mostrar que el enfoque de \emph{Naive Bayes} es matemáticamente similar a la predicción de regresión logística. Sin embargo, dejamos la demostración a un texto más avanzado, como \emph{Elements of Statistical Learning}\footnote{\url{https://web.stanford.edu/~hastie/Papers/ESLII.pdf}}. Podemos ver que son similares empíricamente al comparar las dos curvas resultantes.

\hypertarget{controlando-la-prevalencia}{%
\subsection{Controlando la prevalencia}\label{controlando-la-prevalencia}}

Una característica útil del enfoque \emph{Naive Bayes} es que incluye un parámetro para tomar en cuenta las diferencias en la prevalencia. Usando nuestra muestra, estimamos \(f_{X|Y=1}\), \(f_{X|Y=0}\) y \(\pi\). Si usamos sombreros para denotar los estimadores, podemos escribir \(\hat{p}(x)\) como:

\[
\hat{p}(x)= \frac{\hat{f}_{X|Y=1}(x) \hat{\pi}}
{ \hat{f}_{X|Y=0}(x)(1-\hat{\pi}) + \hat{f}_{X|Y=1}(x)\hat{\pi} }
\]

Como discutimos anteriormente, nuestra muestra tiene una prevalencia mucho menor, 0.21, que la población general. Entonces si usamos la regla \(\hat{p}(x)>0.5\) para predecir mujeres, nuestra exactitud se verá afectada debido a la baja sensibilidad:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_bayes }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(p\_hat\_bayes }\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{)}
\FunctionTok{sensitivity}\NormalTok{(}\AttributeTok{data =} \FunctionTok{factor}\NormalTok{(y\_hat\_bayes), }\AttributeTok{reference =} \FunctionTok{factor}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\CommentTok{\#\textgreater{} [1] 0.213}
\end{Highlighting}
\end{Shaded}

Nuevamente, esto se debe a que el algoritmo da más peso a la especificidad para tomar en cuenta la baja prevalencia:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{specificity}\NormalTok{(}\AttributeTok{data =} \FunctionTok{factor}\NormalTok{(y\_hat\_bayes), }\AttributeTok{reference =} \FunctionTok{factor}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\CommentTok{\#\textgreater{} [1] 0.967}
\end{Highlighting}
\end{Shaded}

Esto se debe principalmente al hecho de que \(\hat{\pi}\) es sustancialmente menor que 0.5, por lo que tendemos a predecir \texttt{Male} más a menudo. Tiene sentido que un algoritmo de \emph{machine learning} haga esto en nuestra muestra porque tenemos un mayor porcentaje de hombres. Pero si tuviéramos que extrapolar esto a una población general, nuestra exactitud general se vería afectada por la baja sensibilidad.

El enfoque \emph{Naive Bayes} nos da una forma directa de corregir esto, ya que simplemente podemos forzar \(\hat{\pi}\) a ser el valor que queremos. Entonces, para equilibrar especificidad y sensibilidad, en lugar de cambiar el umbral en la regla de decisión, simplemente podríamos cambiar \(\hat{\pi}\) a 0.5 así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_hat\_bayes\_unbiased }\OtherTok{\textless{}{-}}\NormalTok{ f1 }\SpecialCharTok{*} \FloatTok{0.5}\SpecialCharTok{/}\NormalTok{ (f1 }\SpecialCharTok{*} \FloatTok{0.5} \SpecialCharTok{+}\NormalTok{ f0 }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}} \FloatTok{0.5}\NormalTok{))}
\NormalTok{y\_hat\_bayes\_unbiased }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(p\_hat\_bayes\_unbiased}\SpecialCharTok{\textgreater{}} \FloatTok{0.5}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta la diferencia de sensibilidad con un mejor equilibrio:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sensitivity}\NormalTok{(}\FunctionTok{factor}\NormalTok{(y\_hat\_bayes\_unbiased), }\FunctionTok{factor}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\CommentTok{\#\textgreater{} [1] 0.693}
\FunctionTok{specificity}\NormalTok{(}\FunctionTok{factor}\NormalTok{(y\_hat\_bayes\_unbiased), }\FunctionTok{factor}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{sex))}
\CommentTok{\#\textgreater{} [1] 0.832}
\end{Highlighting}
\end{Shaded}

La nueva regla también nos da un umbral muy intuitivo entre 66-67, que es aproximadamente la mitad de las alturas promedio de hombres y mujeres:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(x, p\_hat\_bayes\_unbiased, }\AttributeTok{geom =} \StringTok{"line"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_hline}\NormalTok{(}\AttributeTok{yintercept =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_vline}\NormalTok{(}\AttributeTok{xintercept =} \DecValTok{67}\NormalTok{, }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/naive-with-good-prevalence-1} \end{center}

\hypertarget{anuxe1lisis-discriminante-cuadruxe1tico}{%
\subsection{Análisis discriminante cuadrático}\label{anuxe1lisis-discriminante-cuadruxe1tico}}

El \emph{análisis discriminante cuadrático} (QDA) es una versión de \emph{Naive Bayes} en la cual suponemos que las distribuciones \(p_{\mathbf{X}|Y=1}(x)\) y \(p_{\mathbf{X}|Y=0}(\mathbf{x})\) siguen una distribución normal de múltiples variables. El ejemplo sencillo que describimos en la sección anterior es QDA. Veamos ahora un caso un poco más complicado: el ejemplo ``2 o 7''.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En este caso, tenemos dos predictores, por lo que suponemos que cada uno sigue una distribución normal de dos variables. Esto implica que necesitamos estimar dos promedios, dos desviaciones estándar y una correlación para cada caso \(Y=1\) y \(Y=0\). Una vez que tengamos estos, podemos aproximar las distribuciones \(f_{X_1,X_2|Y=1}\) y \(f_{X_1, X_2|Y=0}\). Podemos estimar fácilmente los parámetros a partir de los datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{params }\OtherTok{\textless{}{-}}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(y) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{avg\_1 =} \FunctionTok{mean}\NormalTok{(x\_1), }\AttributeTok{avg\_2 =} \FunctionTok{mean}\NormalTok{(x\_2),}
            \AttributeTok{sd\_1=} \FunctionTok{sd}\NormalTok{(x\_1), }\AttributeTok{sd\_2 =} \FunctionTok{sd}\NormalTok{(x\_2),}
            \AttributeTok{r =} \FunctionTok{cor}\NormalTok{(x\_1, x\_2))}
\NormalTok{params}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 6}
\CommentTok{\#\textgreater{}   y     avg\_1 avg\_2   sd\_1   sd\_2     r}
\CommentTok{\#\textgreater{}   \textless{}fct\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{}  \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1 2     0.129 0.283 0.0702 0.0578 0.401}
\CommentTok{\#\textgreater{} 2 7     0.234 0.288 0.0719 0.105  0.455}
\end{Highlighting}
\end{Shaded}

Aquí ofrecemos una forma visual de mostrar el enfoque. Graficamos los datos y usamos gráficos de contorno (\emph{contour plots} en inglés) para dar una idea de cómo son las dos densidades normales estimadas (mostramos la curva que representa una región que incluye el 95\% de los puntos):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{factor}\NormalTok{(y)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{fill =}\NormalTok{ y, }\AttributeTok{color=}\NormalTok{y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_ellipse}\NormalTok{(}\AttributeTok{type=}\StringTok{"norm"}\NormalTok{, }\AttributeTok{lwd =} \FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/qda-explained-1} \end{center}

Esto define el siguiente estimador de \(f(x_1, x_2)\).

Podemos usar la función \texttt{train} del paquete \textbf{caret} para ajustar el modelo y obtener predictores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{train\_qda }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"qda"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\end{Highlighting}
\end{Shaded}

Vemos que obtenemos una exactitud relativamente buena:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(train\_qda, mnist\_27}\SpecialCharTok{$}\NormalTok{test)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.82}
\end{Highlighting}
\end{Shaded}

La probabilidad condicional estimada se ve relativamente bien, aunque no se ajusta tan bien como los suavizadores de \emph{kernel}:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/qda-estimate-1} \end{center}

Una razón por la que QDA no funciona tan bien como los métodos de \emph{kernel} es quizás porque la presunción de normalidad no es válida. Aunque para los 2s parece razonable, para los 7s no lo parece. Observen la ligera curvatura en los puntos para los 7s:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{factor}\NormalTok{(y)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{fill =}\NormalTok{ y, }\AttributeTok{color=}\NormalTok{y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_ellipse}\NormalTok{(}\AttributeTok{type=}\StringTok{"norm"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/qda-does-not-fit-1} \end{center}

QDA puede funcionar bien aquí, pero se vuelve más difícil de usar a medida que aumente el número de predictores. Aquí tenemos 2 predictores y tuvimos que calcular 4 medias, 4 desviaciones estándar y 2 correlaciones. ¿Cuántos parámetros tendríamos si en lugar de 2 predictores tuviéramos 10?
El principal problema proviene del estimador de correlaciones para 10 predictores. Con 10, tenemos 45 correlaciones para cada clase. En general, la fórmula es \(K\times p(p-1)/2\), que se hace grande rápidamente. Una vez el número de parámetros se acerca al tamaño de nuestros datos, el método deja de ser práctico debido al sobreajuste.

\hypertarget{anuxe1lisis-discriminante-lineal}{%
\subsection{Análisis discriminante lineal}\label{anuxe1lisis-discriminante-lineal}}

Una solución relativamente sencilla para el problema de tener demasiados parámetros es suponer que la estructura de correlación es la misma para todas las clases, lo que reduce el número de parámetros que necesitamos estimar.

En este caso, calcularíamos solo un par de desviaciones estándar y una correlación,
y las distribuciones se ven así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/lda-explained-1} \end{center}

Ahora el tamaño de las elipses y el ángulo son iguales. Esto se debe a que tienen las mismas desviaciones estándar y correlaciones.

Podemos ajustar el modelo LDA usando \textbf{caret}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_lda }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"lda"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(train\_lda, mnist\_27}\SpecialCharTok{$}\NormalTok{test)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.75}
\end{Highlighting}
\end{Shaded}

Cuando forzamos esta suposición, podemos mostrar matemáticamente que el umbral es una línea, al igual que con la regresión logística. Por esta razón, llamamos al método \emph{análisis lineal discriminante} (LDA). Del mismo modo, para QDA, podemos mostrar que el umbral debe ser una función cuadrática.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/lda-estimate-1} \end{center}

En el caso de LDA, la falta de flexibilidad no nos permite capturar la no linealidad en la verdadera función de probabilidad condicional.

\hypertarget{conexiuxf3n-a-distancia}{%
\subsection{Conexión a distancia}\label{conexiuxf3n-a-distancia}}

La densidad normal es:

\[
p(x) = \frac{1}{\sqrt{2\pi} \sigma} \exp\left\{ - \frac{(x-\mu)^2}{\sigma^2}\right\}
\]

Si eliminamos la constante \(1/(\sqrt{2\pi} \sigma)\) y luego tomamos el logaritmo, obtenemos:

\[
- \frac{(x-\mu)^2}{\sigma^2}
\]

que es el negativo de una distancia al cuadrado escalada por la desviación estándar. Para dimensiones mayores, lo mismo es cierto, excepto que la escala es más compleja e implica correlaciones.

\hypertarget{estudio-de-caso-muxe1s-de-tres-clases}{%
\section{Estudio de caso: más de tres clases}\label{estudio-de-caso-muxe1s-de-tres-clases}}

Podemos generar un ejemplo con tres categorías así:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{exists}\NormalTok{(}\StringTok{"mnist"}\NormalTok{)) mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{3456}\NormalTok{)}
\NormalTok{index\_127 }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{which}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{7}\NormalTok{)), }\DecValTok{2000}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels[index\_127]}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images[index\_127,]}
\NormalTok{index\_train }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(y, }\AttributeTok{p=}\FloatTok{0.8}\NormalTok{, }\AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
\DocumentationTok{\#\# get the quadrants}
\NormalTok{row\_column }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(}\AttributeTok{row=}\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, }\AttributeTok{col=}\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{)}
\NormalTok{upper\_left\_ind }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(row\_column}\SpecialCharTok{$}\NormalTok{col }\SpecialCharTok{\textless{}=} \DecValTok{14} \SpecialCharTok{\&}\NormalTok{ row\_column}\SpecialCharTok{$}\NormalTok{row }\SpecialCharTok{\textless{}=} \DecValTok{14}\NormalTok{)}
\NormalTok{lower\_right\_ind }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(row\_column}\SpecialCharTok{$}\NormalTok{col }\SpecialCharTok{\textgreater{}} \DecValTok{14} \SpecialCharTok{\&}\NormalTok{ row\_column}\SpecialCharTok{$}\NormalTok{row }\SpecialCharTok{\textgreater{}} \DecValTok{14}\NormalTok{)}
\DocumentationTok{\#\# binarize the values. Above 200 is ink, below is no ink}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{\textgreater{}} \DecValTok{200}
\DocumentationTok{\#\# proportion of pixels in lower right quadrant}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(}\FunctionTok{rowSums}\NormalTok{(x[ ,upper\_left\_ind])}\SpecialCharTok{/}\FunctionTok{rowSums}\NormalTok{(x),}
           \FunctionTok{rowSums}\NormalTok{(x[ ,lower\_right\_ind])}\SpecialCharTok{/}\FunctionTok{rowSums}\NormalTok{(x))}
\DocumentationTok{\#\#save data}
\NormalTok{train\_set }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{y =} \FunctionTok{factor}\NormalTok{(y[index\_train]),}
                        \AttributeTok{x\_1 =}\NormalTok{ x[index\_train,}\DecValTok{1}\NormalTok{], }\AttributeTok{x\_2 =}\NormalTok{ x[index\_train,}\DecValTok{2}\NormalTok{])}
\NormalTok{test\_set }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{y =} \FunctionTok{factor}\NormalTok{(y[}\SpecialCharTok{{-}}\NormalTok{index\_train]),}
                       \AttributeTok{x\_1 =}\NormalTok{ x[}\SpecialCharTok{{-}}\NormalTok{index\_train,}\DecValTok{1}\NormalTok{], }\AttributeTok{x\_2 =}\NormalTok{ x[}\SpecialCharTok{{-}}\NormalTok{index\_train,}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Aquí están los datos de entrenamiento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{color=}\NormalTok{y)) }\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-27-training-data-1} \end{center}

Podemos usar el paquete \textbf{caret} para entrenar el modelo QDA:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_qda }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"qda"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ train\_set)}
\end{Highlighting}
\end{Shaded}

Ahora estimamos tres probabilidades condicionales (aunque tienen que sumar a 1):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{predict}\NormalTok{(train\_qda, test\_set, }\AttributeTok{type =} \StringTok{"prob"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{}        1       2       7}
\CommentTok{\#\textgreater{} 1 0.7655 0.23043 0.00405}
\CommentTok{\#\textgreater{} 2 0.2031 0.72514 0.07175}
\CommentTok{\#\textgreater{} 3 0.5396 0.45909 0.00132}
\CommentTok{\#\textgreater{} 4 0.0393 0.09419 0.86655}
\CommentTok{\#\textgreater{} 5 0.9600 0.00936 0.03063}
\CommentTok{\#\textgreater{} 6 0.9865 0.00724 0.00623}
\end{Highlighting}
\end{Shaded}

Nuestras predicciones son una de las tres clases:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{predict}\NormalTok{(train\_qda, test\_set) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{head}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 1 2 1 7 1 1}
\CommentTok{\#\textgreater{} Levels: 1 2 7}
\end{Highlighting}
\end{Shaded}

La matriz de confusión es, por lo tanto, una tabla de 3 por 3:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{confusionMatrix}\NormalTok{(}\FunctionTok{predict}\NormalTok{(train\_qda, test\_set), test\_set}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{table}
\CommentTok{\#\textgreater{}           Reference}
\CommentTok{\#\textgreater{} Prediction   1   2   7}
\CommentTok{\#\textgreater{}          1 111   9  11}
\CommentTok{\#\textgreater{}          2  10  86  21}
\CommentTok{\#\textgreater{}          7  21  28 102}
\end{Highlighting}
\end{Shaded}

La exactitud es 0.749.

Tengan en cuenta que para la sensibilidad y especificidad, tenemos un par de valores para \textbf{cada} clase. Para definir estos términos, necesitamos un resultado binario. Por lo tanto, tenemos tres columnas: una para cada clase como positivos y las otras dos como negativas.

Para visualizar qué partes de la región se llaman 1, 2 y 7, ahora necesitamos tres colores:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/three-classes-plot-1} \end{center}

La exactitud para LDA,
0.629,
es mucho peor porque el modelo es más rígido. Aquí vemos como se ve la regla de decisión:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/lda-too-rigid-1} \end{center}

Los resultados para kNN:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ train\_set,}
                   \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{seq}\NormalTok{(}\DecValTok{15}\NormalTok{, }\DecValTok{51}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

son mucho mejores con una exactitud de
0.749. La regla de decisión se ve así:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/three-classes-knn-better-1} \end{center}

Noten que una de las limitaciones de los modelos generativos mostrados aquí se debe a la falta de ajuste del supuesto normal, en particular para la clase 1.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y =} \FunctionTok{factor}\NormalTok{(y)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_1, x\_2, }\AttributeTok{fill =}\NormalTok{ y, }\AttributeTok{color=}\NormalTok{y)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{show.legend =} \ConstantTok{FALSE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_ellipse}\NormalTok{(}\AttributeTok{type=}\StringTok{"norm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/three-classes-lack-of-fit-1} \end{center}

Los modelos generativos pueden ser muy útiles, pero solo cuando somos capaces de aproximar con éxito la distribución de predictores condicionados en cada clase.

\hypertarget{ejercicios-53}{%
\section{Ejercicios}\label{ejercicios-53}}

Vamos a aplicar LDA y QDA al set de datos \texttt{tissue\_gene\_expression}. Comenzaremos con ejemplos sencillos basados en este set de datos y luego desarrollaremos un ejemplo realista.

1. Cree un set de datos con solo las clases ``cerebellum'' e ``hippocampus'' (dos partes del cerebro) y una matriz de predicción con 10 columnas seleccionadas al azar.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1993}\NormalTok{)}
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\NormalTok{tissues }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"cerebellum"}\NormalTok{, }\StringTok{"hippocampus"}\NormalTok{)}
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{y }\SpecialCharTok{\%in\%}\NormalTok{ tissues)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{droplevels}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{y[ind])}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x[ind, ]}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x[, }\FunctionTok{sample}\NormalTok{(}\FunctionTok{ncol}\NormalTok{(x), }\DecValTok{10}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

Utilice la función \texttt{train} para estimar la exactitud de LDA.

2. En este caso, LDA se ajusta a dos distribuciones normales de 10 dimensiones. Mire el modelo ajustado mirando el componente \texttt{finalModel} del resultado de \texttt{train}. Observe que hay un componente llamado \texttt{means} que incluye el estimador de los promedios de ambas distribuciones. Grafique este vector de promedios uno contra el otro y determine qué predictores (genes) parecen estar impulsando el algoritmo.

3. Repita el ejercicio 1 con QDA. ¿Tiene mejor exactitud que LDA?

4. ¿Los mismos predictores (genes) impulsan el algoritmo? Haga un gráfico como en el ejercicio 2.

5. Algo que vemos en el gráfico anterior es que el valor de los predictores se correlaciona en ambos grupos: algunos predictores son bajos en ambos grupos, mientras que otros son altos en ambos grupos. El valor medio de cada predictor, \texttt{colMeans(x)}, no es informativo ni útil para la predicción, y para fines de interpretación, a menudo es útil centrar o escalar cada columna. Esto se puede lograr con el argumento \texttt{preProcessing} en \texttt{train}. Vuelva a ejecutar LDA con \texttt{preProcessing\ =\ "scale"}. Tenga en cuenta que la exactitud no cambia, pero vea cómo es más fácil identificar los predictores que difieren más entre los grupos en el gráfico realizado en el ejercicio 4.

6. En los ejercicios anteriores, vimos que ambos enfoques funcionaron bien. Grafique los valores predictores para los dos genes con las mayores diferencias entre los dos grupos en un diagrama de dispersión para ver cómo parecen seguir una distribución normal de dos variables como se supone para los enfoques LDA y QDA. Coloree los puntos por el resultado.

7. Ahora vamos a aumentar un poco la complejidad del desafío: consideraremos todos los tipos de tejidos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1993}\NormalTok{)}
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{y}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x[, }\FunctionTok{sample}\NormalTok{(}\FunctionTok{ncol}\NormalTok{(x), }\DecValTok{10}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

¿Qué exactitud obtiene con LDA?

8. Vemos que los resultados son ligeramente peores. Utilice la función \texttt{confusionMatrix} para aprender qué tipo de errores estamos cometiendo.

9. Grafique una imagen de los centros de las siete distribuciones normales de 10 dimensiones.

\hypertarget{uxe1rboles-de-clasificaciuxf3n-y-regresiuxf3n-cart}{%
\section{Árboles de clasificación y regresión (CART)}\label{uxe1rboles-de-clasificaciuxf3n-y-regresiuxf3n-cart}}

\hypertarget{la-maldiciuxf3n-de-la-dimensionalidad}{%
\subsection{La maldición de la dimensionalidad}\label{la-maldiciuxf3n-de-la-dimensionalidad}}

Describimos cómo métodos como LDA y QDA no deben usarse con muchos predictores \(p\) porque el número de parámetros que necesitamos estimar se vuelve demasiado grande. Por ejemplo, con el ejemplo de dígitos \(p=784\), tendríamos más de 600,000 parámetros con LDA y lo multiplicaríamos por el número de clases para QDA. Los métodos de \emph{kernel}, como kNN o regresión local, no tienen parámetros de modelo para estimar. Sin embargo, también se enfrentan a un desafío cuando se utilizan predictores múltiples debido a lo que se conoce como la \emph{maldición de la dimensionalidad}. La \emph{dimensión} aquí se refiere al hecho de que cuando tenemos \(p\) predictores, la distancia entre dos observaciones se calcula en un espacio \(p\)-dimensional.

Una manera útil de entender la maldición de la dimensionalidad es considerar cuán grande tenemos que hacer un \emph{span}/vecindario/ventana para incluir un porcentaje dado de los datos. Recuerden que con vecindarios más grandes, nuestros métodos pierden flexibilidad.

Por ejemplo, supongan que tenemos un predictor continuo con puntos igualmente espaciados en el intervalo {[}0,1{]} y queremos crear ventanas que incluyen 1/10 de datos. Entonces es fácil ver que nuestras ventanas tienen que ser de tamaño 0.1:

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/curse-of-dim-1} \end{center}

Ahora, para dos predictores, si decidimos mantener el vecindario igual de pequeño, 10\% para cada dimensión, incluimos solo 1 punto. Si queremos incluir el 10\% de los datos, entonces necesitamos aumentar el tamaño de cada lado del cuadrado a \(\sqrt{.10} \approx .316\):

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/curse-of-dim-2-1} \end{center}

Usando la misma lógica, si queremos incluir el 10\% de los datos en un espacio tridimensional, entonces el lado de cada cubo es \(\sqrt[3]{.10} \approx 0.464\).
En general, para incluir el 10\% de los datos en un caso con \(p\) dimensiones, necesitamos un intervalo con cada lado del tamaño \(\sqrt[p]{.10}\) del total. Esta proporción se acerca a 1 rápidamente y, si la proporción es 1, significa que incluimos todos los datos y ya no estamos suavizando.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{p }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}
\FunctionTok{qplot}\NormalTok{(p, .}\DecValTok{1}\SpecialCharTok{\^{}}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\NormalTok{p), }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/curse-of-dim-4-1} \end{center}

Cuando llegamos a 100 predictores, el vecindario ya no es muy local, puesto que cada lado cubre casi todo el set de datos.

Aquí observamos un conjunto de métodos elegantes y versátiles que se adaptan a dimensiones más altas y también permiten que estas regiones tomen formas más complejas mientras producen modelos que son interpretables. Estos son métodos muy populares, conocidos y estudiados. Nos concentraremos en los árboles de regresión y decisión y su extensión a bosques aleatorios.

\hypertarget{motivaciuxf3n-cart}{%
\subsection{Motivación CART}\label{motivaciuxf3n-cart}}

Para motivar esta sección, utilizaremos un nuevo set de datos
que incluye el desglose de la composición del aceite de oliva en 8 ácidos grasos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"olive"}\NormalTok{)}
\FunctionTok{names}\NormalTok{(olive)}
\CommentTok{\#\textgreater{}  [1] "region"      "area"        "palmitic"    "palmitoleic"}
\CommentTok{\#\textgreater{}  [5] "stearic"     "oleic"       "linoleic"    "linolenic"  }
\CommentTok{\#\textgreater{}  [9] "arachidic"   "eicosenoic"}
\end{Highlighting}
\end{Shaded}

Con fines ilustrativos, intentaremos predecir la región utilizando los valores de composición de ácidos grasos como predictores.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(olive}\SpecialCharTok{$}\NormalTok{region)}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Northern Italy       Sardinia Southern Italy }
\CommentTok{\#\textgreater{}            151             98            323}
\end{Highlighting}
\end{Shaded}

Quitamos la columna \texttt{area} porque no la usaremos como predictor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{olive }\OtherTok{\textless{}{-}} \FunctionTok{select}\NormalTok{(olive, }\SpecialCharTok{{-}}\NormalTok{area)}
\end{Highlighting}
\end{Shaded}

Intentemos rápidamente predecir la región usando kNN:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(region }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
             \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{2}\NormalTok{)),}
             \AttributeTok{data =}\NormalTok{ olive)}
\FunctionTok{ggplot}\NormalTok{(fit)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/olive-knn-1} \end{center}

Vemos que usando solo un vecino, podemos predecir relativamente bien. Sin embargo, un poco de exploración de datos revela que deberíamos poder hacerlo aún mejor. Por ejemplo, si observamos la distribución de cada predictor estratificado por región, vemos que el \emph{eicosenoic} solo está presente en el sur de Italia y que el \emph{linoleic} separa el norte de Italia de Cerdeña.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/olive-eda-1} \end{center}

¡Esto implica que deberíamos ser capaces de construir un algoritmo que prediga perfectamente! Podemos ver esto claramente al graficar los valores para \emph{eicosenoic} y \emph{linoleic}.

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/olive-two-predictors-1} \end{center}

En la Sección \ref{predictor-space}, definimos espacios predictores. El espacio predictor aquí consiste en puntos de ocho dimensiones con valores entre 0 y 100. En el gráfico anterior, mostramos el espacio definido por los dos predictores \emph{eicosenoic} y \emph{linoleic} y, a simple vista,
podemos construir una regla de predicción que divida el espacio del predictor para que cada partición contenga solo resultados de una categoría. Esto a su vez se puede utilizar para definir un algoritmo con una exactitud perfecta. Específicamente, definimos la siguiente regla de decisión. Si el \emph{eicosenoic} es mayor que 0.065, predecimos el sur de Italia. Si no, entonces si \emph{linoleic} es más grande que \(10.535\), predecimos Cerdeña, y si es más bajo, predecimos el norte de Italia. Podemos dibujar este árbol de decisión así:

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/olive-tree-1} \end{center}

Los árboles de decisión como este se usan a menudo en la práctica. Por ejemplo, para determinar el riesgo de una persona de tener un mal resultado después de un ataque cardíaco, los médicos usan lo siguiente:

\begin{center}\includegraphics[width=0.5\linewidth]{ml/img/Decision-Tree-for-Heart-Attack-Victim-adapted-from-Gigerenzer-et-al-1999-4} \end{center}

(Fuente: Walton 2010 Informal Logic, Vol. 30, No.~2, pp.~159-184\footnote{\url{https://papers.ssrn.com/sol3/Delivery.cfm/SSRN_ID1759289_code1486039.pdf?abstractid=1759289\&mirid=1\&type=2}}.)

Un árbol es básicamente un diagrama de flujo con preguntas de sí o no. La idea general de los métodos que estamos describiendo es definir un algoritmo que use datos para crear estos árboles con predicciones en los extremos, conocidos como \emph{nodos} (\emph{nodes} en inglés). Los árboles de regresión y de decisión operan prediciendo una variable de resultado \(Y\) al dividir los predictores.

\hypertarget{uxe1rboles-de-regresiuxf3n}{%
\subsection{Árboles de regresión}\label{uxe1rboles-de-regresiuxf3n}}

Cuando el resultado es continuo, llamamos al método un árbol de \emph{regresión}. Para introducir árboles de regresión, utilizaremos los datos de la encuesta de 2008 que usamos en secciones anteriores para describir la idea básica de cómo construimos estos algoritmos. Al igual que con otros algoritmos de \emph{machine learning}, intentaremos estimar la expectativa condicional \(f(x) = \mbox{E}(Y | X = x)\) con \(Y\) el margen de la encuesta y \(x\) el dia.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"polls\_2008"}\NormalTok{)}
\FunctionTok{qplot}\NormalTok{(day, margin, }\AttributeTok{data =}\NormalTok{ polls\_2008)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-again-1} \end{center}

La idea general aquí es construir un árbol de decisión y, al final de cada \emph{nodo}, obtener un predictor \(\hat{y}\). Una forma matemática de describir esto es decir que estamos dividiendo el espacio predictivo en \(J\) regiones no superpuestas, \(R_1, R_2, \ldots, R_J\), y luego para cualquier predictor \(x\) que caiga dentro de la región \(R_j\), estimar \(f(x)\) con el promedio de las observaciones de entrenamiento \(y_i\) para el cual el predictor asociado \(x_i\) también está en \(R_j\).

¿Pero cómo decidimos la partición \(R_1, R_2, \ldots, R_J\) y como elegimos \(J\)? Aquí es donde el algoritmo se vuelve un poco complicado.

Los árboles de regresión crean particiones de manera recursiva. Comenzamos el algoritmo con una partición, el espacio predictor completo. En nuestro primer ejemplo sencillo, este espacio es el intervalo {[}-155, 1{]}. Pero después del primer paso, tendremos dos particiones. Después del segundo paso, dividiremos una de estas particiones en dos y tendremos tres particiones, luego cuatro, entonces cinco, y así sucesivamente. Describimos cómo elegimos la partición para una partición adicional, y cuándo parar, más adelante.

Después de seleccionar una partición \(\mathbf{x}\) para dividir a fin de crear las nuevas particiones, encontramos un predictor \(j\) y un valor \(s\) que definen dos nuevas particiones, que llamaremos \(R_1(j,s)\) y \(R_2(j,s)\) y que dividen nuestras observaciones en la partición actual al preguntar si \(x_j\) es mayor que \(s\):

\[
R_1(j,s) = \{\mathbf{x} \mid x_j < s\} \mbox{ and } R_2(j,s) = \{\mathbf{x} \mid x_j \geq s\}
\]

En nuestro ejemplo actual, solo tenemos un predictor, por lo que siempre elegiremos \(j=1\), pero en general este no será el caso. Ahora, después de definir las nuevas particiones \(R_1\) y \(R_2\) y parar el proceso de particionar, calculamos predictores tomando el promedio de todas las observaciones \(y\) para el cual el \(\mathbf{x}\) asociado está en \(R_1\) y \(R_2\). Nos referimos a estos dos como \(\hat{y}_{R_1}\) y \(\hat{y}_{R_2}\) respectivamente.

¿Pero cómo elegimos \(j\) y \(s\)? Básicamente, encontramos el par que minimiza la suma de errores cuadrados (\emph{residual sum of squares} o RSS por sus siglas en inglés):
\[
\sum_{i:\, x_i \in R_1(j,s)} (y_i - \hat{y}_{R_1})^2 +
\sum_{i:\, x_i \in R_2(j,s)} (y_i - \hat{y}_{R_2})^2
\]

Esto se aplica de manera recursiva a las nuevas regiones \(R_1\) y \(R_2\). Describimos cómo paramos más tarde, pero una vez que terminemos de dividir el espacio del predictor en regiones, en cada región se realiza una predicción utilizando las observaciones en esa región.

Echemos un vistazo a lo que hace este algoritmo en los datos de la encuesta de las elecciones presidenciales de 2008. Utilizaremos la funcion \texttt{rpart} del paquete \textbf{rpart}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(rpart)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{rpart}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ polls\_2008)}
\end{Highlighting}
\end{Shaded}

Aquí, solo hay un predictor y, por lo tanto, no tenemos que decidir cuál dividir. Simplemente tenemos que decidir qué valor \(s\) utilizaremos para dividir. Podemos ver visualmente dónde se hicieron las divisiones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(fit, }\AttributeTok{margin =} \FloatTok{0.1}\NormalTok{)}
\FunctionTok{text}\NormalTok{(fit, }\AttributeTok{cex =} \FloatTok{0.75}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.6\linewidth]{libro_files/figure-latex/polls-2008-tree-1} \end{center}

La primera división se realiza el día 39.5. Una de esas regiones se divide en el día 86.5. Las dos nuevas particiones que resultan se dividen en los días 49.5 y 117.5, respectivamente, y así sucesivamente. Terminamos con 8 particiones. El estimador final \(\hat{f}(x)\) se ve así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y\_hat =} \FunctionTok{predict}\NormalTok{(fit)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_step}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, y\_hat), }\AttributeTok{col=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-tree-fit-1} \end{center}

Observen que el algoritmo paró luego de 8 particiones. Ahora explicamos cómo se toma esa decisión.

Primero, necesitamos definir el término \emph{parámetro de complejidad} (\emph{complexity parameter} o cp por sus siglas en inglés). Cada vez que dividimos y definimos dos nuevas particiones, nuestro set de entrenamiento RSS disminuye. Esto se debe a que con más particiones, nuestro modelo tiene más flexibilidad para adaptarse a los datos de entrenamiento. De hecho, si se divide hasta que cada punto sea su propia partición, entonces RSS baja hasta 0 ya que el promedio de un valor es el mismo valor. Para evitar esto, el algoritmo establece un mínimo de cuánto debe mejorar el RSS para que se agregue otra partición. Este parámetro se conoce como \emph{parámetro de complejidad}. El RSS debe mejorar por un factor de cp para que se agregue la nueva partición. Por lo tanto, los valores grandes de cp obligarán al algoritmo a detenerse antes, lo que resulta en menos nodos.

Sin embargo, cp no es el único parámetro utilizado para decidir si debemos dividir una partición existente. Otro parámetro común es el número mínimo de observaciones requeridas en una partición antes de dividirla más. El argumento que se usa en la función \texttt{rpart} es \texttt{minsplit} y el valor predeterminado es 20. La implementación \texttt{rpart} de árboles de regresión también permite a los usuarios determinar un número mínimo de observaciones en cada nodo. El argumento es \texttt{minbucket} y por defecto usa el valor \texttt{round(minsplit/3)}.

Como se esperaba, si establecemos \texttt{cp\ =\ 0} y \texttt{minsplit\ =\ 2}, nuestra predicción es lo más flexible posible y nuestros predictores son nuestros datos originales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{rpart}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data =}\NormalTok{ polls\_2008,}
             \AttributeTok{control =} \FunctionTok{rpart.control}\NormalTok{(}\AttributeTok{cp =} \DecValTok{0}\NormalTok{, }\AttributeTok{minsplit =} \DecValTok{2}\NormalTok{))}
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y\_hat =} \FunctionTok{predict}\NormalTok{(fit)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_step}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, y\_hat), }\AttributeTok{col=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-tree-over-fit-1} \end{center}

Intuitivamente, sabemos que este no es un buen enfoque, ya que generalmente dará como resultado un entrenamiento excesivo. Estos tres parámetros, \texttt{cp}, \texttt{minsplit} y \texttt{minbucket}, se pueden usar para controlar la variabilidad de los predictores finales. Entre más grandes sean estos valores, más datos se promedian para calcular un predictor y, por lo tanto, reducir la variabilidad. El inconveniente es que restringe la flexibilidad.

Entonces, ¿cómo elegimos estos parámetros? Podemos usar validación cruzada, descrita en el Capítulo \ref{cross-validation}, como con cualquier parámetro de ajuste. Aquí tenemos un ejemplo del uso de validación cruzada para elegir cp:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{train\_rpart }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(margin }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .,}
                     \AttributeTok{method =} \StringTok{"rpart"}\NormalTok{,}
                     \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{cp =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.05}\NormalTok{, }\AttributeTok{len =} \DecValTok{25}\NormalTok{)),}
                     \AttributeTok{data =}\NormalTok{ polls\_2008)}
\FunctionTok{ggplot}\NormalTok{(train\_rpart)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-tree-train-1} \end{center}

Para ver el árbol que resulta, accedemos \texttt{finalModel} y lo graficamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(train\_rpart}\SpecialCharTok{$}\NormalTok{finalModel, }\AttributeTok{margin =} \FloatTok{0.1}\NormalTok{)}
\FunctionTok{text}\NormalTok{(train\_rpart}\SpecialCharTok{$}\NormalTok{finalModel, }\AttributeTok{cex =} \FloatTok{0.75}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.8\linewidth]{libro_files/figure-latex/polls-2008-final-model-1} \end{center}

Y debido a que solo tenemos un predictor, podemos graficar \(\hat{f}(x)\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y\_hat =} \FunctionTok{predict}\NormalTok{(train\_rpart)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_step}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, y\_hat), }\AttributeTok{col=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-final-fit-1} \end{center}

Tengan en cuenta que si ya tenemos un árbol y queremos aplicar un valor de cp más alto, podemos usar la función \texttt{prune}. Llamamos a esto \emph{podar} (\emph{pruning} en inglés) un árbol porque estamos cortando particiones que no cumplen con un criterio \texttt{cp}. Anteriormente creamos un árbol que usaba un \texttt{cp\ =\ 0} y lo guardamos en \texttt{fit}. Podemos podarlo así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pruned\_fit }\OtherTok{\textless{}{-}} \FunctionTok{prune}\NormalTok{(fit, }\AttributeTok{cp =} \FloatTok{0.01}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxe1rboles-de-clasificaciuxf3n-decisiuxf3n}{%
\subsection{Árboles de clasificación (decisión)}\label{uxe1rboles-de-clasificaciuxf3n-decisiuxf3n}}

Los árboles de clasificación, o árboles de decisión, se usan en problemas de predicción donde el resultado es categórico. Utilizamos el mismo principio de partición con algunas diferencias para tomar en cuenta el hecho de que ahora estamos trabajando con un resultado categórico.

La primera diferencia es que formamos predicciones calculando qué clase es la más común entre las observaciones del set de entrenamiento dentro de la partición, en lugar de tomar el promedio en cada partición (ya que no podemos tomar el promedio de las categorías).

La segunda es que ya no podemos usar RSS para elegir la partición. Si bien podríamos utilizar el enfoque simplista de buscar particiones que minimicen el error de entrenamiento, los enfoques de mejor desempeño utilizan métricas más sofisticadas. Dos de los más populares son el \emph{índice de Gini} (\emph{Gini Index} en inglés) y \emph{entropia} (\emph{entropy} en inglés).

En una situación perfecta, los resultados en cada una de nuestras particiones son todos de la misma categoría, ya que esto permitirá una exactitud perfecta. El \emph{índice de Gini} será 0 en este caso y se hará más grande a medida que nos desviamos de este escenario. Para definir el índice de Gini, definimos \(\hat{p}_{j,k}\) como la proporción de observaciones en partición \(j\) que son de clase \(k\). Específicamente, el índice de Gini se define como:

\[
\mbox{Gini}(j) = \sum_{k=1}^K \hat{p}_{j,k}(1-\hat{p}_{j,k})
\]

Si estudian la fórmula cuidadosamente, verán que es 0 en la situación perfecta descrita anteriormente.

\emph{Entropia} es una cantidad muy similar, definida como:

\[
\mbox{entropy}(j) = -\sum_{k=1}^K \hat{p}_{j,k}\log(\hat{p}_{j,k}), \mbox{ with } 0 \times \log(0) \mbox{ defined as }0
\]

Veamos cómo funciona un árbol de clasificación en el ejemplo de dígitos que examinamos antes utilizando este código para ejecutar el algoritmo y trazar la exactitud resultante:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_rpart }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ .,}
                     \AttributeTok{method =} \StringTok{"rpart"}\NormalTok{,}
                     \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{cp =} \FunctionTok{seq}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\AttributeTok{len =} \DecValTok{25}\NormalTok{)),}
                     \AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train)}
\FunctionTok{plot}\NormalTok{(train\_rpart)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-27-tree-1} \end{center}

La exactitud que logramos con este enfoque es mejor que la que obtuvimos con la regresión, pero no es tan buena como la que obtuvimos con los métodos \emph{kernel}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(train\_rpart, mnist\_27}\SpecialCharTok{$}\NormalTok{test)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.805}
\end{Highlighting}
\end{Shaded}

El gráfico de la probabilidad condicional estimada nos muestra las limitaciones de los árboles de clasificación:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/rf-cond-prob-1} \end{center}

Tengan en cuenta que con los árboles de decisión, es difícil suavizar los límites ya que cada partición crea una discontinuidad.

Los árboles de clasificación tienen ciertas ventajas que los hacen muy útiles. Son altamente interpretables, incluso más que los modelos lineales. Son fáciles de visualizar (si son lo suficientemente pequeños). Finalmente, pueden modelar procesos de decisión humana y no requieren el uso de predictores ficticios para variables categóricas. Por otro lado, si usamos particiones recursivas es muy posible que sobreentrenemos y, por lo tanto, es un poco más difícil de entrenar que, por ejemplo, la regresión lineal o kNN. Además, en términos de exactitud, rara vez es el método de mejor rendimiento, ya que no es muy flexible y es muy inestable a los cambios en los datos de entrenamiento. Los bosques aleatorios, explicados a continuación, mejoran varias de estas deficiencias.

\hypertarget{bosques-aleatorios}{%
\section{Bosques aleatorios}\label{bosques-aleatorios}}

Los bosques aleatorios son un enfoque de \emph{machine learning} \textbf{muy popular} que abordan las deficiencias de los árboles de decisión utilizando una idea inteligente. El objetivo es mejorar la predicción y reducir la inestabilidad mediante \emph{el promedio} de múltiples árboles de decisión (un bosque de árboles construido con aleatoriedad). Tienen dos atributos que ayudan a lograr esto.

El primer paso es \emph{bootstrap aggregation} o \emph{bagging}. La idea general es generar muchos predictores, cada uno utilizando árboles de regresión o de clasificación, y luego formar una predicción final basada en la predicción promedio de todos estos árboles. Para asegurar que los árboles individuales no sean iguales, utilizamos el \emph{bootstrap} para inducir aleatoriedad. Estos dos atributos combinados explican el nombre: el \emph{bootstrap} hace que los árboles individuales sean \textbf{aleatorios} y la combinación de árboles es el \textbf{bosque}. Los pasos específicos son los siguientes.

1. Construyan \(B\) árboles de decisión utilizando el set de entrenamiento. Nos referimos a los modelos ajustados como \(T_1, T_2, \dots, T_B\). Entonces explicamos cómo nos aseguramos de que sean diferentes.

2. Para cada observación en el set de evaluación, formen una predicción \(\hat{y}_j\) usando el árbol \(T_j\).

3. Para resultados continuos, formen una predicción final con el promedio \(\hat{y} = \frac{1}{B} \sum_{j=1}^B \hat{y}_j\). Para la clasificación de datos categóricos, predigan \(\hat{y}\) con voto mayoritario (clase más frecuente entre \(\hat{y}_1, \dots, \hat{y}_T\)).

Entonces, ¿cómo obtenemos diferentes árboles de decisión de un solo set de entrenamiento? Para esto, usamos la aleatoriedad en dos maneras que explicamos en los pasos a continuación. Dejen que \(N\) sea el número de observaciones en el set de entrenamiento. Para crear \(T_j, \, j=1,\ldots,B\) del set de entrenamiento, hagan lo siguiente:

1. Creen un set de entrenamiento de \emph{bootstrap} al mostrar \(N\) observaciones del set de entrenamiento \textbf{con reemplazo}. Esta es la primera forma de inducir aleatoriedad.

2. Una gran cantidad de atributos es típico en los desafíos de \emph{machine learning}. A menudo, muchos atributos pueden ser informativos, pero incluirlos todos en el modelo puede resultar en un sobreajuste. La segunda forma en que los bosques aleatorios inducen aleatoriedad es seleccionando al azar los atributos que se incluirán en la construcción de cada árbol. Se selecciona un subconjunto aleatorio diferente para cada árbol. Esto reduce la correlación entre los árboles en el bosque, mejorando así la exactitud de la predicción.

Para ilustrar cómo los primeros pasos pueden dar como resultado estimadores más uniformes, demostraremos ajustando un bosque aleatorio a los datos de las encuestas de 2008. Utilizaremos la función \texttt{randomForest} en el paquete \textbf{randomForest}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(randomForest)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{randomForest}\NormalTok{(margin}\SpecialCharTok{\textasciitilde{}}\NormalTok{., }\AttributeTok{data =}\NormalTok{ polls\_2008)}
\end{Highlighting}
\end{Shaded}

Noten que si aplicamos la función \texttt{plot} al objeto resultante, almacenado en \texttt{fit}, vemos cómo cambia la tasa de error de nuestro algoritmo a medida que agregamos árboles.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rafalib}\SpecialCharTok{::}\FunctionTok{mypar}\NormalTok{()}
\FunctionTok{plot}\NormalTok{(fit)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/more-trees-better-fit-1} \end{center}

Podemos ver que en este caso, la exactitud mejora a medida que agregamos más árboles hasta unos 30 árboles donde la exactitud se estabiliza.

El estimador resultante para este bosque aleatorio puede verse así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polls\_2008 }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{y\_hat =} \FunctionTok{predict}\NormalTok{(fit, }\AttributeTok{newdata =}\NormalTok{ polls\_2008)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, margin)) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\FunctionTok{aes}\NormalTok{(day, y\_hat), }\AttributeTok{col=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/polls-2008-rf-fit-1} \end{center}

Observen que el estimador del bosque aleatorio es mucho más uniforme que lo que logramos con el árbol de regresión en la sección anterior. Esto es posible porque el promedio de muchas funciones de escalón puede ser suave. Podemos ver esto examinando visualmente cómo cambia el estimador a medida que agregamos más árboles. En el siguiente gráfico, pueden ver cada una de las muestras de \emph{bootstrap} para varios valores de \(b\) y para cada una vemos el árbol que se ajusta en gris, los árboles anteriores que se ajustaron en gris más claro y el resultado de tomar el promedio de todos los árboles estimadores hasta ese punto.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/rf-animation-1} \end{center}

Aquí está el ajuste del bosque aleotorio para nuestro ejemplo de dígitos basado en dos predictores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(randomForest)}
\NormalTok{train\_rf }\OtherTok{\textless{}{-}} \FunctionTok{randomForest}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data=}\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train)}

\FunctionTok{confusionMatrix}\NormalTok{(}\FunctionTok{predict}\NormalTok{(train\_rf, mnist\_27}\SpecialCharTok{$}\NormalTok{test),}
\NormalTok{                mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.79}
\end{Highlighting}
\end{Shaded}

Así es como se ven las probabilidades condicionales:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/cond-prob-rf-1} \end{center}

La visualización del estimador muestra que, aunque obtenemos una alta exactitud, parece que podemos mejorar al hacer que el estimador sea más uniforme. Esto podría lograrse cambiando el parámetro que controla el número mínimo de puntos de datos en los nodos del árbol. Mientras más grande sea este mínimo, más suave será el estimador final. Podemos entrenar los parámetros del bosque aleatorio. A continuación, utilizamos el paquete \textbf{caret} para optimizar el tamaño mínimo del nodo. Debido a que este no es uno de los parámetros que el paquete \textbf{caret} optimiza por defecto, escribiremos nuestro propio código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nodesize }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{51}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{acc }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(nodesize, }\ControlFlowTok{function}\NormalTok{(ns)\{}
  \FunctionTok{train}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{method =} \StringTok{"rf"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ mnist\_27}\SpecialCharTok{$}\NormalTok{train,}
        \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{mtry =} \DecValTok{2}\NormalTok{),}
        \AttributeTok{nodesize =}\NormalTok{ ns)}\SpecialCharTok{$}\NormalTok{results}\SpecialCharTok{$}\NormalTok{Accuracy}
\NormalTok{\})}
\FunctionTok{qplot}\NormalTok{(nodesize, acc)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/acc-versus-nodesize-1} \end{center}

Ahora podemos ajustar el bosque aleatorio con el tamaño de nodo mínimo optimizado a todos los datos de entrenamiento y evaluar el rendimiento en los datos de evaluación.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_rf\_2 }\OtherTok{\textless{}{-}} \FunctionTok{randomForest}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ ., }\AttributeTok{data=}\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train,}
                           \AttributeTok{nodesize =}\NormalTok{ nodesize[}\FunctionTok{which.max}\NormalTok{(acc)])}

\FunctionTok{confusionMatrix}\NormalTok{(}\FunctionTok{predict}\NormalTok{(train\_rf\_2, mnist\_27}\SpecialCharTok{$}\NormalTok{test),}
\NormalTok{                mnist\_27}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}     0.82}
\end{Highlighting}
\end{Shaded}

El modelo seleccionado mejora la exactitud y provee un estimador más uniforme.

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/cond-prob-final-rf-1} \end{center}

Tengan en cuenta que podemos evitar escribir nuestro propio código utilizando otras implementaciones de bosques aleatorios como se describe en el manual \textbf{caret}\footnote{\url{http://topepo.github.io/caret/available-models.html}}.

El bosque aleatorio funciona mejor en todos los ejemplos que hemos considerado. Sin embargo, una desventaja de los bosques aleatorios es que perdemos interpretabilidad. Un enfoque que ayuda con la interpretabilidad es examinar la \emph{importancia de la variable} (\emph{variable importance} en inglés). Para definir importancia, contamos cuán frecuentemente se usa el predictor en los árboles individuales. Pueden obtener más información sobre \emph{importancia} en un libro de \emph{machine learning} avanzado\footnote{\url{https://web.stanford.edu/~hastie/Papers/ESLII.pdf}}. El paquete \textbf{caret} incluye la función \texttt{varImp} que extrae la importancia de cada variable de cualquier modelo en el que se implementa el cálculo. Ofecemos un ejemplo de cómo usamos la importancia en la siguiente sección.

\hypertarget{ejercicios-54}{%
\section{Ejercicios}\label{ejercicios-54}}

1. Cree un set de datos sencillo donde el resultado crece 0.75 unidades en promedio por cada aumento en un predictor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{sigma }\OtherTok{\textless{}{-}} \FloatTok{0.25}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(n, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FloatTok{0.75} \SpecialCharTok{*}\NormalTok{ x }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(n, }\DecValTok{0}\NormalTok{, sigma)}
\NormalTok{dat }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x, }\AttributeTok{y =}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

Utilice \texttt{rpart} para ajustar un árbol de regresión y guarde el resultado en \texttt{fit}.

2. Grafique el árbol final para que pueda ver dónde ocurrieron las particiones.

3. Haga un diagrama de dispersión de \texttt{y} versus \texttt{x} junto con los valores predichos basados en el ajuste.

4. Ahora modele con un bosque aleatorio en lugar de un árbol de regresión usando \texttt{randomForest} del paquete \textbf{randomForest} y rehaga el diagrama de dispersión con la línea de predicción.

5. Use la función \texttt{plot} para ver si el bosque aleatorio ha convergido o si necesitamos más árboles.

6. Parece que los valores predeterminados para el bosque aleatorio dan como resultado un estimador demasiado flexible (no uniforme). Vuelva a ejecutar el bosque aleatorio pero esta vez con \texttt{nodesize} fijado en 50 y \texttt{maxnodes} fijado en 25. Rehaga el gráfico.

7. Vemos que esto produce resultados más suaves. Usemos la función \texttt{train} para ayudarnos a elegir estos valores. Del manual \textbf{caret}\footnote{\url{https://topepo.github.io/caret/available-models.html}} vemos que no podemos ajustar el parámetro \texttt{maxnodes} ni el argumento \texttt{nodesize} con la función \texttt{randomForest}, así que usaremos el paquete \textbf{Rborist} y ajustaremos el argumento \texttt{minNode}. Utilice la función \texttt{train} para probar valores \texttt{minNode\ \textless{}-\ seq(5,\ 250,\ 25)}. Vea qué valor minimiza el estimador RMSE.

8. Haga un diagrama de dispersión junto con la predicción del modelo mejor ajustado.

9. Utilice la función \texttt{rpart} para ajustar un árbol de clasificación al set de datos \texttt{tissue\_gene\_expression}. Utilice la función \texttt{train} para estimar la exactitud. Pruebe valores \texttt{cp} de \texttt{seq(0,\ 0.05,\ 0.01)}. Grafique la exactitud para indicar los resultados del mejor modelo.

10. Estudie la matriz de confusión para el árbol de clasificación de mejor ajuste. ¿Qué observa que sucede con la placenta?

11. Tenga en cuenta que las placentas se llaman endometrio con más frecuencia que placenta. Además, noten que la cantidad de placentas es solo seis y que, de forma predeterminada, \texttt{rpart} requiere 20 observaciones antes de dividir un nodo. Por lo tanto, no es posible con estos parámetros tener un nodo en el que las placentas sean la mayoría. Vuelva a ejecutar el análisis anterior, pero esta vez permita que \texttt{rpart} divida cualquier nodo usando el argumento \texttt{control\ =\ rpart.control(minsplit\ =\ 0)}. ¿Aumenta la exactitud? Mire la matriz de confusión de nuevo.

12. Grafique el árbol del modelo de mejor ajuste obtenido en el ejercicio 11.

13. Podemos ver que con solo seis genes, podemos predecir el tipo de tejido. Ahora veamos si podemos hacerlo aún mejor con un bosque aleatorio. Utilice la función \texttt{train} y el método \texttt{rf} para entrenar un bosque aleatorio. Pruebe valores de \texttt{mtry} que van desde, al menos, \texttt{seq(50,\ 200,\ 25)}. ¿Qué valor de \texttt{mtry} maximiza la exactitud? Para permitir que pequeños \texttt{nodesize} crezcan como lo hicimos con los árboles de clasificación, use el siguiente argumento: \texttt{nodesize\ =\ 1}. Esto tardará varios segundos en ejecutarse. Si desea probarlo, intente usar valores más pequeños con \texttt{ntree}. Fije la semilla en 1990.

14. Use la función \texttt{varImp} en el resultado de \texttt{train} y guárdelo en un objeto llamado \texttt{imp}.

15. El modelo \texttt{rpart} que ejecutamos anteriormente produjo un árbol que utilizaba solo seis predictores. Extraer los nombres de los predictores no es sencillo, pero se puede hacer. Si el resultado de la llamada a \texttt{train} fue \texttt{fit\_rpart}, podemos extraer los nombres así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind }\OtherTok{\textless{}{-}} \SpecialCharTok{!}\NormalTok{(fit\_rpart}\SpecialCharTok{$}\NormalTok{finalModel}\SpecialCharTok{$}\NormalTok{frame}\SpecialCharTok{$}\NormalTok{var }\SpecialCharTok{==} \StringTok{"\textless{}leaf\textgreater{}"}\NormalTok{)}
\NormalTok{tree\_terms }\OtherTok{\textless{}{-}}
\NormalTok{  fit\_rpart}\SpecialCharTok{$}\NormalTok{finalModel}\SpecialCharTok{$}\NormalTok{frame}\SpecialCharTok{$}\NormalTok{var[ind] }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unique}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{as.character}\NormalTok{()}
\NormalTok{tree\_terms}
\end{Highlighting}
\end{Shaded}

¿Cuál es la importancia de variable para estos predictores? ¿Cuáles son sus rangos?

16. \textbf{Avanzado}: extraiga los 50 predictores principales según la importancia, tome un subconjunto de \texttt{x} con solo estos predictores y aplique la función \texttt{heatmap} para ver cómo se comportan estos genes a través de los tejidos. Presentaremos la función \texttt{heatmap} en el Capítulo \ref{clustering}.

\hypertarget{machine-learning-en-la-pruxe1ctica}{%
\chapter{Machine learning en la práctica}\label{machine-learning-en-la-pruxe1ctica}}

Ahora que hemos aprendido varios métodos y los hemos explorado con ejemplos ilustrativos, los aplicaremos a un ejemplo real: los dígitos MNIST.

Podemos cargar estos datos usando el siguiente paquete de \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\NormalTok{mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

El set de datos incluye dos componentes, un set de entrenamiento y un set de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mnist)}
\CommentTok{\#\textgreater{} [1] "train" "test"}
\end{Highlighting}
\end{Shaded}

Cada uno de estos componentes incluye una matriz con atributos en las columnas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images)}
\CommentTok{\#\textgreater{} [1] 60000   784}
\end{Highlighting}
\end{Shaded}

y un vector con las clases como enteros:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels)}
\CommentTok{\#\textgreater{} [1] "integer"}
\FunctionTok{table}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels)}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{}    0    1    2    3    4    5    6    7    8    9 }
\CommentTok{\#\textgreater{} 5923 6742 5958 6131 5842 5421 5918 6265 5851 5949}
\end{Highlighting}
\end{Shaded}

Como queremos que este ejemplo se ejecute en una computadora portátil pequeña y en menos de una hora, consideraremos un subconjunto del set de datos. Tomaremos muestras de 10,000 filas aleatorias del set de entrenamiento y 1,000 filas aleatorias del set de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1990}\NormalTok{)}
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images), }\DecValTok{10000}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images[index,]}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels[index])}

\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{images), }\DecValTok{1000}\NormalTok{)}
\NormalTok{x\_test }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{images[index,]}
\NormalTok{y\_test }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{labels[index])}
\end{Highlighting}
\end{Shaded}

\hypertarget{preprocesamiento}{%
\section{Preprocesamiento}\label{preprocesamiento}}

En \emph{machine learning}, a menudo transformamos predictores antes de ejecutar el algoritmo. También eliminamos predictores que claramente no son útiles. Llamamos a estos pasos \emph{preprocesamiento} (\emph{preprocessing} en inglés).

Ejemplos de preprocesamiento incluyen estandarizar los predictores, transformar logarítmicamente algunos predictores, eliminar los predictores que están altamente correlacionados con otros y eliminar los predictores con muy pocos valores no únicos o una variación cercana a cero. Mostramos un ejemplo a continuación.

Podemos ejecutar la función \texttt{nearZero} del paquete \textbf{caret} para ver que muchos atributos no varían mucho de una observación a otra. Podemos ver que hay una gran cantidad de atributos con variabilidad 0:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(matrixStats)}
\NormalTok{sds }\OtherTok{\textless{}{-}} \FunctionTok{colSds}\NormalTok{(x)}
\FunctionTok{qplot}\NormalTok{(sds, }\AttributeTok{bins =} \DecValTok{256}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pixel-sds-1} \end{center}

Esto se espera porque hay partes de la imagen que raras veces contienen escritura (píxeles oscuros).

El paquete \textbf{caret} incluye una función que recomienda que se eliminen estos atributos debido a que la variación es casi cero:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{nzv }\OtherTok{\textless{}{-}} \FunctionTok{nearZeroVar}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Podemos ver las columnas que se recomiendan eliminar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{784} \SpecialCharTok{\%in\%}\NormalTok{ nzv, }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rafalib}\SpecialCharTok{::}\FunctionTok{mypar}\NormalTok{()}
\FunctionTok{image}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{784} \SpecialCharTok{\%in\%}\NormalTok{ nzv, }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/near-zero-image-1} \end{center}

Entonces nos quedeamos con este número de columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{col\_index }\OtherTok{\textless{}{-}} \FunctionTok{setdiff}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(x), nzv)}
\FunctionTok{length}\NormalTok{(col\_index)}
\CommentTok{\#\textgreater{} [1] 252}
\end{Highlighting}
\end{Shaded}

Ahora estamos listos para adaptarnos a algunos modelos. Antes de comenzar, debemos agregar nombres de columna a las matrices de predictores, ya que \textbf{caret} los requiere:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images)}
\FunctionTok{colnames}\NormalTok{(x\_test) }\OtherTok{\textless{}{-}} \FunctionTok{colnames}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\hypertarget{k-vecino-muxe1s-cercano-y-bosque-aleatorio}{%
\section{k-vecino más cercano y bosque aleatorio}\label{k-vecino-muxe1s-cercano-y-bosque-aleatorio}}

Comencemos con kNN. El primer paso es optimizar para \(k\). Tengan en cuenta que cuando ejecutamos el algoritmo, tendremos que calcular una distancia entre cada observación en el set de evaluación y cada observación en el set de entrenamiento. Hay muchos cálculos. Por lo tanto, utilizaremos la validación cruzada \emph{k-fold} para mejorar la velocidad.

Si ejecutamos el siguiente código, el tiempo de computación en una computadora portátil estándar será de varios minutos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control }\OtherTok{\textless{}{-}} \FunctionTok{trainControl}\NormalTok{(}\AttributeTok{method =} \StringTok{"cv"}\NormalTok{, }\AttributeTok{number =} \DecValTok{10}\NormalTok{, }\AttributeTok{p =}\NormalTok{ .}\DecValTok{9}\NormalTok{)}
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(x[ ,col\_index], y,}
                   \AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
                   \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{)),}
                   \AttributeTok{trControl =}\NormalTok{ control)}
\NormalTok{train\_knn}
\end{Highlighting}
\end{Shaded}

En general, es una buena idea hacer una prueba con un subconjunto de datos para tener una idea del tiempo antes de comenzar a ejecutar un código que puede tardar horas en completarse. Podemos hacer esto de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{index }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(x), n)}
\NormalTok{control }\OtherTok{\textless{}{-}} \FunctionTok{trainControl}\NormalTok{(}\AttributeTok{method =} \StringTok{"cv"}\NormalTok{, }\AttributeTok{number =}\NormalTok{ b, }\AttributeTok{p =}\NormalTok{ .}\DecValTok{9}\NormalTok{)}
\NormalTok{train\_knn }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(x[index, col\_index], y[index],}
                   \AttributeTok{method =} \StringTok{"knn"}\NormalTok{,}
                   \AttributeTok{tuneGrid =} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{k =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{)),}
                   \AttributeTok{trControl =}\NormalTok{ control)}
\end{Highlighting}
\end{Shaded}

Entonces podemos aumentar \texttt{n} y \texttt{b} e intentar establecer un patrón de cómo afectan el tiempo de computación para tener una idea de cuánto tiempo tomará el proceso de ajuste para valores mayores de \texttt{n} y \texttt{b}. Quieren saber si una función tomará horas, o incluso días, antes de ejecutarla.

Una vez que optimicemos nuestro algoritmo, podemos aplicarlo a todo el set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit\_knn }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(x[, col\_index], y, }\AttributeTok{k =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

¡La exactitud es casi 0.95!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_knn, x\_test[, col\_index], }\AttributeTok{type=}\StringTok{"class"}\NormalTok{)}
\NormalTok{cm }\OtherTok{\textless{}{-}} \FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_knn, }\FunctionTok{factor}\NormalTok{(y\_test))}
\NormalTok{cm}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.953}
\end{Highlighting}
\end{Shaded}

Ahora logramos una exactitud de aproximadamente 0.95. De la especificidad y sensibilidad, también vemos que los 8 son los más difíciles de detectar y que el dígito pronosticado incorrectamente con mas frecuencia es el 7.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cm}\SpecialCharTok{$}\NormalTok{byClass[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{}          Sensitivity Specificity}
\CommentTok{\#\textgreater{} Class: 0       0.990       0.996}
\CommentTok{\#\textgreater{} Class: 1       1.000       0.993}
\CommentTok{\#\textgreater{} Class: 2       0.965       0.997}
\CommentTok{\#\textgreater{} Class: 3       0.950       0.999}
\CommentTok{\#\textgreater{} Class: 4       0.930       0.997}
\CommentTok{\#\textgreater{} Class: 5       0.921       0.993}
\CommentTok{\#\textgreater{} Class: 6       0.977       0.996}
\CommentTok{\#\textgreater{} Class: 7       0.956       0.989}
\CommentTok{\#\textgreater{} Class: 8       0.887       0.999}
\CommentTok{\#\textgreater{} Class: 9       0.951       0.990}
\end{Highlighting}
\end{Shaded}

Ahora veamos si podemos hacerlo aún mejor con el algoritmo de bosque aleatorio.

Con bosque aleatorio, el tiempo de cálculo es un reto. Para cada bosque, necesitamos construir cientos de árboles. También tenemos varios parámetros que podemos ajustar.

Debido a que con el bosque aleatorio el ajuste es la parte más lenta del procedimiento en lugar de la predicción (como con kNN), usaremos solo una validación cruzada de cinco pliegues (\emph{folds} en inglés). Además, reduciremos la cantidad de árboles que se ajustan ya que aún no estamos construyendo nuestro modelo final.

Finalmente, para calcular en un set de datos más pequeño, tomaremos una muestra aleatoria de las observaciones al construir cada árbol. Podemos cambiar este número con el argumento \texttt{nSamp}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(randomForest)}
\NormalTok{control }\OtherTok{\textless{}{-}} \FunctionTok{trainControl}\NormalTok{(}\AttributeTok{method=}\StringTok{"cv"}\NormalTok{, }\AttributeTok{number =} \DecValTok{5}\NormalTok{)}
\NormalTok{grid }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{mtry =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{))}

\NormalTok{train\_rf }\OtherTok{\textless{}{-}} \FunctionTok{train}\NormalTok{(x[, col\_index], y,}
                  \AttributeTok{method =} \StringTok{"rf"}\NormalTok{,}
                  \AttributeTok{ntree =} \DecValTok{150}\NormalTok{,}
                  \AttributeTok{trControl =}\NormalTok{ control,}
                  \AttributeTok{tuneGrid =}\NormalTok{ grid,}
                  \AttributeTok{nSamp =} \DecValTok{5000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora que hemos optimizado nuestro algoritmo, estamos listos para ajustar nuestro modelo final:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit\_rf }\OtherTok{\textless{}{-}} \FunctionTok{randomForest}\NormalTok{(x[, col\_index], y,}
                       \AttributeTok{minNode =}\NormalTok{ train\_rf}\SpecialCharTok{$}\NormalTok{bestTune}\SpecialCharTok{$}\NormalTok{mtry)}
\end{Highlighting}
\end{Shaded}

Para verificar que ejecutamos suficientes árboles, podemos usar la función \texttt{plot}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(fit\_rf)}
\end{Highlighting}
\end{Shaded}

Vemos que logramos una alta exactitud:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat\_rf }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_rf, x\_test[ ,col\_index])}
\NormalTok{cm }\OtherTok{\textless{}{-}} \FunctionTok{confusionMatrix}\NormalTok{(y\_hat\_rf, y\_test)}
\NormalTok{cm}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.956}
\end{Highlighting}
\end{Shaded}

Con algunos ajustes adicionales, podemos obtener una exactitud aún mayor.

\hypertarget{importancia-variable}{%
\section{Importancia variable}\label{importancia-variable}}

La siguiente función calcula la importancia de cada atributo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imp }\OtherTok{\textless{}{-}} \FunctionTok{importance}\NormalTok{(fit\_rf)}
\end{Highlighting}
\end{Shaded}

Podemos ver qué atributos se utilizan más al graficar una imagen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FunctionTok{ncol}\NormalTok{(x))}
\NormalTok{mat[col\_index] }\OtherTok{\textless{}{-}}\NormalTok{ imp}
\FunctionTok{image}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(mat, }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rafalib}\SpecialCharTok{::}\FunctionTok{mypar}\NormalTok{()}
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FunctionTok{ncol}\NormalTok{(x))}
\NormalTok{mat[col\_index] }\OtherTok{\textless{}{-}}\NormalTok{ imp}
\FunctionTok{image}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(mat, }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/importance-image-1} \end{center}

\hypertarget{evaluaciones-visuales}{%
\section{Evaluaciones visuales}\label{evaluaciones-visuales}}

Una parte importante del análisis de datos es visualizar los resultados para determinar por qué estamos fallando. Cómo hacemos esto depende de la aplicación. A continuación mostramos las imágenes de dígitos para los cuales hicimos una predicción incorrecta. Podemos comparar lo que obtenemos con kNN a los resultados de bosque aleatorio.

Aquí vemos unos errores para el bosque aleatorio:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/knn-images-1} \end{center}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/rf-images,-1} \end{center}

Al examinar errores como este, a menudo encontramos debilidades específicas en los algoritmos o en las opciones de parámetros que podemos intentar corregir.

\hypertarget{conjuntos}{%
\section{Conjuntos}\label{conjuntos}}

La idea de un conjunto (\emph{ensemble} en inglés) es similar a la idea de combinar datos de diferentes encuestadores para obtener un mejor estimador del verdadero apoyo para cada candidato.

En \emph{machine learning}, generalmente se pueden mejorar los resultados finales combinando los resultados de diferentes algoritmos.

Aquí hay un ejemplo sencillo donde calculamos nuevas probabilidades de clase tomando el promedio de bosque aleatorio y kNN. Podemos ver que la exactitud mejora a 0.96:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_rf }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_rf, x\_test[,col\_index], }\AttributeTok{type =} \StringTok{"prob"}\NormalTok{)}
\NormalTok{p\_rf}\OtherTok{\textless{}{-}}\NormalTok{ p\_rf}\SpecialCharTok{/} \FunctionTok{rowSums}\NormalTok{(p\_rf)}
\NormalTok{p\_knn }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit\_knn, x\_test[,col\_index])}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ (p\_rf }\SpecialCharTok{+}\NormalTok{ p\_knn)}\SpecialCharTok{/}\DecValTok{2}
\NormalTok{y\_pred }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{apply}\NormalTok{(p, }\DecValTok{1}\NormalTok{, which.max)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_pred, y\_test)}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.961}
\end{Highlighting}
\end{Shaded}

En los ejercicios, vamos a construir varios modelos de \emph{machine learning} para el set de datos \texttt{mnist\_27} y luego construir un conjunto.

\hypertarget{ejercicios-55}{%
\section{Ejercicios}\label{ejercicios-55}}

1. Utilice el set de entrenamiento \texttt{mnist\_27} para construir un modelo con varios de los modelos disponibles del paquete \textbf{caret}. Por ejemplo, puede tratar estos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{models }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"glm"}\NormalTok{, }\StringTok{"lda"}\NormalTok{, }\StringTok{"naive\_bayes"}\NormalTok{, }\StringTok{"svmLinear"}\NormalTok{, }\StringTok{"gamboost"}\NormalTok{,}
            \StringTok{"gamLoess"}\NormalTok{, }\StringTok{"qda"}\NormalTok{, }\StringTok{"knn"}\NormalTok{, }\StringTok{"kknn"}\NormalTok{, }\StringTok{"loclda"}\NormalTok{, }\StringTok{"gam"}\NormalTok{, }\StringTok{"rf"}\NormalTok{,}
            \StringTok{"ranger"}\NormalTok{,}\StringTok{"wsrf"}\NormalTok{, }\StringTok{"Rborist"}\NormalTok{, }\StringTok{"avNNet"}\NormalTok{, }\StringTok{"mlp"}\NormalTok{, }\StringTok{"monmlp"}\NormalTok{, }\StringTok{"gbm"}\NormalTok{,}
            \StringTok{"adaboost"}\NormalTok{, }\StringTok{"svmRadial"}\NormalTok{, }\StringTok{"svmRadialCost"}\NormalTok{, }\StringTok{"svmRadialSigma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Aunque no hemos explicado muchos de estos algoritmos, aplíquelos usando \texttt{train} con todos los parámetros predeterminados. Guarde los resultados en una lista. Es posible que tenga que instalar algunos paquetes. Es posible que probablemente recibirá algunas advertencias.

2. Ahora que tiene todos los modelos entrenados en una lista, use \texttt{sapply} o \texttt{map} para crear una matriz de predicciones para el set de evaluación. Debería terminar con una matriz con \texttt{length(mnist\_27\$test\$y)} filas y \texttt{length(models)} columnas.

3. Ahora calcule la exactitud para cada modelo en el set de evaluación.

4. Ahora construya una predicción de conjunto para el voto mayoritario y calcule su exactitud.

5. Anteriormente calculamos la exactitud de cada método en el set de entrenamiento y notamos que variaban. ¿Qué métodos individuales funcionan mejor que el conjunto?

6. Es tentador eliminar los métodos que no funcionan bien y volver a hacer el conjunto. El problema con este acercamiento es que estamos utilizando los datos de evaluación para tomar una decisión. Sin embargo, podríamos usar los estimadores de exactitud obtenidos de la validación cruzada con los datos de entrenamiento. Obtenga estos estimadores y guárdelos en un objeto.

7. Ahora solo consideremos los métodos con una exactitud estimada de 0.8 al construir el conjunto. ¿Cuál es la exactitud ahora?

8. \textbf{Avanzado}: Si dos métodos dan resultados que son iguales, unirlos no cambiará los resultados en absoluto. Para cada par de métricas, compare cuán frequentemente predicen lo mismo. Entonces use la función \texttt{heatmap} para visualizar los resultados. Sugerencia: use el argumento \texttt{method\ =\ "binary"} en la función \texttt{dist}.

9. \textbf{Avanzado}: Tenga en cuenta que cada método también puede producir una probabilidad condicional estimada. En lugar del voto mayoritario, podemos tomar el promedio de estas probabilidades condicionales estimadas. Para la mayoría de los métodos, podemos usar el \texttt{type\ =\ "prob"} en la función \texttt{train}. Sin embargo, algunos de los métodos requieren que use el argumento \texttt{trControl=trainControl(classProbs=TRUE)} al llamar \texttt{train}. Además, estos métodos no funcionan si las clases tienen números como nombres. Sugerencia: cambie los niveles de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{recode\_factor}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{y, }\StringTok{"2"}\OtherTok{=}\StringTok{"two"}\NormalTok{, }\StringTok{"7"}\OtherTok{=}\StringTok{"seven"}\NormalTok{)}
\NormalTok{dat}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{recode\_factor}\NormalTok{(dat}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{y, }\StringTok{"2"}\OtherTok{=}\StringTok{"two"}\NormalTok{, }\StringTok{"7"}\OtherTok{=}\StringTok{"seven"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

10. En este capítulo, ilustramos un par de algoritmos de \emph{machine learning} en un subconjunto del set de datos MNIST. Intente ajustar un modelo a todo el set de datos.

\hypertarget{sets-grandes-de-datos}{%
\chapter{Sets grandes de datos}\label{sets-grandes-de-datos}}

Los problemas de \emph{machine learning} a menudo implican sets de datos que son tan o más grandes que el set de datos MNIST. Existe una variedad de técnicas computacionales y conceptos estadísticos que son útiles para análisis de grandes sets de datos. En este capítulo, exploramos brevemente estas técnicas y conceptos al describir álgebra matricial, reducción de dimensiones, regularización y factorización de matrices. Utilizamos sistemas de recomendación relacionados con las clasificaciones de películas como un ejemplo motivador.

\hypertarget{matrix-algebra}{%
\section{Álgebra matricial}\label{matrix-algebra}}

En \emph{machine learning}, las situaciones en las que todos los predictores son numéricos, o pueden representarse como números son comunes. El set de datos de dígitos es un ejemplo: cada píxel registra un número entre 0 y 255. Carguemos los datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{exists}\NormalTok{(}\StringTok{"mnist"}\NormalTok{)) mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

En estos casos, a menudo es conveniente guardar los predictores en una matriz y el resultado en un vector en lugar de utilizar un \emph{data frame}. Pueden ver que los predictores se guardan en una matriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images)}
\CommentTok{\#\textgreater{} [1] "matrix" "array"}
\end{Highlighting}
\end{Shaded}

Esta matriz representa 60,000 dígitos, así que para los ejemplos en este capítulo, usaremos un subconjunto más manejable. Tomaremos los primeros 1,000 predictores \texttt{x} y etiquetas \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{1000}\NormalTok{,]}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{1000}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

La razón principal para usar matrices es que ciertas operaciones matemáticas necesarias para desarrollar código eficiente se pueden realizar usando técnicas de una rama de las matemáticas llamada álgebra lineal. De hecho, álgebra lineal y notación matricial son elementos claves del lenguaje utilizado en trabajos académicos que describen técnicas de \emph{machine learning}. No cubriremos álgebra lineal en detalle aquí, pero demostraremos cómo usar matrices en R para que puedan aplicar las técnicas de álgebra lineal ya implementadas en la base R u otros paquetes.

Para motivar el uso de matrices, plantearemos cinco preguntas/desafíos:

1. ¿Algunos dígitos requieren más tinta que otros? Estudien la distribución de la oscuridad total de píxeles y cómo varía según los dígitos.

2. ¿Algunos píxeles no son informativos? Estudien la variación de cada píxel y eliminen los predictores (columnas) asociados con los píxeles que no cambian mucho y, por lo tanto, no proveen mucha información para la clasificación.

3. ¿Podemos eliminar las manchas? Primero, observen la distribución de todos los valores de píxeles. Usen esto para elegir un umbral para definir el espacio no escrito. Luego, cambien cualquier valor por debajo de ese umbral a 0.

4. Binaricen los datos. Primero, observen la distribución de todos los valores de píxeles. Usen esto para elegir un umbral para distinguir entre escritura y no escritura. Luego, conviertan todas las entradas en 1 o 0, respectivamente.

5. Escalen cada uno de los predictores en cada entrada para tener el mismo promedio y desviación estándar.

Para completar esto, tendremos que realizar operaciones matemáticas que involucran varias variables. El \textbf{tidyverse} no está desarrollado para realizar este tipo de operaciones matemáticas. Para esta tarea, es conveniente usar matrices.

Antes de hacer esto, presentaremos la notación matricial y el código R básico para definir y operar en matrices.

\hypertarget{notaciuxf3n-2}{%
\subsection{Notación}\label{notaciuxf3n-2}}

En álgebra matricial, tenemos tres tipos principales de objetos: escalares, vectores y matrices. Un escalar es solo un número, por ejemplo \(a = 1\). Para denotar escalares en notación matricial, generalmente usamos una letra minúscula no en negrilla.

Los vectores son como los vectores numéricos que definimos en R: incluyen varias entradas escalares. Por ejemplo, la columna que contiene el primer píxel:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(x[,}\DecValTok{1}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] 1000}
\end{Highlighting}
\end{Shaded}

tiene 1,000 entradas. En álgebra matricial, utilizamos la siguiente notación para un vector que representa un atributo/predictor:

\[
\begin{pmatrix}
x_1\\\
x_2\\\
\vdots\\\
x_N
\end{pmatrix}
\]

Del mismo modo, podemos usar la notación matemática para representar diferentes atributos matemáticamente agregando un índice:

\[
\mathbf{X}_1 = \begin{pmatrix}
x_{1,1}\\
\vdots\\
x_{N,1}
\end{pmatrix} \mbox{ and }
\mathbf{X}_2 = \begin{pmatrix}
x_{1,2}\\
\vdots\\
x_{N,2}
\end{pmatrix}
\]

Si estamos escribiendo una columna, como \(\mathbf{X}_1\), en una oración, a menudo usamos la notación: \(\mathbf{X}_1 = ( x_{1,1}, \dots x_{N,1})^\top\) con \(^\top\) la operación de transposición que convierte las columnas en filas y las filas en columnas.

Una matriz se puede definir como una serie de vectores del mismo tamaño unidos como columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_1 }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\NormalTok{x\_2 }\OtherTok{\textless{}{-}} \DecValTok{6}\SpecialCharTok{:}\DecValTok{10}
\FunctionTok{cbind}\NormalTok{(x\_1, x\_2)}
\CommentTok{\#\textgreater{}      x\_1 x\_2}
\CommentTok{\#\textgreater{} [1,]   1   6}
\CommentTok{\#\textgreater{} [2,]   2   7}
\CommentTok{\#\textgreater{} [3,]   3   8}
\CommentTok{\#\textgreater{} [4,]   4   9}
\CommentTok{\#\textgreater{} [5,]   5  10}
\end{Highlighting}
\end{Shaded}

Matemáticamente, los representamos con letras mayúsculas en negrilla:

\[
\mathbf{X} = [ \mathbf{X}_1 \mathbf{X}_2 ] = \begin{pmatrix}
x_{1,1}&x_{1,2}\\
\vdots\\
x_{N,1}&x_{N,2}
\end{pmatrix}
\]

La \emph{dimensión} de una matriz a menudo es un atributo importante necesario para asegurar que se puedan realizar ciertas operaciones. La dimensión es un resumen de dos números definido como el número de filas \(\times\) el número de columnas. En R, podemos extraer la dimensión de una matriz con la función \texttt{dim}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 1000  784}
\end{Highlighting}
\end{Shaded}

Los vectores pueden considerarse \(N\times 1\) matrices. Sin embargo, en R, un vector no tiene dimensiones:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(x\_1)}
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

No obstante, explícitamente convertimos un vector en una matriz usando la función \texttt{as.matrix}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(x\_1))}
\CommentTok{\#\textgreater{} [1] 5 1}
\end{Highlighting}
\end{Shaded}

Podemos usar esta notación para denotar un número arbitrario de predictores con la siguiente matriz \(N\times p\), por ejemplo, con \(p=784\):

\[
\mathbf{X} = \begin{pmatrix}
x_{1,1}&\dots & x_{1,p} \\
x_{2,1}&\dots & x_{2,p} \\
& \vdots & \\
x_{N,1}&\dots & x_{N,p}
\end{pmatrix}
\]

Almacenamos esta matriz en x:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 1000  784}
\end{Highlighting}
\end{Shaded}

Ahora aprenderemos varias operaciones útiles relacionadas con el álgebra matricial. Utilizamos tres de las preguntas motivadoras mencionadas anteriormente.

\hypertarget{convertir-un-vector-en-una-matriz}{%
\subsection{Convertir un vector en una matriz}\label{convertir-un-vector-en-una-matriz}}

A menudo es útil convertir un vector en una matriz. Por ejemplo, debido a que las variables son píxeles en una cuadrícula, podemos convertir las filas de intensidades de píxeles en una matriz que representa esta cuadrícula.

Podemos convertir un vector en una matriz con la función \texttt{matrix} y especificando el número de filas y columnas que debe tener la matriz resultante. La matriz se llena \textbf{por columna}: la primera columna se llena primero, luego la segunda y así sucesivamente. Este ejemplo ayuda a ilustrar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_vector }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{15}
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(my\_vector, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mat}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3]}
\CommentTok{\#\textgreater{} [1,]    1    6   11}
\CommentTok{\#\textgreater{} [2,]    2    7   12}
\CommentTok{\#\textgreater{} [3,]    3    8   13}
\CommentTok{\#\textgreater{} [4,]    4    9   14}
\CommentTok{\#\textgreater{} [5,]    5   10   15}
\end{Highlighting}
\end{Shaded}

Podemos llenar por fila usando el argumento \texttt{byrow}. Entonces, por ejemplo, para \emph{transponer} la matriz \texttt{mat}, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat\_t }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(my\_vector, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{mat\_t}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    2    3    4    5}
\CommentTok{\#\textgreater{} [2,]    6    7    8    9   10}
\CommentTok{\#\textgreater{} [3,]   11   12   13   14   15}
\end{Highlighting}
\end{Shaded}

Cuando convertimos las columnas en filas, nos referimos a las operaciones como \emph{transponer} la matriz. La función \texttt{t} se puede usar para transponer directamente una matriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{identical}\NormalTok{(}\FunctionTok{t}\NormalTok{(mat), mat\_t)}
\CommentTok{\#\textgreater{} [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{Advertencia}: La función \texttt{matrix} recicla valores en el vector \textbf{sin advertencia} si el producto de las columnas y las filas no coincide con la longitud del vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{matrix}\NormalTok{(my\_vector, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} Warning in matrix(my\_vector, 4, 5): la longitud de los datos [15] no es}
\CommentTok{\#\textgreater{} un submúltiplo o múltiplo del número de filas [4] en la matriz}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    5    9   13    2}
\CommentTok{\#\textgreater{} [2,]    2    6   10   14    3}
\CommentTok{\#\textgreater{} [3,]    3    7   11   15    4}
\CommentTok{\#\textgreater{} [4,]    4    8   12    1    5}
\end{Highlighting}
\end{Shaded}

Para poner las intensidades de píxeles de nuestra, digamos, tercera entrada, que es 4 en la cuadrícula, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grid }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(x[}\DecValTok{3}\NormalTok{,], }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Para confirmar que lo hemos hecho correctamente, podemos usar la función \texttt{image}, que muestra una imagen de su tercer argumento. La parte superior de este gráfico es el píxel 1, que se muestra en la parte inferior para que la imagen se voltee. A continuación incluimos el código que muestra cómo voltearlo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, grid)}
\FunctionTok{image}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, grid[, }\DecValTok{28}\SpecialCharTok{:}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/matrix-image-1} \end{center}

\hypertarget{resuxfamenes-de-filas-y-columnas}{%
\subsection{Resúmenes de filas y columnas}\label{resuxfamenes-de-filas-y-columnas}}

Para la primera tarea, relacionada con la oscuridad total de píxeles, queremos sumar los valores de cada fila y luego visualizar cómo estos valores varían por dígito.

La función \texttt{rowSums} toma una matriz como entrada y calcula los valores deseados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sums }\OtherTok{\textless{}{-}} \FunctionTok{rowSums}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

También podemos calcular los promedios con \texttt{rowMeans} si queremos que los valores permanezcan entre 0 y 255:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avg }\OtherTok{\textless{}{-}} \FunctionTok{rowMeans}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Una vez que tengamos esto, podemos generar un diagrama de caja:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{labels =} \FunctionTok{as.factor}\NormalTok{(y), }\AttributeTok{row\_averages =}\NormalTok{ avg) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{qplot}\NormalTok{(labels, row\_averages, }\AttributeTok{data =}\NormalTok{ ., }\AttributeTok{geom =} \StringTok{"boxplot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/boxplot-of-digit-averages-1} \end{center}

De este gráfico vemos que, como era de esperar, los 1s usan menos tinta que los otros dígitos.

Podemos calcular las sumas y los promedios de la columna usando la función \texttt{colSums} y \texttt{colMeans}, respectivamente.

El paquete \textbf{matrixStats} agrega funciones que realizan operaciones en cada fila o columna de manera muy eficiente, incluyendo las funciones \texttt{rowSds} y \texttt{colSds}.

\hypertarget{apply}{%
\subsection{\texorpdfstring{\texttt{apply}}{apply}}\label{apply}}

Las funciones que acabamos de describir están realizando una operación similar a la que hacen \texttt{sapply} y la función \texttt{map} de \textbf{purrr}: aplicar la misma función a una parte de su objeto. En este caso, la función se aplica a cada fila o cada columna. La función \texttt{apply} les permite aplicar cualquier función, no solo \texttt{sum} o \texttt{mean}, a una matriz. El primer argumento es la matriz, el segundo es la dimensión (1 para las filas y 2 para las columnas) y el tercero es la función. Así, por ejemplo, \texttt{rowMeans} se puede escribir como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{avgs }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(x, }\DecValTok{1}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

Pero noten que al igual que con \texttt{sapply} y \texttt{map}, podemos ejecutar cualquier función. Entonces, si quisiéramos la desviación estándar para cada columna, podríamos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sds }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, sd)}
\end{Highlighting}
\end{Shaded}

La desventaja de esta flexibilidad es que estas operaciones no son tan rápidas como las funciones dedicadas, como \texttt{rowMeans}.

\hypertarget{filtrar-columnas-basado-en-resuxfamenes}{%
\subsection{Filtrar columnas basado en resúmenes}\label{filtrar-columnas-basado-en-resuxfamenes}}

Ahora pasamos a la tarea 2: estudiar la variación de cada píxel y eliminar las columnas asociadas con píxeles que no cambian mucho y, por lo tanto, no informan la clasificación. Aunque es un enfoque simplista, cuantificaremos la variación de cada píxel con su desviación estándar en todas las entradas. Como cada columna representa un píxel, utilizamos la función \texttt{colSds} del paquete \textbf{matrixStats}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(matrixStats)}
\NormalTok{sds }\OtherTok{\textless{}{-}} \FunctionTok{colSds}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Un vistazo rápido a la distribución de estos valores muestra que algunos píxeles tienen una variabilidad muy baja de entrada a entrada:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(sds, }\AttributeTok{bins =} \StringTok{"30"}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/sds-histogram-1} \end{center}

Esto tiene sentido ya que no escribimos en algunas partes del cuadro. Aquí está la variación graficada por ubicación:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{28}\NormalTok{, }\FunctionTok{matrix}\NormalTok{(sds, }\DecValTok{28}\NormalTok{, }\DecValTok{28}\NormalTok{)[, }\DecValTok{28}\SpecialCharTok{:}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/pixel-variance-1} \end{center}

Vemos que hay poca variación en las esquinas.

Podríamos eliminar atributos que no tienen variación ya que estos no nos ayuda a predecir. En la Sección \ref{matrices}, describimos las operaciones utilizadas para extraer columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[ ,}\FunctionTok{c}\NormalTok{(}\DecValTok{351}\NormalTok{,}\DecValTok{352}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

y para extraer filas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{),]}
\end{Highlighting}
\end{Shaded}

Además, podemos usar índices lógicos para determinar qué columnas o filas mantener. Entonces, si quisiéramos eliminar predictores no informativos de nuestra matriz, podríamos escribir esta línea de código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_x }\OtherTok{\textless{}{-}}\NormalTok{ x[ ,}\FunctionTok{colSds}\NormalTok{(x) }\SpecialCharTok{\textgreater{}} \DecValTok{60}\NormalTok{]}
\FunctionTok{dim}\NormalTok{(new\_x)}
\CommentTok{\#\textgreater{} [1] 1000  314}
\end{Highlighting}
\end{Shaded}

Solo se mantienen las columnas para las que la desviación estándar es superior a 60, lo que elimina más de la mitad de los predictores.

Aquí agregamos una advertencia importante relacionada con el subconjunto de matrices: si seleccionan una columna o una fila, el resultado ya no es una matriz sino un vector.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x[,}\DecValTok{1}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] "integer"}
\FunctionTok{dim}\NormalTok{(x[}\DecValTok{1}\NormalTok{,])}
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

Sin embargo, podemos preservar la clase de matriz usando el argumento \texttt{drop=FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x[ , }\DecValTok{1}\NormalTok{, }\AttributeTok{drop=}\ConstantTok{FALSE}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] "matrix" "array"}
\FunctionTok{dim}\NormalTok{(x[, }\DecValTok{1}\NormalTok{, }\AttributeTok{drop=}\ConstantTok{FALSE}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] 1000    1}
\end{Highlighting}
\end{Shaded}

\hypertarget{indexaciuxf3n-con-matrices}{%
\subsection{Indexación con matrices}\label{indexaciuxf3n-con-matrices}}

Podemos hacer rápidamente un histograma de todos los valores en nuestro set de datos. Vimos cómo podemos convertir vectores en matrices. También podemos deshacer esto y convertir matrices en vectores. La operación se realiza por fila:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\FunctionTok{as.vector}\NormalTok{(mat)}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15}
\end{Highlighting}
\end{Shaded}

Para ver un histograma de todos nuestros datos predictores, podemos usar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(}\FunctionTok{as.vector}\NormalTok{(x), }\AttributeTok{bins =} \DecValTok{30}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/histogram-all-pixels-1} \end{center}

Notamos una clara dicotomía que se explica como partes de la imagen con tinta y partes sin ella. Si creemos que los valores menor que, digamos, 50 son manchas, podemos cambiarlos a cero usando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_x }\OtherTok{\textless{}{-}}\NormalTok{ x}
\NormalTok{new\_x[new\_x }\SpecialCharTok{\textless{}} \DecValTok{50}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

Para ver un ejemplo de cómo esto ocurre, usamos una matriz más pequeña:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mat[mat }\SpecialCharTok{\textless{}} \DecValTok{3}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{mat}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3]}
\CommentTok{\#\textgreater{} [1,]    0    6   11}
\CommentTok{\#\textgreater{} [2,]    0    7   12}
\CommentTok{\#\textgreater{} [3,]    3    8   13}
\CommentTok{\#\textgreater{} [4,]    4    9   14}
\CommentTok{\#\textgreater{} [5,]    5   10   15}
\end{Highlighting}
\end{Shaded}

También podemos usar operadores lógicas con una matriz de valores logicos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{15}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mat[mat }\SpecialCharTok{\textgreater{}} \DecValTok{6} \SpecialCharTok{\&}\NormalTok{ mat }\SpecialCharTok{\textless{}} \DecValTok{12}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{mat}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3]}
\CommentTok{\#\textgreater{} [1,]    1    6    0}
\CommentTok{\#\textgreater{} [2,]    2    0   12}
\CommentTok{\#\textgreater{} [3,]    3    0   13}
\CommentTok{\#\textgreater{} [4,]    4    0   14}
\CommentTok{\#\textgreater{} [5,]    5    0   15}
\end{Highlighting}
\end{Shaded}

\hypertarget{binarizar-los-datos}{%
\subsection{Binarizar los datos}\label{binarizar-los-datos}}

El histograma anterior parece sugerir que estos datos son principalmente binarios. Un píxel tiene tinta o no. Usando lo que hemos aprendido, podemos binarizar los datos usando solo operaciones de matrices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bin\_x }\OtherTok{\textless{}{-}}\NormalTok{ x}
\NormalTok{bin\_x[bin\_x }\SpecialCharTok{\textless{}} \DecValTok{255}\SpecialCharTok{/}\DecValTok{2}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{bin\_x[bin\_x }\SpecialCharTok{\textgreater{}} \DecValTok{255}\SpecialCharTok{/}\DecValTok{2}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

También podemos convertir a una matriz de valores lógicos y luego forzar una conversión a números como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bin\_X }\OtherTok{\textless{}{-}}\NormalTok{ (x }\SpecialCharTok{\textgreater{}} \DecValTok{255}\SpecialCharTok{/}\DecValTok{2}\NormalTok{)}\SpecialCharTok{*}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\hypertarget{vectorizaciuxf3n-para-matrices}{%
\subsection{Vectorización para matrices}\label{vectorizaciuxf3n-para-matrices}}

En R, si restamos un vector de una matriz, el primer elemento del vector se resta de la primera fila, el segundo elemento de la segunda fila, y así sucesivamente. Usando notación matemática, lo escribiríamos de la siguiente manera:

\[
\begin{pmatrix}
X_{1,1}&\dots & X_{1,p} \\
X_{2,1}&\dots & X_{2,p} \\
& \vdots & \\
X_{N,1}&\dots & X_{N,p}
\end{pmatrix}
-
\begin{pmatrix}
a_1\\\
a_2\\\
\vdots\\\
a_N
\end{pmatrix}
=
\begin{pmatrix}
X_{1,1}-a_1&\dots & X_{1,p} -a_1\\
X_{2,1}-a_2&\dots & X_{2,p} -a_2\\
& \vdots & \\
X_{N,1}-a_n&\dots & X_{N,p} -a_n
\end{pmatrix}
\]

Lo mismo es válido para otras operaciones aritméticas. Esto implica que podemos escalar cada fila de una matriz así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x }\SpecialCharTok{{-}} \FunctionTok{rowMeans}\NormalTok{(x))}\SpecialCharTok{/} \FunctionTok{rowSds}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Si desean escalar cada columna, tengan cuidado ya que este enfoque no funciona para las columnas. Para realizar una operación similar, convertimos las columnas en filas usando la transposición \texttt{t}, procedemos como se indica arriba y volvemos a transponer:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(}\FunctionTok{t}\NormalTok{(X) }\SpecialCharTok{{-}} \FunctionTok{colMeans}\NormalTok{(X))}
\end{Highlighting}
\end{Shaded}

También podemos usar la función \texttt{sweep} que funciona de manera similar a \texttt{apply}. Toma cada entrada de un vector y la resta de la fila o columna correspondiente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X\_mean\_0 }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

La función \texttt{sweep} tiene otro argumento que les permite definir la operación aritmética. Entonces, para dividir por la desviación estándar, hacemos lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_mean\_0 }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(x))}
\NormalTok{x\_standardized }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x\_mean\_0, }\DecValTok{2}\NormalTok{, }\FunctionTok{colSds}\NormalTok{(x), }\AttributeTok{FUN =} \StringTok{"/"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{operaciones-de-uxe1lgebra-matricial}{%
\subsection{Operaciones de álgebra matricial}\label{operaciones-de-uxe1lgebra-matricial}}

Finalmente, aunque no discutimos las operaciones de álgebra matricial, como la multiplicación de matrices, compartimos aquí los comandos relevantes para aquellos que conocen las matemáticas y quieren aprender el código:

1. La multiplicación de matrices se realiza con \texttt{\%*\%}. Por ejemplo, el producto cruzado es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(x) }\SpecialCharTok{\%*\%}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

2. Podemos calcular el producto cruzado directamente con la función:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{crossprod}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

3. Para calcular el inverso de una función, usamos \texttt{solve}. Aquí se aplica al producto cruzado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{solve}\NormalTok{(}\FunctionTok{crossprod}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

4. La descomposición QR está fácilmente disponible mediante el uso de la función \texttt{qr}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qr}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-56}{%
\section{Ejercicios}\label{ejercicios-56}}

1. Cree una matriz de 100 por 10 de números normales generados aleatoriamente. Ponga el resultado en \texttt{x}.

2. Aplique las tres funciones de R que le dan la dimensión de \texttt{x}, el número de filas de \texttt{x} y el número de columnas de \texttt{x}, respectivamente.

3. Agregue el escalar 1 a la fila 1, el escalar 2 a la fila 2 y así sucesivamente, a la matriz \texttt{x}.

4. Agregue el escalar 1 a la columna 1, el escalar 2 a la columna 2 y así sucesivamente, a la matriz \texttt{x}. Sugerencia: use \texttt{sweep} con \texttt{FUN\ =\ "+"}.

5. Calcule el promedio de cada fila de \texttt{x}.

6. Calcule el promedio de cada columna de \texttt{x}.

7. Para cada dígito en los datos de entrenamiento MNIST, calcule la proporción de píxeles que se encuentran en un área gris, definida como valores entre 50 y 205. Haga un diagrama de caja basado en clase de dígitos. Sugerencia: utilice operadores lógicos y \texttt{rowMeans}.

\hypertarget{distancia}{%
\section{Distancia}\label{distancia}}

Muchos de los análisis que realizamos con datos de alta dimensión se relacionan directa o indirectamente con la distancia. La mayoría de las técnicas de agrupamiento y \emph{machine learning} se basan en la capacidad de definir la distancia entre observaciones, utilizando atributos (\emph{features} en inglés) o predictores.

\hypertarget{distancia-euclidiana}{%
\subsection{Distancia euclidiana}\label{distancia-euclidiana}}

Como repaso, definamos la distancia entre dos puntos, \(A\) y \(B\), en un plano cartesiano.

\begin{center}\includegraphics[width=0.35\linewidth]{libro_files/figure-latex/euclidean-distance-1} \end{center}

La distancia euclidiana entre \(A\) y \(B\) es simplemente:

\[
\mbox{dist}(A,B) = \sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}
\]

Esta definición se aplica al caso de una dimensión, en la que la distancia entre dos números es el valor absoluto de su diferencia. Entonces, si nuestros dos números unidimensionales son \(A\) y \(B\), la distancia es:

\[
\mbox{dist}(A,B) = \sqrt{ (A - B)^2 } = | A - B |
\]

\hypertarget{distancia-en-dimensiones-superiores}{%
\subsection{Distancia en dimensiones superiores}\label{distancia-en-dimensiones-superiores}}

Anteriormente presentamos un set de datos de entrenamiento con matriz para 784 atributos. Con fines ilustrativos, veremos una muestra aleatoria de 2s y 7s.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}

\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{exists}\NormalTok{(}\StringTok{"mnist"}\NormalTok{)) mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}

\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1995}\NormalTok{)}
\NormalTok{ind }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{7}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{sample}\NormalTok{(}\DecValTok{500}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images[ind,]}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels[ind]}
\end{Highlighting}
\end{Shaded}

Los predictores están en \texttt{x} y las etiquetas en \texttt{y}.

Para el propósito de, por ejemplo, suavizamiento, estamos interesados en describir la distancia entre observaciones; en este caso, dígitos. Más adelante, con el fin de seleccionar atributos, también podríamos estar interesados en encontrar píxeles que se comporten \emph{de manera similar} en todas las muestras.

Para definir la distancia, necesitamos saber qué son \emph{puntos}, ya que la distancia matemática se calcula entre puntos. Con datos de alta dimensión, los puntos ya no están en el plano cartesiano. En cambio, los puntos están en dimensiones más altas. Ya no podemos visualizarlos y necesitamos pensar de manera abstracta. Por ejemplo, predictores \(\mathbf{X}_i\) se definen como un punto en el espacio dimensional 784: \(\mathbf{X}_i = (x_{i,1},\dots,x_{i,784})^\top\).

Una vez que definamos los puntos de esta manera, la distancia euclidiana se define de manera muy similar a la de dos dimensiones. Por ejemplo, la distancia entre los predictores para dos observaciones, digamos observaciones \(i=1\) y \(i=2\), es:

\[
\mbox{dist}(1,2) = \sqrt{ \sum_{j=1}^{784} (x_{1,j}-x_{2,j })^2 }
\]

Este es solo un número no negativo, tal como lo es para dos dimensiones.

\hypertarget{ejemplo-de-distancia-euclidiana}{%
\subsection{Ejemplo de distancia euclidiana}\label{ejemplo-de-distancia-euclidiana}}

Las etiquetas para las tres primeras observaciones son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 7 2 7}
\end{Highlighting}
\end{Shaded}

Los vectores de predictores para cada una de estas observaciones son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_1 }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{1}\NormalTok{,]}
\NormalTok{x\_2 }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{2}\NormalTok{,]}
\NormalTok{x\_3 }\OtherTok{\textless{}{-}}\NormalTok{ x[}\DecValTok{3}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

El primer y tercer número son 7s y el segundo es un 2. Esperamos que las distancias entre el mismo número:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{((x\_1 }\SpecialCharTok{{-}}\NormalTok{ x\_2)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 3273}
\end{Highlighting}
\end{Shaded}

sean más pequeñas que entre diferentes números:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{((x\_1 }\SpecialCharTok{{-}}\NormalTok{ x\_3)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 2311}
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{sum}\NormalTok{((x\_2 }\SpecialCharTok{{-}}\NormalTok{ x\_3)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 2636}
\end{Highlighting}
\end{Shaded}

Como se esperaba, los 7s están más cerca uno del otro.

Una forma más rápida de calcular esto es usar álgebra matricial:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{crossprod}\NormalTok{(x\_1 }\SpecialCharTok{{-}}\NormalTok{ x\_2))}
\CommentTok{\#\textgreater{}      [,1]}
\CommentTok{\#\textgreater{} [1,] 3273}
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{crossprod}\NormalTok{(x\_1 }\SpecialCharTok{{-}}\NormalTok{ x\_3))}
\CommentTok{\#\textgreater{}      [,1]}
\CommentTok{\#\textgreater{} [1,] 2311}
\FunctionTok{sqrt}\NormalTok{(}\FunctionTok{crossprod}\NormalTok{(x\_2 }\SpecialCharTok{{-}}\NormalTok{ x\_3))}
\CommentTok{\#\textgreater{}      [,1]}
\CommentTok{\#\textgreater{} [1,] 2636}
\end{Highlighting}
\end{Shaded}

También podemos calcular \textbf{todas} las distancias a la vez de manera relativamente rápida utilizando la función \texttt{dist}, que calcula la distancia entre cada fila y produce un objeto de clase \texttt{dist}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(x)}
\FunctionTok{class}\NormalTok{(d)}
\CommentTok{\#\textgreater{} [1] "dist"}
\end{Highlighting}
\end{Shaded}

Hay varias funciones relacionadas con \emph{machine learning} en R que toman objetos de clase \texttt{dist} como entrada. Para acceder a las entradas usando índices de fila y columna, necesitamos forzar \texttt{d} a ser una matriz. Podemos ver la distancia que calculamos arriba de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.matrix}\NormalTok{(d)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}      1    2    3}
\CommentTok{\#\textgreater{} 1    0 3273 2311}
\CommentTok{\#\textgreater{} 2 3273    0 2636}
\CommentTok{\#\textgreater{} 3 2311 2636    0}
\end{Highlighting}
\end{Shaded}

Rápidamente vemos una imagen de estas distancias usando este código:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(d))}
\end{Highlighting}
\end{Shaded}

Si ordenamos esta distancia por las etiquetas, podemos ver que, en general, los 2s están más cerca uno del otro y los 7s están más cerca el uno del otro:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(d)[}\FunctionTok{order}\NormalTok{(y), }\FunctionTok{order}\NormalTok{(y)])}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/diatance-image-ordered-1} \end{center}

Algo que notamos aquí es que parece haber más uniformidad en la forma en que se dibujan los 7s, ya que parecen estar más cercas (más rojos) a otros 7s que los 2s a otros 2s.

\hypertarget{predictor-space}{%
\subsection{Espacio predictor}\label{predictor-space}}

El \emph{espacio predictor} (\emph{predictor space} en inglés) es un concepto que a menudo se usa para describir algoritmos de \emph{machine learning}. El término \emph{espacio} se refiere a una definición matemática que no describimos en detalle aquí. En cambio, ofrecemos una explicación simplificada para ayudar a entender el término espacio predictor cuando se usa en el contexto de algoritmos de \emph{machine learning}.

El espacio predictor puede considerarse como la colección de todos los posibles vectores de predictores que deben considerarse para el reto en cuestión de \emph{machine learning}. Cada miembro del espacio se conoce como un \emph{punto}. Por ejemplo, en el set de datos 2 o 7, el espacio predictor consta de todos los pares \((x_1, x_2)\) tal que ambos \(x_1\) y \(x_2\) están dentro de 0 y 1. Este espacio en particular puede representarse gráficamente como un cuadrado. En el set de datos MNIST, el espacio predictor consta de todos los vectores de 784 dimensiones, con cada elemento vectorial un número entero entre 0 y 256. Un elemento esencial de un espacio predictor es que necesitamos definir una función que nos de la distancia entre dos puntos. En la mayoría de los casos, usamos la distancia euclidiana, pero hay otras posibilidades. Un caso particular en el que no podemos simplemente usar la distancia euclidiana es cuando tenemos predictores categóricos.

Definir un espacio predictor es útil en \emph{machine learning} porque hacemos cosas como definir vecindarios de puntos, como lo requieren muchas técnicas de suavización. Por ejemplo, podemos definir un vecindario como todos los puntos que están dentro de 2 unidades de un centro predefinido. Si los puntos son bidimensionales y usamos la distancia euclidiana, este vecindario se representa gráficamente como un círculo con radio 2. En tres dimensiones, el vecindario es una esfera. Pronto aprenderemos sobre algoritmos que dividen el espacio en regiones que no se superponen y luego hacen diferentes predicciones para cada región utilizando los datos de la región.

\hypertarget{distancia-entre-predictores}{%
\subsection{Distancia entre predictores}\label{distancia-entre-predictores}}

También podemos calcular distancias entre predictores. Si \(N\) es el número de observaciones, la distancia entre dos predictores, digamos 1 y 2, es:

\[
\mbox{dist}(1,2) = \sqrt{ \sum_{i=1}^{N} (x_{i,1}-x_{i,2})^2 }
\]

Para calcular la distancia entre todos los pares de los 784 predictores, primero podemos transponer la matriz y luego usar \texttt{dist}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(}\FunctionTok{t}\NormalTok{(x))}
\FunctionTok{dim}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(d))}
\CommentTok{\#\textgreater{} [1] 784 784}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-57}{%
\section{Ejercicios}\label{ejercicios-57}}

1. Cargue el siguiente set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Este set de datos incluye una matriz \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

con la expresión génica medida en 500 genes para 189 muestras biológicas que representan siete tejidos diferentes. El tipo de tejido se almacena en \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

Calcule la distancia entre cada observación y almacénela en un objeto \texttt{d}.

2. Compare la distancia entre las dos primeras observaciones (ambos cerebelos), las observaciones 39 y 40 (ambos colones) y las observaciones 73 y 74 (ambos endometrios). Vea si las observaciones del mismo tipo de tejido están más cercanas entre sí.

3. Vemos que, de hecho, las observaciones del mismo tipo de tejido están más cercanas entre sí en los seis ejemplos de tejido que acabamos de examinar. Haga un diagrama de todas las distancias usando la función \texttt{image} para ver si este patrón es general. Sugerencia: primero convierta \texttt{d} en una matriz.

\hypertarget{reducciuxf3n-de-dimensiones}{%
\section{Reducción de dimensiones}\label{reducciuxf3n-de-dimensiones}}

Un reto típico de \emph{machine learning} incluirá una gran cantidad de predictores, lo que hace que la visualización sea algo retante. Hemos mostrado métodos para visualizar datos univariados y emparejados, pero los gráficos que revelan relaciones entre muchas variables son más complicados en dimensiones más altas. Por ejemplo, para comparar cada uno de las 784 atributos en nuestro ejemplo de predicción de dígitos, tendríamos que crear, por ejemplo, 306,936 diagramas de dispersión. La creación de un único diagrama de dispersión de los datos es imposible debido a la alta dimensionalidad.

Aquí describimos técnicas eficaces y útiles para el análisis exploratorio de datos, entre otras cosas, generalmente conocidas como \emph{reducción de dimensiones}. La idea general es reducir la dimensión del set de datos mientras se conservan características importantes, como la distancia entre atributos u observaciones. Con menos dimensiones, la visualización es más factible. La técnica detrás de todo, la descomposición de valores singulares, también es útil en otros contextos. El \emph{análisis de componentes principales} (\emph{principal component analysis} o PCA por sus siglas en inglés) es el enfoque que mostraremos. Antes de aplicar PCA a sets de datos de alta dimensión, motivaremos las ideas con un ejemplo sencillo.

\hypertarget{preservando-la-distancia}{%
\subsection{Preservando la distancia}\label{preservando-la-distancia}}

Consideremos un ejemplo con alturas de gemelos. Algunas parejas son adultas, otras son niños. Aquí simulamos 100 puntos bidimensionales que representan el número de desviaciones estándar que cada individuo tiene respecto a la altura media. Cada punto es un par de gemelos. Utilizamos la función \texttt{mvrnorm} del paquete \textbf{MASS} para simular datos de distribución normal de dos variables.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1988}\NormalTok{)}
\FunctionTok{library}\NormalTok{(MASS)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{9} \SpecialCharTok{*} \FloatTok{0.9}\NormalTok{, }\DecValTok{9} \SpecialCharTok{*} \FloatTok{0.92}\NormalTok{, }\DecValTok{9} \SpecialCharTok{*} \DecValTok{1}\NormalTok{), }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(}\FunctionTok{mvrnorm}\NormalTok{(n}\SpecialCharTok{/} \DecValTok{2}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{69}\NormalTok{, }\DecValTok{69}\NormalTok{), Sigma),}
           \FunctionTok{mvrnorm}\NormalTok{(n}\SpecialCharTok{/} \DecValTok{2}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{55}\NormalTok{, }\DecValTok{55}\NormalTok{), Sigma))}
\end{Highlighting}
\end{Shaded}

Un diagrama de dispersión revela que la correlación es alta y que hay dos grupos de gemelos, los adultos (puntos superiores derechos) y los niños (puntos inferiores izquierdos):

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/distance-illustration-1} \end{center}

Nuestros atributos son \(N\) puntos bidimensionales, las dos alturas y, con fines ilustrativos, finjiremos como si visualizar dos dimensiones es demasiado difícil. Por lo tanto, queremos reducir las dimensiones de dos a una, pero todavía poder entender atributos importantes de los datos, por ejemplo, que las observaciones se agrupan en dos grupos: adultos y niños.

Consideremos un desafío específico: queremos un resumen unidimensional de nuestros predictores a partir del cual podamos aproximar la distancia entre dos observaciones. En el gráfico anterior, mostramos la distancia entre la observación 1 y 2 (azul) y la observación 1 y 51 (rojo). Noten que la línea azul es más corta, que implica que 1 y 2 están más cerca.

Podemos calcular estas distancias usando \texttt{dist}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(x)}
\FunctionTok{as.matrix}\NormalTok{(d)[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 1.98}
\FunctionTok{as.matrix}\NormalTok{(d)[}\DecValTok{2}\NormalTok{, }\DecValTok{51}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 18.7}
\end{Highlighting}
\end{Shaded}

Esta distancia se basa en dos dimensiones y necesitamos una aproximación de distancia basada en solo una.

Comencemos con un enfoque simplista de solo eliminar una de las dos dimensiones. Comparemos las distancias reales con la distancia calculada solo con la primera dimensión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}}\NormalTok{ x[,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Aquí están las distancias aproximadas versus las distancias originales:

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/one-dim-approx-to-dist-1} \end{center}

El gráfico se ve casi igual si usamos la segunda dimensión. Obtenemos una subestimación general. Esto no sorprende porque estamos añadiendo más cantidades positivas al cálculo de la distancia a medida que aumentamos el número de dimensiones. Si, en cambio, usamos un promedio, como este:

\[\sqrt{ \frac{1}{2} \sum_{j=1}^2 (X_{1,j}-X_{2,j})^2 },\]

entonces la subestimación desaparece. Dividimos la distancia por \(\sqrt{2}\) para lograr la corrección.

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/distance-approx-1-1} \end{center}

Esto funciona bastante bien y obtenemos una diferencia típica de:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(}\FunctionTok{dist}\NormalTok{(x) }\SpecialCharTok{{-}} \FunctionTok{dist}\NormalTok{(z)}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 1.21}
\end{Highlighting}
\end{Shaded}

Ahora, ¿podemos elegir un resumen unidimensional que haga que esta aproximación sea aún mejor?

Si consideramos el diagrama de dispersión anterior y visualizamos una línea entre cualquier par de puntos, la longitud de esta línea es la distancia entre los dos puntos. Estas líneas tienden a ir a lo largo de la dirección de la diagonal. Noten que si en su lugar graficamos la diferencia versus el promedio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{((x[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ x[,}\DecValTok{1}\NormalTok{])}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, x[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{{-}}\NormalTok{ x[,}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

podemos ver cómo la distancia entre puntos se explica principalmente por la primera dimensión: el promedio.

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/rotation-1} \end{center}

Esto significa que podemos ignorar la segunda dimensión y no perder demasiada información. Si la línea es completamente plana, no perdemos ninguna información. Usando la primera dimensión de esta matriz transformada, obtenemos una aproximación aún mejor:

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/distance-approx-2-1} \end{center}

con la diferencia típica mejorada aproximadamente un 35\%:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(}\FunctionTok{dist}\NormalTok{(x) }\SpecialCharTok{{-}} \FunctionTok{dist}\NormalTok{(z[,}\DecValTok{1}\NormalTok{])}\SpecialCharTok{*}\FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 0.315}
\end{Highlighting}
\end{Shaded}

Más tarde, aprendemos que \texttt{z{[},1{]}} es el primer componente principal de la matriz \texttt{x}.

\hypertarget{transformaciones-lineales-avanzado}{%
\subsection{Transformaciones lineales (avanzado)}\label{transformaciones-lineales-avanzado}}

Tengan en cuenta que cada fila de \(X\) se transformó usando una transformación lineal. Para cualquier fila \(i\), la primera entrada fue:

\[Z_{i,1} = a_{1,1} X_{i,1} + a_{2,1} X_{i,2}\]

con \(a_{1,1} = 0.5\) y \(a_{2,1} = 0.5\).

La segunda entrada también fue una transformación lineal:

\[Z_{i,2} = a_{1,2} X_{i,1} + a_{2,2} X_{i,2}\]

con \(a_{1,2} = 1\) y \(a_{2,2} = -1\).

Además, podemos usar la transformación lineal para obtener \(X\) de \(Z\):

\[X_{i,1} = b_{1,1} Z_{i,1} + b_{2,1} Z_{i,2}\]

con \(b_{1,2} = 1\) y \(b_{2,1} = 0.5\) y

\[X_{i,2} = b_{2,1} Z_{i,1} + b_{2,2} Z_{i,2}\]

con \(b_{2,1} = 1\) y \(a_{1,2} = -0.5\).

Si saben álgebra lineal, pueden escribir la operación que acabamos de realizar de esta manera:

\[
Z = X A
\mbox{ with }
A = \,
\begin{pmatrix}
1/2&1\\
1/2&-1\\
\end{pmatrix}.
\]

Y que podemos transformar de vuelta a \(X\) multiplicando por \(A^{-1}\) así:

\[
X = Z A^{-1}
\mbox{ with }
A^{-1} = \,
\begin{pmatrix}
1&1\\
1/2&-1/2\\
\end{pmatrix}.
\]

La reducción de dimensiones frecuentemente se puede describir como la aplicación de una transformación \(A\) a una matriz \(X\) con muchas columnas que mueven la información contenida en \(X\) a las primeras columnas de \(Z=AX\), manteniendo solo estas pocas columnas informativas y reduciendo así la dimensión de los vectores contenidos en las filas.

\hypertarget{transformaciones-ortogonales-avanzado}{%
\subsection{Transformaciones ortogonales (avanzado)}\label{transformaciones-ortogonales-avanzado}}

Noten que dividimos lo anterior por \(\sqrt{2}\) para tomar en cuenta las diferencias en las dimensiones al comparar una distancia de 2 dimensiones con una distancia de 1 dimensión. De hecho, podemos garantizar que las escalas de distancia sigan siendo las mismas si volvemos a escalar las columnas de \(A\) para asegurar que la suma de cuadrados es 1:

\[a_{1,1}^2 + a_{2,1}^2 = 1\mbox{ and } a_{1,2}^2 + a_{2,2}^2=1,\]

y que la correlación de las columnas es 0:

\[
a_{1,1} a_{1,2} + a_{2,1} a_{2,2} = 0.
\]

Recuerden que si las columnas están centradas para tener un promedio de 0, entonces la suma de los cuadrados es equivalente a la varianza o desviación estándar al cuadrado.

En nuestro ejemplo, para lograr ortogonalidad, multiplicamos el primer set de coeficientes (primera columna de \(A\)) por \(\sqrt{2}\) y el segundo por \(1/\sqrt{2}\). Entonces obtenemos la misma distancia exacta cuando usamos ambas dimensiones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z[,}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ (x[,}\DecValTok{1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ x[,}\DecValTok{2}\NormalTok{])}\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{z[,}\DecValTok{2}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ (x[,}\DecValTok{2}\NormalTok{] }\SpecialCharTok{{-}}\NormalTok{ x[,}\DecValTok{1}\NormalTok{])}\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Esto nos da una transformación que preserva la distancia entre dos puntos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(}\FunctionTok{dist}\NormalTok{(z) }\SpecialCharTok{{-}} \FunctionTok{dist}\NormalTok{(x))}
\CommentTok{\#\textgreater{} [1] 3.24e{-}14}
\end{Highlighting}
\end{Shaded}

y una aproximación mejorada si usamos solo la primera dimensión:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sd}\NormalTok{(}\FunctionTok{dist}\NormalTok{(x) }\SpecialCharTok{{-}} \FunctionTok{dist}\NormalTok{(z[,}\DecValTok{1}\NormalTok{]))}
\CommentTok{\#\textgreater{} [1] 0.315}
\end{Highlighting}
\end{Shaded}

En este caso, \(Z\) se llama una rotación ortogonal de \(X\): conserva las distancias entre filas.

Tengan en cuenta que al usar la transformación anterior, podemos resumir la distancia entre cualquier par de gemelos con una sola dimensión. Por ejemplo, una exploración de datos unidimensionales de la primera dimensión de \(Z\) muestra claramente que hay dos grupos, adultos y niños:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{qplot}\NormalTok{(z[,}\DecValTok{1}\NormalTok{], }\AttributeTok{bins =} \DecValTok{20}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/twins-pc-1-hist-1} \end{center}

Redujimos exitosamente el número de dimensiones de dos a uno con muy poca pérdida de información.

La razón por la que pudimos hacer esto es porque las columnas de \(X\) estaban muy correlacionadas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(x[,}\DecValTok{1}\NormalTok{], x[,}\DecValTok{2}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] 0.988}
\end{Highlighting}
\end{Shaded}

y la transformación produjo columnas no correlacionadas con información ``independiente'' en cada columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(z[,}\DecValTok{1}\NormalTok{], z[,}\DecValTok{2}\NormalTok{])}
\CommentTok{\#\textgreater{} [1] 0.0876}
\end{Highlighting}
\end{Shaded}

Una forma en que esta información puede ser útil en una aplicación de \emph{machine learning} es que podemos reducir la complejidad de un modelo utilizando solo \(Z_1\) en lugar de ambos \(X_1\) y \(X_2\).

Es común obtener datos con varios predictores altamente correlacionados. En estos casos, PCA, que describimos a continuación, puede ser bastante útil para reducir la complejidad del modelo que se está ajustando.

\hypertarget{pca}{%
\subsection{Análisis de componentes principales}\label{pca}}

En el cálculo anterior, la variabilidad total en nuestros datos puede definirse como la suma de la suma de los cuadrados de las columnas. Suponemos que las columnas están centradas, por lo que esta suma es equivalente a la suma de las varianzas de cada columna:

\[
v_1 + v_2, \mbox{ with } v_1 = \frac{1}{N}\sum_{i=1}^N X_{i,1}^2 \mbox{ and } v_2 = \frac{1}{N}\sum_{i=1}^N X_{i,2}^2
\]

Podemos calcular \(v_1\) y \(v_2\) al utilizar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colMeans}\NormalTok{(x}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 3904 3902}
\end{Highlighting}
\end{Shaded}

y podemos mostrar matemáticamente que si aplicamos una transformación ortogonal como la anterior, la variación total sigue siendo la misma:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{colMeans}\NormalTok{(x}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 7806}
\FunctionTok{sum}\NormalTok{(}\FunctionTok{colMeans}\NormalTok{(z}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 7806}
\end{Highlighting}
\end{Shaded}

Sin embargo, mientras que la variabilidad en las dos columnas de \texttt{X} es casi la misma, en la versión transformada \(Z\), el 99\% de la variabilidad se incluye solo en la primera dimensión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{colMeans}\NormalTok{(z}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\NormalTok{v}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(v)}
\CommentTok{\#\textgreater{} [1] 1.00e+00 9.93e{-}05}
\end{Highlighting}
\end{Shaded}

El primer \emph{componente principal} (\emph{principal component} o PC por sus siglas en inglés) de una matriz \(X\) es la transformación ortogonal lineal de \(X\) que maximiza esta variabilidad. La función \texttt{prcomp} provee esta información:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pca }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(x)}
\NormalTok{pca}\SpecialCharTok{$}\NormalTok{rotation}
\CommentTok{\#\textgreater{}         PC1    PC2}
\CommentTok{\#\textgreater{} [1,] {-}0.702  0.712}
\CommentTok{\#\textgreater{} [2,] {-}0.712 {-}0.702}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que el primer PC es casi el mismo que ese proporcionado por el \((X_1 + X_2)/ \sqrt{2}\) que utilizamos anteriormente (excepto quizás por un cambio de signo que es arbitrario).

La función \texttt{prcomp} devuelve la rotación necesaria para transformar \(X\) para que la variabilidad de las columnas disminuya de más variable a menos (se accede con \texttt{\$rotation}) así como la nueva matriz resultante (que se accede con \texttt{\$x}). Por defecto, \texttt{prcomp} centra las columnas de \(X\) antes de calcular las matrices.

Entonces, usando la multiplicación de matrices que se muestra arriba, notamos que las dos siguientes operaciones dan el mismo resultado (demostrado por una diferencia entre elementos de prácticamente cero):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(x))}
\NormalTok{b }\OtherTok{\textless{}{-}}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{x }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(pca}\SpecialCharTok{$}\NormalTok{rotation)}
\FunctionTok{max}\NormalTok{(}\FunctionTok{abs}\NormalTok{(a }\SpecialCharTok{{-}}\NormalTok{ b))}
\CommentTok{\#\textgreater{} [1] 3.55e{-}15}
\end{Highlighting}
\end{Shaded}

La rotación es ortogonal, lo que significa que el inverso es su transposición. Entonces también tenemos que estos dos son idénticos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(x)) }\SpecialCharTok{\%*\%}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{rotation}
\NormalTok{b }\OtherTok{\textless{}{-}}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{x}
\FunctionTok{max}\NormalTok{(}\FunctionTok{abs}\NormalTok{(a }\SpecialCharTok{{-}}\NormalTok{ b))}
\CommentTok{\#\textgreater{} [1] 0}
\end{Highlighting}
\end{Shaded}

Podemos visualizarlos para ver cómo el primer componente resume los datos. En el gráfico a continuación, el rojo representa valores altos y el azul representa valores negativos. Más adelante, en la Sección \ref{factor-analysis}, aprendemos por qué llamamos a estos pesos (\emph{weights} en inglés) y patrones (\emph{patterns} en inglés):

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/illustrate-pca-twin-heights-1} \end{center}

Resulta que podemos encontrar esta transformación lineal no solo para dos dimensiones, sino también para matrices de cualquier dimensión \(p\).

Para una matriz multidimensional \(X\) con \(p\) columnas, se puede encontrar una transformación \(Z\) que conserva la distancia entre filas, pero con la varianza de las columnas en orden decreciente. La segunda columna es el segundo componente principal, la tercera columna es el tercer componente principal y así sucesivamente. Como en nuestro ejemplo, si después de un cierto número de columnas, digamos \(k\), las variaciones de las columnas de \(Z_j\) con \(j>k\) son muy pequeñas, significa que estas dimensiones tienen poco que contribuir a la distancia y podemos aproximar la distancia entre dos puntos con solo \(k\) dimensiones. Si \(k\) es mucho más pequeño que \(p\), entonces podemos lograr un resumen muy eficiente de nuestros datos.

\hypertarget{ejemplo-de-lirios}{%
\subsection{Ejemplo de lirios}\label{ejemplo-de-lirios}}

Los datos del lirio (\emph{iris} en inglés) son un ejemplo ampliamente utilizado en los cursos de análisis de datos. Incluye cuatro medidas botánicas relacionadas con tres especies de flores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(iris)}
\CommentTok{\#\textgreater{} [1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width" }
\CommentTok{\#\textgreater{} [5] "Species"}
\end{Highlighting}
\end{Shaded}

Si imprimen \texttt{iris\$Species}, verán que los datos están ordenados por especie.

Calculemos la distancia entre cada observación. Pueden ver claramente las tres especies con una especie muy diferente de las otras dos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ iris[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as.matrix}\NormalTok{()}
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(x)}
\FunctionTok{image}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(d), }\AttributeTok{col =} \FunctionTok{rev}\NormalTok{(RColorBrewer}\SpecialCharTok{::}\FunctionTok{brewer.pal}\NormalTok{(}\DecValTok{9}\NormalTok{, }\StringTok{"RdBu"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/iris-distances-1} \end{center}

Nuestros predictores aquí tienen cuatro dimensiones, pero tres están muy correlacionadas:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(x)}
\CommentTok{\#\textgreater{}              Sepal.Length Sepal.Width Petal.Length Petal.Width}
\CommentTok{\#\textgreater{} Sepal.Length        1.000      {-}0.118        0.872       0.818}
\CommentTok{\#\textgreater{} Sepal.Width        {-}0.118       1.000       {-}0.428      {-}0.366}
\CommentTok{\#\textgreater{} Petal.Length        0.872      {-}0.428        1.000       0.963}
\CommentTok{\#\textgreater{} Petal.Width         0.818      {-}0.366        0.963       1.000}
\end{Highlighting}
\end{Shaded}

Si aplicamos PCA, deberíamos poder aproximar esta distancia con solo dos dimensiones, comprimiendo las dimensiones altamente correlacionadas. Utilizando la función \texttt{summary}, podemos ver la variabilidad explicada por cada PC:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pca }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(x)}
\FunctionTok{summary}\NormalTok{(pca)}
\CommentTok{\#\textgreater{} Importance of components:}
\CommentTok{\#\textgreater{}                          PC1    PC2    PC3     PC4}
\CommentTok{\#\textgreater{} Standard deviation     2.056 0.4926 0.2797 0.15439}
\CommentTok{\#\textgreater{} Proportion of Variance 0.925 0.0531 0.0171 0.00521}
\CommentTok{\#\textgreater{} Cumulative Proportion  0.925 0.9777 0.9948 1.00000}
\end{Highlighting}
\end{Shaded}

Las dos primeras dimensiones representan el 97\% de la variabilidad. Por lo tanto, deberíamos poder aproximar bien la distancia con dos dimensiones. Podemos visualizar los resultados de PCA:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/illustrate-pca-twin-heights-iris-1} \end{center}

Y ver que el primer patrón es la longitud del sépalo, la longitud del pétalo y el ancho del pétalo (rojo) en una dirección y el ancho del sépalo (azul) en la otra. El segundo patrón es la longitud del sépalo y el ancho del pétalo en una dirección (azul) y la longitud y el ancho del pétalo en la otra (rojo). Pueden ver de los pesos que la primera PC1 controla la mayor parte de la variabilidad y separa claramente el primer tercio de las muestras (setosa) de los dos tercios (versicolor y virginica). Si miran la segunda columna de los pesos, observarán que separa un poco versicolor (rojo) de virginica (azul).

Podemos ver esto mejor al graficar los dos primeros PCs con color representando especie:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(pca}\SpecialCharTok{$}\NormalTok{x[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{], }\AttributeTok{Species=}\NormalTok{iris}\SpecialCharTok{$}\NormalTok{Species) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(PC1,PC2, }\AttributeTok{fill =}\NormalTok{ Species))}\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{cex=}\DecValTok{3}\NormalTok{, }\AttributeTok{pch=}\DecValTok{21}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{coord\_fixed}\NormalTok{(}\AttributeTok{ratio =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/iris-pca-1} \end{center}

Vemos que las dos primeras dimensiones preservan la distancia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_approx }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(pca}\SpecialCharTok{$}\NormalTok{x[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{])}
\FunctionTok{qplot}\NormalTok{(d, d\_approx) }\SpecialCharTok{+} \FunctionTok{geom\_abline}\NormalTok{(}\AttributeTok{color=}\StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{libro_files/figure-latex/dist-approx-4-1} \end{center}

Este ejemplo es más realista que el primer ejemplo artificial que utilizamos, ya que mostramos cómo podemos visualizar los datos usando dos dimensiones cuando los datos eran de cuatro dimensiones.

\hypertarget{ejemplo-de-mnist}{%
\subsection{Ejemplo de MNIST}\label{ejemplo-de-mnist}}

El ejemplo de dígitos escritos tiene 784 atributos. ¿Hay espacio para la reducción de datos? ¿Podemos crear algoritmos sencillos de \emph{machine learning} con menos atributos?

Carguemos los datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dslabs)}
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{exists}\NormalTok{(}\StringTok{"mnist"}\NormalTok{)) mnist }\OtherTok{\textless{}{-}} \FunctionTok{read\_mnist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Debido a que los píxeles son tan pequeños, esperamos que los píxeles cercanos entre sí en la cuadrícula estén correlacionados, lo que significa que la reducción de dimensión debería ser posible.

Probemos PCA y exploremos la variación de los PCs. Esto tomará unos segundos ya que es una matriz bastante grande.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{col\_means }\OtherTok{\textless{}{-}} \FunctionTok{colMeans}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{images)}
\NormalTok{pca }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{images)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pc }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{images)}
\FunctionTok{qplot}\NormalTok{(pc, pca}\SpecialCharTok{$}\NormalTok{sdev)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-pca-variance-explained-1} \end{center}

Podemos ver que los primeros PCs ya explican un gran porcentaje de la variabilidad:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(pca)}\SpecialCharTok{$}\NormalTok{importance[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\CommentTok{\#\textgreater{}                            PC1     PC2      PC3      PC4      PC5}
\CommentTok{\#\textgreater{} Standard deviation     576.823 493.238 459.8993 429.8562 408.5668}
\CommentTok{\#\textgreater{} Proportion of Variance   0.097   0.071   0.0617   0.0539   0.0487}
\CommentTok{\#\textgreater{} Cumulative Proportion    0.097   0.168   0.2297   0.2836   0.3323}
\end{Highlighting}
\end{Shaded}

Y con solo mirar las dos primeras PCs vemos información sobre la clase. Aquí hay una muestra aleatoria de 2,000 dígitos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{PC1 =}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{x[,}\DecValTok{1}\NormalTok{], }\AttributeTok{PC2 =}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{x[,}\DecValTok{2}\NormalTok{],}
           \AttributeTok{label=}\FunctionTok{factor}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{label)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\DecValTok{2000}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(PC1, PC2, }\AttributeTok{fill=}\NormalTok{label))}\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{cex=}\DecValTok{3}\NormalTok{, }\AttributeTok{pch=}\DecValTok{21}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-pca-1-2-scatter-1} \end{center}

También podemos ver las combinaciones lineales en la cuadrícula para tener una idea de lo que se está ponderando:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/mnist-pca-1-4-1} \end{center}

Los PCs de menor varianza parecen estar relacionadas a la variabilidad irrelevante en las esquinas:

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/mnist-pca-last,-1} \end{center}

Ahora apliquemos la transformación que aprendimos con los datos de entrenamiento a los datos de evaluación, reduzcamos la dimensión y ejecutemos \texttt{knn3} en solo un pequeño número de dimensiones.

Intentamos 36 dimensiones ya que esto explica aproximadamente el 80\% de los datos. Primero, ajuste el modelo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\NormalTok{k }\OtherTok{\textless{}{-}} \DecValTok{36}
\NormalTok{x\_train }\OtherTok{\textless{}{-}}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{x[,}\DecValTok{1}\SpecialCharTok{:}\NormalTok{k]}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{train}\SpecialCharTok{$}\NormalTok{labels)}
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{knn3}\NormalTok{(x\_train, y)}
\end{Highlighting}
\end{Shaded}

Ahora, transformen el set de evaluación:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_test }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{images, }\DecValTok{2}\NormalTok{, col\_means) }\SpecialCharTok{\%*\%}\NormalTok{ pca}\SpecialCharTok{$}\NormalTok{rotation}
\NormalTok{x\_test }\OtherTok{\textless{}{-}}\NormalTok{ x\_test[,}\DecValTok{1}\SpecialCharTok{:}\NormalTok{k]}
\end{Highlighting}
\end{Shaded}

Y estamos listos para predecir y evaluar los resultados:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_hat }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(fit, x\_test, }\AttributeTok{type =} \StringTok{"class"}\NormalTok{)}
\FunctionTok{confusionMatrix}\NormalTok{(y\_hat, }\FunctionTok{factor}\NormalTok{(mnist}\SpecialCharTok{$}\NormalTok{test}\SpecialCharTok{$}\NormalTok{labels))}\SpecialCharTok{$}\NormalTok{overall[}\StringTok{"Accuracy"}\NormalTok{]}
\CommentTok{\#\textgreater{} Accuracy }
\CommentTok{\#\textgreater{}    0.975}
\end{Highlighting}
\end{Shaded}

Con solo 36 dimensiones, obtenemos una exactitud muy superior a 0.95.

\hypertarget{ejercicios-58}{%
\section{Ejercicios}\label{ejercicios-58}}

1. Queremos explorar los predictores \texttt{tissue\_gene\_expression} graficándolos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\FunctionTok{dim}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

Procuramos tener una idea de qué observaciones están cercas entre sí, pero como los predictores son de 500 dimensiones, es difícil graficar. Grafique los dos primeros componentes principales con color representando el tipo de tejido.

2. Los predictores de cada observación se miden en el mismo dispositivo
de medición (un microarreglo de expresión génica) después de un
procedimiento experimental. Se utiliza un dispositivo y procedimiento
diferente para cada observación. Esto puede introducir sesgos que
afecten a todos los predictores de cada observación de la misma
manera. Para explorar el efecto de este posible sesgo, para cada
observación, calcule el promedio de todos los predictores y luego
grafique esto contra el primer PC con el color que representa el
tejido. Indique la correlación.

3. Vemos una asociación con el primer PC y los promedios de observación. Vuelva a hacer el PCA pero solo después de quitar el centro.

4. Para los primeros 10 PCs, haga un diagrama de caja que muestre los valores para cada tejido.

5. Grafique el porcentaje de varianza explicado por el número de PC. Sugerencia: use la función \texttt{summary}.

\hypertarget{sistemas-de-recomendaciuxf3n}{%
\section{Sistemas de recomendación}\label{sistemas-de-recomendaciuxf3n}}

Los sistemas de recomendación utilizan clasificaciones que los \emph{consumidores} le han dado a \emph{artículos} para hacer recomendaciones específicas. Las compañías que venden muchos productos a muchos clientes y permiten que estos clientes califiquen sus productos, como Amazon, pueden recopilar sets de datos masivos que se pueden utilizar para predecir qué calificación le otorgará un usuario en particular a un artículo específico. Artículos para los cuales se predice una calificación alta para un usuario particular, se recomiendan a ese usuario.

Netflix utiliza un sistema de recomendación para predecir cuántas \emph{estrellas} le dará un usuario a una película específica. Una estrella sugiere que no es una buena película, mientras que cinco estrellas sugieren que es una película excelente. Aquí, ofrecemos los conceptos básicos de cómo se hacen estas recomendaciones, motivados por algunos de los enfoques adoptados por los ganadores del \emph{Netflix challenge}.

En octubre de 2006, Netflix le dio un reto a la comunidad de ciencia de datos: mejoren nuestro algoritmo de recomendación por un 10\% y ganen un millón de dólares. En septiembre de 2009, los ganadores se anunciaron\footnote{\url{http://bits.blogs.nytimes.com/2009/09/21/netflix-awards-1-million-prize-and-starts-a-new-contest/}}. Pueden leer un buen resumen de cómo se creó el algoritmo ganador aquí: \url{http://blog.echen.me/2011/10/24/winning-the-netflix-prize-a-summary/}
y una explicación más detallada aquí:
\url{http://www.netflixprize.com/assets/GrandPrize2009_BPC_BellKor.pdf}. Ahora le mostraremos algunas de las estrategias de análisis de datos utilizadas por el equipo ganador.

\hypertarget{datos-de-movielens}{%
\subsection{Datos de Movielens}\label{datos-de-movielens}}

Los datos de Netflix no están disponibles públicamente, pero el laboratorio de investigación GroupLens\footnote{\url{https://grouplens.org/}} generó su propia base de datos con más de 20 millones de calificaciones para más de 27,000 películas por más de 138,000 usuarios. Ponemos a disposición un pequeño subconjunto de estos datos a través del paquete \textbf{dslabs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"movielens"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos ver que esta tabla está en formato \emph{tidy} con miles de filas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{movielens }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as\_tibble}\NormalTok{()}
\CommentTok{\#\textgreater{} \# A tibble: 100,004 x 7}
\CommentTok{\#\textgreater{}   movieId title              year genres         userId rating timestamp}
\CommentTok{\#\textgreater{}     \textless{}int\textgreater{} \textless{}chr\textgreater{}             \textless{}int\textgreater{} \textless{}fct\textgreater{}           \textless{}int\textgreater{}  \textless{}dbl\textgreater{}     \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1      31 Dangerous Minds    1995 Drama               1    2.5    1.26e9}
\CommentTok{\#\textgreater{} 2    1029 Dumbo              1941 Animation|Chi\textasciitilde{}      1    3      1.26e9}
\CommentTok{\#\textgreater{} 3    1061 Sleepers           1996 Thriller            1    3      1.26e9}
\CommentTok{\#\textgreater{} 4    1129 Escape from New \textasciitilde{}  1981 Action|Advent\textasciitilde{}      1    2      1.26e9}
\CommentTok{\#\textgreater{} 5    1172 Cinema Paradiso \textasciitilde{}  1989 Drama               1    4      1.26e9}
\CommentTok{\#\textgreater{} \# ... with 99,999 more rows}
\end{Highlighting}
\end{Shaded}

Cada fila representa una calificación dada por un usuario a una película.

Podemos ver la cantidad de usuarios únicos que dan calificaciones y cuántas películas únicas fueron calificadas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{n\_users =} \FunctionTok{n\_distinct}\NormalTok{(userId),}
            \AttributeTok{n\_movies =} \FunctionTok{n\_distinct}\NormalTok{(movieId))}
\CommentTok{\#\textgreater{}   n\_users n\_movies}
\CommentTok{\#\textgreater{} 1     671     9066}
\end{Highlighting}
\end{Shaded}

Si multiplicamos esos dos números, obtenemos un número mayor de 5 millones. Sin embargo, nuestra tabla de datos tiene aproximadamente 100,000 filas. Esto implica que no todos los usuarios calificaron todas las películas. Por lo tanto, podemos pensar en estos datos como una matriz muy grande, con usuarios en las filas y películas en las columnas, con muchas celdas vacías. La función \texttt{pivot\_longer} nos permite convertirla a este formato, pero si lo intentamos para toda la matriz, colgaremos a R. Mostremos la matriz para seis usuarios y cuatro películas.

\begin{table}
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{rrrrr}
\toprule
userId & Pulp Fiction & Shawshank Redemption & Forrest Gump & Silence of the Lambs\\
\midrule
13 & 3.5 & 4.5 & 5.0 & NA\\
15 & 5.0 & 2.0 & 1.0 & 5.0\\
16 & NA & 4.0 & NA & NA\\
17 & 5.0 & 5.0 & 2.5 & 4.5\\
19 & 5.0 & 4.0 & 5.0 & 3.0\\
\addlinespace
20 & 0.5 & 4.5 & 2.0 & 0.5\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

Pueden pensar en la tarea de un sistema de recomendación como completar los \texttt{NA}s en la tabla de arriba. Para ver cuán dispersa es la matriz, aquí tenemos la matriz para una muestra aleatoria de 100 películas y 100 usuarios con amarillo indicando una combinación de usuario/película para la que tenemos una calificación.

\begin{center}\includegraphics[width=0.4\linewidth]{libro_files/figure-latex/sparsity-of-movie-recs-1} \end{center}

Este reto de \emph{machine learning} es más complicado de lo que hemos estudiado hasta ahora porque cada resultado \(Y\) tiene un set diferente de predictores. Para ver esto, tengan en cuenta que si estamos prediciendo la calificación de la película \(i\) por usuario \(u\), en principio, todas las otras clasificaciones relacionadas con la película \(i\) y por el usuario \(u\) pueden usarse como predictores, pero diferentes usuarios califican diferentes películas y diferentes números de películas. Además, podemos usar información de otras películas que hemos determinado que son parecidas a la película \(i\) o de usuarios que se consideran similares al usuario \(u\). Básicamente, toda la matriz se puede utilizar como predictores para cada celda.

Veamos algunas de las propiedades generales de los datos para entender mejor los retos.

Lo primero que notamos es que algunas películas se evalúan más que otras. A continuación se muestra la distribución. Esto no debería sorprendernos dado que hay películas de gran éxito vistas por millones y películas artísticas e independientes vistas por pocos. Nuestra segunda observación es que algunos usuarios son más activos que otros en la calificación de películas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/movie-id-and-user-hists-1} \end{center}

\hypertarget{sistemas-de-recomendaciuxf3n-como-un-desafuxedo-de-machine-learning}{%
\subsection{\texorpdfstring{Sistemas de recomendación como un desafío de \emph{machine learning}}{Sistemas de recomendación como un desafío de machine learning}}\label{sistemas-de-recomendaciuxf3n-como-un-desafuxedo-de-machine-learning}}

Para ver cómo esto se puede considerar \emph{machine learning}, noten que necesitamos construir un algoritmo con los datos que hemos recopilado que luego se aplicarán fuera de nuestro control, a medida que los usuarios busquen recomendaciones de películas. Así que creamos un set de evaluación para evaluar la exactitud de los modelos que implementamos.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(caret)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{755}\NormalTok{)}
\NormalTok{test\_index }\OtherTok{\textless{}{-}} \FunctionTok{createDataPartition}\NormalTok{(}\AttributeTok{y =}\NormalTok{ movielens}\SpecialCharTok{$}\NormalTok{rating, }\AttributeTok{times =} \DecValTok{1}\NormalTok{, }\AttributeTok{p =} \FloatTok{0.2}\NormalTok{,}
                                  \AttributeTok{list =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{train\_set }\OtherTok{\textless{}{-}}\NormalTok{ movielens[}\SpecialCharTok{{-}}\NormalTok{test\_index,]}
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ movielens[test\_index,]}
\end{Highlighting}
\end{Shaded}

Para asegurarnos de que no incluimos usuarios y películas en el set de evaluación que no aparecen en el set de entrenamiento, eliminamos estas entradas usando la función \texttt{semi\_join}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_set }\OtherTok{\textless{}{-}}\NormalTok{ test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{semi\_join}\NormalTok{(train\_set, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{semi\_join}\NormalTok{(train\_set, }\AttributeTok{by =} \StringTok{"userId"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{netflix-loss-function}{%
\subsection{Función de pérdida}\label{netflix-loss-function}}

El \emph{Netflix challenge} usó la pérdida de error típica: decidieron un ganador basado en la \emph{desviación cuadrática media} (RMSE por sus siglas en inglés) en un set de evaluación. Definimos \(y_{u,i}\) como la calificación de la película \(i\) por usuario \(u\) y denotamos nuestra predicción con \(\hat{y}_{u,i}\). El RMSE se define entonces como:

\[
\mbox{RMSE} = \sqrt{\frac{1}{N} \sum_{u,i}^{} \left( \hat{y}_{u,i} - y_{u,i} \right)^2 }
\]
con \(N\) siendo el número de combinaciones de usuario/película y la suma que ocurre en todas estas combinaciones.

Recuerden que podemos interpretar el RMSE de manera similar a una desviación estándar: es el error típico que cometemos al predecir una calificación de película. Si este número es mayor que 1, significa que nuestro error típico es mayor que una estrella, lo cual no es bueno.

Escribamos una función que calcule el RMSE para vectores de clasificaciones y sus predictores correspondientes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RMSE }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(true\_ratings, predicted\_ratings)\{}
  \FunctionTok{sqrt}\NormalTok{(}\FunctionTok{mean}\NormalTok{((true\_ratings }\SpecialCharTok{{-}}\NormalTok{ predicted\_ratings)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{un-primer-modelo}{%
\subsection{Un primer modelo}\label{un-primer-modelo}}

Comencemos construyendo el sistema de recomendación más sencillo posible: predecimos la misma calificación para todas las películas, independientemente del usuario. ¿Qué número debería ser esta predicción? Podemos usar un enfoque basado en modelos para responder a esto. Un modelo que supone la misma calificación para todas las películas y usuarios con todas las diferencias explicadas por la variación aleatoria se vería así:

\[
Y_{u,i} = \mu + \varepsilon_{u,i}
\]

con \(\varepsilon_{i,u}\) errores independientes muestreados de la misma distribución centrada en 0 y \(\mu\) la calificación ``verdadera'' para todas las películas. Sabemos que el estimador que minimiza el RMSE es el estimador de mínimos cuadrados de \(\mu\) y, en este caso, es el promedio de todas las calificaciones:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu\_hat }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{rating)}
\NormalTok{mu\_hat}
\CommentTok{\#\textgreater{} [1] 3.54}
\end{Highlighting}
\end{Shaded}

Si predecimos todas las calificaciones desconocidas con \(\hat{\mu}\), obtenemos el siguiente RMSE:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{naive\_rmse }\OtherTok{\textless{}{-}} \FunctionTok{RMSE}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{rating, mu\_hat)}
\NormalTok{naive\_rmse}
\CommentTok{\#\textgreater{} [1] 1.05}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que si usan cualquier otro número, obtendrám un RMSE más alto. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predictions }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{3}\NormalTok{, }\FunctionTok{nrow}\NormalTok{(test\_set))}
\FunctionTok{RMSE}\NormalTok{(test\_set}\SpecialCharTok{$}\NormalTok{rating, predictions)}
\CommentTok{\#\textgreater{} [1] 1.19}
\end{Highlighting}
\end{Shaded}

Al observar la distribución de calificaciones, podemos visualizar que esta es la desviación estándar de esa distribución. Obtenemos un RMSE de aproximadamente 1. Para ganar el gran premio de \$1,000,000, un equipo participante tuvo que obtener un RMSE de aproximadamente 0.857. ¡Definitivamente podemos mejorar!

A medida que avanzamos, compararemos diferentes enfoques. Comencemos creando una tabla de resultados con este enfoque simplista:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rmse\_results }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}\AttributeTok{method =} \StringTok{"Just the average"}\NormalTok{, }\AttributeTok{RMSE =}\NormalTok{ naive\_rmse)}
\end{Highlighting}
\end{Shaded}

\hypertarget{modelando-los-efectos-de-peluxedculas}{%
\subsection{Modelando los efectos de películas}\label{modelando-los-efectos-de-peluxedculas}}

Sabemos por experiencia que algunas películas generalmente tienen una calificación más alta que otras. Esta intuición, que las diferentes películas se clasifican de manera diferente, la confirma los datos. Podemos expandir nuestro modelo anterior agregando el término \(b_i\) para representar la clasificación promedio de la película \(i\):

\[
Y_{u,i} = \mu + b_i + \varepsilon_{u,i}
\]

Los libros de texto de estadísticas se refieren a \(b\)s como efectos. Sin embargo, en los artículos sobre el \emph{Netflix challenge}, se refieren a ellos como ``sesgo'' (o \emph{bias} en inglés; por lo tanto, la notación \(b\)).

De nuevo podemos usar mínimos cuadrados para estimar \(b_i\) de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(rating }\SpecialCharTok{\textasciitilde{}} \FunctionTok{as.factor}\NormalTok{(movieId), }\AttributeTok{data =}\NormalTok{ movielens)}
\end{Highlighting}
\end{Shaded}

Como hay miles de \(b_i\), a medida que cada película obtiene una, la función \texttt{lm()} será muy lenta aquí. Por eso, no recomendamos ejecutar el código anterior. Pero en esta situación particular, sabemos que el estimador de los mínimos cuadrados \(\hat{b}_i\) es solo el promedio de \(Y_{u,i} - \hat{\mu}\) para cada película \(i\). Entonces podemos calcularlos de esta manera (dejaremos de usar la notación \texttt{hat} en el código para representar los estimadores en el futuro):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{rating)}
\NormalTok{movie\_avgs }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_i =} \FunctionTok{mean}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ mu))}
\end{Highlighting}
\end{Shaded}

Podemos ver que estos estimadores varían sustancialmente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(b\_i, }\AttributeTok{data =}\NormalTok{ movie\_avgs, }\AttributeTok{bins =} \DecValTok{10}\NormalTok{, }\AttributeTok{color =} \FunctionTok{I}\NormalTok{(}\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/movie-effects-1} \end{center}

Recuerden \(\hat{\mu}=3.5\), entonces una \(b_i = 1.5\) implica una calificación perfecta de cinco estrellas.

Veamos cuánto mejora nuestra predicción cuando usamos \(\hat{y}_{u,i} = \hat{\mu} + \hat{b}_i\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predicted\_ratings }\OtherTok{\textless{}{-}}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs, }\AttributeTok{by=}\StringTok{\textquotesingle{}movieId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(b\_i)}
\FunctionTok{RMSE}\NormalTok{(predicted\_ratings, test\_set}\SpecialCharTok{$}\NormalTok{rating)}
\CommentTok{\#\textgreater{} [1] 0.989}
\end{Highlighting}
\end{Shaded}

Ya observamos una mejora. ¿Pero podemos mejorar más?

\hypertarget{efectos-de-usuario}{%
\subsection{Efectos de usuario}\label{efectos-de-usuario}}

Calculemos la calificación promedio para el usuario \(u\) para aquellos que han calificado 100 o más películas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(userId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{()}\SpecialCharTok{\textgreater{}=}\DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_u =} \FunctionTok{mean}\NormalTok{(rating)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(b\_u)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{bins =} \DecValTok{30}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/user-effect-hist-1} \end{center}

Noten que también existe una variabilidad sustancial entre los usuarios: algunos usuarios son muy exigentes y otros adoran cada película. Esto implica que una mejora adicional de nuestro modelo puede ser:

\[
Y_{u,i} = \mu + b_i + b_u + \varepsilon_{u,i}
\]

dónde \(b_u\) es un efecto específico de cada usuario. Ahora, si un usuario exigente (\(b_u\) negativo) califica una película excelente (\(b_i\) positiva), los efectos se contrarrestan y podemos predecir correctamente que este usuario le dio a esta gran película un 3 en lugar de un 5.

Para ajustar este modelo, podríamos nuevamente usar \texttt{lm} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lm}\NormalTok{(rating }\SpecialCharTok{\textasciitilde{}} \FunctionTok{as.factor}\NormalTok{(movieId) }\SpecialCharTok{+} \FunctionTok{as.factor}\NormalTok{(userId))}
\end{Highlighting}
\end{Shaded}

pero, por las razones descritas anteriormente, no lo haremos. En cambio, calcularemos una aproximación calculando \(\hat{\mu}\) y \(\hat{b}_i\) y estimando \(\hat{b}_u\) como el promedio de \(y_{u,i} - \hat{\mu} - \hat{b}_i\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{user\_avgs }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs, }\AttributeTok{by=}\StringTok{\textquotesingle{}movieId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(userId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_u =} \FunctionTok{mean}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ mu }\SpecialCharTok{{-}}\NormalTok{ b\_i))}
\end{Highlighting}
\end{Shaded}

Ahora podemos construir predictores y ver cuánto mejora el RMSE:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predicted\_ratings }\OtherTok{\textless{}{-}}\NormalTok{ test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs, }\AttributeTok{by=}\StringTok{\textquotesingle{}movieId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(user\_avgs, }\AttributeTok{by=}\StringTok{\textquotesingle{}userId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ b\_i }\SpecialCharTok{+}\NormalTok{ b\_u) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(pred)}
\FunctionTok{RMSE}\NormalTok{(predicted\_ratings, test\_set}\SpecialCharTok{$}\NormalTok{rating)}
\CommentTok{\#\textgreater{} [1] 0.905}
\end{Highlighting}
\end{Shaded}

\hypertarget{ejercicios-59}{%
\section{Ejercicios}\label{ejercicios-59}}

1. Cargue los datos \texttt{movielens}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"movielens"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Calcule el número de calificaciones para cada película y luego compárelo con el año en que salió la película. Transforme los datos usando la raíz cuadrada en los recuentos.

2. Vemos que, en promedio, las películas que salieron después de 1993 obtienen más calificaciones. También vemos que con las películas más nuevas, a partir de 1993, el número de calificaciones disminuye con el año: entre más reciente sea una película, menos tiempo han tenido los usuarios para calificarla.

Entre las películas que salieron en 1993 o más tarde, ¿cuáles son las 25 películas con más calificaciones por año? Además, indique la calificación promedio.

3. De la tabla construida en el ejemplo anterior, vemos que las películas mejor calificadas tienden a tener calificaciones superiores al promedio. Esto no es sorprendente: más personas ven películas populares. Para confirmar esto, estratifique las películas posteriores a 1993 por calificaciones por año y calcule sus calificaciones promedio. Haga un gráfico de la calificación promedio versus calificaciones por año y muestre un estimador de la tendencia.

4. En el ejercicio anterior, vemos que entre más se califica una película, mayor es la calificación. Suponga que está haciendo un análisis predictivo en el que necesita completar las calificaciones faltantes con algún valor. ¿Cuál de las siguientes estrategias usaría?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Completar los valores faltantes con la calificación promedio de todas las películas.
\item
  Completar los valores faltantes con 0.
\item
  Completar el valor con un valor más bajo que el promedio ya que la falta de calificación se asocia con calificaciones más bajas. Pruebe diferentes valores y evalúe la predicción en un set de evaluación.
\item
  Ninguna de las anteriores.
\end{enumerate}

5. El set de datos \texttt{movielens} también incluye un sello de tiempo. Esta variable representa el tiempo y los datos en los que se le dio la calificación. Las unidades son segundos desde el 1 de enero de 1970. Cree una nueva columna \texttt{date} con la fecha. Sugerencia: use la función \texttt{as\_datetime} en el paquete \textbf{lubridate}.

6. Calcule la calificación promedio de cada semana y calcule este promedio para cada día. Sugerencia: use la función \texttt{round\_date} antes de \texttt{group\_by}.

7. El gráfico muestra alguna evidencia de un efecto temporero. Si definimos \(d_{u,i}\) como el día que el usuario \(u\) hizo su calificación de la película \(i\), ¿cuál de los siguientes modelos es el más apropiado?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \(Y_{u,i} = \mu + b_i + b_u + d_{u,i} + \varepsilon_{u,i}\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + d_{u,i}\beta + \varepsilon_{u,i}\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + d_{u,i}\beta_i + \varepsilon_{u,i}\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + f(d_{u,i}) + \varepsilon_{u,i}\), con \(f\) una función suave de \(d_{u,i}\).
\end{enumerate}

8. Los datos \texttt{movielens} también tienen un columna \texttt{genres}. Esta columna incluye todos los géneros que aplican a la película. Algunas películas pertenecen a varios géneros. Defina una categoría como cualquier combinación que aparezca en esta columna. Mantenga solo categorías con más de 1,000 calificaciones. Luego, calcule el promedio y error estándar para cada categoría. Grafique estos usando diagramas de barras de error.

9. El gráfico muestra evidencia convincente de un efecto de género. Si definimos \(g_{u,i}\) como el género para la calificación del usuario \(u\) de la película \(i\), ¿cuál de los siguientes modelos es el más apropiado?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  \(Y_{u,i} = \mu + b_i + b_u + d_{u,i} + \varepsilon_{u,i}\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + d_{u,i}\beta + \varepsilon_{u,i}\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + \sum_{k=1}^K x_{u,i} \beta_k + \varepsilon_{u,i}\), con \(x^k_{u,i} = 1\) si \(g_{u,i}\) es genero \(k\).
\item
  \(Y_{u,i} = \mu + b_i + b_u + f(d_{u,i}) + \varepsilon_{u,i}\), con \(f\) una función suave de \(d_{u,i}\).
\end{enumerate}

\hypertarget{regularizaciuxf3n}{%
\section{Regularización}\label{regularizaciuxf3n}}

\hypertarget{motivaciuxf3n}{%
\subsection{Motivación}\label{motivaciuxf3n}}

A pesar de la gran variación de película a película, nuestra mejora en RMSE fue solo como 5\%. Exploremos dónde cometimos errores en nuestro primer modelo, usando solo efectos de película \(b_i\). Aquí están los 10 errores más grandes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs, }\AttributeTok{by=}\StringTok{\textquotesingle{}movieId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{residual =}\NormalTok{ rating }\SpecialCharTok{{-}}\NormalTok{ (mu }\SpecialCharTok{+}\NormalTok{ b\_i)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(}\FunctionTok{abs}\NormalTok{(residual))) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(title)}
\CommentTok{\#\textgreater{}  [1] "Kingdom, The (Riget)"            "Heaven Knows, Mr. Allison"      }
\CommentTok{\#\textgreater{}  [3] "American Pimp"                   "Chinatown"                      }
\CommentTok{\#\textgreater{}  [5] "American Beauty"                 "Apocalypse Now"                 }
\CommentTok{\#\textgreater{}  [7] "Taxi Driver"                     "Wallace \& Gromit: A Close Shave"}
\CommentTok{\#\textgreater{}  [9] "Down in the Delta"               "Stalag 17"}
\end{Highlighting}
\end{Shaded}

Todas estas parecen ser películas desconocidas. Para muchas de ellas, predecimos calificaciones altas. Echemos un vistazo a las 10 peores y 10 mejores películas basadas en \(\hat{b}_i\). Primero, vamos a crear una base de datos que conecta \texttt{movieId} al título de la película:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{movie\_titles }\OtherTok{\textless{}{-}}\NormalTok{ movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(movieId, title) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{distinct}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Aquí están las 10 mejores películas según nuestro estimador:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{movie\_avgs }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(b\_i)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(title)}
\CommentTok{\#\textgreater{}  [1] "When Night Is Falling"                                  }
\CommentTok{\#\textgreater{}  [2] "Lamerica"                                               }
\CommentTok{\#\textgreater{}  [3] "Mute Witness"                                           }
\CommentTok{\#\textgreater{}  [4] "Picture Bride (Bijo photo)"                             }
\CommentTok{\#\textgreater{}  [5] "Red Firecracker, Green Firecracker (Pao Da Shuang Deng)"}
\CommentTok{\#\textgreater{}  [6] "Paris, France"                                          }
\CommentTok{\#\textgreater{}  [7] "Faces"                                                  }
\CommentTok{\#\textgreater{}  [8] "Maya Lin: A Strong Clear Vision"                        }
\CommentTok{\#\textgreater{}  [9] "Heavy"                                                  }
\CommentTok{\#\textgreater{} [10] "Gate of Heavenly Peace, The"}
\end{Highlighting}
\end{Shaded}

Y aquí están las 10 peores:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{movie\_avgs }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(b\_i) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(title)}
\CommentTok{\#\textgreater{}  [1] "Children of the Corn IV: The Gathering"           }
\CommentTok{\#\textgreater{}  [2] "Barney\textquotesingle{}s Great Adventure"                         }
\CommentTok{\#\textgreater{}  [3] "Merry War, A"                                     }
\CommentTok{\#\textgreater{}  [4] "Whiteboyz"                                        }
\CommentTok{\#\textgreater{}  [5] "Catfish in Black Bean Sauce"                      }
\CommentTok{\#\textgreater{}  [6] "Killer Shrews, The"                               }
\CommentTok{\#\textgreater{}  [7] "Horrors of Spider Island (Ein Toter Hing im Netz)"}
\CommentTok{\#\textgreater{}  [8] "Monkeybone"                                       }
\CommentTok{\#\textgreater{}  [9] "Arthur 2: On the Rocks"                           }
\CommentTok{\#\textgreater{} [10] "Red Heat"}
\end{Highlighting}
\end{Shaded}

Todas parecen ser bastante desconocidas. Veamos con qué frecuencia se califican.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{count}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(b\_i)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(n)}
\CommentTok{\#\textgreater{}  [1] 1 1 1 1 3 1 1 2 1 1}

\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{count}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_avgs) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(b\_i) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(n)}
\CommentTok{\#\textgreater{} Joining, by = "movieId"}
\CommentTok{\#\textgreater{}  [1] 1 1 1 1 1 1 1 1 1 1}
\end{Highlighting}
\end{Shaded}

Las supuestas películas ``mejores'' y ``peores'' fueron calificadas por muy pocos usuarios, en la mayoría de los casos por solo 1. Estas películas son en su mayoría desconocidas. Esto se debe a que con solo unos pocos usuarios, tenemos más incertidumbre. Por lo tanto, mayores estimadores de \(b_i\), negativo o positivo, son más probables.

Estos son estimadores ruidosos en los que no debemos confiar, especialmente cuando se trata de predicciones. Grandes errores pueden aumentar nuestro RMSE, por lo que preferimos ser conservadores cuando no estamos seguros.

En secciones anteriores, calculamos el error estándar y construimos intervalos de confianza para tomar en cuenta los diferentes niveles de incertidumbre. Sin embargo, al hacer predicciones, necesitamos un número, una predicción, no un intervalo. Para esto, presentamos el concepto de regularización.

La regularización nos permite penalizar estimadores más grandes que se forman utilizando pequeños tamaños de muestra. Tienen puntos en común con el enfoque bayesiano que redujo las predicciones descritas en la Sección \ref{bayesian-statistics}.

\hypertarget{muxednimos-cuadrados-penalizados}{%
\subsection{Mínimos cuadrados penalizados}\label{muxednimos-cuadrados-penalizados}}

La idea general detrás de la regularización es restringir la variabilidad total de los tamaños del efecto. ¿Por qué esto ayuda? Consideren un caso en el que tenemos película \(i=1\) con 100 clasificaciones de usuarios y 4 películas \(i=2,3,4,5\) con solo una calificación de usuario. Tenemos la intención de ajustar el modelo:

\[
Y_{u,i} = \mu + b_i + \varepsilon_{u,i}
\]

Supongan que sabemos que la calificación promedio es, digamos, \(\mu = 3\). Si usamos mínimos cuadrados, el estimador para el primer efecto de película \(b_1\) es el promedio de las 100 calificaciones de los usuarios, \(1/100 \sum_{i=1}^{100} (Y_{i,1} - \mu)\), que esperamos sea bastante preciso. Sin embargo, el estimador para las películas 2, 3, 4 y 5 será simplemente la desviación observada de la calificación promedio \(\hat{b}_i = Y_{u,i} - \hat{\mu}\). Pero esto es un estimador basado en un solo número, por lo cual no será preciso. Tengan en cuenta que estos estimadores hacen el error \(Y_{u,i} - \mu + \hat{b}_i\) igual a 0 para \(i=2,3,4,5\), pero este es un caso de sobreentrenamiento. De hecho, ignorando al único usuario y adivinando que las películas 2, 3, 4 y 5 son solo películas promedio (\(b_i = 0\)) podría ofrecer una mejor predicción. La idea general de la regresión penalizada es controlar la variabilidad total de los efectos de la película: \(\sum_{i=1}^5 b_i^2\). Específicamente, en lugar de minimizar la ecuación de mínimos cuadrados, minimizamos una ecuación que añade una penalización:

\[\sum_{u,i} \left(y_{u,i} - \mu - b_i\right)^2 + \lambda \sum_{i} b_i^2\]

El primer término es solo la suma de errores cuadrados y el segundo es una penalización que aumenta cuando muchos \(b_i\) son grandes. Usando cálculo, podemos mostrar que los valores de \(b_i\) que minimizan esta ecuación son:

\[
\hat{b}_i(\lambda) = \frac{1}{\lambda + n_i} \sum_{u=1}^{n_i} \left(Y_{u,i} - \hat{\mu}\right)
\]

dónde \(n_i\) es la cantidad de clasificaciones hechas para la película \(i\). Este enfoque tendrá el efecto deseado: cuando nuestro tamaño de muestra \(n_i\) es muy grande, un caso que nos dará un estimador estable, entonces la penalización \(\lambda\) es efectivamente ignorada ya que \(n_i+\lambda \approx n_i\). Sin embargo, cuando el \(n_i\) es pequeño, entonces el estimador \(\hat{b}_i(\lambda)\) se encoge hacia 0. Entre más grande \(\lambda\), más nos encogemos.

Calculemos estos estimadores regularizados de \(b_i\) utilizando \(\lambda=3\). Más adelante, veremos por qué elegimos 3.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lambda }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{rating)}
\NormalTok{movie\_reg\_avgs }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_i =} \FunctionTok{sum}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ mu)}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{n}\NormalTok{()}\SpecialCharTok{+}\NormalTok{lambda), }\AttributeTok{n\_i =} \FunctionTok{n}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

Para ver cómo se reducen los estimadores, hagamos un gráfico de los estimadores regularizados versus los estimadores de mínimos cuadrados.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{original =}\NormalTok{ movie\_avgs}\SpecialCharTok{$}\NormalTok{b\_i,}
       \AttributeTok{regularlized =}\NormalTok{ movie\_reg\_avgs}\SpecialCharTok{$}\NormalTok{b\_i,}
       \AttributeTok{n =}\NormalTok{ movie\_reg\_avgs}\SpecialCharTok{$}\NormalTok{n\_i) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(original, regularlized, }\AttributeTok{size=}\FunctionTok{sqrt}\NormalTok{(n))) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{shape=}\DecValTok{1}\NormalTok{, }\AttributeTok{alpha=}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/regularization-shrinkage-1} \end{center}

Ahora, echemos un vistazo a las 10 mejores películas según los estimadores penalizados \(\hat{b}_i(\lambda)\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_reg\_avgs, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(b\_i)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(title)}
\CommentTok{\#\textgreater{}  [1] "Paris Is Burning"          "Shawshank Redemption, The"}
\CommentTok{\#\textgreater{}  [3] "Godfather, The"            "African Queen, The"       }
\CommentTok{\#\textgreater{}  [5] "Band of Brothers"          "Paperman"                 }
\CommentTok{\#\textgreater{}  [7] "On the Waterfront"         "All About Eve"            }
\CommentTok{\#\textgreater{}  [9] "Usual Suspects, The"       "Ikiru"}
\end{Highlighting}
\end{Shaded}

¡Esto tiene mucho más sentido! Estas películas son más populares y tienen más calificaciones. Aquí están las 10 peores películas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_reg\_avgs, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_titles, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(b\_i) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(title, b\_i, n) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{slice}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(title)}
\CommentTok{\#\textgreater{}  [1] "Battlefield Earth"                      }
\CommentTok{\#\textgreater{}  [2] "Joe\textquotesingle{}s Apartment"                        }
\CommentTok{\#\textgreater{}  [3] "Super Mario Bros."                      }
\CommentTok{\#\textgreater{}  [4] "Speed 2: Cruise Control"                }
\CommentTok{\#\textgreater{}  [5] "Dungeons \& Dragons"                     }
\CommentTok{\#\textgreater{}  [6] "Batman \& Robin"                         }
\CommentTok{\#\textgreater{}  [7] "Police Academy 6: City Under Siege"     }
\CommentTok{\#\textgreater{}  [8] "Cats \& Dogs"                            }
\CommentTok{\#\textgreater{}  [9] "Disaster Movie"                         }
\CommentTok{\#\textgreater{} [10] "Mighty Morphin Power Rangers: The Movie"}
\end{Highlighting}
\end{Shaded}

¿Mejoramos nuestros resultados?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predicted\_ratings }\OtherTok{\textless{}{-}}\NormalTok{ test\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{left\_join}\NormalTok{(movie\_reg\_avgs, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ b\_i) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(pred)}
\FunctionTok{RMSE}\NormalTok{(predicted\_ratings, test\_set}\SpecialCharTok{$}\NormalTok{rating)}
\CommentTok{\#\textgreater{} [1] 0.97}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> # A tibble: 4 x 2
#>   method                          RMSE
#>   <chr>                          <dbl>
#> 1 Just the average               1.05 
#> 2 Movie Effect Model             0.989
#> 3 Movie + User Effects Model     0.905
#> 4 Regularized Movie Effect Model 0.970
\end{verbatim}

Los estimadores penalizados ofrecen una gran mejora sobre los estimadores de mínimos cuadrados.

\hypertarget{cuxf3mo-elegir-los-tuxe9rminos-de-penalizaciuxf3n}{%
\subsection{Cómo elegir los términos de penalización}\label{cuxf3mo-elegir-los-tuxe9rminos-de-penalizaciuxf3n}}

Noten que \(\lambda\) es un parámetro de ajuste. Podemos usar validación cruzada para elegirlo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lambdas }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{0.25}\NormalTok{)}

\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{rating)}
\NormalTok{just\_the\_sum }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{s =} \FunctionTok{sum}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ mu), }\AttributeTok{n\_i =} \FunctionTok{n}\NormalTok{())}

\NormalTok{rmses }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(lambdas, }\ControlFlowTok{function}\NormalTok{(l)\{}
\NormalTok{  predicted\_ratings }\OtherTok{\textless{}{-}}\NormalTok{ test\_set }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{left\_join}\NormalTok{(just\_the\_sum, }\AttributeTok{by=}\StringTok{\textquotesingle{}movieId\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{b\_i =}\NormalTok{ s}\SpecialCharTok{/}\NormalTok{(n\_i}\SpecialCharTok{+}\NormalTok{l)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ b\_i) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(pred)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{RMSE}\NormalTok{(predicted\_ratings, test\_set}\SpecialCharTok{$}\NormalTok{rating))}
\NormalTok{\})}
\FunctionTok{qplot}\NormalTok{(lambdas, rmses)}
\NormalTok{lambdas[}\FunctionTok{which.min}\NormalTok{(rmses)]}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/best-penalty-1} \end{center}

Sin embargo, si bien mostramos esto como una ilustración, en la práctica deberíamos usar validación cruzada completa solo en el set de entrenamiento, sin usar el set de evaluación hasta la evaluación final. El set de evaluación nunca debe utilizarse para el ajustamiento.

También podemos utilizar la regularización para estimar los efectos del usuario. Estamos minimizando:

\[
\sum_{u,i} \left(y_{u,i} - \mu - b_i - b_u \right)^2 +
\lambda \left(\sum_{i} b_i^2 + \sum_{u} b_u^2\right)
\]

Los estimadores que minimizan esto se pueden encontrar de manera similar a lo que hicimos anteriormente. Aquí usamos validación cruzada para elegir un \(\lambda\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lambdas }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{0.25}\NormalTok{)}

\NormalTok{rmses }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(lambdas, }\ControlFlowTok{function}\NormalTok{(l)\{}
  
\NormalTok{  mu }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(train\_set}\SpecialCharTok{$}\NormalTok{rating)}
  
\NormalTok{  b\_i }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_i =} \FunctionTok{sum}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ mu)}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{n}\NormalTok{()}\SpecialCharTok{+}\NormalTok{l))}
  
\NormalTok{  b\_u }\OtherTok{\textless{}{-}}\NormalTok{ train\_set }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{left\_join}\NormalTok{(b\_i, }\AttributeTok{by=}\StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(userId) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{b\_u =} \FunctionTok{sum}\NormalTok{(rating }\SpecialCharTok{{-}}\NormalTok{ b\_i }\SpecialCharTok{{-}}\NormalTok{ mu)}\SpecialCharTok{/}\NormalTok{(}\FunctionTok{n}\NormalTok{()}\SpecialCharTok{+}\NormalTok{l))}
  
\NormalTok{  predicted\_ratings }\OtherTok{\textless{}{-}}
\NormalTok{    test\_set }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{left\_join}\NormalTok{(b\_i, }\AttributeTok{by =} \StringTok{"movieId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{left\_join}\NormalTok{(b\_u, }\AttributeTok{by =} \StringTok{"userId"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ mu }\SpecialCharTok{+}\NormalTok{ b\_i }\SpecialCharTok{+}\NormalTok{ b\_u) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pull}\NormalTok{(pred)}
  
  \FunctionTok{return}\NormalTok{(}\FunctionTok{RMSE}\NormalTok{(predicted\_ratings, test\_set}\SpecialCharTok{$}\NormalTok{rating))}
\NormalTok{\})}

\FunctionTok{qplot}\NormalTok{(lambdas, rmses)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/best-lambdas-1} \end{center}

Para el modelo completo, el \(\lambda\) óptimo es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lambda }\OtherTok{\textless{}{-}}\NormalTok{ lambdas[}\FunctionTok{which.min}\NormalTok{(rmses)]}
\NormalTok{lambda}
\CommentTok{\#\textgreater{} [1] 3.25}
\end{Highlighting}
\end{Shaded}

\begin{table}
\centering\begingroup\fontsize{8}{10}\selectfont

\begin{tabular}{lr}
\toprule
method & RMSE\\
\midrule
Just the average & 1.053\\
Movie Effect Model & 0.989\\
Movie + User Effects Model & 0.905\\
Regularized Movie Effect Model & 0.970\\
Regularized Movie + User Effect Model & 0.881\\
\bottomrule
\end{tabular}
\endgroup{}
\end{table}

\hypertarget{ejercicios-60}{%
\section{Ejercicios}\label{ejercicios-60}}

Un experto en educación aboga por escuelas más pequeñas. El experto basa esta recomendación en el hecho de que entre las mejores escuelas, muchas son escuelas pequeñas. Simulemos un set de datos para 100 escuelas. Primero, simulemos el número de estudiantes en cada escuela.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1986}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{round}\NormalTok{(}\DecValTok{2}\SpecialCharTok{\^{}}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Ahora asignemos una calidad \emph{verdadera} para cada escuela completamente independiente del tamaño. Este es el parámetro que queremos estimar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mu }\OtherTok{\textless{}{-}} \FunctionTok{round}\NormalTok{(}\DecValTok{80} \SpecialCharTok{+} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{rt}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\FunctionTok{range}\NormalTok{(mu)}
\NormalTok{schools }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{id =} \FunctionTok{paste}\NormalTok{(}\StringTok{"PS"}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{),}
                      \AttributeTok{size =}\NormalTok{ n,}
                      \AttributeTok{quality =}\NormalTok{ mu,}
                      \AttributeTok{rank =} \FunctionTok{rank}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{mu))}
\end{Highlighting}
\end{Shaded}

Podemos ver que las 10 mejores escuelas son:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{schools }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{top\_n}\NormalTok{(}\DecValTok{10}\NormalTok{, quality) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(quality))}
\end{Highlighting}
\end{Shaded}

Ahora hagamos que los estudiantes en la escuela tomen un examen. Existe una variabilidad aleatoria en la toma de exámenes, por lo que simularemos las puntuaciones de los exámenes distribuidos normalmente con el promedio determinado por la calidad de la escuela y las desviaciones estándar de 30 puntos porcentuales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scores }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(schools), }\ControlFlowTok{function}\NormalTok{(i)\{}
\NormalTok{  scores }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(schools}\SpecialCharTok{$}\NormalTok{size[i], schools}\SpecialCharTok{$}\NormalTok{quality[i], }\DecValTok{30}\NormalTok{)}
\NormalTok{  scores}
\NormalTok{\})}
\NormalTok{schools }\OtherTok{\textless{}{-}}\NormalTok{ schools }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{score =} \FunctionTok{sapply}\NormalTok{(scores, mean))}
\end{Highlighting}
\end{Shaded}

1. ¿Cuáles son las mejores escuelas según la puntuación promedio? Muestre solo la identificación, el tamaño y la puntuación promedio.

2. Compare el tamaño medio de la escuela con el tamaño medio de las 10 mejores escuelas según la puntuación.

3. Según esta prueba, parece que las escuelas pequeñas son mejores que las grandes. Cinco de las 10 mejores escuelas tienen 100 estudiantes o menos. ¿Pero cómo puede ser ésto? Construimos la simulación para que la calidad y el tamaño sean independientes. Repita el ejercicio para las peores 10 escuelas.

4. ¡Lo mismo es cierto para las peores escuelas! También son pequeñas. Grafique la puntuación promedio versus el tamaño de la escuela para ver qué está pasando. Destaque las 10 mejores escuelas según la calidad \emph{verdadera}. Use la transformación de escala logarítmica para el tamaño.

5. Podemos ver que el error estándar de la puntuación tiene una mayor variabilidad cuando la escuela es más pequeña. Esta es una realidad estadística básica que aprendimos en las secciones de probabilidad e inferencia. De hecho, noten que 4 de las 10 mejores escuelas se encuentran en las 10 mejores escuelas según la puntuación del examen.

Usemos la regularización para elegir las mejores escuelas. Recuerde que la regularización encoge las desviaciones del promedio hacia 0. Entonces para aplicar la regularización aquí, primero debemos definir el promedio general para todas las escuelas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{overall }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(}\FunctionTok{sapply}\NormalTok{(scores, mean))}
\end{Highlighting}
\end{Shaded}

y luego definir, para cada escuela, cómo se desvía de ese promedio. Escriba un código que calcule la puntuación por encima del promedio de cada escuela pero dividiéndolo por \(n + \lambda\) en lugar de \(n\), con \(n\) el tamaño de la escuela y \(\lambda\) un parámetro de regularización. Intente con \(\lambda = 3\).

6. Noten que esto mejora un poco las cosas. El número de escuelas pequeñas que no figuran entre las mejores ahora es 4. ¿Existe un \(\lambda\) mejor? Encuentre el \(\lambda\) que minimiza el RMSE = \(1/100 \sum_{i=1}^{100} (\mbox{quality} - \mbox{estimate})^2\).

7. Clasifique las escuelas según el promedio obtenido con los mejores \(\alpha\). Tengan en cuenta que ninguna escuela pequeña se incluye incorrectamente.

8. Un error común al usar la regularización es reducir los valores hacia 0 que no están centrados alrededor de 0. Por ejemplo, si no restamos el promedio general antes de reducir, obtenemos un resultado muy similar. Confirme esto volviendo a ejecutar el código del ejercicio 6, pero sin eliminar la media general.

\hypertarget{factorizaciuxf3n-de-matrices}{%
\section{Factorización de matrices}\label{factorizaciuxf3n-de-matrices}}

La factorización de matrices es un concepto ampliamente utilizado en \emph{machine learning}. Está muy relacionado con el análisis de factores, la descomposición de valores singulares (\emph{singular value decomposition} o SVD por sus siglas en inglés) y el análisis de componentes principales (PCA). Aquí describimos el concepto en el contexto de los sistemas de recomendación de películas.

Hemos descrito cómo el modelo:

\[
Y_{u,i} = \mu + b_i + b_u + \varepsilon_{u,i}
\]

explica las diferencias de película a película a través de la \(b_i\) y las diferencias de usuario a usuario a través de la \(b_u\). Pero este modelo omite una fuente importante de variación relacionada con el hecho de que los grupos de películas tienen patrones de calificación similares y los grupos de usuarios también tienen patrones de calificación similares. Descubriremos estos patrones estudiando los residuos:

\[
r_{u,i} = y_{u,i} - \hat{b}_i - \hat{b}_u
\]

Para ver esto, convertiremos los datos en una matriz para que cada usuario obtenga una fila, cada película obtenga una columna y \(y_{u,i}\) sea la entrada en fila \(u\) y columna \(i\). Con fines ilustrativos, solo consideraremos un pequeño subconjunto de películas con muchas calificaciones y usuarios que han calificado muchas películas. También incluímos \emph{Scent of a Woman} (\texttt{movieId\ ==\ 3252}) porque la usamos para un ejemplo específico:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train\_small }\OtherTok{\textless{}{-}}\NormalTok{ movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{50} \SpecialCharTok{|}\NormalTok{ movieId }\SpecialCharTok{==} \DecValTok{3252}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(userId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{50}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{ungroup}\NormalTok{()}

\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ train\_small }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{select}\NormalTok{(userId, movieId, rating) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =} \StringTok{"movieId"}\NormalTok{, }\AttributeTok{values\_from =} \StringTok{"rating"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{as.matrix}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Agregamos nombres de fila y columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rownames}\NormalTok{(y)}\OtherTok{\textless{}{-}}\NormalTok{ y[,}\DecValTok{1}\NormalTok{]}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ y[,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]}

\NormalTok{movie\_titles }\OtherTok{\textless{}{-}}\NormalTok{ movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(movieId, title) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{distinct}\NormalTok{()}

\FunctionTok{colnames}\NormalTok{(y) }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(movie\_titles, title[}\FunctionTok{match}\NormalTok{(}\FunctionTok{colnames}\NormalTok{(y), movieId)])}
\end{Highlighting}
\end{Shaded}

y los convertimos en residuos eliminando los efectos de columna y fila:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(y, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(y, }\AttributeTok{na.rm=}\ConstantTok{TRUE}\NormalTok{))}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(y, }\DecValTok{1}\NormalTok{, }\FunctionTok{rowMeans}\NormalTok{(y, }\AttributeTok{na.rm=}\ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Si el modelo anterior explica todas las señales, y los \(\varepsilon\) son solo ruido, entonces los residuos para diferentes películas deben ser independientes entre sí. Pero no lo son. Aquí hay unos ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_1 }\OtherTok{\textless{}{-}} \StringTok{"Godfather, The"}
\NormalTok{m\_2 }\OtherTok{\textless{}{-}} \StringTok{"Godfather: Part II, The"}
\NormalTok{p1 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(y[ ,m\_1], y[,m\_2], }\AttributeTok{xlab =}\NormalTok{ m\_1, }\AttributeTok{ylab =}\NormalTok{ m\_2)}

\NormalTok{m\_1 }\OtherTok{\textless{}{-}} \StringTok{"Godfather, The"}
\NormalTok{m\_3 }\OtherTok{\textless{}{-}} \StringTok{"Goodfellas"}
\NormalTok{p2 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(y[ ,m\_1], y[,m\_3], }\AttributeTok{xlab =}\NormalTok{ m\_1, }\AttributeTok{ylab =}\NormalTok{ m\_3)}

\NormalTok{m\_4 }\OtherTok{\textless{}{-}} \StringTok{"You\textquotesingle{}ve Got Mail"}
\NormalTok{m\_5 }\OtherTok{\textless{}{-}} \StringTok{"Sleepless in Seattle"}
\NormalTok{p3 }\OtherTok{\textless{}{-}} \FunctionTok{qplot}\NormalTok{(y[ ,m\_4], y[,m\_5], }\AttributeTok{xlab =}\NormalTok{ m\_4, }\AttributeTok{ylab =}\NormalTok{ m\_5)}

\NormalTok{gridExtra}\SpecialCharTok{::}\FunctionTok{grid.arrange}\NormalTok{(p1, p2 ,p3, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/movie-cor-1} \end{center}

Estos gráficos muestran que a los usuarios que les gustó \emph{The Godfather} más de lo que el modelo espera de ellos, según la película y los efectos del usuario, también les gustó \emph{The Godfather II} más de lo esperado. Se observa una relación similar al comparar \emph{The Godfather} y \emph{Goodfellas}. Aunque no es tan fuerte, todavía hay correlación. También vemos correlaciones entre \emph{You've Got Mail} y \emph{Sleepless in Seattle}.

Al observar la correlación entre películas, podemos ver un patrón (cambiamos los nombres de las columnas para ahorrar espacio de impresión):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ y[, }\FunctionTok{c}\NormalTok{(m\_1, m\_2, m\_3, m\_4, m\_5)]}
\NormalTok{short\_names }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Godfather"}\NormalTok{, }\StringTok{"Godfather2"}\NormalTok{, }\StringTok{"Goodfellas"}\NormalTok{,}
                 \StringTok{"You\textquotesingle{}ve Got"}\NormalTok{, }\StringTok{"Sleepless"}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}}\NormalTok{ short\_names}
\FunctionTok{cor}\NormalTok{(x, }\AttributeTok{use=}\StringTok{"pairwise.complete"}\NormalTok{)}
\CommentTok{\#\textgreater{}            Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless}
\CommentTok{\#\textgreater{} Godfather      1.000      0.829      0.444     {-}0.440    {-}0.378}
\CommentTok{\#\textgreater{} Godfather2     0.829      1.000      0.521     {-}0.331    {-}0.358}
\CommentTok{\#\textgreater{} Goodfellas     0.444      0.521      1.000     {-}0.481    {-}0.402}
\CommentTok{\#\textgreater{} You\textquotesingle{}ve Got    {-}0.440     {-}0.331     {-}0.481      1.000     0.533}
\CommentTok{\#\textgreater{} Sleepless     {-}0.378     {-}0.358     {-}0.402      0.533     1.000}
\end{Highlighting}
\end{Shaded}

Parece que hay personas a las que les gustan las comedias románticas más de lo esperado, mientras que hay otras personas a las que les gustan las películas de gángsters más de lo esperado.

Estos resultados nos dicen que hay estructura en los datos. Pero, ¿cómo podemos modelar esto?

\hypertarget{factor-analysis}{%
\subsection{Análisis de factores}\label{factor-analysis}}

Aquí hay una ilustración, usando una simulación, de cómo podemos usar un poco de estructura para predecir el \(r_{u,i}\). Supongan que nuestros residuos \texttt{r} se ven así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(r, }\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{}    Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless}
\CommentTok{\#\textgreater{} 1        2.0        2.3        2.2       {-}1.8      {-}1.9}
\CommentTok{\#\textgreater{} 2        2.0        1.7        2.0       {-}1.9      {-}1.7}
\CommentTok{\#\textgreater{} 3        1.9        2.4        2.1       {-}2.3      {-}2.0}
\CommentTok{\#\textgreater{} 4       {-}0.3        0.3        0.3       {-}0.4      {-}0.3}
\CommentTok{\#\textgreater{} 5       {-}0.3       {-}0.4        0.3        0.2       0.3}
\CommentTok{\#\textgreater{} 6       {-}0.1        0.1        0.2       {-}0.3       0.2}
\CommentTok{\#\textgreater{} 7       {-}0.1        0.0       {-}0.2       {-}0.2       0.3}
\CommentTok{\#\textgreater{} 8        0.2        0.2        0.1        0.0       0.4}
\CommentTok{\#\textgreater{} 9       {-}1.7       {-}2.1       {-}1.8        2.0       2.4}
\CommentTok{\#\textgreater{} 10      {-}2.3       {-}1.8       {-}1.7        1.8       1.7}
\CommentTok{\#\textgreater{} 11      {-}1.7       {-}2.0       {-}2.1        1.9       2.3}
\CommentTok{\#\textgreater{} 12      {-}1.8       {-}1.7       {-}2.1        2.3       2.0}
\end{Highlighting}
\end{Shaded}

Parece que hay un patrón aquí. De hecho, podemos ver patrones de correlación muy fuertes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cor}\NormalTok{(r)}
\CommentTok{\#\textgreater{}            Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless}
\CommentTok{\#\textgreater{} Godfather      1.000      0.980      0.978     {-}0.974    {-}0.966}
\CommentTok{\#\textgreater{} Godfather2     0.980      1.000      0.983     {-}0.987    {-}0.992}
\CommentTok{\#\textgreater{} Goodfellas     0.978      0.983      1.000     {-}0.986    {-}0.989}
\CommentTok{\#\textgreater{} You\textquotesingle{}ve Got    {-}0.974     {-}0.987     {-}0.986      1.000     0.986}
\CommentTok{\#\textgreater{} Sleepless     {-}0.966     {-}0.992     {-}0.989      0.986     1.000}
\end{Highlighting}
\end{Shaded}

Podemos crear vectores \texttt{q} y \texttt{p}, que pueden explicar gran parte de la estructura que vemos. Los \texttt{q} se verían así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(q)}
\CommentTok{\#\textgreater{}      Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless}
\CommentTok{\#\textgreater{} [1,]         1          1          1         {-}1        {-}1}
\end{Highlighting}
\end{Shaded}

y reduce las películas a dos grupos: gángster (codificado con 1) y romance (codificado con -1). También podemos reducir los usuarios a tres grupos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(p)}
\CommentTok{\#\textgreater{}      1 2 3 4 5 6 7 8  9 10 11 12}
\CommentTok{\#\textgreater{} [1,] 2 2 2 0 0 0 0 0 {-}2 {-}2 {-}2 {-}2}
\end{Highlighting}
\end{Shaded}

los que les gustan las películas de gángsters y no les gustan las películas románticas (codificadas como 2), los que les gustan las películas románticas y no les gustan las películas de gángsters (codificadas como -2), y los que no les importa (codificadas como 0). El punto principal aquí es que casi podemos reconstruir \(r\), que tiene 60 valores, con un par de vectores que totalizan 17 valores. Noten que \texttt{p} y \texttt{q} son equivalentes a los patrones y pesos que describimos en la Sección \ref{pca}.

Si \(r\) contiene los residuos para usuarios \(u=1,\dots,12\) para peliculas \(i=1,\dots,5\), podemos escribir la siguiente fórmula matemática para nuestros residuos \(r_{u,i}\).

\[
r_{u,i} \approx p_u q_i
\]
Esto implica que podemos explicar más variabilidad modificando nuestro modelo anterior para recomendaciones de películas a:

\[
Y_{u,i} = \mu + b_i + b_u + p_u q_i + \varepsilon_{u,i}
\]

Sin embargo, motivamos la necesidad del término \(p_u q_i\) con una simulación sencilla. La estructura que se encuentra en los datos suele ser más compleja. Por ejemplo, en esta primera simulación supusimos que solo había un factor \(p_u\) que determinaba a cuál de las dos películas de géneros \(u\) pertenece. Pero la estructura en nuestros datos de películas parece ser mucho más complicada que las películas de gángsters versus las románticas. Podemos tener muchos otros factores. Aquí presentamos una simulación un poco más compleja. Ahora agregamos una sexta película.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(r, }\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{}    Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless Scent}
\CommentTok{\#\textgreater{} 1        0.5        0.6        1.6       {-}0.5      {-}0.5  {-}1.6}
\CommentTok{\#\textgreater{} 2        1.5        1.4        0.5       {-}1.5      {-}1.4  {-}0.4}
\CommentTok{\#\textgreater{} 3        1.5        1.6        0.5       {-}1.6      {-}1.5  {-}0.5}
\CommentTok{\#\textgreater{} 4       {-}0.1        0.1        0.1       {-}0.1      {-}0.1   0.1}
\CommentTok{\#\textgreater{} 5       {-}0.1       {-}0.1        0.1        0.0       0.1  {-}0.1}
\CommentTok{\#\textgreater{} 6        0.5        0.5       {-}0.4       {-}0.6      {-}0.5   0.5}
\CommentTok{\#\textgreater{} 7        0.5        0.5       {-}0.5       {-}0.6      {-}0.4   0.4}
\CommentTok{\#\textgreater{} 8        0.5        0.6       {-}0.5       {-}0.5      {-}0.4   0.4}
\CommentTok{\#\textgreater{} 9       {-}0.9       {-}1.0       {-}0.9        1.0       1.1   0.9}
\CommentTok{\#\textgreater{} 10      {-}1.6       {-}1.4       {-}0.4        1.5       1.4   0.5}
\CommentTok{\#\textgreater{} 11      {-}1.4       {-}1.5       {-}0.5        1.5       1.6   0.6}
\CommentTok{\#\textgreater{} 12      {-}1.4       {-}1.4       {-}0.5        1.6       1.5   0.6}
\end{Highlighting}
\end{Shaded}

Al explorar la estructura de correlación de este nuevo set de datos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colnames}\NormalTok{(r)[}\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"YGM"}\NormalTok{, }\StringTok{"SS"}\NormalTok{, }\StringTok{"SW"}\NormalTok{)}
\FunctionTok{cor}\NormalTok{(r)}
\CommentTok{\#\textgreater{}            Godfather Godfather2 Goodfellas    YGM     SS     SW}
\CommentTok{\#\textgreater{} Godfather      1.000      0.997      0.562 {-}0.997 {-}0.996 {-}0.571}
\CommentTok{\#\textgreater{} Godfather2     0.997      1.000      0.577 {-}0.998 {-}0.999 {-}0.583}
\CommentTok{\#\textgreater{} Goodfellas     0.562      0.577      1.000 {-}0.552 {-}0.583 {-}0.994}
\CommentTok{\#\textgreater{} YGM           {-}0.997     {-}0.998     {-}0.552  1.000  0.998  0.558}
\CommentTok{\#\textgreater{} SS            {-}0.996     {-}0.999     {-}0.583  0.998  1.000  0.588}
\CommentTok{\#\textgreater{} SW            {-}0.571     {-}0.583     {-}0.994  0.558  0.588  1.000}
\end{Highlighting}
\end{Shaded}

notamos que quizás necesitamos un segundo factor para tomar en cuenta el hecho de que a algunos usuarios les gusta Al Pacino, mientras que a otros no les gusta o no les importa. Observen que la estructura general de la correlación obtenida de los datos simulados no está tan lejos de la correlación real:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{six\_movies }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(m\_1, m\_2, m\_3, m\_4, m\_5, m\_6)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ y[, six\_movies]}
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}} \FunctionTok{colnames}\NormalTok{(r)}
\FunctionTok{cor}\NormalTok{(x, }\AttributeTok{use=}\StringTok{"pairwise.complete"}\NormalTok{)}
\CommentTok{\#\textgreater{}            Godfather Godfather2 Goodfellas    YGM     SS      SW}
\CommentTok{\#\textgreater{} Godfather     1.0000      0.829      0.444 {-}0.440 {-}0.378  0.0589}
\CommentTok{\#\textgreater{} Godfather2    0.8285      1.000      0.521 {-}0.331 {-}0.358  0.1186}
\CommentTok{\#\textgreater{} Goodfellas    0.4441      0.521      1.000 {-}0.481 {-}0.402 {-}0.1230}
\CommentTok{\#\textgreater{} YGM          {-}0.4397     {-}0.331     {-}0.481  1.000  0.533 {-}0.1699}
\CommentTok{\#\textgreater{} SS           {-}0.3781     {-}0.358     {-}0.402  0.533  1.000 {-}0.1822}
\CommentTok{\#\textgreater{} SW            0.0589      0.119     {-}0.123 {-}0.170 {-}0.182  1.0000}
\end{Highlighting}
\end{Shaded}

Para explicar esta estructura más complicada, necesitamos dos factores. Por ejemplo, algo como lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(q)}
\CommentTok{\#\textgreater{}      Godfather Godfather2 Goodfellas You\textquotesingle{}ve Got Sleepless Scent}
\CommentTok{\#\textgreater{} [1,]         1          1          1         {-}1        {-}1    {-}1}
\CommentTok{\#\textgreater{} [2,]         1          1         {-}1         {-}1        {-}1     1}
\end{Highlighting}
\end{Shaded}

con el primer factor (la primera fila) utilizado para codificar las películas de gángster versus las películas románticas y un segundo factor (la segunda fila) para explicar los grupos de películas con Al Pacino versus los grupos sin Al Pacino. También necesitaremos dos sets de coeficientes para explicar la variabilidad introducida por los tipos de grupos \(3\times 3\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(p)}
\CommentTok{\#\textgreater{}         1   2   3 4 5   6   7   8  9   10   11   12}
\CommentTok{\#\textgreater{} [1,]  1.0 1.0 1.0 0 0 0.0 0.0 0.0 {-}1 {-}1.0 {-}1.0 {-}1.0}
\CommentTok{\#\textgreater{} [2,] {-}0.5 0.5 0.5 0 0 0.5 0.5 0.5  0 {-}0.5 {-}0.5 {-}0.5}
\end{Highlighting}
\end{Shaded}

El modelo con dos factores tiene 36 parámetros que se pueden usar para explicar gran parte de la variabilidad en las 72 clasificaciones:

\[
Y_{u,i} = \mu + b_i + b_u + p_{u,1} q_{1,i} + p_{u,2} q_{2,i} + \varepsilon_{u,i}
\]

Tengan en cuenta que en una aplicación de datos real, necesitamos ajustar este modelo a los datos. Para explicar la correlación compleja que observamos en datos reales, generalmente permitimos que las entradas de \(p\) y \(q\) sean valores continuos, en lugar de discretos como las que usamos en la simulación. Por ejemplo, en lugar de dividir las películas en gángster o romance, definimos un continuo. Además, recuerden que este no es un modelo lineal y para ajustarlo necesitamos usar un algoritmo diferente a ese usado por \texttt{lm} para encontrar los parámetros que minimizan los mínimos cuadrados. Los algoritmos ganadores del \emph{Netflix challenge} ajustaron un modelo similar al anterior y utilizaron la regularización para penalizar por grandes valores de \(p\) y \(q\), en lugar de usar mínimos cuadrados. Implementar este enfoque está más allá del alcance de este libro.

\hypertarget{conexiuxf3n-a-svd-y-pca}{%
\subsection{Conexión a SVD y PCA}\label{conexiuxf3n-a-svd-y-pca}}

La descomposición:

\[
r_{u,i} \approx p_{u,1} q_{1,i} + p_{u,2} q_{2,i}
\]

está muy relacionada a SVD y PCA. SVD y PCA son conceptos complicados, pero una forma de entenderlos es que SVD es un algoritmo que encuentra los vectores \(p\) y \(q\) que nos permiten reescribir la matriz \(\mbox{r}\) con \(m\) filas y \(n\) columnas como:

\[
r_{u,i} = p_{u,1} q_{1,i} + p_{u,2} q_{2,i} + \dots + p_{u,n} q_{n,i}
\]

con la variabilidad de cada término disminuyendo y con las \(p\)s no correlacionadas. El algoritmo también calcula esta variabilidad para que podamos saber cuánta de la variabilidad total de las matrices se explica a medida que vayamos agregando nuevos términos. Esto nos deja ver que, con solo unos pocos términos, podemos explicar la mayor parte de la variabilidad.

Veamos un ejemplo con los datos de la película. Para calcular la descomposición, haremos que los residuos con NAs sean iguales a 0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[}\FunctionTok{is.na}\NormalTok{(y)] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{pca }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

Los vectores \(q\) se denominan componentes principales y se almacenan en esta matriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(pca}\SpecialCharTok{$}\NormalTok{rotation)}
\CommentTok{\#\textgreater{} [1] 454 292}
\end{Highlighting}
\end{Shaded}

Mientras que la \(p\), o los efectos del usuario, están aquí:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(pca}\SpecialCharTok{$}\NormalTok{x)}
\CommentTok{\#\textgreater{} [1] 292 292}
\end{Highlighting}
\end{Shaded}

Podemos ver la variabilidad de cada uno de los vectores:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{qplot}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(x), pca}\SpecialCharTok{$}\NormalTok{sdev, }\AttributeTok{xlab =} \StringTok{"PC"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/pca-sds-1} \end{center}

También notamos que los dos primeros componentes principales están relacionados a la estructura en las opiniones sobre películas:

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/movies-pca-1} \end{center}

Con solo mirar los 10 primeros en cada dirección, vemos un patrón significativo. El primer PC muestra la diferencia entre las películas aclamadas por la crítica en un lado:

\begin{verbatim}
#>  [1] "Pulp Fiction"              "Seven (a.k.a. Se7en)"     
#>  [3] "Fargo"                     "2001: A Space Odyssey"    
#>  [5] "Silence of the Lambs, The" "Clockwork Orange, A"      
#>  [7] "Taxi Driver"               "Being John Malkovich"     
#>  [9] "Royal Tenenbaums, The"     "Shining, The"
\end{verbatim}

y los éxitos de taquilla de Hollywood en otro:

\begin{verbatim}
#>  [1] "Independence Day (a.k.a. ID4)"  "Shrek"                         
#>  [3] "Spider-Man"                     "Titanic"                       
#>  [5] "Twister"                        "Armageddon"                    
#>  [7] "Harry Potter and the Sorcer..." "Forrest Gump"                  
#>  [9] "Lord of the Rings: The Retu..." "Enemy of the State"
\end{verbatim}

Mientras que el segundo PC parece ir de películas artísticas e independientes:

\begin{verbatim}
#>  [1] "Shawshank Redemption, The"      "Truman Show, The"              
#>  [3] "Little Miss Sunshine"           "Slumdog Millionaire"           
#>  [5] "Amelie (Fabuleux destin d'A..." "Kill Bill: Vol. 1"             
#>  [7] "American Beauty"                "City of God (Cidade de Deus)"  
#>  [9] "Mars Attacks!"                  "Beautiful Mind, A"
\end{verbatim}

hacia favoritas de los \emph{nerds}:

\begin{verbatim}
#>  [1] "Lord of the Rings: The Two ..." "Lord of the Rings: The Fell..."
#>  [3] "Lord of the Rings: The Retu..." "Matrix, The"                   
#>  [5] "Star Wars: Episode IV - A N..." "Star Wars: Episode VI - Ret..."
#>  [7] "Star Wars: Episode V - The ..." "Spider-Man 2"                  
#>  [9] "Dark Knight, The"               "Speed"
\end{verbatim}

Ajustar un modelo que incorpora estos estimadores es complicado. Para aquellos interesados en implementar un enfoque que incorpore estas ideas, recomendamos el paquete \textbf{recommenderlab}. Los detalles están más allá del alcance de este libro.

\hypertarget{ejercicios-61}{%
\section{Ejercicios}\label{ejercicios-61}}

En este set de ejercicios, trataremos un tema útil para comprender la factorización de matrices: la \emph{descomposición de valores singulares} (\emph{singular value decomposition} o SVD por sus siglas en inglés). SVD es un resultado matemático que se usa ampliamente en \emph{machine learning}, tanto en la práctica como para comprender las propiedades matemáticas de algunos algoritmos. Este es un tema bastante avanzado y para completar este set de ejercicios tendrán que estar familiarizados con conceptos de álgebra lineal, como la multiplicación de matrices, las matrices ortogonales y las matrices diagonales.

El SVD nos dice que podemos \emph{descomponer} un \(N\times p\) matriz \(Y\) con \(p < N\) como:

\[ Y = U D V^{\top} \]

con \(U\) y \(V\) \emph{ortogonal} de dimensiones \(N\times p\) y \(p\times p\), respectivamente, y \(D\) un \(p \times p\) matriz \emph{diagonal} con los valores de la diagonal decreciendo:

\[d_{1,1} \geq d_{2,2} \geq \dots d_{p,p}.\]

En este ejercicio, veremos una de las formas en que esta descomposición puede ser útil. Para hacer esto, construiremos un set de datos que representa las calificaciones de 100 estudiantes en 24 materias diferentes. El promedio general se ha eliminado, por lo que estos datos representan el punto porcentual que cada estudiante recibió por encima o por debajo de la puntuación promedio de la prueba. Entonces un 0 representa una calificación promedio (C), un 25 es una calificación alta (A +) y un -25 representa una calificación baja (F). Puede simular los datos de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1987}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{k }\OtherTok{\textless{}{-}} \DecValTok{8}
\NormalTok{Sigma }\OtherTok{\textless{}{-}} \DecValTok{64} \SpecialCharTok{*} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, .}\DecValTok{75}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{75}\NormalTok{, }\DecValTok{1}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{5}\NormalTok{, .}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{m }\OtherTok{\textless{}{-}}\NormalTok{ MASS}\SpecialCharTok{::}\FunctionTok{mvrnorm}\NormalTok{(n, }\FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{), Sigma)}
\NormalTok{m }\OtherTok{\textless{}{-}}\NormalTok{ m[}\FunctionTok{order}\NormalTok{(}\FunctionTok{rowMeans}\NormalTok{(m), }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{),]}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ m }\SpecialCharTok{\%x\%} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, k), }\AttributeTok{nrow =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(n }\SpecialCharTok{*}\NormalTok{ k }\SpecialCharTok{*} \DecValTok{3}\NormalTok{)), n, k }\SpecialCharTok{*} \DecValTok{3}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(y) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{paste}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{"Math"}\NormalTok{,k), }\DecValTok{1}\SpecialCharTok{:}\NormalTok{k, }\AttributeTok{sep=}\StringTok{"\_"}\NormalTok{),}
                 \FunctionTok{paste}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{"Science"}\NormalTok{,k), }\DecValTok{1}\SpecialCharTok{:}\NormalTok{k, }\AttributeTok{sep=}\StringTok{"\_"}\NormalTok{),}
                 \FunctionTok{paste}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{"Arts"}\NormalTok{,k), }\DecValTok{1}\SpecialCharTok{:}\NormalTok{k, }\AttributeTok{sep=}\StringTok{"\_"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Nuestro objetivo es describir el desempeño de los estudiantes de la manera más sucinta posible. Por ejemplo, queremos saber si los resultados de estas pruebas son solo números independientes aleatorios. ¿Todos los estudiantes son igual de buenos? ¿Ser bueno en un tema implica ser bueno en otro? ¿Cómo ayuda el SVD con todo esto? Iremos paso a paso para mostrar que con solo tres pares relativamente pequeños de vectores podemos explicar gran parte de la variabilidad en este \(100 \times 24\) set de datos.

Puede visualizar las 24 puntuaciones de las pruebas para los 100 estudiantes al graficar una imagen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_image }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{zlim =} \FunctionTok{range}\NormalTok{(x), ...)\{}
\NormalTok{  colors }\OtherTok{=} \FunctionTok{rev}\NormalTok{(RColorBrewer}\SpecialCharTok{::}\FunctionTok{brewer.pal}\NormalTok{(}\DecValTok{9}\NormalTok{, }\StringTok{"RdBu"}\NormalTok{))}
\NormalTok{  cols }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(x)}
\NormalTok{  rows }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(x)}
  \FunctionTok{image}\NormalTok{(cols, rows, }\FunctionTok{t}\NormalTok{(x[}\FunctionTok{rev}\NormalTok{(rows),,}\AttributeTok{drop=}\ConstantTok{FALSE}\NormalTok{]), }\AttributeTok{xaxt =} \StringTok{"n"}\NormalTok{, }\AttributeTok{yaxt =} \StringTok{"n"}\NormalTok{,}
        \AttributeTok{xlab=}\StringTok{""}\NormalTok{, }\AttributeTok{ylab=}\StringTok{""}\NormalTok{, }\AttributeTok{col =}\NormalTok{ colors, }\AttributeTok{zlim =}\NormalTok{ zlim, ...)}
  \FunctionTok{abline}\NormalTok{(}\AttributeTok{h=}\NormalTok{rows }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{, }\AttributeTok{v =}\NormalTok{ cols }\SpecialCharTok{+} \FloatTok{0.5}\NormalTok{)}
  \FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{1}\NormalTok{, cols, }\FunctionTok{colnames}\NormalTok{(x), }\AttributeTok{las =} \DecValTok{2}\NormalTok{)}
\NormalTok{\}}

\FunctionTok{my\_image}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

1. ¿Cómo describiría los datos basados en esta figura?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Las puntuaciones de las pruebas son independientes entre sí.
\item
  Los estudiantes que evalúan bien están en la parte superior de la imagen y parece que hay tres agrupaciones por materia.
\item
  Los estudiantes que son buenos en matemáticas no son buenos en ciencias.
\item
  Los estudiantes que son buenos en matemáticas no son buenos en humanidades.
\end{enumerate}

2. Puede examinar la correlación entre las puntuaciones de la prueba directamente de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{my\_image}\NormalTok{(}\FunctionTok{cor}\NormalTok{(y), }\AttributeTok{zlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{range}\NormalTok{(}\FunctionTok{cor}\NormalTok{(y))}
\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{2}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(y), }\FunctionTok{rev}\NormalTok{(}\FunctionTok{colnames}\NormalTok{(y)), }\AttributeTok{las =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

¿Cuál de las siguientes opciones describe mejor lo que ve?

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Las puntuaciones de las pruebas son independientes.
\item
  Las matemáticas y las ciencias están altamente correlacionadas, pero las humanidades no.
\item
  Existe una alta correlación entre las pruebas en la misma materia pero no hay correlación entre las materias.
\item
  Hay una correlación entre todas las pruebas, pero es mayor si las pruebas son de ciencias y matemáticas e incluso mayor dentro de cada materia.
\end{enumerate}

3. Recuerde que la ortogonalidad significa que \(U^{\top}U\) y \(V^{\top}V\) son iguales a la matriz de identidad. Esto implica que también podemos reescribir la descomposición como:

\[ Y V = U D \mbox{ or } U^{\top}Y = D V^{\top}\]

Podemos pensar en \(YV\) y \(U^{\top}V\) como dos transformaciones de Y que preservan la variabilidad total de \(Y\) ya que \(U\) y \(V\) son ortogonales.

Use la función \texttt{svd} para calcular el SVD de \texttt{y}. Esta función devolverá \(U\), \(V\) y las entradas diagonales de \(D\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OtherTok{\textless{}{-}} \FunctionTok{svd}\NormalTok{(y)}
\FunctionTok{names}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

Puede verificar que el SVD funciona al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_svd }\OtherTok{\textless{}{-}}\NormalTok{ s}\SpecialCharTok{$}\NormalTok{u }\SpecialCharTok{\%*\%} \FunctionTok{diag}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d) }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{v)}
\FunctionTok{max}\NormalTok{(}\FunctionTok{abs}\NormalTok{(y }\SpecialCharTok{{-}}\NormalTok{ y\_svd))}
\end{Highlighting}
\end{Shaded}

Calcule la suma de cuadrados de las columnas de \(Y\) y guárdelas en \texttt{ss\_y}. Luego calcule la suma de cuadrados de columnas del transformado \(YV\) y guárdelas en \texttt{ss\_yv}. Confirme que \texttt{sum(ss\_y)} es igual a \texttt{sum(ss\_yv)}.

4. Vemos que se conserva la suma total de cuadrados. Esto es porque \(V\) es ortogonal. Ahora para comenzar a entender cómo \(YV\) es útil, grafique \texttt{ss\_y} contra el número de columna y luego haga lo mismo para \texttt{ss\_yv}. ¿Qué observa?

5. Vemos que la variabilidad de las columnas de \(YV\) está disminuyendo. Además, vemos que, en relación con los tres primeros, la variabilidad de las columnas más allá del tercero es casi 0. Ahora observe que no tuvimos que calcular \texttt{ss\_yv} porque ya tenemos la respuesta ¿Cómo? Recuerde que \(YV = UD\) y como \(U\) es ortogonal, sabemos que la suma de cuadrados de las columnas de \(UD\) son las entradas diagonales de \(D\) al cuadrado. Confirme esto graficando la raíz cuadrada de \texttt{ss\_yv} versus las entradas diagonales de \(D\).

6. De lo anterior, sabemos que la suma de cuadrados de las columnas de \(Y\) (la suma total de cuadrados) se añade a la suma de \texttt{s\$d\^{}2} y que la transformación \(YV\) nos da columnas con sumas de cuadrados iguales a \texttt{s\$d\^{}2}. Ahora calcule qué porcentaje de la variabilidad total se explica solo por las tres primeras columnas de \(YV\).

7. Vemos que casi el 99\% de la variabilidad se explica por las primeras tres columnas de \(YV = UD\). Entonces esto implica que deberíamos poder explicar gran parte de la variabilidad y estructura que encontramos al explorar los datos con unas pocas columnas. Antes de continuar, vamos a mostrar un truco computacional útil para evitar crear la matriz \texttt{diag(s\$d)}. Para motivar esto, notamos que si escribimos \(U\) en sus columnas \([U_1, U_2,\dots, U_p]\), entonces \(UD\) es igual a:

\[UD = [U_1 d_{1,1}, U_2 d_{2,2}, \dots, U_p d_{p,p}]\]

Utilice la función \texttt{sweep} para calcular \(UD\) sin construir \texttt{diag(s\$d)} y sin usar multiplicación de matrices.

8. Sabemos que \(U_1 d_{1,1}\), la primera columna de \(UD\), tiene la mayor variabilidad de todas las columnas de \(UD\). Anteriormente vimos una imagen de \(Y\):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{my\_image}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

en la que podemos ver que la variabilidad de estudiante a estudiante es bastante grande y que parece que los estudiantes que son buenos en una materia son buenos en todas. Esto implica que el promedio (en todas las materias) de cada alumno debe explicar en gran medida la variabilidad. Calcule la puntuación promedio de cada estudiante y grafíquelo contra \(U_1 d_{1,1}\). Describa lo que encuentra.

9. Notamos que los signos en SVD son arbitrarios porque:

\[ U D V^{\top} = (-U) D (-V)^{\top} \]

Con esto en mente, vemos que la primera columna de \(UD\) es casi idéntica a la puntuación promedio de cada estudiante, excepto por el signo.

Esto implica que multiplicar \(Y\) por la primera columna de \(V\) debe realizar una operación similar a tomar el promedio. Haga un gráfico de imagen de \(V\) y describa la primera columna en relación con las otras y cómo se relaciona esto con tomar un promedio.

10. Ya vimos que podemos reescribir \(UD\) como:

\[U_1 d_{1,1} + U_2 d_{2,2} + \dots + U_p d_{p,p}\]

con \(U_j\) la columna j de \(U\). Esto implica que podemos reescribir todo el SVD como:

\[Y = U_1 d_{1,1} V_1 ^{\top} + U_2 d_{2,2} V_2 ^{\top} + \dots + U_p d_{p,p} V_p ^{\top}\]

con \(V_j\) la columna j de \(V\). Grafique \(U_1\), luego grafique \(V_1^{\top}\) usando el mismo rango para los límites del eje y, entonces haga una imagen de \(U_1 d_{1,1} V_1 ^{\top}\) y compárela con la imagen de \(Y\). Sugerencia: use la función \texttt{my\_image} definida anteriormente y el argumento \texttt{drop=FALSE} para asegurar que los subconjuntos de matrices son matrices.

11. Vemos que con solo un vector de longitud 100, un escalar y un vector de longitud 24, nos acercamos a reconstruir la matriz \(100 \times 24\) original. Esta es nuestra primera factorización de matrices:

\[ Y \approx d_{1,1} U_1 V_1^{\top}\]

Sabemos que explica \texttt{s\ \$d{[}1{]}\^{}2/sum(s\$\ d\^{}2)\ *\ 100} por ciento de la variabilidad total. Nuestra aproximación solo explica la observación de que los buenos estudiantes tienden a ser buenos en todas las materias. Pero otro aspecto de los datos originales que nuestra aproximación no explica es la mayor similitud que observamos dentro de las materias. Podemos ver esto calculando la diferencia entre nuestra aproximación y los datos originales y luego calculando las correlaciones. Pueden ver esto ejecutando este código:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resid }\OtherTok{\textless{}{-}}\NormalTok{ y }\SpecialCharTok{{-}} \FunctionTok{with}\NormalTok{(s,(u[,}\DecValTok{1}\NormalTok{, }\AttributeTok{drop=}\ConstantTok{FALSE}\NormalTok{]}\SpecialCharTok{*}\NormalTok{d[}\DecValTok{1}\NormalTok{]) }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(v[,}\DecValTok{1}\NormalTok{, }\AttributeTok{drop=}\ConstantTok{FALSE}\NormalTok{]))}
\FunctionTok{my\_image}\NormalTok{(}\FunctionTok{cor}\NormalTok{(resid), }\AttributeTok{zlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{2}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(y), }\FunctionTok{rev}\NormalTok{(}\FunctionTok{colnames}\NormalTok{(y)), }\AttributeTok{las =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ahora que hemos eliminado el efecto general del estudiante, el gráfico de correlación revela que todavía no hemos explicado la correlación interna de la materia ni el hecho de que las puntuaciones en matemáticas y ciencias son más parecidas entre sí que a las puntuaciones en las artes. Así que exploremos la segunda columna del SVD. Repita el ejercicio anterior pero para la segunda columna: grafique \(U_2\), entonces grafique \(V_2^{\top}\) usando el mismo rango para los límites del eje y, finalmente haga una imagen de \(U_2 d_{2,2} V_2 ^{\top}\) y compárela con la imagen de \texttt{resid}.

12. La segunda columna se relaciona claramente con la diferencia de habilidad del estudiante en matemáticas/ciencias versus las artes. Podemos ver esto más claramente en el gráfico de \texttt{s\$v{[},2{]}}. Sumar las matrices resultantes usando estas dos columnas ayudará con nuestra aproximación:

\[ Y \approx d_{1,1} U_1 V_1^{\top} + d_{2,2} U_2 V_2^{\top} \]

Sabemos que explicará:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{) }\SpecialCharTok{*} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

porcentaje de la variabilidad total. Podemos calcular nuevos residuos así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resid }\OtherTok{\textless{}{-}}\NormalTok{ y }\SpecialCharTok{{-}} \FunctionTok{with}\NormalTok{(s,}\FunctionTok{sweep}\NormalTok{(u[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{], }\DecValTok{2}\NormalTok{, d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{], }\AttributeTok{FUN=}\StringTok{"*"}\NormalTok{) }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(v[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]))}
\FunctionTok{my\_image}\NormalTok{(}\FunctionTok{cor}\NormalTok{(resid), }\AttributeTok{zlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{2}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(y), }\FunctionTok{rev}\NormalTok{(}\FunctionTok{colnames}\NormalTok{(y)), }\AttributeTok{las =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y ver que la estructura que queda es impulsada por las diferencias entre matemáticas y ciencias. Confirme esto graficando \(U_3\), luego grafique \(V_3^{\top}\) usando el mismo rango para los límites del eje y, luego haga una imagen de \(U_3 d_{3,3} V_3 ^{\top}\) y compárela con la imagen de \texttt{resid}.

13. La tercera columna se relaciona claramente con la diferencia de habilidad del estudiante en matemáticas y ciencias. Podemos ver esto más claramente en el gráfico de \texttt{s\$v{[},3{]}}. Agregar la matriz que obtenemos con estas dos columnas ayudará con nuestra aproximación:

\[ Y \approx d_{1,1} U_1 V_1^{\top} + d_{2,2} U_2 V_2^{\top} + d_{3,3} U_3 V_3^{\top}\]

Sabemos que explicará:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(s}\SpecialCharTok{$}\NormalTok{d}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{) }\SpecialCharTok{*} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

porcentaje de la variabilidad total. Podemos calcular nuevos residuos como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resid }\OtherTok{\textless{}{-}}\NormalTok{ y }\SpecialCharTok{{-}} \FunctionTok{with}\NormalTok{(s,}\FunctionTok{sweep}\NormalTok{(u[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{], }\DecValTok{2}\NormalTok{, d[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{], }\AttributeTok{FUN=}\StringTok{"*"}\NormalTok{) }\SpecialCharTok{\%*\%} \FunctionTok{t}\NormalTok{(v[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]))}
\FunctionTok{my\_image}\NormalTok{(}\FunctionTok{cor}\NormalTok{(resid), }\AttributeTok{zlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{2}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(y), }\FunctionTok{rev}\NormalTok{(}\FunctionTok{colnames}\NormalTok{(y)), }\AttributeTok{las =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ya no vemos estructura en los residuos: parecen ser independientes entre sí. Esto implica que podemos describir los datos con el siguiente modelo:

\[ Y = d_{1,1} U_1 V_1^{\top} + d_{2,2} U_2 V_2^{\top} + d_{3,3} U_3 V_3^{\top} + \varepsilon\]

con \(\varepsilon\) una matriz de errores independientes idénticamente distribuidos. Este modelo es útil porque resumimos \(100 \times 24\) observaciones con \(3 \times (100+24+1) = 375\) números. Además, los tres componentes del modelo tienen interpretaciones útiles: 1) la capacidad general de un estudiante, 2) la diferencia en la habilidad entre las matemáticas/ciencias y las artes, y 3) las diferencias restantes entre las tres materias. Los tamaños \(d_{1,1}, d_{2,2}\) y \(d_{3,3}\) nos dicen la variabilidad explicada por cada componente. Finalmente, tengan en cuenta que los componentes \(d_{j,j} U_j V_j^{\top}\) son equivalentes al componente principal j.

Termine el ejercicio graficando una imagen de \(Y\), una imagen de \(d_{1,1} U_1 V_1^{\top} + d_{2,2} U_2 V_2^{\top} + d_{3,3} U_3 V_3^{\top}\) y una imagen de los residuos, todos con el mismo \texttt{zlim}.

14. \textbf{Avanzado}: El set de datos \texttt{movielens} incluido en el paquete \textbf{dslabs} es un pequeño subconjunto de un set de datos más grande con millones de clasificaciones. Puede encontrar el set de datos más reciente aquí: \url{https://grouplens.org/datasets/movielens/20m/}. Cree su propio sistema de recomendaciones utilizando todas las herramientas que le hemos mostrado.

\hypertarget{clustering}{%
\chapter{Agrupación}\label{clustering}}

Los algoritmos que hemos descrito hasta ahora son ejemplos de un enfoque general denominado \emph{machine learning supervisado}. El nombre proviene del hecho de que usamos los resultados en un set de entrenamiento para supervisar la creación de nuestro algoritmo de predicción. Hay otro subconjunto de \emph{machine learning} denominado \emph{no supervisado}. En este subconjunto, no necesariamente conocemos los resultados y, en cambio, estamos interesados en descubrir grupos. Estos algoritmos también se denominan algoritmos de \emph{agrupamiento} (\emph{clustering} en inglés) ya que los predictores se utilizan para definir \emph{grupos} (\emph{clusters} en inglés).

En los dos ejemplos que hemos utilizado en esta parte del libro, la agrupación no sería muy útil. En el primer ejemplo, si simplemente se nos dan las alturas, no podremos descubrir dos grupos, hombres y mujeres, porque la intersección es grande. En el segundo ejemplo, al graficar los predictores, podemos ver que descubrir los dos dígitos, 2 y 7, será retante:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(dslabs)}
\FunctionTok{data}\NormalTok{(}\StringTok{"mnist\_27"}\NormalTok{)}
\NormalTok{mnist\_27}\SpecialCharTok{$}\NormalTok{train }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{qplot}\NormalTok{(x\_1, x\_2, }\AttributeTok{data =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{libro_files/figure-latex/mnist-27-unsupervised-1} \end{center}

Sin embargo, hay aplicaciones en las que el aprendizaje no supervisado puede ser una técnica poderosa, en particular como una herramienta exploratoria.

Un primer paso en cualquier algoritmo de agrupamiento es definir una distancia entre observaciones o grupos de observaciones. Luego, decidimos cómo unir las observaciones en grupos. Hay muchos algoritmos para hacer esto. Aquí presentamos dos como ejemplos: jerárquico y \emph{k-means}.

Construiremos un ejemplo sencillo basado en clasificaciones de películas. Aquí construimos rápidamente una matriz \texttt{x} que tiene calificaciones para las 50 películas con más calificaciones.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"movielens"}\NormalTok{)}
\NormalTok{top }\OtherTok{\textless{}{-}}\NormalTok{ movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(movieId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{n=}\FunctionTok{n}\NormalTok{(), }\AttributeTok{title =} \FunctionTok{first}\NormalTok{(title)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{top\_n}\NormalTok{(}\DecValTok{50}\NormalTok{, n) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pull}\NormalTok{(movieId)}

\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ movielens }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(movieId }\SpecialCharTok{\%in\%}\NormalTok{ top) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(userId) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\FunctionTok{n}\NormalTok{() }\SpecialCharTok{\textgreater{}=} \DecValTok{25}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(title, userId, rating) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{spread}\NormalTok{(userId, rating)}

\NormalTok{row\_names }\OtherTok{\textless{}{-}} \FunctionTok{str\_remove}\NormalTok{(x}\SpecialCharTok{$}\NormalTok{title, }\StringTok{": Episode"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{str\_trunc}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x[,}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{as.matrix}\NormalTok{()}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(x, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{))}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\FunctionTok{rowMeans}\NormalTok{(x, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{))}
\FunctionTok{rownames}\NormalTok{(x) }\OtherTok{\textless{}{-}}\NormalTok{ row\_names}
\end{Highlighting}
\end{Shaded}

Queremos utilizar estos datos para averiguar si hay grupos de películas basados en las calificaciones de 139 calificadores de películas. Un primer paso es encontrar la distancia entre cada par de películas usando la función \texttt{dist}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\hypertarget{agrupaciuxf3n-jeruxe1rquica}{%
\section{Agrupación jerárquica}\label{agrupaciuxf3n-jeruxe1rquica}}

Con la distancia calculada entre cada par de películas, necesitamos un algoritmo para definir grupos a partir de estas. La agrupación jerárquica comienza definiendo cada observación como un grupo separado. Entonces, los dos grupos más cercanos se unen en un grupo de forma iterativa hasta que solo haya un grupo que incluye todas las observaciones. La función \texttt{hclust} implementa este algoritmo y toma una distancia como entrada.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h }\OtherTok{\textless{}{-}} \FunctionTok{hclust}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

Podemos ver los grupos resultantes usando un \emph{dendrograma}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(h, }\AttributeTok{cex =} \FloatTok{0.65}\NormalTok{, }\AttributeTok{main =} \StringTok{""}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/dendrogram-1} \end{center}

Para interpretar este gráfico, primero, determinamos la distancia entre dos películas encontrando la primera posición, de arriba a abajo, donde las películas se dividen en dos grupos diferentes. La altura de esta ubicación es la distancia entre estos dos grupos. Entonces, la distancia entre las películas de \emph{Star Wars} es de 8 o menos, mientras que la distancia entre \emph{Raiders of the Lost of Ark} y \emph{Silence of the Lambs} es de aproximadamente 17.

Para generar grupos reales, podemos hacer una de dos cosas: 1) decidir la distancia mínima necesaria para que las observaciones estén en el mismo grupo o 2) decidir la cantidad de grupos que desean y luego encontrar la distancia mínima que lo logra. La función \texttt{cutree} se puede aplicar al resultado de \texttt{hclust} para realizar cualquiera de estas dos operaciones y generar grupos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{groups }\OtherTok{\textless{}{-}} \FunctionTok{cutree}\NormalTok{(h, }\AttributeTok{k =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Noten que la agrupación provee algunas ideas sobre los tipos de películas. El grupo 4 parece ser éxitos de taquilla:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(groups)[groups}\SpecialCharTok{==}\DecValTok{4}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "Apollo 13"            "Braveheart"           "Dances with Wolves"  }
\CommentTok{\#\textgreater{} [4] "Forrest Gump"         "Good Will Hunting"    "Saving Private Ryan" }
\CommentTok{\#\textgreater{} [7] "Schindler\textquotesingle{}s List"     "Shawshank Redempt..."}
\end{Highlighting}
\end{Shaded}

Y el grupo 9 parece ser películas \emph{nerd}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(groups)[groups}\SpecialCharTok{==}\DecValTok{9}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "Lord of the Rings..." "Lord of the Rings..." "Lord of the Rings..."}
\CommentTok{\#\textgreater{} [4] "Star Wars IV {-} A ..." "Star Wars V {-} The..." "Star Wars VI {-} Re..."}
\end{Highlighting}
\end{Shaded}

Podemos cambiar el tamaño del grupo haciendo \texttt{k} más grande o \texttt{h} más pequeño. También podemos explorar los datos para ver si hay grupos de evaluadores de películas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h\_2 }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(}\FunctionTok{t}\NormalTok{(x)) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{hclust}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{k-means}{%
\section{k-means}\label{k-means}}

Para usar el algoritmo de agrupamiento \emph{k-means}, tenemos que predefinir \(k\), el número de grupos que queremos definir. El algoritmo \emph{k-means} es iterativo. El primer paso es definir \(k\) centros. Luego, cada observación se asigna al grupo con el centro más cercano a esa observación. En un segundo paso, los centros se redefinen utilizando la observación en cada grupo: los medios de columna se utilizan para definir un \emph{centroide}. Repetimos estos dos pasos hasta que los centros converjan.

La función \texttt{kmeans} incluida en base R no funciona con NAs. Con fines ilustrativos, reemplazaremos las NAs con 0s. En general, la decisión de cómo completar los datos que faltan, o si uno debería hacerlo, debe hacerse con cuidado.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_0 }\OtherTok{\textless{}{-}}\NormalTok{ x}
\NormalTok{x\_0[}\FunctionTok{is.na}\NormalTok{(x\_0)] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{k }\OtherTok{\textless{}{-}} \FunctionTok{kmeans}\NormalTok{(x\_0, }\AttributeTok{centers =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Las asignaciones de grupos están en el componente \texttt{cluster}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{groups }\OtherTok{\textless{}{-}}\NormalTok{ k}\SpecialCharTok{$}\NormalTok{cluster}
\end{Highlighting}
\end{Shaded}

Recuerden que debido a que el primer centro se elige al azar, los grupos finales son aleatorios. Imponemos cierta estabilidad al repetir la función entera varias veces y tomar el promedio de los resultados. El número de valores iniciales aleatorios para utilizar se puede asignar a través del argumento \texttt{nstart}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k }\OtherTok{\textless{}{-}} \FunctionTok{kmeans}\NormalTok{(x\_0, }\AttributeTok{centers =} \DecValTok{10}\NormalTok{, }\AttributeTok{nstart =} \DecValTok{25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{mapas-de-calor}{%
\section{Mapas de calor}\label{mapas-de-calor}}

Una poderosa herramienta de visualización para descubrir grupos o patrones en sus datos es el \emph{mapa de calor} (\emph{heatmap} en inglés). La idea es sencilla: graficar una imagen de su matriz de datos con colores utilizados como señal visual y con tanto las columnas como las filas ordenadas según los resultados de un algoritmo de agrupamiento. Demostraremos esto con el set de datos \texttt{tissue\_gene\_expression}. Escalaremos las filas de la matriz de expresión génica.

El primer paso es calcular:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"tissue\_gene\_expression"}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x, }\DecValTok{2}\NormalTok{, }\FunctionTok{colMeans}\NormalTok{(tissue\_gene\_expression}\SpecialCharTok{$}\NormalTok{x))}
\NormalTok{h\_1 }\OtherTok{\textless{}{-}} \FunctionTok{hclust}\NormalTok{(}\FunctionTok{dist}\NormalTok{(x))}
\NormalTok{h\_2 }\OtherTok{\textless{}{-}} \FunctionTok{hclust}\NormalTok{(}\FunctionTok{dist}\NormalTok{(}\FunctionTok{t}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

Ahora podemos usar los resultados de esta agrupación para ordenar las filas y columnas.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(x[h\_1}\SpecialCharTok{$}\NormalTok{order, h\_2}\SpecialCharTok{$}\NormalTok{order])}
\end{Highlighting}
\end{Shaded}

Pero hay una función, \texttt{heatmap}, que lo hace por nosotros:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{heatmap}\NormalTok{(x, }\AttributeTok{col =}\NormalTok{ RColorBrewer}\SpecialCharTok{::}\FunctionTok{brewer.pal}\NormalTok{(}\DecValTok{11}\NormalTok{, }\StringTok{"Spectral"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

No mostramos los resultados de la función \texttt{heatmap} porque hay demasiados atributos para que el gráfico sea útil. Por lo tanto, filtramos algunas columnas y rehacemos los gráficos.

\hypertarget{filtrando-atributos}{%
\section{Filtrando atributos}\label{filtrando-atributos}}

Si la información sobre los grupos se incluye en unos pocos atributos, incluir todos los atributos puede agregar suficiente ruido como para que detectar grupos sea retante. Un enfoque sencillo para tratar de eliminar atributos sin información es incluir solo aquellos con alta varianza. En el ejemplo de la película, un usuario con baja variación en sus calificaciones no es realmente informativo: todas las películas le parecen iguales. Aquí hay un ejemplo de cómo podemos incluir solo los atributos con alta varianza.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(matrixStats)}
\NormalTok{sds }\OtherTok{\textless{}{-}} \FunctionTok{colSds}\NormalTok{(x, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{o }\OtherTok{\textless{}{-}} \FunctionTok{order}\NormalTok{(sds, }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{25}\NormalTok{]}
\FunctionTok{heatmap}\NormalTok{(x[,o], }\AttributeTok{col =}\NormalTok{ RColorBrewer}\SpecialCharTok{::}\FunctionTok{brewer.pal}\NormalTok{(}\DecValTok{11}\NormalTok{, }\StringTok{"Spectral"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1\linewidth]{libro_files/figure-latex/heatmap-3-1} \end{center}

\hypertarget{ejercicios-62}{%
\section{Ejercicios}\label{ejercicios-62}}

1. Cargue el set de datos \texttt{tissue\_gene\_expression}. Reste las medias de cada fila y calcule la distancia entre cada observación. Guarde el resultado en \texttt{d}.

2. Haga un gráfico de agrupamiento jerárquico y agregue los tipos de tejido como etiquetas.

3. Ejecute una agrupación \emph{k-means} en los datos con \(K=7\). Haga una tabla que compara los grupos identificados con los tipos de tejidos correctos. Ejecute el algoritmo varias veces para ver cómo cambia la respuesta.

4. Seleccione los 50 genes más variables. Asegúrese de que las observaciones aparezcan en las columnas y que los predictores estén centrados. Agregue una barra de colores para mostrar los diferentes tipos de tejidos. Sugerencia: use el argumento \texttt{ColSideColors} para asignar colores. Además, use \texttt{col\ =\ RColorBrewer::brewer.pal(11,\ "RdBu")} para un mejor uso de los colores.

\hypertarget{part-herramientas-de-productividad}{%
\part{Herramientas de productividad}\label{part-herramientas-de-productividad}}

\hypertarget{introducciuxf3n-a-las-herramientas-de-productividad}{%
\chapter{Introducción a las herramientas de productividad}\label{introducciuxf3n-a-las-herramientas-de-productividad}}

En términos generales, no recomendamos utilizar enfoques de apuntar y hacer clic para el análisis de datos. En cambio, recomendamos lenguajes de script, como R, ya que son más flexibles y facilitan enormemente la reproducibilidad. Del mismo modo, recomendamos no utilizar enfoques de apuntar y hacer clic para organizar archivos y preparar documentos. En este capítulo, demostraremos enfoques alternativos. Específicamente, aprenderemos a usar herramientas disponibles de forma gratuita que, aunque al principio parezcan complicadas y no intuitivas, eventualmente los convertirán en científicos de datos mucho más eficientes y productivos.

Tres principios generales que motivan lo que aprendemos aquí son: 1) ser sistemáticos al organizar sus sistemas de archivos, 2) automatizar cuando posible y 3) minimizar el uso del mouse. A medida que se vuelvan más competentes en la codificación, encontrarán que: 1) querrán minimizar el tiempo que pasan recordando lo que nombraron un archivo o dónde lo colocaron, 2) si se encuentran repitiendo la misma tarea una y otra vez, probablemente hay una forma de automatizar y 3) cada vez que sus dedos abandonan el teclado, pierden productividad.

Un proyecto de análisis de datos no siempre es un set de datos y un \emph{script}. Un desafío típico de análisis de datos puede involucrar varias partes, cada una con varios archivos de datos, incluyendo los archivos que contienen los \emph{scripts} que usamos para analizar los datos. Mantener todo esto organizado puede ser retante. Aprenderemos a usar el \emph{Unix shell} como herramienta para administrar archivos y directorios en sus sistemas informáticos. El uso de Unix les permitirá usar el teclado, en lugar del mouse, al crear carpetas (\emph{folders} en inglés), moverse de un directorio a otro, además de mover, eliminar o cambiar el nombre de archivos. También ofrecemos sugerencias específicas sobre cómo mantener el sistema de archivos organizado.

El proceso de análisis de datos también es iterativo y adaptativo. Como resultado, estamos constantemente editando nuestros \emph{scripts} e informes. En este capítulo, les presentamos el sistema de control de versiones \emph{Git}, que es una herramienta poderosa para darle seguimiento a estos cambios. También les presentamos GitHub\footnote{\url{http://github.com}}, un servicio que les permite alojar y compartir su código. Les demostraremos cómo pueden utilizar este servicio para facilitar las colaboraciones. Recuerden que otro beneficio positivo de usar GitHub es que pueden mostrar fácilmente su trabajo a posibles empleadores.

Finalmente, aprendemos a escribir informes en R Markdown, lo que les permite incorporar texto y código en un solo documento. Vamos a demostrar cómo, utilizando el paquete \texttt{knitr}, podemos escribir informes reproducibles y estéticamente agradables ejecutando el análisis y generando el informe simultáneamente.

Arreglaremos todo esto utilizando el entorno de escritorio integrado RStudio\footnote{\url{https://www.rstudio.com/}}. A lo largo del capítulo vamos a construir un ejemplo usando los asesinatos con armas de fuego en EE.UU. El proyecto final, que incluye varios archivos y carpetas, se puede ver aquí: \url{https://github.com/rairizarry/murders}. Tengan en cuenta que uno de los archivos de ese proyecto es el informe final: \url{https://github.com/rairizarry/murders/blob/master/report.md}.

\hypertarget{installing-r-rstudio}{%
\chapter{Instalación de R y RStudio}\label{installing-r-rstudio}}

Las instrucciones a continuación incluyen capturas de pantalla del proceso de instalación. En este libro mostramos ejemplos usando el navegador Chrome (pero pueden usar otros navegadores) que pueden descargar e instalar libremente aquí: \url{https://www.google.com/chrome/}.

\hypertarget{instalando-r}{%
\section{Instalando R}\label{instalando-r}}

RStudio es un entorno de desarrollo integrado (IDE por sus siglas en inglés), pero no es R, ni incluye R cuando se descarga e instala. Por lo tanto, para usar RStudio, primero necesitamos instalar R.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Pueden descargar R desde la Red Integral de Archivo R (CRAN)\footnote{\url{https://cran.r-project.org/}}. Busquen CRAN en su navegador:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_12_59} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Una vez en la página de CRAN, seleccionen la versión para su sistema operativo: Linux, Mac OS X o Windows.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_13_21} \end{center}

Aquí mostramos capturas de pantalla para Windows, pero el proceso es similar para las otras plataformas. Cuando difieren, también mostraremos capturas de pantalla para Mac OS X.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Una vez en la página de descarga de CRAN, tendrán varias opciones. Quieren instalar el subdirectorio \emph{base}. Esto instala los paquetes básicos que necesitarán para comenzar. Más adelante, aprenderemos cómo instalar otros paquetes necesarios desde R, en lugar de hacerlo desde esta página web.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_13_29} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Hagan clic en el enlace de la última versión para iniciar la descarga.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_13_35} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Si están utilizando Chrome, en la parte inferior de su navegador deberían ver una pestaña que les muestra el progreso de la descarga. Una vez que se descargue el archivo instalador, pueden hacer clic en esa pestaña para comenzar el proceso de instalación. Otros navegadores pueden ser diferentes, por lo que tendrán que encontrar dónde almacenan los archivos descargados y hacer clic en ellos para comenzar el proceso.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_13} \end{center}

Si usan Safari en la Mac, pueden acceder el archivo descargado a través del botón \emph{Downloads}.

\begin{center}\includegraphics[width=4in]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.34.51-PM} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Ahora pueden hacer clic en diferentes opciones para finalizar la instalación. Le recomendamos que seleccionen todas las opciones predeterminadas.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_19} \end{center}

Seleccionen el valor predeterminado incluso cuando reciban una advertencia ominosa.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_24} \end{center}

Al seleccionar el idioma, tengan en cuenta que será más fácil seguir este libro si seleccionan inglés.

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_31} \end{center}

Continúen seleccionando todos los valores predeterminados:

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_37} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_42} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_47} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_16_54} \end{center}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_17_00} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_17_05} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_17_39} \end{center}

En una Mac se ve diferente, pero aún así deben aceptar los valores predeterminados:

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.34.58-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.03-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.06-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.11-PM} \end{center}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.19-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.25-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.38-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.43-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.35.49-PM} \end{center}

¡Felicidades! Han instalado R.

\hypertarget{instalaciuxf3n-de-rstudio}{%
\section{Instalación de RStudio}\label{instalaciuxf3n-de-rstudio}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Pueden comenzar buscando RStudio en su navegador:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_18_41} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Deben encontrar el sitio web de RStudio como se muestra arriba. Una vez allí, hagan clic en \emph{Download RStudio}.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_18_52} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Esto les dará varias opciones. Para lo que hacemos en este libro, es más que suficiente usar la versión gratuita \emph{RStudio Desktop}:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_18_58} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Una vez que seleccionen esta opción, el programa los llevará a una página con las opciones del sistema operativo. Hagan clic en el enlace que muestra su sistema operativo.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_04} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Una vez que hayan descargado el archivo de instalación, hagan clic en el archivo descargado para iniciar el proceso de instalación:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_22} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Recomendamos hacer clic en \emph{yes} en todos los valores predeterminados.
\end{enumerate}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_33} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_38} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_42} \end{center}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_46} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_19_51} \includegraphics[width=0.45\linewidth,]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_20_28} \end{center}

En la Mac, hay menos clics. Básicamente, arrastran y sueltan el ícono RStudio en el ícono de la carpeta \emph{Applications} como ven aquí:

\begin{center}\includegraphics[width=4in]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.39.08-PM} \end{center}

¡Felicidades! Han instalado RStudio. Ahora pueden comenzar como lo hacen en cualquier otro programa en su computadora. En Windows, pueden abrir RStudio desde el menú \emph{Start}. Si RStudio no aparece, pueden buscarlo:

\begin{center}\includegraphics[width=4in]{productivity/img/windows-screenshots/VirtualBox_Windows-7-Enterprise_22_03_2018_16_21_05} \end{center}

En la Mac, estará en la carpeta \emph{Applications}:

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.40.12-PM} \includegraphics[width=0.45\linewidth,]{productivity/img/mac-screenshots/Screen-Shot-2018-04-11-at-5.40.21-PM} \end{center}

\textbf{Consejo profesional para la Mac}: Para evitar usar el mouse para abrir RStudio, presionen comando+barra espaciadora para abrir \emph{Spotlight Search} y escriban RStudio en esa barra de búsqueda. Luego presionen \emph{enter}.

\hypertarget{accediendo-al-terminal-e-instalando-git}{%
\chapter{Accediendo al terminal e instalando Git}\label{accediendo-al-terminal-e-instalando-git}}

Antes de comenzar, debemos asegurarnos de que tengan acceso a un \emph{terminal} y que Git esté instalado. El terminal está integrado en los sistemas Mac y Linux, pero los usuarios de Windows deberán instalar un \emph{emulador}. Hay muchas opciones de emulador disponibles, pero aquí mostramos cómo instalar Git Bash porque se puede hacer como parte de la instalación de Windows Git. Debido a las diferencias entre Mac y Windows, las secciones de este capítulo se dividen tomando esto en cuenta.

\hypertarget{terminal-on-mac}{%
\section{Accediendo al terminal en una Mac}\label{terminal-on-mac}}

En el Capitulo \ref{unix}, describimos cómo el terminal es nuestra ventana al mundo de Unix. En una Mac, pueden acceder a un terminal abriendo la aplicación en la carpeta \emph{Utilities}:

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.35.44-AM} \includegraphics[width=0.45\linewidth]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.36.29-AM} \includegraphics[width=0.45\linewidth]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.36.48-AM} \end{center}

También pueden usar la aplicación \emph{Spotlight} en la Mac presionando comando-barra espaciadora y entonces escribiendo \emph{Terminal}.

Otra forma de acceder al terminal es desde RStudio. En el panel \emph{Console}, deberían ver una pestaña \emph{Terminal}. Si hacen clic en esa pestaña, abrirá una ventana de terminal.

\hypertarget{instalando-git-en-la-mac}{%
\section{Instalando Git en la Mac}\label{instalando-git-en-la-mac}}

\textbf{Advertencia: Las instrucciones en esta subsección no son para usuarios de Windows.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Comiencen abriendo un terminal como se describe en la sección anterior.
\item
  Una vez que inicien el terminal, verán una consola como esta:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.36.48-AM} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Es posible que ya hayan instalado Git. Una manera de verificarlo es preguntando por la versión escribiendo:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git} \AttributeTok{{-}{-}version}
\end{Highlighting}
\end{Shaded}

Si les devuelve un número de versión, Git ya está instalado. Si no, recibirán el siguiente mensaje:

\begin{center}\includegraphics[width=4in]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.39.31-AM} \end{center}

y se les preguntará si quieren instalarlo. Deben hacer clic en \emph{Install}:

\begin{center}\includegraphics[width=4in]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.39.44-AM} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Esto los guiará por el proceso de instalación:
\end{enumerate}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.40.09-AM} \includegraphics[width=0.45\linewidth,]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-10.40.15-AM} \includegraphics[width=0.45\linewidth,]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-11.10.29-AM} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Una vez instalado, pueden verificar la versión nuevamente y deberían ver algo como esto:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//mac-screenshots/Screen-Shot-2018-04-11-at-11.10.47-AM} \end{center}

Felicidades. Han instalado Git en sus Macs.

\hypertarget{instalaciuxf3n-de-git-y-git-bash-en-windows}{%
\section{Instalación de Git y Git Bash en Windows}\label{instalaciuxf3n-de-git-y-git-bash-en-windows}}

\textbf{Advertencia: Las instrucciones en esta subsección no son para usuarios de Mac.}

Hay varios programas de software que les permitirán ejecutar comandos de Unix en Windows. Usaremos Git Bash ya que interactúa con RStudio y se instala automáticamente cuando instalamos Git for Windows.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Comiencen buscando \emph{Git for Windows} en su navegador y haciendo clic en el enlace de \emph{git-scm.com}.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_31_15} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Esto los llevará a la página \emph{Download Git} donde pueden descargar el \emph{maintained build} mas reciente:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_31_45} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Entonces pueden aceptar ejecutar el instalador y aceptar la licencia:
\end{enumerate}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_32_01} \includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_32_10} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  En uno de los pasos de la instalación, se les pedirá que elijan el editor predeterminado para Git. A menos que ya sean usuarios de \emph{vi} o \emph{vim}, no les recomendamos que seleccionen \emph{vim}, que puede ser el predeterminado. Si no reconocen un editor con el que están familiarizados entre las opciones, les recomendamos que seleccionen \emph{nano} como su editor predeterminado para Git, ya que es el más fácil de aprender:
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_32_55} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  La siguiente decisión de instalación es una \textbf{muy importante}. Este proceso de instalación instala Git Bash. Recomendamos que seleccionen \emph{Git and optional Unix tools from the Windows Command} ya que esto les permitirá aprender Unix desde RStudio. Sin embargo, si hacen esto, \textbf{algunos comandos que se ejecutan en su línea de comandos de Windows dejarán de funcionar}. Si no usan su línea de comandos de Windows, entonces esto no será un problema. Además, la mayoría, si no todas, de estas líneas de comando de Windows tienen un equivalente de Unix que podrán usar.
\end{enumerate}

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_34_52} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Ahora pueden continuar seleccionando las opciones predeterminadas.
\end{enumerate}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_35_03} \includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_35_29} \includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_35_42} \end{center}

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_35_57} \includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_36_43} \end{center}

Ya han instalado Git en Windows.

\hypertarget{terminal-on-windows}{%
\section{Accediendo el terminal en Windows}\label{terminal-on-windows}}

Ahora que Git Bash está instalado, podemos acceder al terminal a través de RStudio o abriendo Git Bash directamente.

Para acceder al terminal a través de RStudio, necesitamos cambiar una preferencia para que Git Bash se convierta en el \emph{shell} predeterminado de Unix en RStudio. En RStudio, vayan a \emph{Preferences} (en el menú de \emph{File}), luego seleccionen \emph{Terminal} y entonces seleccionen \emph{Git Bash}:

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_38_00} \end{center}

Para comprobar que están utilizando Git Bash en RStudio, pueden abrir \emph{New Terminal} en RStudio:

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_10_49_44} \end{center}

Debería verse más o menos así:

\begin{center}\includegraphics[width=4in]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_10_49_51} \end{center}

A menudo queremos acceder al terminal, pero no necesitamos RStudio. Pueden hacer esto ejecutando el programa Git Bash directamente:

\begin{center}\includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_10} \includegraphics[width=0.45\linewidth,]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_12} \end{center}

\hypertarget{unix}{%
\chapter{Organizando con Unix}\label{unix}}

Unix es el sistema operativo de elección en el campo de ciencia de datos. Le presentaremos la forma de pensar de Unix utilizando un ejemplo: cómo mantener organizado un proyecto de análisis de datos. Aprenderemos algunos de los comandos más utilizados a lo largo del camino. Sin embargo, no entraremos en detalles aquí. Les recomendamos que aprendan más, especialmente cuando se encuentran usando demasiado el mouse o realizando una tarea repetitiva con frecuencia. En esos casos, probablemente hay una forma más eficiente de hacerlo en Unix. Aquí tenemos algunos cursos básicos para comenzar:

\begin{itemize}
\tightlist
\item
  \url{https://www.codecademy.com/learn/learn-the-command-line}
\item
  \url{https://www.edx.org/course/introduction-linux-linuxfoundationx-lfs101x-1}
\item
  \url{https://www.coursera.org/learn/unix}
\end{itemize}

También hay muchos libros de referencia\footnote{\url{https://www.quora.com/Which-are-the-best-Unix-Linux-reference-books}}. Por ejemplo, \emph{Bite Size Linux}\footnote{\url{https://gumroad.com/l/bite-size-linux}} y \emph{Bite Size Command Line}\footnote{\url{https://jvns.ca/blog/2018/08/05/new-zine--bite-size-command-line/}} son particularmente claros, concisos y completos.

Cuando busquen recursos de Unix, recuerden que otros términos utilizados para describir lo que aprenderemos aquí son \emph{Linux}, el \emph{shell} y la \emph{línea de comando}. Básicamente, lo que estamos aprendiendo es una serie de comandos y una forma de pensar que facilita la organización de los archivos sin usar el mouse.

Como motivación, vamos a comenzar construyendo un directorio utilizando herramientas de Unix y RStudio.

\hypertarget{convenciuxf3n-de-nomenclatura}{%
\section{Convención de nomenclatura}\label{convenciuxf3n-de-nomenclatura}}

Antes de comenzar a organizar proyectos con Unix, deben elegir una convención que usarán para sistemáticamente nombrar sus archivos y directorios. Esto les ayudará a encontrar archivos y saber qué hay en ellos.

En general, quieren nombrar sus archivos de una manera que se relaciona con
sus contenidos y que especifica cómo se relacionan con otros archivos. El \emph{Smithsonian Data Management Best Practices}\footnote{\url{https://library.si.edu/sites/default/files/tutorial/pdf/filenamingorganizing20180227.pdf}} ofrece ``cinco preceptos para el nombramiento y la organización de archivos''. Estos son:

\begin{quote}
\begin{quote}
\begin{itemize}
\tightlist
\item
  Tener un nombre distintivo, legible por humanos que indique el contenido.
\item
  Seguir un patrón consistente que sea conveniente para la automatización.
\item
  Organizar los archivos en directorios (cuando sea necesario) que siguen un patrón consistente.
\item
  Evitar la repetición de elementos semánticos en los nombres de los archivos y directorios.
\item
  Tener una extensión de archivo que coincida con el formato del archivo (¡sin cambiar las extensiones!)
\end{itemize}
\end{quote}
\end{quote}

Para recomendaciones específicas, pueden consultar \emph{The Tidyverse Style Guide}\footnote{\url{https://style.tidyverse.org/}}.

\hypertarget{the-terminal}{%
\section{El terminal}\label{the-terminal}}

En lugar de hacer clic, arrastrar y soltar para organizar nuestros archivos y carpetas, escribiremos comandos de Unix en el terminal. La forma en que hacemos esto es similar a cómo escribimos comandos en la consola R, pero en lugar de generar gráficos y resúmenes estadísticos, organizaremos archivos en nuestro sistema.

Necesitarán acceso a un terminal\footnote{\url{https://rafalab.github.io/dsbook/accessing-the-terminal-and-installing-git.html}}.
Una vez que tengan un terminal abierto, pueden comenzar a escribir comandos. Deberían ver un cursor intermitente en el lugar donde se muestra lo que escriben. Esta posición se llama la \emph{línea de comando} (\emph{command line} en inglés). Una vez que escriban algo y presionen \emph{enter} en Windows o \emph{return} en la Mac, Unix intentará ejecutar este comando. Si quieren intentar un ejemplo, escriban lo siguiente en su línea de comando:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"hello world"}
\end{Highlighting}
\end{Shaded}

El comando \texttt{echo} es parecido a \texttt{cat} en R. Al ejecutar esta línea deberían ver \texttt{hello\ world} y entonces vuelven a la línea de comando.

Tengan en cuenta que no pueden usar el mouse para moverse en el terminal. Tienen que usar el teclado. Para volver a un comando que escribieron anteriormente, pueden usar la flecha hacia arriba.

Noten que anteriormente incluimos un fragmento de código que muestra los comandos de Unix de la misma manera que anteriormente mostramos los comandos R. Nos aseguraremos de distinguir cuándo el comando está destinado a R y cuándo está destinado a Unix.

\hypertarget{filesystem}{%
\section{El sistema de archivos}\label{filesystem}}

Nos referimos a todos los archivos, carpetas y programas en su computadora como el \emph{sistema de archivos} (\emph{filesystem} en inglés). Recuerden que las carpetas y los programas también son archivos, pero este es un tecnicismo en que rara vez pensamos e ignoraremos en este libro. Nos enfocaremos en los archivos y las carpetas por el momento y discutiremos los programas, o \emph{ejecutables}, en una sección posterior.

\hypertarget{directorios-y-subdirectorios}{%
\subsection{Directorios y subdirectorios}\label{directorios-y-subdirectorios}}

El primer concepto que necesitan entender para convertirse en un usuario de Unix es cómo está organizado su sistema de archivos. Deberían considerarlo como una serie de carpetas anidadas, cada una con archivos, carpetas y ejecutables.

Aquí hay una representación visual de la estructura que estamos describiendo:

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//unix/filesystem} \end{center}

En Unix, nos referimos a las carpetas como \emph{directorios}. Los directorios que están dentro de otros directorios a menudo se denominan \emph{subdirectorios}. Entonces, por ejemplo, en la figura anterior, el directorio \emph{docs} tiene dos subdirectorios: \emph{reports} y \emph{resumes}, y \emph{docs} es un subdirectorio de \emph{home}.

\hypertarget{el-directorio-home}{%
\subsection{\texorpdfstring{El directorio \emph{home}}{El directorio home}}\label{el-directorio-home}}

El directorio \emph{home} es donde se guardan todas sus cosas, a diferencia de los archivos del sistema que vienen con sus computadoras, que se guardan en otro lugar. En la figura anterior, el directorio denominado ``home'' representa su directorio \emph{home}, pero raras veces se llama así. En sus sistemas, el nombre de su directorio \emph{home} probablemente será el mismo que su nombre de usuario en ese sistema. A continuación vemos un ejemplo en Windows y Mac que muestra un directorio \emph{home}, en este caso, llamado \emph{rafa}:

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_13} \includegraphics[width=0.45\linewidth]{productivity/img//mac-screenshots/Screen-Shot-2018-04-13-at-4.34.01-PM} \end{center}

Ahora, miren a la figura anterior que muestra un sistema de archivos. Supongan que están utilizando un sistema de apuntar y hacer clic y desea eliminar el archivo \emph{cv.tex}. Imaginen que en su pantalla pueden ver el directorio \emph{home}. Para borrar este archivo, deben hacer doble clic en el directorio \emph{home}, luego \emph{docs}, entonces \emph{resumes} y luego arrastrar \emph{cv.tex} a la basura. Aquí están experimentando la naturaleza jerárquica del sistema: \emph{cv.tex} es un archivo dentro del directorio \emph{resumes}, que es un subdirectorio dentro del directorio \emph{docs}, que es un subdirectorio del directorio \emph{home}.

Ahora supongan que no pueden ver su directorio \emph{home} en su pantalla. De alguna manera, deberían hacer que aparezca en su pantalla. Una forma de hacerlo es navegar desde lo que se llama el \emph{directorio raíz} (\emph{root directory} en inglés) hasta el directorio \emph{home}. Cualquier sistema de archivos tendrá lo que se llama un directorio raíz, que es el directorio que contiene todos los directorios. El directorio \emph{home}, que se muestra en la figura anterior, generalmente estará a dos o más niveles del directorio raíz. En Windows, tendrán una estructura como esta:

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//unix/windows-filesystem-from-root} \end{center}

mientras en la Mac, será así:

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//unix/mac-filesystem-from-root} \end{center}

\textbf{Nota para usuarios de Windows:} La instalación típica de R hará que su directorio \emph{Documents} sea su directorio \emph{home} en R. Esto probablemente será diferente de su directorio \emph{home} en Git Bash. En general, cuando discutimos directorios \emph{home}, nos referimos al directorio \emph{home} de Unix que para Windows, en este libro, es el directorio de Git Bash Unix.

\hypertarget{working-directory}{%
\subsection{Directorio de trabajo}\label{working-directory}}

El concepto de una \emph{ubicación actual} (\emph{current location} en inglés) es parte de la experiencia de apuntar y hacer clic: en cualquier momento estamos \emph{en una carpeta} y vemos el contenido de esa carpeta. A medida que busquen un archivo, como lo hicimos anteriormente, experimentarán el concepto de una ubicación actual: una vez que hagan doble clic en un directorio, cambiarán de ubicación y estarán \emph{en esa carpeta}, a diferencia de la carpeta en la que estaban antes.

En Unix, no tenemos las mismas señales visuales, pero el concepto de una \emph{ubicación actual} es indispensable. Nos referimos a esto como el \emph{directorio de trabajo} (\emph{working directory} en inglés). Cada ventana del terminal que tienen abierta tiene un directorio de trabajo asociado.

¿Cómo sabemos cuál es nuestro directorio de trabajo? Para responder a esto, aprendemos nuestro primer comando de Unix: \texttt{pwd}, que significa \emph{imprimir el directorio de trabajo} (\emph{print working directory} en inglés). Este comando devuelve el directorio de trabajo.

Abran un terminal y escriban:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{pwd}
\end{Highlighting}
\end{Shaded}

No mostramos el resultado de ejecutar este comando porque será muy diferente en sus sistemas en comparación con otros. Si abren un terminal y escriben \texttt{pwd} como su primer comando, deberían ver algo como \texttt{/Users/yourusername} en la Mac o algo como \texttt{/c/Users/yourusername} en Windows. La cadena de caracteres devuelta al llamar \texttt{pwd} representa su directorio de trabajo. Cuando abrimos un terminal por primera vez, empezamos en nuestro directorio \emph{home}, por lo que en este caso el directorio de trabajo es el directorio \emph{home}.

Tengan en cuenta que las barras diagonales \texttt{/} en las cadenas de arriba separan los directorios. Entonces, por ejemplo, la ubicación \texttt{/c/Users/rafa} implica que nuestro directorio de trabajo se llama \texttt{rafa} y es un subdirectorio de \texttt{Users}, que es un subdirectorio de \texttt{c}, que es un subdirectorio del directorio raíz. Por lo tanto, el directorio raíz está representado solo por una barra diagonal: \texttt{/}.

\hypertarget{paths}{%
\subsection{Rutas}\label{paths}}

Nos referimos a la cadena devuelta por \texttt{pwd} como la \emph{ruta completa} (\emph{full path} en inglés) del directorio de trabajo. El nombre proviene del hecho de que esta cadena explica la \emph{ruta} que deben seguir para llegar al directorio en cuestión desde el directorio raíz. Cada directorio tiene una ruta completa. Más adelante, aprenderemos sobre \emph{rutas relativas}, que nos dicen cómo llegar a un directorio desde el directorio de trabajo.

En Unix, usamos la abreviatura \texttt{\textasciitilde{}} para representar su directorio \emph{home}. Entonces, por ejemplo, si \texttt{docs} es un directorio en su directorio \emph{home}, la ruta completa para \emph{docs} puede escribirse así \texttt{\textasciitilde{}/docs}.

La mayoría de los terminales mostrarán la ruta de su directorio de trabajo directamente en la línea de comando. Si están utilizando la configuración predeterminada y abren un terminal en la Mac, verán que justo en la línea de comando tienen algo como \texttt{computername:\textasciitilde{}\ username} con \texttt{\textasciitilde{}} representando su directorio de trabajo, que en este ejemplo es el directorio \emph{home} \texttt{\textasciitilde{}}. Lo mismo es cierto para el terminal Git Bash, donde verán algo como \texttt{username@computername\ MINGW64\ \textasciitilde{}}, con el directorio de trabajo al final. Cuando cambiemos los directorios, veremos este cambio tanto en Macs como en Windows.

\hypertarget{comandos-de-unix}{%
\section{Comandos de Unix}\label{comandos-de-unix}}

Ahora aprenderemos una serie de comandos de Unix que nos permitirán preparar un directorio para un proyecto de ciencia de datos. También ofrecemos ejemplos de comandos que, si escriben en su terminal, devolverán un error. Esto es porque suponemos que tenemos el sistema de archivos mostrado en el diagrama anterior. Su sistema de archivos es diferente. En la siguiente sección, le ofreceremos ejemplos que pueden escribir.

\hypertarget{ls-listado-de-contenido-del-directorio}{%
\subsection{\texorpdfstring{\texttt{ls}: Listado de contenido del directorio}{ls: Listado de contenido del directorio}}\label{ls-listado-de-contenido-del-directorio}}

En un sistema de apuntar y hacer clic, sabemos lo que hay en un directorio porque lo vemos. En el terminal, no vemos los íconos. En cambio, usamos el comando \texttt{ls} para enumerar el contenido del directorio.

Para ver el contenido de su directorio personal, abran un terminal y escriban:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}
\end{Highlighting}
\end{Shaded}

Veremos más ejemplos pronto.

\hypertarget{mkdir-y-rmdir-crear-y-eliminar-un-directorio}{%
\subsection{\texorpdfstring{\texttt{mkdir} y \texttt{rmdir}: crear y eliminar un directorio}{mkdir y rmdir: crear y eliminar un directorio}}\label{mkdir-y-rmdir-crear-y-eliminar-un-directorio}}

Cuando nos estamos preparando para un proyecto de ciencia de datos, necesitaremos crear directorios. En Unix, podemos hacer esto con el comando \texttt{mkdir}, que significa \emph{crear directorio} (\emph{make directory} en inglés).

Debido a que pronto estarán trabajando en varios proyectos, les recomendamos crear un directorio llamado \emph{proyectos} en su directorio \emph{home}.

Pueden intentar este ejemplo en su sistema. Abran un terminal y escriban:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ projects}
\end{Highlighting}
\end{Shaded}

Si hacen esto correctamente, no pasará nada: no tener noticias es buena noticia. Si el directorio ya existe, recibirán un mensaje de error y el directorio existente permanecerá intacto.

Para confirmar que crearon este directorio, pueden verlo usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}
\end{Highlighting}
\end{Shaded}

Verán una lista de cualquier directorio o archivo, incluyendo los que acaban de crear.

Con fines ilustrativos, vamos a crear algunos directorios más. Pueden enumerar más de un nombre de directorio así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ docs teaching}
\end{Highlighting}
\end{Shaded}

Pueden verificar si se crearon los tres directorios:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}
\end{Highlighting}
\end{Shaded}

Si cometieron un error y necesitan eliminar un directorio, pueden usar el comando \texttt{rmdir} (\emph{remove directory} en inglés):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ junk}
\FunctionTok{rmdir}\NormalTok{ junk}
\end{Highlighting}
\end{Shaded}

Esto eliminará el directorio siempre y cuando esté vacío. Si no está vacío, recibirán un mensaje de error y el directorio permanecerá intacto. Para eliminar directorios que no están vacíos, más tarde aprenderemos sobre el comando \texttt{rm}.

\hypertarget{cd-navegando-por-el-sistema-de-archivos-cambiando-directorios}{%
\subsection{\texorpdfstring{\texttt{cd}: navegando por el sistema de archivos cambiando directorios}{cd: navegando por el sistema de archivos cambiando directorios}}\label{cd-navegando-por-el-sistema-de-archivos-cambiando-directorios}}

A continuación, queremos crear directorios dentro de los directorios que ya hemos creado. También queremos evitar apuntar y hacer clic en nuestro sistema de archivos. Explicamos cómo hacer esto en Unix, usando la línea de comando.

Supongan que abrimos un terminal y nuestro directorio de trabajo es nuestro directorio \emph{home}. Queremos cambiar nuestro directorio de trabajo a \texttt{projects}. Hacemos esto usando el comando \texttt{cd}, que significa \emph{cambiar directorio} (\emph{change directory} en inglés):

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ projects}
\end{Highlighting}
\end{Shaded}

Para verificar que el directorio de trabajo cambió, podemos usar un comando que aprendimos previamente para ver nuestra ubicación:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{pwd}
\end{Highlighting}
\end{Shaded}

Nuestro directorio de trabajo ahora debería ser \texttt{\textasciitilde{}/projects}. Recuerden que en su computadora el directorio \emph{home} \texttt{\textasciitilde{}} se verá algo como: \texttt{/c/Users/yourusername}).

\textbf{Consejo profesional importante}: En Unix, pueden completar automáticamente presionando \emph{tab}. Esto significa que podemos escribir \texttt{cd\ d}, entonces presionar \emph{tab}. Unix se completará automáticamente si \texttt{docs} es el único directorio/archivo que comienza con \texttt{d} o les mostrará las opciones. ¡Inténtelo! Usar Unix sin poder autocompletar sería insoportable.

Cuando usamos \texttt{cd}, podemos escribir una ruta completa, que comenzará con \texttt{/} o \texttt{\textasciitilde{}}, o una \emph{ruta relativa}. En el ejemplo anterior, en el que escribimos \texttt{cd\ projects}, usamos una ruta relativa. Si la ruta que escriben no comienza con \texttt{/} o \texttt{\textasciitilde{}}, Unix supondrá que están escribiendo una ruta relativa y buscará el directorio en su directorio de trabajo actual. Entonces algo como esto les dará un error:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ Users}
\end{Highlighting}
\end{Shaded}

porque no hay directorio \texttt{Users} en su directorio de trabajo.

Ahora supongan que queremos volver al directorio en el que \texttt{projects} es un subdirectorio, denominado el \emph{directorio padre} (\emph{parent directory} en inglés). Podríamos usar la ruta completa del directorio padre, pero Unix proporciona un acceso directo para esto: el directorio padre del directorio de trabajo se representa con dos puntos: \texttt{..}, así que para retroceder simplemente escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ ..}
\end{Highlighting}
\end{Shaded}

Ahora deberían haber vuelto a su directorio \emph{home}, que pueden confirmar usando \texttt{pwd}.

Como podemos usar rutas completas con \texttt{cd}, el siguiente comando:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}}
\end{Highlighting}
\end{Shaded}

siempre nos regresará al directorio \emph{home}, sin importar dónde estemos en el sistema de archivos.

El directorio de trabajo también tiene una abreviatura, que es un solo \texttt{.}, así que si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ .}
\end{Highlighting}
\end{Shaded}

no se moverán. Aunque este uso particular de \texttt{.} no es útil, la abreviatura a veces lo es. Las razones no son relevantes para esta sección, pero aún deben tomar en cuenta este hecho.

En resumen, hemos aprendido que al usar \texttt{cd} una de tres cosas pasan: nos quedamos en la misma ubicación, nos movemos a un nuevo directorio usando el nombre del directorio deseado o volvemos al directorio padre usando \texttt{..}.

Al escribir nombres de directorios, podemos concatenar directorios con barras diagonales. Entonces, si queremos un comando que nos lleve al directorio \texttt{projects} sin importar dónde nos encontremos en el sistema de archivos, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/projects}
\end{Highlighting}
\end{Shaded}

que es equivalente a escribir toda la ruta. Por ejemplo, en Windows escribiríamos algo como:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{cd/c/Users/yourusername/projects}
\end{Highlighting}
\end{Shaded}

Los dos últimos comandos son equivalentes y en ambos casos estamos escribiendo la ruta completa.

Al escribir la ruta del directorio que queremos, ya sea completa o relativa, podemos concatenar directorios con barras diagonales. Ya vimos que podemos pasar al directorio \texttt{projects} independientemente de dónde estamos escribiendo la ruta completa de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/projects}
\end{Highlighting}
\end{Shaded}

También podemos concatenar nombres de directorio para rutas relativas. Por ejemplo, si queremos volver al directorio padre del directorio padre del directorio de trabajo, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ ../..}
\end{Highlighting}
\end{Shaded}

Aquí ofrecemos un par de consejos finales relacionados con el comando \texttt{cd}. Primero, pueden volver al directorio que acaban de dejar escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd} \AttributeTok{{-}}
\end{Highlighting}
\end{Shaded}

Esto puede ser útil si escriben una ruta muy larga y luego se dan cuenta de que quieren volver a donde estaban, y ese también tiene una ruta muy larga.

En segundo lugar, si solo escriben:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}
\end{Highlighting}
\end{Shaded}

regresarán a su directorio \emph{home}.

\hypertarget{algunos-ejemplos}{%
\section{Algunos ejemplos}\label{algunos-ejemplos}}

Exploremos algunos ejemplos de como usar \texttt{cd}. Para ayudarles visualizar, mostraremos la representación gráfica de nuestro sistema de archivos verticalmente:

\begin{center}\includegraphics[width=0.4\linewidth]{productivity/img//unix/filesystem-vertical} \end{center}

Supongan que nuestro directorio de trabajo es \texttt{\textasciitilde{}/projects} y queremos mover \texttt{figs} a \texttt{project-1}.

En este caso, es conveniente usar rutas relativas:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ project{-}1/figs}
\end{Highlighting}
\end{Shaded}

Ahora supongan que nuestro directorio de trabajo es \texttt{\textasciitilde{}/projects} y queremos mover \texttt{reports} a \texttt{docs}, ¿cómo podemos hacer esto?

Una forma es usar rutas relativas:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ ../docs/reports}
\end{Highlighting}
\end{Shaded}

Otra es usar la ruta completa:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/reports}
\end{Highlighting}
\end{Shaded}

Si están intentando esto en su sistema, recuerden aprovecharse de que Unix autocompleta.

Examinemos un ejemplo más. Supongan que estamos en \texttt{\textasciitilde{}/projects/project-1/figs} y queremos cambiar a \texttt{\textasciitilde{}/projects/project-2}. De nuevo, hay dos formas.

Con rutas relativas:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ ../../proejct{-}2}
\end{Highlighting}
\end{Shaded}

y con rutas completas:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/projects/project{-}2}
\end{Highlighting}
\end{Shaded}

\hypertarget{muxe1s-comandos-de-unix}{%
\section{Más comandos de Unix}\label{muxe1s-comandos-de-unix}}

\hypertarget{mv-mover-archivos}{%
\subsection{\texorpdfstring{\texttt{mv}: mover archivos}{mv: mover archivos}}\label{mv-mover-archivos}}

En un sistema de apuntar y hacer clic, movemos los archivos de un directorio a otro arrastrando y soltando. En Unix, usamos el comando \texttt{mv}.

\textbf{Advertencia}: \texttt{mv} no les preguntará ``¿estás seguro?'' si su cambio resulta en sobrescribir un archivo.

Ahora que saben cómo usar rutas completas y relativas, usar \texttt{mv} es relativamente sencillo. La forma general es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mv}\NormalTok{ path{-}to{-}file path{-}to{-}destination{-}directory}
\end{Highlighting}
\end{Shaded}

Por ejemplo, si queremos mover el archivo \texttt{cv.tex} desde \texttt{resumes} a \texttt{reports}, podrían usar las rutas completas de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mv}\NormalTok{ \textasciitilde{}/docs/resumes/cv.tex \textasciitilde{}/docs/reports/}
\end{Highlighting}
\end{Shaded}

También pueden usar rutas relativas y hacer lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/resumes}
\FunctionTok{mv}\NormalTok{ cv.tex ../reports/}
\end{Highlighting}
\end{Shaded}

o esto:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/reports/}
\FunctionTok{mv}\NormalTok{ ../resumes/cv.tex ./}
\end{Highlighting}
\end{Shaded}

Observen que en el último usamos el acceso directo al directorio de trabajo \texttt{.} para dar una ruta relativa como el directorio de destino.

También podemos usar \texttt{mv} para cambiar el nombre de un archivo. Para hacer esto, en lugar de que el segundo argumento sea el directorio de destino, también incluye un nombre de archivo. Entonces, por ejemplo, para cambiar el nombre de \texttt{cv.tex} a \texttt{resume.tex}, simplemente escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/resumes}
\FunctionTok{mv}\NormalTok{ cv.tex resume.tex}
\end{Highlighting}
\end{Shaded}

También podemos combinar el movimiento y un cambio de nombre. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/resumes}
\FunctionTok{mv}\NormalTok{ cv.tex ../reports/resume.tex}
\end{Highlighting}
\end{Shaded}

Y podemos mover directorios completos. Para mover el directorio \texttt{resumes} a \texttt{reports}, hacemos lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mv}\NormalTok{ \textasciitilde{}/docs/resumes \textasciitilde{}/docs/reports/}
\end{Highlighting}
\end{Shaded}

Es importante agregar el último \texttt{/} para que quede claro que no desean cambiar el nombre del directorio \texttt{resumes} a \texttt{reports}, sino más bien moverlo al directorio \texttt{reports}.

\hypertarget{cp-copiando-archivos}{%
\subsection{\texorpdfstring{\texttt{cp}: copiando archivos}{cp: copiando archivos}}\label{cp-copiando-archivos}}

El comando \texttt{cp} se comporta de manera similar a \texttt{mv} excepto que en lugar de mover, copiamos el archivo, que significa que el archivo original permanece intacto.

Entonces, en todos los ejemplos \texttt{mv} anteriores, pueden cambiar \texttt{mv} a \texttt{cp} y copiarán en lugar de mover con una excepción: no podemos copiar directorios completos sin aprender sobre argumentos, que haremos más adelante.

\hypertarget{rm-eliminar-archivos}{%
\subsection{\texorpdfstring{\texttt{rm}: eliminar archivos}{rm: eliminar archivos}}\label{rm-eliminar-archivos}}

En los sistemas de apuntar y hacer clic, eliminamos los archivos arrastrándolos y soltándolos en la basura o haciendo un clic especial con el mouse. En Unix, usamos el comando \texttt{rm}.

\textbf{Advertencia}: A diferencia de echar archivos a la basura, \texttt{rm} es permanente ¡Tengan cuidado!

La forma general en que funciona es la siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{ filename}
\end{Highlighting}
\end{Shaded}

De hecho, pueden enumerar archivos así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{ filename{-}1 filename{-}2 filename{-}3}
\end{Highlighting}
\end{Shaded}

Pueden usar rutas completas o relativas. Para eliminar directorios, tendrán que aprender sobre argumentos, que haremos más adelante.

\hypertarget{less-mirando-un-archivo}{%
\subsection{\texorpdfstring{\texttt{less}: mirando un archivo}{less: mirando un archivo}}\label{less-mirando-un-archivo}}

A menudo, desearán ver rápidamente el contenido de un archivo. Si tal archivo es un archivo de texto, la forma más rápida de hacerlo es mediante el comando \texttt{less}. Para ver el archivo \texttt{cv.tex}, deben hacer lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/docs/resumes}
\FunctionTok{less}\NormalTok{ cv.tex}
\end{Highlighting}
\end{Shaded}

Para escapar del visualizador, escriban \texttt{q}. Si los archivos son largos, pueden usar las teclas de flecha para moverse hacia arriba y hacia abajo. Hay muchos otros comandos de teclado que pueden usar dentro de \texttt{less} para, por ejemplo, buscar o saltar páginas. Aprenderán más sobre esto en una sección posterior. Si se preguntan por qué se llama el comando \texttt{less}, es porque el original fue llamado \texttt{more}, como en ``show me more of this file'' o ``muéstrame más de este archivo''. La segunda versión se llamó \texttt{less} por el dicho ``less is more'' o ``menos es más''.

\hypertarget{prep-project}{%
\section{Preparación para un proyecto de ciencia de datos}\label{prep-project}}

Ahora estamos listos para preparar un directorio para un proyecto. Utilizaremos el proyecto de asesinatos de Estados Unidos\footnote{\url{https://github.com/rairizarry/murders}} como ejemplo.

Deberían comenzar creando un directorio donde guardarán todos sus proyectos. Recomendamos un directorio llamado \emph{projects} en su directorio \emph{home}. Para hacer esto, escriban:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}}
\FunctionTok{mkdir}\NormalTok{ projects}
\end{Highlighting}
\end{Shaded}

Nuestro proyecto se relaciona con asesinatos por armas de fuego, por lo que llamaremos al directorio de nuestro proyecto: \texttt{murders}. Será un subdirectorio en nuestro directorio de proyecto. En el directorio \texttt{murders}, crearemos dos subdirectorios para contener los datos sin procesar y los datos intermedios. Llamaremos a estos \texttt{data} y \texttt{rda}, respectivamente.

Abran un terminal y asegúrense de estar en el directorio \emph{home}:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}}
\end{Highlighting}
\end{Shaded}

Ahora ejecuten los siguientes comandos para crear la estructura de directorio que queremos. Al final, usamos \texttt{ls} y \texttt{pwd} para confirmar que hemos generado el directorio correcto en el directorio de trabajo correcto:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ projects}
\FunctionTok{mkdir}\NormalTok{ murders}
\BuiltInTok{cd}\NormalTok{ murders}
\FunctionTok{mkdir}\NormalTok{ data rdas}
\FunctionTok{ls}
\BuiltInTok{pwd}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que la ruta completa de nuestro set de datos \texttt{murders} es \texttt{\textasciitilde{}/projects/murders}.

Entonces, si abrimos un nuevo terminal y queremos navegar en ese directorio, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ projects/murders}
\end{Highlighting}
\end{Shaded}

En la Sección \ref{organizing}, describiremos cómo podemos usar RStudio para organizar un proyecto de análisis de datos, una vez que se hayan creado este directorio.

\hypertarget{unix-avanzado}{%
\section{Unix avanzado}\label{unix-avanzado}}

La mayoría de las implementaciones de Unix incluyen una gran cantidad de herramientas y utilidades eficaces. Acabamos de aprender los conceptos básicos. Recomendamos que utilicen Unix como su herramienta principal de administración de archivos. Tomará tiempo sentirse cómodo con él, pero durante este tiempo, aprenderán mucho buscando soluciones en el Internet. En esta sección, superficialmente cubrimos temas ligeramente más avanzados. El objetivo principal de la sección es informarles sobre lo que está disponible en lugar de explicar todo en detalle.

\hypertarget{argumentos}{%
\subsection{Argumentos}\label{argumentos}}

La mayoría de los comandos de Unix se pueden ejecutar con argumentos. Los argumentos generalmente se definen usando un guión \texttt{-} o dos guiones \texttt{-\/-} (según el comando) seguido de una letra o una palabra. Un ejemplo de un argumento es una \texttt{-r} detrás \texttt{rm}. La \texttt{r} significa recursivo y el resultado es que los archivos y directorios se eliminan recursivamente. O sea, si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm} \AttributeTok{{-}r}\NormalTok{ directory{-}name}
\end{Highlighting}
\end{Shaded}

se eliminarán todos los archivos, subdirectorios, archivos en subdirectorios, subdirectorios en subdirectorios, etc. Esto es equivalente a echar una carpeta en la basura, excepto que no pueden recuperarla. Una vez que la eliminen, se eliminará para siempre. Frecuentemente, cuando eliminan directorios, encontrarán archivos que están protegidos. En tales casos, pueden usar el argumento \texttt{-f} que significa \texttt{force}.

También pueden combinar argumentos. Por ejemplo, para eliminar un directorio independientemente de los archivos protegidos, escribirían:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm} \AttributeTok{{-}rf}\NormalTok{ directory{-}name}
\end{Highlighting}
\end{Shaded}

Recuerden que una vez que eliminen no hay marcha atrás. Por lo tanto, deben usar este comando con mucho cuidado.

Un comando que a menudo se llama con argumentos es \texttt{ls}. Aquí hay un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}a}
\end{Highlighting}
\end{Shaded}

La \texttt{a} representa a ``todos'' (\emph{all} en inglés). Este argumento hace que \texttt{ls} les muestre todos los archivos en el directorio, incluyendo los archivos ocultos. En Unix, todos los archivos que comienzan con un \texttt{.} están escondidos. Muchas aplicaciones crean directorios ocultos para almacenar información importante sin interferir con su trabajo. Un ejemplo es \texttt{git} (que discutimos en detalle más adelante). Una vez que inicializen un directorio como un directorio git con \texttt{git\ init}, se crea un directorio oculto llamado \texttt{.git}. Otro archivo oculto es el archivo \texttt{.gitignore}.

Otro ejemplo de usar un argumento es:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}l}
\end{Highlighting}
\end{Shaded}

La \texttt{l} significa ``largo'' y el resultado es que se muestra más información sobre los archivos.

A menudo es útil ver los archivos en orden cronológico. Para eso usamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}t}
\end{Highlighting}
\end{Shaded}

y para invertir (\emph{reverse} en inglés) el orden de cómo se muestran los archivos, pueden usar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}r}
\end{Highlighting}
\end{Shaded}

Podemos combinar todos estos argumentos para mostrar más información para todos los archivos en orden cronológico inverso:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}lart}
\end{Highlighting}
\end{Shaded}

Cada comando tiene un conjunto diferente de argumentos. En la siguiente sección, aprendemos cómo averiguar qué hacen cada uno.

\hypertarget{obtener-ayuda}{%
\subsection{Obtener ayuda}\label{obtener-ayuda}}

Como habrán notado, Unix usa una versión extrema de abreviaturas. Esto lo hace muy eficiente, pero también difícil de adivinar cómo llamar a los comandos. Para compensar por esta debilidad, Unix incluye archivos de ayuda completos o \emph{man pages} (``man'' es la abreviatura de manual). En la mayoría de los sistemas, pueden escribir \texttt{man}, seguido por el nombre del comando para obtener ayuda. Entonces para \texttt{ls}, escribiríamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{man}\NormalTok{ ls}
\end{Highlighting}
\end{Shaded}

Este comando no está disponible en algunas de las implementaciones compactas de Unix, como Git Bash. Una forma alternativa de obtener ayuda que funciona en Git Bash es escribir el comando seguido de \texttt{-\/-help}. Entonces para \texttt{ls}, sería lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}{-}help}
\end{Highlighting}
\end{Shaded}

\hypertarget{el-pipe-1}{%
\subsection{\texorpdfstring{El \emph{pipe}}{El pipe}}\label{el-pipe-1}}

Las páginas de ayuda suelen ser largas y si escriben los comandos que hemos discutido, enseña todo el documento. Sería útil si pudiéramos guardar el manual en un archivo y luego usar \texttt{less} para verlo. El \texttt{pipe}, escrito así \texttt{\textbar{}}, hace algo parecido. Transmite los resultados de un comando al comando después de \texttt{pipe}. Esto es similar al \emph{pipe} \texttt{\%\textgreater{}\%} que usamos en R. Para obtener más ayuda, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{man}\NormalTok{ ls }\KeywordTok{|} \FunctionTok{less}
\end{Highlighting}
\end{Shaded}

o en Git Bash:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}{-}help} \KeywordTok{|} \FunctionTok{less}
\end{Highlighting}
\end{Shaded}

Esto también es útil cuando se enumeran archivos con muchos archivos. Podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}lart} \KeywordTok{|} \FunctionTok{less}
\end{Highlighting}
\end{Shaded}

\hypertarget{comodines}{%
\subsection{Comodines}\label{comodines}}

Algunos de los aspectos más poderosos de Unix son los \emph{comodines} (\emph{wild cards} en inglés). Supongan que queremos eliminar todos los archivos HTML temporeros producidos durante la resolución de problemas para un proyecto. Imagínense que hay docenas de archivos. Tomaría muchísimo tiempo eliminarlos uno por uno. En Unix, podemos escribir una expresión que significa todos los archivos que terminan en \texttt{.html}. Para hacer esto, escribimos el comodín \texttt{*}. Como se discutió en la parte de \emph{wrangling} de datos de este libro, este carácter significa cualquier número de cualquier combinación de caracteres. Específicamente, para enumerar todos los archivos HTML, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \PreprocessorTok{*}\NormalTok{.html}
\end{Highlighting}
\end{Shaded}

Para eliminar todos los archivos HTML en un directorio, escribimos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rm }\SpecialCharTok{*}\NormalTok{.html}
\end{Highlighting}
\end{Shaded}

El otro comodín útil es el símbolo \texttt{?}. Esto significa cualquier carácter individual. Entonces, si todos los archivos que queremos borrar tienen la forma \texttt{file-001.html} con los números que van del 1 al 999, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{ file{-}}\PreprocessorTok{???}\NormalTok{.html}
\end{Highlighting}
\end{Shaded}

Esto solo eliminará archivos con ese formato.

Además, podemos combinar comodines. Por ejemplo, para eliminar todos los archivos con el nombre \texttt{file-001} independientemente del sufijo, podemos escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{ file{-}001.}\PreprocessorTok{*}
\end{Highlighting}
\end{Shaded}

\textbf{Advertencia: combinando \texttt{rm} con el comodín \texttt{*} puede ser peligroso. Hay combinaciones de estos comandos que borrarán todo sus sistemas de archivos sin preguntar ``¿está seguro?''. Asegúrense de entender cómo funciona antes de usar este comodín con el comando \texttt{rm}.}

\hypertarget{variables-de-entorno}{%
\subsection{Variables de entorno}\label{variables-de-entorno}}

Unix tiene configuraciones que afectan el \emph{entorno} (\emph{environment} en inglés) de sus líneas de comando. Estas se llaman variables de entorno. El directorio \emph{home} es uno de ellos. De hecho, podemos cambiar algunos de estos. En Unix, las variables se distinguen de otras entidades agregando un \texttt{\$} en le comienzo. El directorio \emph{home} se guarda en \texttt{\$\ HOME}.

Anteriormente vimos que \texttt{echo} es el comando Unix para imprimir. Entonces, podemos ver nuestro directorio \emph{home} al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \VariableTok{$HOME}
\end{Highlighting}
\end{Shaded}

Pueden verlos todos al escribir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{env}
\end{Highlighting}
\end{Shaded}

Pueden cambiar algunas de estas variables del entorno. Pero sus nombres varían según los diferentes \emph{shells}. Describimos los \emph{shells} en la siguiente sección.

\hypertarget{shells}{%
\subsection{\texorpdfstring{\emph{Shells}}{Shells}}\label{shells}}

Mucho lo que usamos en este capítulo es parte de lo que se llama el \emph{Unix shell}. Hay varios \emph{shells} diferentes, aunque estas diferencias son casi imperceptibles. A la vez, son importantes, aunque no los cubrimos aquí. Pueden ver qué \emph{shell} están utilizando escribiendo:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \VariableTok{$SHELL}
\end{Highlighting}
\end{Shaded}

El más común es \texttt{bash}.

Una vez que sepan el \emph{shell} que estan usando, pueden cambiar las variables de entorno. En Bash Shell, lo hacemos usando \texttt{export\ variable\ value}. Para cambiar la ruta, que se describirá con más detalle pronto, escriban: (\textbf{Esto es solo un ejemplo. ¡Asegúrense de no ejecutar este comando!})

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{export} \VariableTok{PATH} \VariableTok{=}\NormalTok{/usr/bin/}
\end{Highlighting}
\end{Shaded}

Hay un programa que se ejecuta cuando usan el terminal donde pueden editar variables para que cambien cada vez que usen el terminal. Esto cambia en diferentes implementaciones, pero si usan bash, pueden crear un archivo llamado \texttt{.bashrc}, \texttt{.bash\_profile},\texttt{.bash\_login} o \texttt{.profile}. Es posible que ya tengan uno.

\hypertarget{ejecutables}{%
\subsection{Ejecutables}\label{ejecutables}}

En Unix, todos los programas son archivos. Se llaman \emph{ejecutables} (\emph{executables} en inglés). Entonces \texttt{ls}, \texttt{mv} y \texttt{git} son todos archivos. ¿Pero dónde están estos archivos de programas? Pueden averiguarlo usando el comando \texttt{which}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{ git}
\CommentTok{\#\textgreater{} /usr/bin/git}
\end{Highlighting}
\end{Shaded}

Ese directorio probablemente está lleno de archivos de programas. El directorio \texttt{/usr/bin} usualmente contiene muchos archivos de programa. Si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{ls/usr/bin}
\end{Highlighting}
\end{Shaded}

en su terminal, verán varios archivos ejecutables.

Hay otros directorios que generalmente contienen archivos de programas. El directorio \emph{Application} en la Mac o \emph{Program Files} en Windows son ejemplos.

Cuando escriben \texttt{ls}, Unix sabe que debe correr un programa que es un ejecutable y que se almacena en algún otro directorio. Entonces, ¿cómo sabe Unix dónde encontrarlo? Esta información se incluye en la variable de entorno \texttt{\$PATH}. Si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \VariableTok{$PATH}
\end{Highlighting}
\end{Shaded}

verán una lista de directorios separados por \texttt{:}. El directorio \texttt{/usr/bin} es probablemente uno de los primeros en la lista.

Unix busca archivos de programas en esos directorios en ese orden. Aunque no lo discutimos aquí, pueden crear ejecutables ustedes mismos. Sin embargo, si lo colocan en su directorio de trabajo y este directorio no está en la ruta, no pueden ejecutarlo simplemente escribiendo el comando. Se evita esto escribiendo la ruta completa. Entonces, si sus comandos se llama \texttt{my-ls}, pueden escribir:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./my{-}ls}
\end{Highlighting}
\end{Shaded}

Una vez que hayan dominado los conceptos básicos de Unix, consideren aprender a escribir sus propios ejecutables, ya que pueden ayudar a reducir el trabajo repetitivo.

\hypertarget{permisos-y-tipos-de-archivo}{%
\subsection{Permisos y tipos de archivo}\label{permisos-y-tipos-de-archivo}}

Si escriben:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls} \AttributeTok{{-}l}
\end{Highlighting}
\end{Shaded}

Al principio, verán una serie de símbolos como este \texttt{-rw-r-\/-r-\/-}. Esta cadena indica el tipo de archivo: archivo normal \texttt{-}, directorio \texttt{d} o ejecutable \texttt{x}. Esta cadena también indica el permiso del archivo: ¿Se puede leer? ¿Se puede cambiar? ¿Es ejecutable? ¿Otros usuarios del sistema pueden leer el archivo? ¿Otros usuarios pueden editar el archivo? ¿Otros usuarios pueden ejecutar si el archivo es ejecutable? Esto es más avanzado que lo que cubrimos aquí, pero pueden aprender mucho más en un libro de referencia de Unix.

\hypertarget{comandos-que-deben-aprender}{%
\subsection{Comandos que deben aprender}\label{comandos-que-deben-aprender}}

Hay muchos comandos que no discutimos en detalle en este libro, pero queremos darles un poco de información sobre ellos y lo que hacen. Son:

\begin{itemize}
\item
  \emph{open/start} - En la Mac, \texttt{open\ filename} intenta averiguar la aplicación correcta del nombre de archivo y abrirlo con esa aplicación. Este es un comando muy útil. En Git Bash, pueden tratar \texttt{start\ filename}. Intenten abrir un archivo \texttt{R} o \texttt{Rmd} con \texttt{open} o \texttt{start}: deberían abrirlo con RStudio.
\item
  \emph{nano}: Un editor de texto básico.
\item
  \emph{ln}: Crea un enlace simbólico. No recomendamos su uso, pero deben estar familiarizados con él.
\item
  \emph{tar}: Archiva archivos y subdirectorios de un directorio en un solo archivo.
\item
  \emph{ssh}: Se conecta a otra computadora.
\item
  \emph{grep}: Busca patrones en un archivo.
\item
  \emph{awk/sed}: Estos son dos comandos muy útiles que les permite encontrar cadenas específicas en archivos y cambiarlas.
\end{itemize}

\hypertarget{manipulaciuxf3n-de-archivos-en-r}{%
\subsection{Manipulación de archivos en R}\label{manipulaciuxf3n-de-archivos-en-r}}

También podemos realizar el manejo de archivos desde R. Las funciones claves para aprender se pueden ver mirando el archivo de ayuda para
\texttt{?files}. Otra función útil es \texttt{unlink}.

Aunque generalmente no lo recomendamos, tengan en cuenta que pueden ejecutar comandos de Unix en R usando \texttt{system}.

\hypertarget{git}{%
\chapter{Git y GitHub}\label{git}}

Aquí proveemos algunos detalles sobre Git y GitHub. Sin embargo, solo estamos rascando la superficie. Para obtener más información sobre este tema, recomendamos los siguientes recursos:

\begin{itemize}
\tightlist
\item
  Codeacademy: \url{https://www.codecademy.com/learn/learn-git}
\item
  Guías de GitHub: \url{https://guides.github.com/activities/hello-world/}
\item
  Try Git tutorial: \url{https://try.github.io/levels/1/challenges/1}
\item
  Happy Git y GitHub para el useR: \href{http://happygitwithr.com/}{http://happygitwithr.com}
\end{itemize}

\hypertarget{por-quuxe9-usar-git-y-github}{%
\section{¿Por qué usar Git y GitHub?}\label{por-quuxe9-usar-git-y-github}}

Hay tres razones principales para usar Git y GitHub.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Compartir: Incluso si no aprovechamos la funcionalidad avanzada y útiles de control de versiones, aún podemos usar Git y GitHub para compartir nuestro código.
\item
  Colaboración: Una vez que configuren un repositorio central, pueden hacer que varias personas realicen cambios en el código y mantengan las versiones sincronizadas. GitHub ofrece un servicio gratuito para repositorios centralizados. GitHub también tiene una herramienta, llamada \emph{pull request}, que cualquier persona puede usar para sugerir cambios a su código. Pueden aceptar o rechazar fácilmente la recomendación.
\item
  Control de versiones: Las capacidades de control de versiones de Git nos permite darle seguimiento a los cambios que realizamos en nuestro código. Además, podemos volver a las versiones anteriores de los archivos. Git también nos permite crear \emph{branches} en las que podemos probar ideas, luego decidir si fusionamos (\emph{merge} en inglés) la nueva rama con la original.
\end{enumerate}

Aquí nos enfocamos en los aspectos de uso compartido de Git y GitHub y remitimos al lector a los enlaces anteriores para obtener más información sobre esta herramienta útil.

\hypertarget{cuentas-github}{%
\section{Cuentas GitHub}\label{cuentas-github}}

Después de instalar git\footnote{\url{https://rafalab.github.io/dsbook/accessing-the-terminal-and-installing-git.html}}, el primer paso es obtener una cuenta de GitHub. Las cuentas básicas de GitHub son gratuitas. Para hacer esto, vayan a \href{http://github.com}{GitHub.com} donde verán un cuadro en el que pueden registrarse.

Quieren escoger un nombre con cuidado. Debe ser breve, fácil de recordar y deletrear, relacionado de alguna manera con su nombre y, por supuesto, profesional. Este último es importante ya que podrían estar enviando enlaces a sus cuentas de GitHub a posibles empleadores. En el siguiente ejemplo, sacrifico la facilidad de deletreo para incorporar mi nombre. Sus iniciales y apellidos suelen ser una buena opción. Si tienen un nombre muy común, es posible que tengan que tomar eso en cuenta. Una solución sencilla sería agregar números o deletrear parte de su nombre.

La cuenta que uso para mi investigación, \emph{rafalab}, es la misma que uso para mi página web\footnote{\url{http://rafalab.org}} y Twitter\footnote{\url{http://twitter.com/rafalab}}, que lo hace fácil de recordar para los que siguen mi trabajo.

Una vez que tengan una cuenta de GitHub, estarán listos para conectar Git y RStudio a esta cuenta.

Un primer paso es dejar que Git sepa quiénes somos. Esto facilitará la conexión con GitHub. Comenzamos abriendo una ventana de terminal en RStudio (recuerden que pueden obtener una a través de \emph{Tools} en la barra de menú). Ahora usamos el comando \texttt{git\ config} para decirle a Git quiénes somos. Escribiremos los siguientes dos comandos en nuestra ventana de terminal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ config }\AttributeTok{{-}{-}global}\NormalTok{ user.name }\StringTok{"Your Name"}
\FunctionTok{git}\NormalTok{ config }\AttributeTok{{-}{-}global}\NormalTok{ user.mail }\StringTok{"your@email.com"}
\end{Highlighting}
\end{Shaded}

Deben usar la cuenta de correo electrónico que utilizaron para abrir su cuenta de GitHub. La sesión de RStudio debería verse así:

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_30_19} \end{center}

Empiecen yendo a \emph{Global Options}, seleccionando \emph{Git/SVN}
y luego ingresando una ruta para el ejecutable de Git que acabamos de instalar.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_14_13} \end{center}

En la instalación predeterminada de Windows, la ruta será \emph{C:/Program File/Git/bin/git.exe}, pero deben encontrarla explorando su sistema, ya que esto puede cambiar de un sistema a otro. Ahora, para evitar ingresar nuestra contraseña de GitHub cada vez que intentemos acceder a nuestro repositorio, crearemos lo que se llama una \emph{SSH RSA Key}. RStudio puede hacer esto por nosotros automáticamente si hacemos clic en el botón \emph{Create RSA Key}:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_14_14} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_14_15} \end{center}

Pueden seguir las instrucciones predeterminadas como se muestra a continuación:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_14_16} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_14_17} \end{center}

Git, RStudio y GitHub ahora deben poder conectarse y estamos listos para crear un primer repositorio de código de GitHub.

\hypertarget{github-repos}{%
\section{Repositorios de GitHub}\label{github-repos}}

Ya pueden crear un repositorio o ``repo'' de GitHub. La idea general es tener al menos dos copias de su código: una copia en sus computadoras y otra en GitHub. Si añaden colaboradores a este proyecto, cada uno tendrá una copia en su computadora. La copia de GitHub generalmente se considera la copia \emph{main} (antes llamada \emph{master}) con la que se sincroniza cada colaborador. Git les ayudará a mantener sincronizadas todas las copias diferentes.

Como se mencionó anteriormente, una de las ventajas de mantener el código en un repositorio de GitHub es que pueden compartirlo fácilmente con posibles empleadores interesados en ver ejemplos de su trabajo. Debido a que muchas compañías de ciencia de datos usan sistemas de control de versiones, como Git, para colaborar en proyectos, también pueden estar impresionadas de que ya conocen al menos los conceptos básicos.

El primer paso para crear un repositorio para su código es inicializar en GitHub. Como ya crearon una cuenta, tendrán una página en GitHub con el URL \texttt{http://github.com/username}.

Para crear un repositorio, primero inicien una sesión en su cuenta haciendo clic en el botón \emph{Sign In} en \href{http://github.com}{https://github.com}. Es posible que ya hayan iniciado una sesión, en cuyo caso el botón \emph{Sign In} no aparecerá.
Si inician sesión, deben ingresar su nombre de usuario y contraseña. Le recomendamos que configuren su navegador para recordar esto y evitar escribirlo cada vez.

Una vez en sus cuentas, pueden hacer clic en \emph{Repositories} y luego hacer clic en \emph{New} para crear un nuevo repositorio:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_23_39} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_23_40} \end{center}

Entonces querrán elegir un buen nombre descriptivo para el proyecto. En el futuro, es posible que tengan docenas de repositorios, así que tomen esto en cuenta al elegir un nombre. Aquí usaremos \texttt{homework-0}. Le recomendamos que hagan público el repositorio. Si prefieren mantenerlo en privado, tendrán que pagar un cargo mensual.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_23_42} \end{center}

Ahora tienen su primer repositorio en GitHub. El siguiente paso será \emph{clonarlo} (\emph{clone it} en inglés) en su computadora y comenzar a editar y sincronizar usando Git.

Para hacer esto, es conveniente copiar el enlace proporcionado por GitHub específicamente para conectarse a este repositorio, usando Git como se muestra a continuación. Más tarde, necesitaremos copiar y pegar esto, así que asegúrense de recordar este paso.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_24_19} \end{center}

\hypertarget{git-overview}{%
\section{Descripción general de Git}\label{git-overview}}

Las principales acciones en Git son:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{pull}: Jalar/tirar cambios desde el repositorio remoto, en este caso el repositorio de GitHub.
\item
  \textbf{add}: Añadir archivos o, como decimos en la jerga de Git, \emph{stage} los archivos.
\item
  \textbf{commit}: Asignar cambios al repositorio local.
\item
  \textbf{push}: Empujar cambios al repositorio \emph{remote}, en nuestro caso el repositorio GitHub.
\end{enumerate}

Para permitir efectivamente el control de versiones y la colaboración en Git, los archivos se mueven a través de cuatro áreas diferentes:

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-layout} \end{center}

Pero, ¿cómo comienza todo? Hay dos formas: podemos clonar un repositorio existente o inicializar uno. Exploraremos la clonación primero.

\hypertarget{clonar}{%
\subsection{Clonar}\label{clonar}}

Vamos a \emph{clonar} un \emph{Upstream Repository} existente. Pueden verlo en GitHub aquí: \url{https://github.com/rairizarry/murders}. Al visitar esta página, pueden ver varios archivos y directorios. Estos son el \emph{Upstream Repository}. Al hacer clic en el botón verde de clonar, podemos copiar el URL del repositorio: \texttt{https://github.com/rairizarry/murders.git}.

Pero, ¿qué significa \emph{clonar}? En lugar de descargar todos estos archivos a su computadora, vamos a copiar toda la estructura de Git, que significa que agregaremos los archivos y directorios a cada una de las tres etapas locales: \emph{Working Directory}, \emph{Staging Area} y \emph{Local Repository}. Cuando clonan, estos tres son exactamente iguales en el comienzo.

Pueden ver rápidamente un ejemplo de esto haciendo lo siguiente. Abran una terminal y escriban:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{pwd}
\FunctionTok{mkdir}\NormalTok{ git{-}example}
\BuiltInTok{cd}\NormalTok{ git{-}example}
\FunctionTok{git}\NormalTok{ clone https://github.com/rairizarry/murders.git}
\BuiltInTok{cd}\NormalTok{ murders}
\CommentTok{\#\textgreater{} /Users/rafa/myDocuments/teaching/data{-}science/dslibro}
\CommentTok{\#\textgreater{} Cloning into \textquotesingle{}murders\textquotesingle{}...}
\end{Highlighting}
\end{Shaded}

Ahora han clonado un repositorio de GitHub y tienen un directorio de trabajo de Git, con todos los archivos, en su sistema.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}
\CommentTok{\#\textgreater{} README.txt}
\CommentTok{\#\textgreater{} analysis.R}
\CommentTok{\#\textgreater{} data}
\CommentTok{\#\textgreater{} download{-}data.R}
\CommentTok{\#\textgreater{} murders.Rproj}
\CommentTok{\#\textgreater{} rdas}
\CommentTok{\#\textgreater{} report.Rmd}
\CommentTok{\#\textgreater{} report.md}
\CommentTok{\#\textgreater{} report\_files}
\CommentTok{\#\textgreater{} wrangle{-}data.R}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-clone} \end{center}

El \emph{Working Directory} es el mismo que el directorio de trabajo de Unix. Cuando editan archivos usando un editor como RStudio, cambian los archivos en esta área y solo en esta área. Git puede decirles cómo se relacionan estos archivos con las versiones de los archivos en otras áreas con el comando \texttt{git\ status}:

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-status} \end{center}

Si verifican el estatus ahora, verán que nada ha cambiado y recibirán el siguiente mensaje:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ status}
\CommentTok{\#\textgreater{} On branch master}
\CommentTok{\#\textgreater{} Your branch is up to date with \textquotesingle{}origin/master\textquotesingle{}.}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} nothing to commit, working tree clean}
\end{Highlighting}
\end{Shaded}

Ahora vamos a hacer cambios en estos archivos. Eventualmente, queremos que estas nuevas versiones de los archivos sean rastreadas y sincronizadas con el \emph{Upstream Repository}. Pero no queremos darle seguimiento a cada cambio pequeño: no queremos sincronizar hasta que estemos seguros de que estas versiones son lo suficientemente finales como para compartirlas. Por esta razón, el sistema de control de versiones no guarda las ediciones en el \emph{Staging Area}.

Para demostrar, agregamos un archivo al \emph{Staging Area} con el comando \texttt{git\ add}. A continuación creamos un archivo usando el comando de Unix \texttt{echo} solo como ejemplo (normalmente usarían RStudio):

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"test"} \OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ new{-}file.txt}
\end{Highlighting}
\end{Shaded}

También estamos agregando un archivo temporero del cual que no queremos llevar cuenta:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"temporary"} \OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ tmp.txt}
\end{Highlighting}
\end{Shaded}

Ahora podemos organizar el archivo que finalmente queremos agregar a nuestro repositorio:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ add new{-}file.txt}
\end{Highlighting}
\end{Shaded}

Observen lo que dice el estatus ahora:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ status}
\CommentTok{\#\textgreater{} On branch master}
\CommentTok{\#\textgreater{} Your branch is up to date with \textquotesingle{}origin/master\textquotesingle{}.}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Changes to be committed:}
\CommentTok{\#\textgreater{}   (use "git restore {-}{-}staged \textless{}file\textgreater{}..." to unstage)}
\CommentTok{\#\textgreater{}  new file:   new{-}file.txt}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} Untracked files:}
\CommentTok{\#\textgreater{}   (use "git add \textless{}file\textgreater{}..." to include in what will be committed)}
\CommentTok{\#\textgreater{}  tmp.txt}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-add} \end{center}

Como \texttt{new-file.txt} está \emph{staged}, la versión actual del archivo se agregará al repositorio local la próxima vez que decidimos \emph{commit}, que hacemos de la siguiente manera:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}m} \StringTok{"adding a new file"}
\CommentTok{\#\textgreater{} [master 5f51e8a] adding a new file}
\CommentTok{\#\textgreater{}  1 file changed, 1 insertion(+)}
\CommentTok{\#\textgreater{}  create mode 100644 new{-}file.txt}
\end{Highlighting}
\end{Shaded}

Ahora hemos cambiado el repositorio local, que pueden confirmar usando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ status}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img///git/git-commit} \end{center}

Sin embargo, si volvemos a editar ese archivo, solo cambia en el directorio de trabajo. Para agregar al repositorio local, necesitamos añadirlo y \emph{commit} los cambios que se agregan al repositorio local:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"adding a line"} \OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ new{-}file.txt}
\FunctionTok{git}\NormalTok{ add new{-}file.txt}
\FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}m} \StringTok{"adding a new line to new{-}file"}
\CommentTok{\#\textgreater{} [master 6b5314c] adding a new line to new{-}file}
\CommentTok{\#\textgreater{}  1 file changed, 1 insertion(+)}
\end{Highlighting}
\end{Shaded}

Tengan en cuenta que este paso a menudo es innecesario en nuestros usos de Git. Podemos omitir la parte de preparación si agregamos el nombre del archivo al comando \emph{commit} de esta manera:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"adding a second line"} \OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ new{-}file.txt}
\FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}m} \StringTok{"minor change to new{-}file"}\NormalTok{ new{-}file.txt}
\CommentTok{\#\textgreater{} [master d7da6d9] minor change to new{-}file}
\CommentTok{\#\textgreater{}  1 file changed, 1 insertion(+)}
\end{Highlighting}
\end{Shaded}

Podemos darle seguimiento a todos los cambios que hemos realizado con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ log new{-}file.txt}
\CommentTok{\#\textgreater{} commit d7da6d9d4ea1c3f27c2287fc8974e775b7f2bfca}
\CommentTok{\#\textgreater{} Author: Rafael A. Irizarry \textless{}rairizarry@gmail.com\textgreater{}}
\CommentTok{\#\textgreater{} Date:   Mon May 24 08:18:45 2021 {-}0400}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{}     minor change to new{-}file}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} commit 6b5314c6005d1bd14415d7bfdf38d1e1abb0635b}
\CommentTok{\#\textgreater{} Author: Rafael A. Irizarry \textless{}rairizarry@gmail.com\textgreater{}}
\CommentTok{\#\textgreater{} Date:   Mon May 24 08:18:44 2021 {-}0400}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{}     adding a new line to new{-}file}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} commit 5f51e8a15fa862b019a3692c1cb7a06e4210174e}
\CommentTok{\#\textgreater{} Author: Rafael A. Irizarry \textless{}rairizarry@gmail.com\textgreater{}}
\CommentTok{\#\textgreater{} Date:   Mon May 24 08:18:44 2021 {-}0400}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{}     adding a new file}
\end{Highlighting}
\end{Shaded}

Para mantener todo sincronizado, el paso final es impulsar los cambios al \emph{Upstream Repository}. Esto se hace con el comando \texttt{git\ push} así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ push}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-push} \end{center}

Sin embargo, en este ejemplo particular, no podrán hacerlo porque no tienen permiso para editar el \emph{Upstream Repository}. Si este fuera su repositorio, podrían.

Si este es un proyecto colaborativo, el \emph{Upstream Repository} puede cambiar y volverse diferente a nuestra versión. Para actualizar nuestro repositorio local para que sea como el \emph{Upstream Repository}, usamos el comando \texttt{fetch}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ fetch}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-fetch} \end{center}

Y entonces para hacer estos cambios al \emph{Staging Area} y \emph{Working Directory}, utilizamos el comando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ merge}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-merge} \end{center}

No obstante, a menudo solo queremos cambiar ambos con un solo comando. Para esto, utilizamos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ pull}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//git/git-pull} \end{center}

Aprenderemos en la Sección \ref{rstudio-git} cómo RStudio tiene botones para hacer todo esto. Los detalles ofrecidos aquí les ayuda a entender lo que sucede en el trasfondo.

\hypertarget{init}{%
\section{Inicializando un directorio Git}\label{init}}

Ahora exploremos la segunda manera en que podemos comenzar: inicializando un directorio en nuestra propia computadora en lugar de clonar.

Supongan que ya tenemos un directorio local con archivos y queremos convertir este directorio en un repositorio colaborativo de GitHub. La forma más eficiente de lograr esto es \emph{inicializando} el directorio local.

Para demostrar cómo hacer esto, inicializaremos el directorio de asesinatos con armas de fuego que creamos en la Sección \ref{prep-project}. Tengan en cuenta que ya creamos un directorio con varios subdirectorios en nuestra computadora, pero aún no tenemos un repositorio local de Git o un \emph{Upstream Repository} de GitHub.

Comenzamos creando un nuevo repositorio en nuestra página de GitHub. Hacemos clic en el botón \emph{New}:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_25} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_26} \end{center}

Lo llamamos \texttt{murders} aquí para que coincida con el nombre del directorio en nuestro sistema local. Pero si están haciendo esto para otro proyecto, elijan un nombre apropiado.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_27} \end{center}

Luego obtenemos una serie de instrucciones sobre cómo comenzar, pero en su lugar podemos usar lo que hemos aprendido. Lo principal que necesitamos de esta página es copiar el URL del repositorio, en este caso: \texttt{https://github.com/rairizarry/murders.git}.

En este momento, podemos abrir un terminal y \texttt{cd} a nuestro directorio de proyectos locales. En nuestro ejemplo, sería:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/projects/murders}
\end{Highlighting}
\end{Shaded}

Entonces, \emph{inicializamos} el directorio. Esto convierte el directorio en un directorio Git y Git comienza a llevar cuenta:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ init}
\end{Highlighting}
\end{Shaded}

Todos los archivos ahora están \textbf{solo} en nuestro directorio de trabajo; no hay archivos en nuestro repositorio local o en GitHub.

El siguiente paso es conectar el repositorio local con el repositorio de GitHub. En un ejemplo anterior, hicimos que RStudio hiciera esto por nosotros. Ahora tenemos que hacerlo nosotros mismos. Podemos agregar cualquiera de los archivos y hacer \emph{commit}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ add README.txt}
\FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}m} \StringTok{"First commit. Adding README.txt file just to get started"}
\end{Highlighting}
\end{Shaded}

Ahora tenemos un archivo en nuestro repositorio local y podemos conectarlo al \emph{Upstream Repository}, que tiene URL: \texttt{https://github.com/rairizarry/murders.git}.

Para hacer esto, usamos el comando \texttt{git\ remote\ add}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ remote add origin }\KeywordTok{\textasciigrave{}}\ExtensionTok{https://github.com/rairizarry/murders.git}\KeywordTok{\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

Ahora podemos usar \texttt{git\ push} ya que hay una conexión a un \emph{Upstream Repository}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ push}
\end{Highlighting}
\end{Shaded}

En la Sección \ref{organizing}, continuamos trabajando con este ejemplo, mientras demostramos cómo podemos usar RStudio para trabajar con Git y mantener un proyecto sincronizado en GitHub.

\hypertarget{rstudio-git}{%
\section{Usando Git y GitHub en RStudio}\label{rstudio-git}}

Si bien la línea de comandos Git es una herramienta eficaz y flexible, puede ser algo desalentador cuando estamos comenzando. RStudio proporciona una interfaz gráfico que facilita el uso de Git en el contexto de un proyecto de análisis de datos. Describimos cómo usar este atributo de RStudio para hacer esto aquí.

Ahora estamos listos para comenzar un proyecto de RStudio que usa control de versiones y almacena el código en un repositorio de GitHub. Para hacer esto, comenzamos un proyecto pero, en lugar de \emph{New Directory}, seleccionaremos \emph{Version Control} y luego seleccionaremos \emph{Git} como nuestro sistema de control de versiones:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_30_35} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_30_43} \end{center}

El URL del repositorio es el enlace que usaron para clonar. En la Sección \ref{github-repos}, usamos \texttt{https://github.com/username/homework-0.git} como ejemplo. En el nombre del directorio del proyecto, deben poner el nombre de la carpeta que se generó, que en nuestro ejemplo será el nombre del repositorio \texttt{homework-0}. Esto creará una carpeta llamada \texttt{homework-0} en su sistema local. Una vez que hagan esto, se crea el proyecto y está al tanto de la conexión a un repositorio de GitHub. Verán en la esquina superior derecha el nombre y el tipo de proyecto, así como una nueva pestaña en el panel superior derecho titulada \emph{Git}.

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_31_10} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_31_11} \end{center}

Si seleccionan esta pestaña, les mostrará los archivos de sus proyectos con algunos iconos que le brindan información sobre estos archivos y su relación con el repositorio. En el ejemplo a continuación, ya agregamos un archivo a la carpeta, llamado \emph{code.R}, que pueden ver en el panel para editar.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_34_06} \end{center}

Ahora debemos prestar atención al panel Git. Es importante saber que \textbf{sus archivos locales y el repositorio de GitHub no se sincronizarán automáticamente}. Como se describe en la Sección \ref{git-overview}, deben sincronizar usando git push cuando estén listos. A continuación, les mostramos que pueden hacerlo a través de RStudio en lugar del terminal.

Antes de comenzar a trabajar en un proyecto colaborativo, generalmente lo primero que hacemos es \emph{pull} los cambios desde el repositorio remoto, en nuestro caso el de GitHub. Sin embargo, para el ejemplo que se muestra aquí, dado que estamos comenzando con un repositorio vacío y somos los únicos que hacemos cambios, no tenemos que comenzar con \emph{pull}.

En RStudio, el status del archivo en relación con los repositorios remotos y locales se representa en los símbolos de status con colores. Un cuadrado amarillo significa que Git no sabe nada sobre este archivo. Para sincronizar con el repositorio de GitHub, necesitamos \emph{add} el archivo, luego \emph{commit} el cambio a nuestro repositorio de Git local y entonces \emph{push} el cambio al repositorio de GitHub. En este momento, el archivo está en nuestra computadora. Para añadir el archivo usando RStudio, hacemos clic en la caja \emph{Stage}. Verán que el ícono de status ahora cambia a una A verde.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_51_31} \end{center}

Nota: solo estamos añadiendo el archivo \emph{code.R}. No necesariamente tenemos que añadir todos los archivos de nuestro repositorio local al repositorio de GitHub, solo los que queremos darle seguimiento o los que queremos compartir. Si nuestro trabajo está produciendo archivos de cierto tipo a los que no queremos darle seguimiento, podemos agregar el sufijo que define estos archivos al archivo .gitignore. Aquí pueden ver más detalles sobre el uso de .gitignore: \url{https://git-scm.com/docs/gitignore}. Estos archivos dejarán de aparecer en su panel RStudio Git. Para el ejemplo que se muestra aquí, solo agregaremos \emph{code.R}. Pero, en general, para un proyecto de RStudio, recomendamos agregar los archivos .gitignore y .Rproj.

Ahora estamos listos para enviar el archivo a nuestro repositorio local. En RStudio, podemos usar el botón \emph{Commit}. Esto abrirá una nueva ventana de diálogo. Con Git, cada vez que hacemos \emph{commit} a un cambio, debemos ingresar un comentario que describe los cambios.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_51_54} \end{center}

En este caso, simplemente escribimos que estamos agregando un nuevo script. En este ventana de diálogo, RStudio también le ofrece un resumen de lo que está cambiando al repositorio de GitHub. Aquí, como es un archivo nuevo, todo el archivo se resalta en verde, que resalta los cambios.

Una vez que presionen el botón \emph{Commit}, deben ver un mensaje de Git con un resumen de los cambios que se confirmaron. Ahora estamos listos para empujar estos cambios al repositorio de GitHub. Podemos hacer esto haciendo clic en el botón \emph{Push} en la esquina superior derecha:

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_52_05} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_52_17} \end{center}

Ahora vemos un mensaje de Git que nos dice que el \emph{push} ha sido exitoso.
En la ventana emergente ya no vemos el archivo \texttt{code.R}. Esto se debe a que no se han realizado nuevos cambios desde la última vez que hicimos \emph{push}. Podemos salir de esta ventana emergente ahora y continuar trabajando en nuestro código.

\begin{center}\includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_52_35} \includegraphics[width=0.45\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_52_44} \end{center}

Si ahora visitamos nuestro repositorio en la web, veremos que coincide con nuestra copia local.

\begin{center}\includegraphics[width=0.5\linewidth]{/Users/rafa/myDocuments/teaching/data-science/dslibro/productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_09} \end{center}

¡Felicitaciones, han compartido código con éxito en un repositorio de GitHub!

\hypertarget{proyectos-reproducibles-con-rstudio-y-r-markdown}{%
\chapter{Proyectos reproducibles con RStudio y R Markdown}\label{proyectos-reproducibles-con-rstudio-y-r-markdown}}

El producto final de un proyecto de análisis de datos frecuentemente es un informe. Muchas publicaciones científicas pueden considerarse como un informe final de un análisis de datos. Lo mismo es cierto para los artículos de noticias basados en datos, un informe de análisis para su empresa o notas para una clase sobre cómo analizar datos. Los informes suelen estar en papel o en un PDF que incluyen una descripción textual de los resultados junto con algunos gráficos y tablas resultantes del análisis.

Imaginen que después de finalizar el análisis y el informe, les informan que les dieron el set de datos incorrecto, les enviarán uno nuevo y les piden que ejecuten el mismo análisis con este nuevo set de datos. ¿O qué pasa si se dan cuenta de que cometieron un error y necesitan volver a examinar el código, corregir el error y volver a ejecutar el análisis? ¿O supongan que alguien a quien están entrenando quiere ver el código y poder reproducir los resultados para conocer su enfoque?

Situaciones como las que acabamos de describir son bastante comunes para los científicos de datos. Aquí, describimos cómo pueden mantener sus proyectos de ciencia de datos organizados con RStudio para que el proceso de volver a ejecutar un análisis sea sencillo. Luego, demostraremos cómo generar informes reproducibles con R Markdown y el paquete \textbf{knitR} de una manera que ayudará enormemente a recrear informes con esfuerzo mínimo. Esto es posible debido a que los documentos de R Markdown permiten combinar códigos y descripciones textuales en el mismo documento, y las figuras y tablas producidas por el código se agregan automáticamente al documento.

\hypertarget{proyectos-de-rstudio}{%
\section{Proyectos de RStudio}\label{proyectos-de-rstudio}}

RStudio ofrece una manera de mantener todos los componentes de un proyecto de análisis de datos organizados en una carpeta y mantener un registro de la información sobre este proyecto, como el estatus Git de los archivos, en un archivo. En la Sección \ref{rstudio-git}, demostramos cómo RStudio facilita el uso de Git y GitHub a través de proyectos de RStudio. En esta sección, demostramos cómo comenzar un nuevo proyecto y ofrecemos algunas recomendaciones sobre cómo mantenerlo organizado. Los proyectos de RStudio también les permiten tener abiertas varias sesiones de RStudio y mantener un registro de cuál es cuál.

Para comenzar un proyecto, hagan clic en \emph{File} y luego en \emph{New Project}. Muchas veces ya hemos creado una carpeta para guardar el trabajo, como lo hicimos en la Sección \ref{prep-project}, en cual caso seleccionamos \emph{Existing Directory}. Aquí les mostramos un ejemplo
en el que aún no hemos creado una carpeta y seleccionamos la opción \emph{New Directory}.

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_20_21} \includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_20_28} \end{center}

Entonces para un proyecto de análisis de datos, generalmente seleccionan la opción \emph{New Project}:

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_20_35} \end{center}

Ahora tendrán que decidir la ubicación de la carpeta que se asociará con su proyecto, así como el nombre de la carpeta. Al igual que con los nombres de archivo, cuando eligen un nombre de carpeta, aasegúrense de que sea un nombre significativo que los ayude a recordar de qué se trata el proyecto. Además, al igual que con los archivos, recomendamos usar letras minúsculas, sin espacios y con guiones para separar las palabras. Llamaremos a la carpeta para este proyecto \emph{my-first-project}. Esto generará un archivo \emph{Rproj} llamado \emph{my-first-project.Rproj} en la carpeta asociada con el proyecto. Veremos cómo esto es útil más abajo.

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_21_09} \end{center}

Les dará opciones sobre dónde debe estar esta carpeta en su sistema de archivos. En este ejemplo, lo colocaremos en nuestra carpeta de inicio, aunque esto generalmente no es una buena práctica. Como describimos en la Sección \ref{prep-project} en el capítulo de Unix, quieren organizar su sistema de archivos siguiendo un enfoque jerárquico y con una carpeta llamada \emph{proyectos} donde guardarán una carpeta para cada proyecto.

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_21_56} \end{center}

Cuando comiencen a usar RStudio con un proyecto, verán el nombre del proyecto en la esquina superior izquierda. Esto les recordará a qué proyecto pertenece esta sesión de RStudio en particular. Cuando abran una sesión de RStudio sin ningún proyecto, dirá \emph{Project:(None)}.

Al trabajar en un proyecto, todos los archivos se guardarán y se buscarán en la carpeta asociada con el proyecto. A continuación, mostramos un ejemplo de un \emph{script} que escribimos y guardamos con el nombre \emph{code.R}. Como usamos un nombre significativo para el proyecto, podemos ser un poco menos informativos cuando nombramos los archivos. Aunque no lo hacemos aquí, pueden tener varios \emph{scripts} abiertos a la vez. Simplemente necesitan hacer clic en \emph{File}, luego en \emph{New File} y entonces elegir el tipo de archivo que desean editar.

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_23_26} \end{center}

Una de las principales ventajas de usar \emph{Projects} es que después de cerrar RStudio, si deseamos continuar donde pausamos, simplemente hacemos doble clic o abrimos el archivo guardado cuando creamos el proyecto de RStudio. En este caso, el archivo se llama \emph{my-first-project.Rproj}. Si lo abrimos, RStudio se iniciará y abrirá los \emph{scripts} que estábamos editando.

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_24_08} \includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_09_24_21} \end{center}

Otra ventaja es que si hacen clic en dos o más archivos diferentes de Rproj, iniciará nuevas sesiones de RStudio y R para cada uno.

\hypertarget{r-markdown}{%
\section{R Markdown}\label{r-markdown}}

R Markdown es un formato para documentos de \emph{programación literaria} (\emph{literate programming} en inglés). Se basa en \emph{markdown}, un lenguaje de \emph{markup} que se usa ampliamente para generar páginas HTML\footnote{\url{https://www.markdowntutorial.com/}}. La programación literaria teje instrucciones, documentación y comentarios detallados entre el código ejecutable de la máquina, produciendo un documento que describe el programa que es mejor para la comprensión humana (Knuth 1984). A diferencia de un procesador de textos, como Microsoft Word, donde lo que ven es lo que obtienen, con R Markdown, necesitan \emph{compilar} el documento en el informe final. El documento de R Markdown se ve diferente al producto final. De primer instancia, esto puede parecer una desventaja. Sin embargo, no lo es ya que en vez de producir gráficos e insertarlos uno por uno en el documento de procesamiento de texto, los gráficos se agregan automáticamente.

En RStudio, puede iniciar un documento de R Markdown haciendo clic en \emph{File}, \emph{New File} y entonces \emph{R Markdown}. Luego se les pedirá que ingresen un título y un autor para su documento. Vamos a preparar un informe sobre asesinatos con armas de fuego, por lo que le daremos un nombre apropiado. También pueden escoger el formato del informe final: HTML, PDF o Microsoft Word. Más adelante, podemos cambiar esto fácilmente, pero aquí seleccionamos HTML ya que es el formato preferido para propósitos de depuración:

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_18} \includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_19} \end{center}

Esto generará un archivo de plantilla:

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_20} \end{center}

Como convención, usamos el sufijo \texttt{Rmd} para estos archivos.

Una vez que tengan más experiencia con R Markdown, podrán hacer esto sin la plantilla y simplemente comenzarán desde una plantilla en blanco.

En la plantilla, verán varias cosas para considerar.

\hypertarget{el-encabezado}{%
\subsection{El encabezado}\label{el-encabezado}}

En la parte superior ven:

\begin{verbatim}
---
title: "Report on Gun Murders"
author: "Rafael Irizarry"
date: "April 16, 2018"
output: html_document
---
\end{verbatim}

Todo lo que está entre \texttt{-\/-\/-} es el encabezado. No necesitamos un encabezado, pero a menudo es útil. Pueden definir muchas otras cosas en el encabezado además de lo que se incluye en la plantilla. No discutimos esos aquí, pero hay mucha información disponible en línea. El único parámetro que destacaremos es \texttt{output}. Al cambiar esto a, por ejemplo, \texttt{pdf\_document}, podemos controlar el tipo de \emph{output} que se produce cuando compilamos.

\hypertarget{fragmentos-de-cuxf3digo-r}{%
\subsection{Fragmentos de código R}\label{fragmentos-de-cuxf3digo-r}}

En varios lugares del documento, vemos algo como lo siguiente:

\begin{verbatim}
```{r}
summary(pressure)
```
\end{verbatim}

Estos son fragmentos de código. Cuando compilan el documento, el código R dentro del fragmento, en este caso \texttt{summary(pressure)}, será evaluado y el resultado incluido en esa posición en el documento final.

Para añadir sus propios fragmentos de R, pueden escribir los caracteres de arriba rápidamente con la combinación de teclas opción-I en Mac y Ctrl-Alt-I en Windows.

Esto aplica también a los gráficos; el gráfico se colocará en esa posición. Podemos escribir algo como esto:

\begin{verbatim}
```{r}
plot(pressure)
```
\end{verbatim}

Por defecto, el código también aparecerá. Para evitar esto, pueden usar el argumento \texttt{echo=FALSE}. Por ejemplo:

\begin{verbatim}
```{r echo=FALSE}
summary(pressure)
```
\end{verbatim}

Recomendamos acostumbrarse a añadir una etiqueta a los fragmentos de código R. Esto será muy útil al depurar, entre otras situaciones. Para hacer esto, agreguen una palabra descriptiva como esta:

\begin{verbatim}
```{r pressure-summary}
summary(pressure)
```
\end{verbatim}

\hypertarget{opciones-globales}{%
\subsection{Opciones globales}\label{opciones-globales}}

Uno de los fragmentos de R contiene una llamada que parece complicada:

\begin{verbatim}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
\end{verbatim}

No cubriremos esto aquí, pero a medida que tengan más experiencia con R Markdown, aprenderán las ventajas de establecer opciones globales para el proceso de compilación.

\hypertarget{knitr}{%
\subsection{knitR}\label{knitr}}

Usamos el paquete \textbf{knitR} para compilar documentos de R Markdown. La función específica utilizada para compilar es \texttt{knit}, que toma un nombre de archivo como entrada. RStudio provee un botón que facilita la compilación del documento. En la siguiente captura de pantalla, hemos editado el documento para que se produzca un informe sobre asesinatos con armas de fuego. Pueden ver el archivo aquí: \url{https://raw.githubusercontent.com/rairizarry/murders/master/report.Rmd}. Ahora pueden hacer clic en el botón \emph{Knit}:

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_21.0} \end{center}

La primera vez que hacen clic en el botón \emph{Knit}, puede aparecer un cuadro de diálogo pidiéndoles que instalen los paquetes que necesitan.

Una vez que hayan instalado los paquetes, al hacer clic en \emph{Knit} se compilará su archivo de R Markdown y emergerá el documento resultante.

Esto produce un documento HTML que pueden ver en su directorio de trabajo. Para verlo, abran un terminal y enumeren los archivos. Pueden abrir el archivo en un navegador y usarlo para presentar su análisis. Además, pueden producir un documento PDF o de Microsoft cambiando:

\texttt{output:\ html\_document} a \texttt{output:\ pdf\_document} o \texttt{output:\ word\_document}.

También podemos producir documentos que se procesan en GitHub usando \texttt{output:\ github\_document}.
Esto producirá un archivo de Markdown, con sufijo \texttt{md}, que se puede visualizar como una página de web en GitHub. Como hemos subido estos archivos a GitHub, pueden hacer clic en el archivo \texttt{md} y verán el informe:

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_38} \end{center}

Esta es una manera conveniente de compartir sus informes.

\hypertarget{muxe1s-sobre-r-markdown}{%
\subsection{Más sobre R Markdown}\label{muxe1s-sobre-r-markdown}}

Hay mucho más que pueden hacer con R Markdown. Le recomendamos que continúen aprendiendo a medida que adquieran más experiencia escribiendo informes en R. Hay muchos recursos gratuitos en el Internet que incluyen:

\begin{itemize}
\tightlist
\item
  Tutorial de RStudio: \url{https://rmarkdown.rstudio.com}
\item
  La hoja de referencia: \url{https://github.com/rstudio/cheatsheets/raw/master/translations/spanish/rmarkdown-2.0_Spanish.pdf}
\item
  El libro de knitR: \url{https://yihui.name/knitr/}
\end{itemize}

\hypertarget{organizing}{%
\section{Organizando un proyecto de ciencia de datos}\label{organizing}}

En esta sección, juntamos todo para crear el proyecto de asesinatos de EE.UU. y compartirlo en GitHub.

\hypertarget{crear-directorios-en-unix}{%
\subsection{Crear directorios en Unix}\label{crear-directorios-en-unix}}

En la Sección \ref{prep-project}, demostramos cómo usar Unix para prepararnos para un proyecto de ciencia de datos usando un ejemplo. Aquí continuamos con este ejemplo y mostramos cómo usar RStudio. En la Sección \ref{prep-project}, creamos los siguientes directorios usando Unix:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}}
\BuiltInTok{cd}\NormalTok{ projects}
\FunctionTok{mkdir}\NormalTok{ murders}
\BuiltInTok{cd}\NormalTok{ murders}
\FunctionTok{mkdir}\NormalTok{ data rdas}
\end{Highlighting}
\end{Shaded}

\hypertarget{crear-un-proyecto-en-rstudio}{%
\subsection{Crear un proyecto en RStudio}\label{crear-un-proyecto-en-rstudio}}

En la siguiente sección, crearemos un proyecto en RStudio. Primero vamos a \emph{File} y luego a \emph{New Project}\ldots{} y, al ver las opciones, elegimos \emph{Existing Directory}. Entonces escribimos la ruta completa del directorio \texttt{murders} creado anteriormente.

\begin{center}\includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_14} \includegraphics[width=0.45\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_15} \end{center}

Una vez que hagan esto, verán los directorios \texttt{rdas} y \texttt{data} que crearon en la pestaña \emph{Files} de RStudio.

\begin{center}\includegraphics[width=0.7\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_16} \end{center}

Tengan en cuenta que cuando estamos en este proyecto, nuestro directorio de trabajo predeterminado será \texttt{\textasciitilde{}/projects/murders}. Pueden confirmar esto escribiendo \texttt{getwd()} en su sesión de R. Esto es importante porque nos ayudará a organizar el código cuando necesitemos escribir rutas de archivos. Consejo profesional: siempre usen rutas relativas en el código para proyectos de ciencia de datos. Estas deben ser relativas al directorio de trabajo que ha sido predeterminado. El problema con el uso de rutas completas es que es poco probable que sus códigos funcionen en sistemas de archivos distintos a los suyos, ya que las estructuras de directorio serán diferentes. Esto incluye el uso del directorio \emph{home} \texttt{\textasciitilde{}} como parte de su ruta.

\hypertarget{editar-algunos-scripts-de-r}{%
\subsection{Editar algunos scripts de R}\label{editar-algunos-scripts-de-r}}

Ahora escribamos un \emph{script} que descargue un archivo en el directorio de datos. Llamaremos a este archivo \texttt{download-data.R}.

El contenido de este archivo será:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url }\OtherTok{\textless{}{-}} \StringTok{"https://raw.githubusercontent.com/rafalab/dslabs/master/inst/}
\StringTok{extdata/murders.csv"}
\NormalTok{dest\_file }\OtherTok{\textless{}{-}} \StringTok{"data/murders.csv"}
\FunctionTok{download.file}\NormalTok{(url, }\AttributeTok{destfile =}\NormalTok{ dest\_file)}
\end{Highlighting}
\end{Shaded}

Recuerden que estamos utilizando la ruta relativa \texttt{data/murders.csv}.

Ejecuten este código en R y verán que se agrega un archivo al directorio \texttt{data}.

Ahora estamos listos para escribir un \emph{script} para leer estos datos y preparar una tabla que podamos usar para el análisis. Llamen al archivo \texttt{wrangle-data.R}. El contenido de este archivo será:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\NormalTok{murders }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\StringTok{"data/murders.csv"}\NormalTok{)}
\NormalTok{murders }\OtherTok{\textless{}{-}}\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{region =} \FunctionTok{factor}\NormalTok{(region),}
                             \AttributeTok{rate =}\NormalTok{ total}\SpecialCharTok{/}\NormalTok{ population }\SpecialCharTok{*} \DecValTok{10}\SpecialCharTok{\^{}}\DecValTok{5}\NormalTok{)}
\FunctionTok{save}\NormalTok{(murders, }\AttributeTok{file =} \StringTok{"rdas/murders.rda"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Una vez más, tengan en cuenta que utilizamos rutas relativas exclusivamente.

En este archivo, presentamos un comando R que no hemos visto antes: \texttt{save}. El comando \texttt{save} guarda objetos en lo que se llama un \emph{archivo rda}: \emph{rda} es la abreviatura de datos de R. Recomendamos usar el sufijo \texttt{.rda} en archivos que guardan objetos R. Veran que \texttt{.RData} también se usa.

Si ejecutan el código anterior, el objeto de datos procesados se guardará en un archivo en el directorio \texttt{rda}. Aunque no es el caso aquí, este enfoque a menudo es práctico porque generar el objeto de datos que usamos para los análisis y gráficos finales puede ser un proceso complejo que requiere mucho tiempo. Entonces ejecutamos este proceso una vez y guardamos el archivo. Pero aún queremos poder generar el análisis completo a partir de los datos sin procesar.

Ahora estamos listos para escribir el archivo de análisis. Vamos a llamarlo \texttt{analysis.R}. El contenido debe ser el siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{load}\NormalTok{(}\StringTok{"rdas/murders.rda"}\NormalTok{)}

\NormalTok{murders }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{mutate}\NormalTok{(}\AttributeTok{abb =} \FunctionTok{reorder}\NormalTok{(abb, rate)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(abb, rate)) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{width =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{color =} \StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{coord\_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Si ejecutan este análisis, verán que genera un gráfico.

\hypertarget{crear-muxe1s-directorios-usando-unix}{%
\subsection{Crear más directorios usando Unix}\label{crear-muxe1s-directorios-usando-unix}}

Ahora supongan que queremos guardar el gráfico generado para un informe o presentación. Podemos hacer esto con el comando \texttt{ggsave} de \textbf{ggplot}. ¿Pero dónde ponemos el gráfico? Deberíamos organizarnos sistemáticamente para que podamos guardar los gráficos en un directorio llamado \texttt{figs}. Comiencen creando un directorio escribiendo lo siguiente en el terminal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ figs}
\end{Highlighting}
\end{Shaded}

y luego pueden agregar la línea:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggsave}\NormalTok{(}\StringTok{"figs/barplot.png"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

a su \emph{script} de R. Si ejecutan el \emph{script} ahora, se guardará en un archivo png en el directorio \texttt{figs}. Si queremos copiar ese archivo a otro directorio donde estamos desarrollando una presentación, podemos evitar usar el mouse usando el comando \texttt{cp} en nuestro terminal.

\hypertarget{agregar-un-archivo-readme}{%
\subsection{Agregar un archivo README}\label{agregar-un-archivo-readme}}

Ahora tienen un análisis autónomo en un directorio. Una recomendación final es crear un archivo \texttt{README.txt} que describe lo que cada uno de estos archivos hace para el beneficio de otros que lean su código, incluyendo ustedes en el futuro. Esto no sería un \emph{script}, sino solo algunas notas. Una de las opciones proporcionadas al abrir un nuevo archivo en RStudio es un archivo de texto. Puede guardar algo como esto en el archivo de texto:

\begin{verbatim}
We analyze US gun murder data collected by the FBI.

download-data.R - Downloads csv file to data directory

wrangle-data.R - Creates a derived dataset and saves as R object in rdas
directory

analysis.R - A plot is generated and saved in the figs directory.
\end{verbatim}

\hypertarget{inicializando-un-directorio-git}{%
\subsection{Inicializando un directorio Git}\label{inicializando-un-directorio-git}}

En la Sección \ref{init}, demostramos cómo inicializar un directorio Git y conectarlo al \emph{Upstream Repository} en GitHub, que ya creamos en esa sección.

Podemos hacer esto en el terminal de Unix:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/projects/murders}
\FunctionTok{git}\NormalTok{ init}
\FunctionTok{git}\NormalTok{ add README.txt}
\FunctionTok{git}\NormalTok{ commit }\AttributeTok{{-}m} \StringTok{"First commit. Adding README.txt file just to get started"}
\FunctionTok{git}\NormalTok{ remote add origin }\KeywordTok{\textasciigrave{}}\ExtensionTok{https://github.com/rairizarry/murders.git}\KeywordTok{\textasciigrave{}}
\FunctionTok{git}\NormalTok{ push}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-commit-y-push-archivos-con-rstudio}{%
\subsection{\texorpdfstring{\emph{Add}, \emph{commit} y \emph{push} archivos con RStudio}{Add, commit y push archivos con RStudio}}\label{add-commit-y-push-archivos-con-rstudio}}

Podemos continuar \emph{adding} y \emph{committing} cada archivo, pero podría ser más fácil usar RStudio. Para hacer esto, inicien el proyecto abriendo el archivo Rproj. Deben aparecer los iconos git y pueden \emph{add}, \emph{commit} y \emph{push} con estos.

\begin{center}\includegraphics[width=0.3\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_32} \includegraphics[width=0.3\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_34} \includegraphics[width=0.3\linewidth]{productivity/img//windows-screenshots/VirtualBox_Windows-7-Enterprise_23_03_2018_14_53_35} \end{center}

Ahora podemos ir a GitHub y confirmar que nuestros archivos están allí.
Pueden ver una versión de este proyecto, organizada con directorios de Unix, en GitHub\footnote{\url{https://github.com/rairizarry/murders}}.
Pueden descargar una copia a su computadora utilizando el comando \texttt{git\ clone} en su terminal. Este comando creará un directorio llamado \texttt{murders} en su directorio de trabajo, así que tengan cuidado desde dónde lo llama.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{git clone https}\SpecialCharTok{:}\ErrorTok{//}\NormalTok{github.com}\SpecialCharTok{/}\NormalTok{rairizarry}\SpecialCharTok{/}\NormalTok{murders.git}
\end{Highlighting}
\end{Shaded}


\renewcommand\bibname{Contenido}
  \bibliography{book.bib,packages.bib}

\end{document}
