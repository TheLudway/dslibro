# Procesamiento de cadenas


```{r, echo=FALSE}
img_path <- "wrangling/img/"
```

Uno de los desafíos más comunes del _wrangling_ de datos consiste en extraer datos numéricos contenidos en cadenas de caracteres y convertirlos en las representaciones numéricas requeridas para hacer gráficos, calcular resúmenes o ajustar modelos en R. También, es común tener que procesar texto no organizado y convertirlo en nombres de variables entendibles o variables categóricas. Muchos de los desafíos de procesamiento de cadenas que enfrentan los científicos de datos son únicos y a menudo inesperados. Por lo tanto, es bastante ambicioso escribir una sección completa sobre este tema. Aquí usamos una serie de estudios de casos que nos ayudan a demostrar cómo el procesamiento de cadenas es un paso necesario para muchos desafíos de disputas de datos. Específicamente, para los ejemplos `murders`, `heights` y `research_funding_rates`, describimos el proceso de convertir los datos sin procesar originales, que aún no hemos mostrados, en los _data frames_ que hemos estudiado en este libro.

Al repasar estos estudios de caso, cubriremos algunas de las tareas más comunes en el procesamiento de cadenas, incluyendo cómo extraer números de cadenas, eliminar caracteres no deseados del texto, encontrar y reemplazar caracteres, extraer partes específicas de cadenas, convertir texto de forma libre a formatos más uniformes y dividir cadenas en múltiples valores.


Base R incluye funciones para realizar todas estas tareas. Sin embargo, no siguen una convención unificadora, lo que las hace un poco difíciles de memorizar y usar. El paquete __stringr__ básicamente reempaqueta esta funcionalidad, pero utiliza un enfoque más consistente de nombrar funciones y ordenar sus argumentos. Por ejemplo, en __stringr__, todas las funciones de procesamiento de cadenas comienzan con `str_`. Esto significa que si escriben `str_` y presionan _tab_, R se completará automáticamente y mostrará todas las funciones disponibles. Como resultado, no necesariamente tenemos que memorizar todos los nombres de las funciones. Otra ventaja es que en las funciones de este paquete, la cadena que se procesa siempre es el primer argumento, lo que significa que podemos usar el _pipe_ más fácilmente. Por lo tanto, comenzaremos describiendo cómo usar las funciones en el paquete __stringr__.

La mayoría de los ejemplos provendrán del segundo estudio de caso que trata sobre las alturas autoreportadas por los estudiantes y la mayor parte del capítulo se dedica al aprendizaje de expresiones regulares (_regular expressions_ o _regex_ en inglés) y funciones en el paquete __stringr__.


## El paquete stringr {#stringr}

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(stringr)
```
En general, las tareas de procesamiento de cadenas se pueden dividir en **detectar**, **ubicar**, **extraer** o **reemplazar** patrones en cadenas. Veremos varios ejemplos. La siguiente tabla incluye las funciones disponibles en el paquete __stringr__. Las dividimos por tarea. También incluimos el equivalente de base R cuando está disponible.

Todas estas funciones toman un vector de caracteres como primer argumento. Además, para cada función, las operaciones se vectorizan: la operación se aplica a cada cadena en el vector.

Finalmente, tengan en cuenta que en esta tabla mencionamos _groups_. Estos se explicarán en la Sección \@ref(groups).

| stringr | Tarea | Descripción | Base R |
|--------------- |----------|--------------------------------------|-------------|
| `str_detect` | Detectar | ¿El patrón está en la cadena? | `grepl` |
| `str_which` | Detectar | Devuelve el índice de entradas que contienen el patrón. | `grep` |
| `str_subset` | Detectar | Devuelve el subconjunto de cadenas que contienen el patrón. | `grep` con `value = TRUE` |
| `str_locate` | Localizar | Devuelve las posiciones de la primera aparición del patrón en una cadena. |`regexpr` |
| `str_locate_all` | Localizar | Devuelve la posición de todas las apariciones del patrón en una cadena. | `gregexpr` |
| `str_view`  | Localizar | Muestra la primera parte de la cadena que corresponde con el patrón. |  |
| `str_view_all` | Localizar | Muestra todas las partes de la cadena que corresponden con el patrón. |
| `str_extract` | Extraer | Extrae la primera parte de la cadena que corresponde con el patrón. |  |
`str_extract_all` | Extraer | Extrae todas las partes de la cadena que corresponden con el patrón. |  |
| `str_match` | Extraer | Extrae la primera parte de la cadena que corresponde con los grupos y los patrones definidos por los grupos.|
| `str_match_all` | Extraer | Extrae todas las partes de la cadena que corresponden con los grupos y los patrones definidos por los grupos. | |
| `str_sub`| Extraer | Extrae una subcadena.| `substring` |
| `str_split`| Extraer | Divide una cadena en una lista con partes separadas por patrón.| `strsplit`|
| `str_split_fixed`| Extraer | Divide una cadena en una matriz con partes separadas por patrón. | `strsplit` con `fixed = TRUE`|
| `str_count` | Describir | Cuenta el número de veces que aparece un patrón en una cadena. | |
| `str_length` | Describir | Número de caracteres en la cadena. | `nchar` |
| `str_replace` | Reemplazar | Reemplaza la primera parte de una cadena que corresponde con un patrón con otro patrón. | |
| `str_replace_all` | Reemplazar | Reemplaza todas las partes de una cadena que corresponden con un patrón con otro patrón. | `gsub` |
| `str_to_upper` | Reemplazar | Cambia todos los caracteres a mayúsculas. | `toupper` |
| `str_to_lower` | Reemplazar | Cambia todos los caracteres a minúsculas. | `tolower` |
| `str_to_title` | Reemplazar | Cambia el primer carácter a mayúscula y el resto a minúscula. | |
| `str_replace_na` | Reemplazar | Reemplaza todo los `NA`s con un nuevo valor. | |
| `str_trim` | Reemplazar | Elimina el espacio en blanco del inicio y del final de la cadena. | |
| `str_c` | Manipular | Une múltiples cadenas. | `paste0` |
| `str_conv` | Manipular | Cambia la codificación de la cadena. |
| `str_sort` | Manipular | Pone el vector en orden alfabético.  |`sort` |
| `str_order` | Manipular | Índice necesario para ordenar el vector alfabéticamente. | `order` |
| `str_trunc` | Manipular | Trunca una cadena a un tamaño fijo. | |
| `str_pad` | Manipular | Agrega espacio en blanco a la cadena para que tenga un tamaño fijo. | |
| `str_dup` | Manipular | Repite una cadena. | `rep` luego `paste` |
| `str_wrap` | Manipular | Pone la cadena en párrafos formateados. | |
| `str_interp` | Manipular | Interpolación de cadenas. | `sprintf` |


## Estudio de caso 1: datos de asesinatos en EE. UU.


En esta sección presentamos algunos de los desafíos más sencillos de procesamiento de cadenas, con los siguientes sets de datos como ejemplo:

```{r,message=FALSE, warning=FALSE}
library(rvest)
url <- paste0("https://en.wikipedia.org/w/index.php?title=",
"Gun_violence_in_the_United_States_by_state",
"&direction=prev&oldid=810166167")
murders_raw <- read_html(url) %>%
html_node("table") %>%
html_table() %>%
setNames(c("state", "population", "total", "murder_rate"))
```

El código anterior muestra el primer paso para construir el set de datos,

```{r}
library(dslabs)
data(murders)
```

de los datos sin procesar, que se extrajeron de una página de Wikipedia.

En general, el procesamiento de cadenas implica una cadena y un patrón. En R, generalmente almacenamos cadenas en un vector de caracteres como `murders$population`. Las primeras tres cadenas en este vector definidas por la variable de población son:

```{r}
murders_raw$population[1:3]
```

Forzar una conversión usando `as.numeric` no funciona aquí:

```{r}
as.numeric(murders_raw$population[1:3])
```

Esto se debe a las comas `,`. El procesamiento de cadenas que queremos hacer aquí es eliminar el **patrón**, `,`, de las **cadenas** en `murders_raw$population` y luego forzar una conversión de los números.

Podemos usar la función `str_detect` para ver que dos de las tres columnas tienen comas en las entradas:

```{r}
commas <- function(x) any(str_detect(x, ","))
murders_raw %>% summarize_all(commas)
```

Entonces podemos usar la función `str_replace_all` para eliminarlas:

```{r}
test_1 <- str_replace_all(murders_raw$population, ",", "")
test_1 <- as.numeric(test_1)
```

De ahí podemos usar `mutate_all` para aplicar esta operación a cada columna, ya que no afectará a las columnas sin comas.

Resulta que esta operación es tan común que `readr` incluye la función `parse_number` específicamente para eliminar caracteres no numéricos antes de forzar una conversión:

```{r}
test_2 <- parse_number(murders_raw$population)
identical(test_1, test_2)
```

Entonces podemos obtener nuestra tabla deseada usando:

```{r}
murders_new <- murders_raw %>% mutate_at(2:3, parse_number)
head(murders_new)
```

Este caso es relativamente sencillo en comparación con los desafíos de procesamiento de cadenas que normalmente enfrentamos en la ciencia de datos. El siguiente ejemplo es bastante complejo y ofrece varios retos que nos permitirán aprender muchas técnicas de procesamiento de cadenas.

## Estudio de caso 2: alturas autoreportadas

El paquete __dslabs__ incluye el set de datos sin procesar del cual se obtuvo el set de datos de alturas. Pueden cargarlo así:

```{r}
data(reported_heights)
```

Estas alturas se obtuvieron mediante un formulario web en el que se les pedía a los estudiantes que ingresaran sus alturas. Podían ingresar cualquier cosa, pero las instrucciones pedían _altura en pulgadas_, un número. [fix] Recopilamos `r prettyNum(nrow(reported_heights), big.mark=",")` presentaciones, pero desafortunadamente el vector de columna con las alturas reportadas tenía varias entradas no numéricas y como resultado se convirtió en un vector de caracteres:

```{r}
class(reported_heights$height)
```

Si intentamos analizarlo en números, recibimos una advertencia:

```{r}
x <- as.numeric(reported_heights$height)
```

Aunque la mayoría de los valores parecen ser la altura en pulgadas según lo solicitado:

```{r}
head(x)
```

terminamos con muchos `NA`s:

```{r}
sum(is.na(x))
```

Podemos ver algunas de las entradas que no se convierten correctamente utilizando `filter` para mantener solo las entradas que resultan en `NA`s:

```{r, warning=FALSE}
reported_heights %>%
mutate(new_height = as.numeric(height)) %>%
filter(is.na(new_height)) %>%
head(n=10)
```

Inmediatamente vemos lo que está sucediendo. Algunos de los estudiantes no reportaron sus alturas en pulgadas según lo solicitado. Podríamos descartar estos datos y continuar. Sin embargo, muchas de las entradas siguen patrones que, en principio, podemos convertir fácilmente a pulgadas. Por ejemplo, en el resultado anterior, vemos varios casos que usan el formato `x'y''` con `x` y `y` representando pies y pulgadas, respectivamente. Cada uno de estos casos puede ser leído y convertido a pulgadas por un humano, por ejemplo `5'4''` es `5*12 + 4 = 64`. Entonces podríamos arreglar todas las entradas problemáticas _a mano_. Sin embargo, los humanos son propensos a cometer errores, por lo que es preferible un enfoque automatizado. Además, debido a que planeamos continuar recolectando datos, será conveniente escribir código que lo haga automáticamente.

Un primer paso en este tipo de tarea es examinar las entradas problemáticas e intentar definir patrones específicos seguidos de un gran grupo de entradas. Cuanto más grandes sean estos grupos, más entradas podremos arreglar con un solo enfoque programático. Queremos encontrar patrones que puedan describirse con precisión con una regla, como "un dígito, seguido por un símbolo de pie, seguido por uno o dos dígitos, seguido por un símbolo de pulgadas".

Para buscar dichos patrones, es útil eliminar las entradas que son consistentes con estar en pulgadas y ver solo las entradas problemáticas. Por lo tanto, escribimos una función para hacer esto automáticamente. Mantenemos entradas que resultan en `NA`s al aplicar `as.numeric` o están fuera de un rango de alturas plausibles. Permitimos un rango que cubre aproximadamente el 99.9999% de la población adulta. También usamos `suppressWarnings` para evitar el mensaje de advertencia que sabemos que `as.numeric` nos da.

```{r, echo=FALSE, eval=FALSE}
alpha <- 1/ 10^6
qnorm(1 - alpha/ 2, 69.1, 2.9)
qnorm(alpha/ 2, 63.7, 2.7)
```

```{r}
not_inches <- function(x, smallest = 50, tallest = 84){
inches <- suppressWarnings(as.numeric(x))
ind <- is.na(inches) | inches < smallest | inches > tallest
ind
}
```

Aplicamos esta función y encontramos el número de entradas problemáticas:
```{r}
problems <- reported_heights %>%
filter(not_inches(height)) %>%
pull(height)
length(problems)
```


Ahora podemos ver todos los casos simplemente imprimiéndolos. No hacemos eso aquí porque hay `length(problems)`, pero después de examinarlos cuidadosamente, vemos que se pueden usar tres patrones para definir tres grandes grupos dentro de estas excepciones.

1\. Un patrón de la forma `x'y` o `x' y''` o `x'y"` con `x` y `y` representando pies y pulgadas, respectivamente. Aquí hay diez ejemplos:

```{r, echo=FALSE}
pattern <- "^\\d\\s*'\\s*\\d{1,2}\\.*\\d*'*\"*$"
str_subset(problems, pattern) %>% head(n=10) %>% cat()
```

2\. Un patrón de la forma `x.y` o `x,y` con `x` pies y `y` pulgadas. Aquí hay diez ejemplos:

```{r, echo=FALSE}
pattern <- "^[4-6]\\s*[\\.|,]\\s*([0-9]|10|11)$"
str_subset(problems, pattern) %>% head(n=10) %>% cat()
```


3\. Entradas en centímetros en vez de pulgadas. Aquí hay diez ejemplos:

```{r, echo=FALSE}
ind <- which(between(suppressWarnings(as.numeric(problems))/2.54, 54, 81) )
ind <- ind[!is.na(ind)]
problems[ind] %>% head(n=10) %>% cat
```

Una vez que veamos estos grandes grupos siguiendo patrones específicos, podemos desarrollar un plan de ataque. Recuerden que rara vez hay una sola forma de realizar estas tareas. Aquí elegimos una que nos ayuda a enseñar varias técnicas útiles, aunque seguramente hay una forma más eficiente de realizar la tarea.

**Plan de ataque**: convertiremos las entradas que se ajusten a los dos primeros patrones en una estandarizada. Luego aprovecharemos la estandarización para extraer los pies y pulgadas y convertirlos a pulgadas. Entonces definiremos un procedimiento para identificar entradas que estén en centímetros y convertirlas a pulgadas. Después de aplicar estos pasos, verificaremos nuevamente para ver qué entradas no se corrigieron y ver si podemos ajustar nuestro enfoque para que sea más completo.

Al final, esperamos tener un _script_ que haga que los métodos de recolección de datos basados en la web sean robustos para los errores más comunes de los usuarios.

Para lograr nuestro objetivo, utilizaremos una técnica que nos permite detectar con precisión patrones y extraer las partes que queremos: expresiones regulares (_regular expressions_ o _regex_ en inglés). Pero primero, describimos rápidamente cómo _escaparse_ ("escapar" viene de la tecla _esc_ o _escape_) de la función de ciertos caracteres para que puedan incluirse en cadenas.


## Cómo _escapar_ al definir cadenas

Para definir cadenas en R, podemos usar comillas dobles:

```{r}
s <- "Hello!"
```

o comillas simples:

```{r}
s <- 'Hello!'
```

Asegúrense de elegir la comilla simple correcta, ya que usar la comilla inversa le dará un error:

```{r, eval=FALSE}
s <- `Hello`
```
```
Error: object 'Hello' not found
```

Ahora, ¿qué sucede si la cadena que queremos definir incluye comillas dobles? Por ejemplo, si queremos escribir 10 pulgadas así `10"`?
En este caso no pueden usar:

```{r, eval=FALSE}
s <- "10""
```

porque esto es solo la cadena `10` seguido por una comilla doble. Si escriben esto en R, obtendrán un error porque tiene comillas doble sin cerrar. Para evitar esto, podemos usar las comillas simples:

```{r}
s <- '10"'
```

Si imprimimos `s`, vemos que escapamos las comillas dobles con la barra inversa `\`.
```{r}
s
```

De hecho, escapar con la barra diagonal inversa ofrece una forma de definir la cadena y a la vez seguir utilizando las comillas dobles para definir cadenas:

```{r}
s <- "10\""
```

En R, la función `cat` nos permite ver como se ve la cadena:

```{r}
cat(s)
```

Ahora, ¿qué pasa si queremos que nuestra cadena sea de 5 pies escrita así `5'`? En ese caso, podemos usar las comillas dobles:

```{r}
s <- "5'"
cat(s)
```

Así que hemos aprendido a escribir 5 pies y 10 pulgadas por separado, pero ¿qué pasa si queremos escribirlos juntos para representar _5 pies y 10 pulgadas_ así: `5'10"`? En este caso, ni las comillas simples ni las dobles funcionarán. Esto:

```{r, eval=FALSE}
s <- '5'10"'
```

cierra la cadena después de 5 y esto:

```{r, eval=FALSE}
s <- "5'10""
```
cierra la cadena después de 10. Tengan en cuenta que si escribimos uno de los fragmentos de código anteriores en R, se atascará esperando que cierren la comilla abierta y tendrán que salir de la ejecución con la tecla _esc_.

En esta situación, necesitamos escapar de la función de las comillas con la barra diagonal inversa `\`. Pueden escapar cualquiera de los dos de la siguiente manera:

```{r}
s <- '5\'10"'
cat(s)
```

o así:

```{r}
s <- "5'10\""
cat(s)
```

Los caracteres de escape son algo que a menudo tenemos que usar al procesar cadenas.

## Expresiones regulares

Una expresión regular (_regex_) es una forma de describir patrones específicos de caracteres de texto. Se pueden usar para determinar si una cadena dada corresponde con el patrón. Se ha definido un conjunto de reglas para hacer esto de manera eficiente y precisa, y aquí mostramos algunos ejemplos. Podemos aprender más sobre estas reglas leyendo tutoriales  detallados^[https://www.regular-expressions.info/tutorial.html] ^[http://r4ds.had.co.nz/strings.html#matching-patrones-con-expresiones-regulares]. La hoja de referencia de RStudio^[https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf] también es muy útil.


[fix] Los patrones suministrados a las funciones __stringr__ pueden ser una expresión regular en lugar de una cadena estándar. Aprenderemos cómo funciona esto a través de una serie de ejemplos.

A lo largo de esta sección, verán que creamos cadenas para probar nuestra expresión regular. Para hacer esto, definimos patrones que sabemos deben corresponder y también patrones que sabemos no deben corresponder. Los llamaremos `yes` y `no`, respectivamente. Esto nos permite verificar los dos tipos de errores: no corresponder o corresponder incorrectamente.


### Las cadenas son una expresión regular

Técnicamente, cualquier cadena es una expresión regular, quizás el ejemplo más simple es un solo carácter. Entonces la coma `,` usada en el siguiente ejemplo de código, es un ejemplo sencillo de una búsqueda con expresiones regulares.

```{r, eval=FALSE}
pattern <- ","
str_detect(murders_raw$total, pattern)
```

Suprimimos el _output_ que es un vector lógico que nos dice qué entradas tienen comas.

Arriba, notamos que una entrada incluía un `cm`. Este es también un ejemplo sencillo de una expresión regular. Podemos mostrar todas las entradas que usaron `cm` así:

```{r}
str_subset(reported_heights$height, "cm")
```

### Caracteres especiales

Ahora consideremos un ejemplo un poco más complicado. ¿Cuál de las siguientes cadenas contiene el patrón `cm` o `inches`?


```{r}
yes <- c("180 cm", "70 inches")
no <- c("180", "70''")
s <- c(yes, no)
```


```{r}
str_detect(s, "cm") | str_detect(s, "inches")
```

Sin embargo, no necesitamos hacer esto. La característica principal que distingue el lenguaje de las expresiones regulares de cadenas es que podemos usar caracteres especiales. Estos son caracteres con un significado. Comenzamos presentando `|` que significa _o_. Entonces, si queremos saber si `cm` o `inches` aparece en las cadenas, podemos usar la expresión regular `cm|inches`:

```{r}
str_detect(s, "cm|inches")
```

y obtener la respuesta correcta.

Otro carácter especial que será útil para identificar valores de pies y pulgadas es `\d` que significa cualquier dígito: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. La barra inversa se utiliza para distinguirlo del carácter `d`. En R, tenemos que escapar de la barra inversa `\` así que tenemos que usar `\\d` para representar dígitos. Aquí hay un ejemplo:

```{r}
yes <- c("5", "6", "5'10", "5 feet", "4'11")
no <- c("", ".", "Five", "six")
s <- c(yes, no)
pattern <- "\\d"
str_detect(s, pattern)
```

Aprovechamos esta oportunidad para presentar la función `str_view`, que es útil para la solución de problemas, ya que nos muestra la primera ocurrencia que corresponde exactamente para cada cadena:

```{r, eval=FALSE}
str_view(s, pattern)
```
```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"str_view-1.png"))
```

y `str_view_all` nos muestra todos los patrones que corresponden, entonces `3'2` tiene dos equivalencias y `5'10` tiene tres.

```{r, eval=FALSE}
str_view_all(s, pattern)
```
```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"str_view-2.png"))
```


Hay muchos otros caracteres especiales. Aprenderemos algunos mas a continuación, pero pueden ver la mayoría o todos en la hoja de referencia^[https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf] mencionada anteriormente.


### Clases de caracteres

Las clases de caracteres se utilizan para definir una serie de caracteres que pueden corresponder. Definimos clases de caracteres entre corchetes `[]`. Entonces, por ejemplo, si queremos que el patrón corresponda solo si tenemos un `5` o un `6`, usamos la expresión regular `[56]`:

```{r, eval=FALSE}
str_view(s, "[56]")
```
```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"str_view-3.png"))
```


Supongamos que queremos unir valores entre 4 y 7. Una forma común de definir clases de caracteres es con rangos. Así por ejemplo, `[0-9]` es equivalente a `\\d`. El patrón que queremos es por lo tanto `[4-7]`.


```{r}
yes <- as.character(4:7)
no <- as.character(1:3)
s <- c(yes, no)
str_detect(s, "[4-7]")
```

Sin embargo, es importante saber que en _regex_ todo es un carácter; no hay números. Entonces `4` es el carácter `4` y no el número cuatro. Noten, por ejemplo, que `[1-20]` **no** significa 1 a 20, significa los caracteres 1 a 2 o el carácter 0. Entonces `[1-20]` simplemente significa la clase de caracteres compuesta por 0, 1 y 2.

Tengan en cuenta que los caracteres tienen un orden y los dígitos siguen el orden numérico. Entonces `0` viene antes de `1` que viene antes de `2` y así. Por la misma razón, podemos definir letras minúsculas como `[a-z]`, letras mayúsculas como `[A-Z]` y `[a-zA-z]` como ambas.

### Anclas

¿Qué pasa si queremos una correspondencia cuando tenemos exactamente 1 dígito? Esto será útil en nuestro estudio de caso, ya que los pies nunca tienen más de 1 dígito, por lo que una restricción nos ayudará. Una forma de hacer esto con _regex_ es usando _anclas_ (_anchors_ en inglés), que nos permiten definir patrones que deben comenzar o terminar en un lugar específico. Las dos anclas más comunes son
`^` y ` $` que representan el comienzo y el final de una cadena, respectivamente. Entonces el patrón `^\\d$` se lee como "inicio de la cadena seguido por un dígito seguido por el final de la cadena".

Este patrón ahora solo detecta las cadenas con exactamente un dígito:

```{r, eval=FALSE}
pattern <- "^\\d$"
yes <- c("1", "5", "9")
no <- c("12", "123", " 1", "a4", "b")
s <- c(yes, no)
str_view_all(s, pattern)
```

```{r, echo=FALSE}
pattern <- "^\\d$"
yes <- c("1", "5", "9")
no <- c("12", "123", " 1", "a4", "b")
s <- c(yes, no)
knitr::include_graphics(file.path(img_path,"str_view-4.png"))
```



El ` 1` no corresponde porque no comienza con el dígito sino con un espacio, que no es fácil de ver.

### Cuantificadores

Para la parte de pulgadas, podemos tener uno o dos dígitos. Esto se puede especificar en _regex_ con _cuantificadores_ (_quantifiers_ en inglés). Esto se hace siguiendo el patrón con la cantidad de veces que se puede repetir cerrada por llaves. Usemos un ejemplo para ilustrar. El patrón para uno o dos dígitos es:

```{r, eval=FALSE}
pattern <- "^\\d{1,2}$"
yes <- c("1", "5", "9", "12")
no <- c("123", "a4", "b")
str_view(c(yes, no), pattern)
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"str_view-5.png"))
```

En este caso, `123` **no** corresponde, pero `12` sí. Entonces, para buscar nuestro patrón de pies y pulgadas, podemos agregar los símbolos para pies `'` y pulgadas `"` después de los dígitos.


Con lo que hemos aprendido, ahora podemos construir un ejemplo para el patrón `x'y\"` con `x` pies y `y` pulgadas.

```{r}
pattern <- "^[4-7]'\\d{1,2}\"$"
```


El patrón ahora se está volviendo complejo, pero pueden mirarlo cuidadosamente y desglosarlo:

- `^` = inicio de la cadena
- `[4-7]` = un dígito, ya sea 4, 5, 6 o 7
- `'` = símbolo de pies
- `\\d{1,2}` = uno o dos dígitos
- `\"` = símbolo de pulgadas
- `$` = final de la cadena

Probémoslo:

```{r}
yes <- c("5'7\"", "6'2\"", "5'12\"")
no <- c("6,2\"", "6.2\"","I am 5'11\"", "3'2\"", "64")
str_detect(yes, pattern)
str_detect(no, pattern)
```

Por ahora, estamos permitiendo que las pulgadas sean 12 o más grandes. Agregaremos una restricción más tarde ya que la expresión regular para esto es un poco más compleja de lo que estamos preparados para mostrar.

### Espacio en blanco `\s`

Otro problema que tenemos son los espacios. Por ejemplo, nuestro patrón no corresponde con `5' 4"` porque hay un espacio entre `'` y `4` que nuestro patrón no permite. Los espacios son caracteres y R no los ignora:

```{r}
identical("Hi", "Hi ")
```

En _regex_, `\s` representa el espacio en blanco. Para encontrar patrones como `5' 4`, podemos cambiar nuestro patrón a:

```{r}
pattern_2 <- "^[4-7]'\\s\\d{1,2}\"$"
str_subset(problems, pattern_2)
```

Sin embargo, esto no encontrará equivalencia con los patrones sin espacio. Entonces, ¿necesitamos más de un patrón _regex_? Resulta que también podemos usar un cuantificador para esto.

### Cuantificadores: `*`, `?`, `+`

Queremos que el patrón permita espacios pero que no los requiera. Incluso si hay varios espacios, como en este ejemplo `5' 4`, todavía queremos que corresponda. Hay un cuantificador para exactamente este propósito. En _regex_, el carácter `*` significa cero o más instancias del carácter anterior. Aquí hay un ejemplo:

```{r}
yes <- c("AB", "A1B", "A11B", "A111B", "A1111B")
no <- c("A2B", "A21B")
str_detect(yes, "A1*B")
str_detect(no, "A1*B")
```

El patrón anterior encuentra correspondencia con la primera cadena, que tiene cero 1s, y todas las cadenas con un o más 1. Entonces podemos mejorar nuestro patrón agregando el `*` después del carácter espacial `\s`.

Hay otros dos cuantificadores similares. Para ninguno o una vez, podemos usar `?`, y para uno o más, podemos usar `+`. Pueden ver cómo difieren con este ejemplo:

```{r}
data.frame(string = c("AB", "A1B", "A11B", "A111B", "A1111B"),
none_or_more = str_detect(yes, "A1*B"),
nore_or_once = str_detect(yes, "A1?B"),
once_or_more = str_detect(yes, "A1+B"))
```

Usaremos los tres en nuestro ejemplo de alturas reportadas, pero los veremos en una sección posterior.

### No

Para especificar patrones que **no** queremos detectar, podemos usar el símbolo `^` pero solo __dentro__ de corchetes. Recuerden que fuera del corchete `^` significa el inicio de la cadena. Entonces, por ejemplo, si queremos detectar dígitos precedidos por algo que no sea una letra, podemos hacer lo siguiente:

```{r}
pattern <- "[^a-zA-Z]\\d"
yes <- c(".3", "+2", "-0","*4")
no <- c("A3", "B2", "C0", "E4")
str_detect(yes, pattern)
str_detect(no, pattern)
```

Otra forma de generar un patrón que busca _todo excepto_ es usar la mayúscula del carácter especial. Por ejemplo `\\D` significa cualquier cosa que no sea un dígito, `\\S` significa cualquier cosa excepto un espacio, y así sucesivamente.

### Grupos {#groups}

Los _grupos_ son un aspecto poderoso de la expresión regular que permite la extracción de valores. Los grupos se definen usando paréntesis. No afectan las equivalencias de patrones. En cambio, permiten que las herramientas identifiquen partes específicas del patrón para que podamos extraerlas.

Queremos cambiar las alturas escritas como `5.6` a `5'6`.

Para evitar cambiar patrones como `70.2`, requeriremos que el primer dígito esté entre 4 y 7 `[4-7]` y que el segundo sea ninguno o uno o más dígitos `\\d*`. Comencemos definiendo un patrón sencillo que corresponda con lo siguiente:

```{r}
pattern_without_groups <- "^[4-7],\\d*$"
```

Queremos extraer los dígitos para poder formar la nueva versión usando un punto. Estos son nuestros dos grupos, por lo que los encapsulamos con paréntesis:

```{r}
pattern_with_groups <- "^([4-7]),(\\d*)$"
```

Encapsulamos la parte del patrón que corresponde con las partes que queremos conservar para su uso posterior. Agregar grupos no afecta la detección, ya que solo indica que queremos guardar lo que capturan los grupos. Tengan en cuenta que ambos patrones devuelven el mismo resultado cuando se usa `str_detect`:

```{r}
yes <- c("5,9", "5,11", "6,", "6,1")
no <- c("5'9", ",", "2,8", "6.1.1")
s <- c(yes, no)
str_detect(s, pattern_without_groups)
str_detect(s, pattern_with_groups)
```

Una vez que definimos los grupos, podemos usar la función `str_match` para extraer los valores que definen estos grupos:

```{r}
str_match(s, pattern_with_groups)
```

Observen que las segunda y tercera columnas contienen pies y pulgadas, respectivamente. La primera columna es la parte de la cadena que corresponde con el patrón. Si no se encuentra una equivalencia, vemos un `NA`.

Ahora podemos entender la diferencia entre las funciones `str_extract` y `str_match`. `str_extract` extrae solo cadenas que corresponden con un patrón, no los valores definidos por grupos:

```{r}
str_extract(s, pattern_with_groups)
```


## Buscar y reemplazar con expresiones regulares

Anteriormente definimos el objeto `problems` que contiene las cadenas que no parecen estar en pulgadas. Podemos ver que pocas de nuestras cadenas problemáticas corresponden con el patrón:

```{r}
pattern <- "^[4-7]'\\d{1,2}\"$"
sum(str_detect(problems, pattern))
```

Para ver por qué esto es así, mostramos algunos ejemplos que exponen por qué no tenemos más equivalencias:

```{r, eval=FALSE}
problems[c(2, 10, 11, 12, 15)] %>% str_view(pattern)
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"str_view-6.png"))
```
Un problema inicial que vemos de inmediato es que algunos estudiantes escribieron las palabras "pies" y "pulgadas". Podemos ver las entradas que hicieron esto con la función `str_subset`:

```{r}
str_subset(problems, "inches")
```

También vemos que algunas entradas usan dos comillas simples `''` en lugar de una comilla doble `"`.

```{r}
str_subset(problems, "''")
```

Para corregir esto, podemos reemplazar las diferentes formas de representar pulgadas y pies con un símbolo uniforme. Usaremos `'` para pies, mientras que para pulgadas simplemente no usaremos un símbolo ya que algunas entradas tienen la forma `x'y`. Ahora, si ya no usamos el símbolo de pulgadas, tenemos que cambiar nuestro patrón en consecuencia:

```{r}
pattern <- "^[4-7]'\\d{1,2}$"
```

Si hacemos este reemplazo antes de buscar equivalencias, obtendremos muchas más equivalencias:

```{r}
problems %>%
str_replace("feet|ft|foot", "'") %>% # replace feet, ft, foot with '
str_replace("inches|in|''|\"", "") %>% # remove all inches symbols
str_detect(pattern) %>%
sum()
```

Sin embargo, todavía nos faltan muchos casos.

Tengan en cuenta que en el código anterior, [fix] aprovechamos la coherencia __stringr__ y usamos el _pipe_.

Por ahora, mejoramos nuestro patrón agregando `\\s*` delante y después del símbolo de los pies `'` para permitir espacio entre el símbolo de los pies y los números. Ahora encontraremos más equivalencias:

```{r}
pattern <- "^[4-7]\\s*'\\s*\\d{1,2}$"
problems %>%
str_replace("feet|ft|foot", "'") %>% # replace feet, ft, foot with '
str_replace("inches|in|''|\"", "") %>% # remove all inches symbols
str_detect(pattern) %>%
sum
```

Podríamos estar tentados a evitar esto eliminando todos los espacios con `str_replace_all`.  Sin embargo, al hacer una operación de este tipo, debemos asegurarnos de evitar efectos indeseados. En nuestros ejemplos de alturas autoreportadas, esto será un problema porque algunas entradas tienen la forma `x y` con espacio separando los pies de las pulgadas. Si eliminamos todos los espacios, cambiaríamos incorrectamente `x y` a `xy` lo que implica que un `6 1` se convertiría en `61` pulgadas en vez de `73` pulgadas.


El segundo grupo grande de entradas problemáticas tienen las formas `x.y`, `x,y` o `x y`. Queremos cambiar todo esto a nuestro formato común `x'y`. Pero no podemos simplemente buscar y reemplazar porque cambiaríamos valores como `70.5` a `70'5`. Por lo tanto, nuestra estrategia será buscar un patrón muy específico que nos asegure que se devuelvan pies y pulgadas y luego, para aquellos que correspondan, se reemplazcan adecuadamente.

### Buscar y reemplazar usando grupos

Otro aspecto poderoso de los grupos es que puede hacer referencia a los valores extraídos en una expresión regular cuando buscan y reemplazan.

El carácter especial _regex_ para el grupo en el lugar `i` es `\\i`. Entonces `\\1` es el valor extraído del primer grupo, `\\2` el valor del segundo y así sucesivamente. Como un ejemplo simple, tengan en cuenta que el siguiente código reemplazará una coma con un punto, pero solo si está entre dos dígitos:

```{r}
pattern_with_groups <- "^([4-7]),(\\d*)$"
yes <- c("5,9", "5,11", "6,", "6,1")
no <- c("5'9", ",", "2,8", "6.1.1")
s <- c(yes, no)
str_replace(s, pattern_with_groups, "\\1'\\2")
```

Podemos usar esto para convertir casos en nuestras alturas reportadas.

Ahora estamos listos para definir un patrón que nos ayudará a convertir todos los `x.y`, `x,y` y `x y` a nuestro formato preferido. Necesitamos adaptar `pattern_with_groups` para que sea un poco más flexible y capture todos los casos.

```{r}
pattern_with_groups <-"^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$"
```

Examinemos este patrón _regex_:

- `^` = inicio de la cadena
- `[4-7]` = un dígito, ya sea 4, 5, 6 o 7
- `\\s*` = ninguno o más espacios en blanco
- `[,\\.\\s+]` = el símbolo de pies es `,`, `.` o al menos un espacio
- `\\s*` = ninguno o más espacios en blanco
- `\\d*` = ninguno o más dígitos
- `$` = final de la cadena

Podemos ver que parece estar funcionando:
```{r}
str_subset(problems, pattern_with_groups) %>% head()
```

Ahora usamos esto para buscar y reemplazar:

```{r}
str_subset(problems, pattern_with_groups) %>%
str_replace(pattern_with_groups, "\\1'\\2") %>% head
```

Lidiaremos con el desafío de pulgadas-más-grandes-que-doce más tarde.

## Probar y mejorar

Desarrollar la expresión regular correcta en el primer intento a menudo es difícil. Probar y mejorar es un enfoque común para encontrar el patrón de expresiones regulares que satisface todas las condiciones deseadas. En las secciones anteriores, hemos desarrollado una potente técnica de procesamiento de cadenas que puede ayudarnos a detectar muchas de las entradas problemáticas. Aquí probaremos nuestro enfoque, buscaremos más problemas y modificaremos nuestro enfoque para posibles mejoras. Escribamos una función que identifique todas las entradas que no se pueden convertir en números recordando que algunas están en centímetros (nos encargaremos de arreglar esas más adelante):

```{r}
not_inches_or_cm <- function(x, smallest = 50, tallest = 84){
inches <- suppressWarnings(as.numeric(x))
ind <- !is.na(inches) &
((inches >= smallest & inches <= tallest) |
(inches/2.54 >= smallest & inches/2.54 <= tallest))
!ind
}

problems <- reported_heights %>%
filter(not_inches_or_cm(height)) %>%
pull(height)
length(problems)
```

Veamos qué proporción de estos se ajusta a nuestro patrón después de los pasos de procesamiento que desarrollamos anteriormente:

```{r}
converted <- problems %>%
str_replace("feet|foot|ft", "'") %>% # convert feet symbols to '
str_replace("inches|in|''|\"", "") %>% # remove inches symbols
str_replace("^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$", "\\1'\\2")# change format

pattern <- "^[4-7]\\s*'\\s*\\d{1,2}$"
index <- str_detect(converted, pattern)
mean(index)
```

Observe cómo aprovechamos el _pipe_, una de las ventajas de usar __stringr__. Este último fragmento de código muestra que encontramos equivalencias en más de la mitad de las cadenas. Examinemos los casos restantes:

```{r}
converted[!index]
```

Surgen cuatro patrones claros:

1. Muchos estudiantes que miden exactamente 5 o 6 pies no ingresaron ninguna pulgada, por ejemplo `6'`, y nuestro patrón requiere que se incluyan pulgadas.
2. Algunos estudiantes que miden exactamente 5 o 6 pies ingresaron solo ese número.
3. Algunas de las pulgadas se ingresaron con puntos decimales. Por ejemplo `5'7.5''`. Nuestro patrón solo busca dos dígitos.
4. Algunas entradas tienen espacios al final, por ejemplo `5 ' 9 `.

Aunque no es tan común, también vemos los siguientes problemas:

5. Algunas entradas están en metros y algunas usan decimales europeos: `1.6`, `1,70`.
6. Dos estudiantes añadieron `cm`.
7. Un estudiante deletreó los números: `Five foot eight inches`.

No está claro que valga la pena escribir código para manejar estos últimos tres casos, ya que son bastante raros. Sin embargo, algunos de ellos nos brindan la oportunidad de aprender algunas técnicas más de expresiones regulares, por lo que crearemos una solución.

Para el caso 1, si agregamos un `'0` después del primer dígito, por ejemplo, convertir todo `6` a `6'0`, entonces nuestro patrón previamente definido correspondará. Esto se puede hacer usando grupos:

```{r}
yes <- c("5", "6", "5")
no <- c("5'", "5''", "5'4")
s <- c(yes, no)
str_replace(s, "^([4-7])$", "\\1'0")
```

El patrón dice que tiene que comenzar ( `^`) con un dígito entre 4 y 7 y terminar ahí ( `$`). El paréntesis define el grupo que pasamos como `\\1` para generar la cadena de expresiones regulares de reemplazo.

Podemos adaptar este código ligeramente para manejar también el caso 2, que cubre la entrada `5'`. Notem que `5'` se deja intacto. Esto es porque el extra `'` hace que el patrón no corresponda ya que tenemos que terminar con un 5 o 6. Queremos permitir que el 5 o 6 sea seguido por un signo de 0 o 1 pie. Entonces podemos simplemente agregar `'{0,1}` después de la `'` para hacer esto. Sin embargo, podemos usar el carácter especial, `?`, que significa ninguna o una vez. Como vimos anteriormente, esto es diferente a `*`, que significa ninguna o más. Ahora vemos que el cuarto caso también se convierte:

```{r}
str_replace(s, "^([56])'?$", "\\1'0")
```

Aquí solo permitimos 5 y 6, pero no 4 y 7. Esto se debe a que 5 y 6 pies de altura es bastante común, por lo que asumimos que aquellos que escribieron 5 o 6 en verdad querían decir `60` o `72` pulgadas. Sin embargo, `4` y `7` pies de altura son tan raros que, aunque aceptamos `84` como una entrada válida, suponemos que `7` fue ingresado por error.

Podemos usar cuantificadores para tratar el caso 3. Estas entradas no corresponden porque las pulgadas incluyen decimales y nuestro patrón no lo permite. Necesitamos permitir que el segundo grupo incluya decimales, no solo dígitos. Esto significa que debemos permitir cero o un punto `.`, entonces cero o más dígitos. Entonces usaremos ambos `?` y `*`. También recuerden que, para este caso particular, el punto debe escaparse ya que es un carácter especial (significa cualquier carácter excepto el salto de línea). Aquí hay un ejemplo sencillo de cómo podemos usar `*`.

Entonces podemos adaptar nuestro patrón, actualmente `^[4-7]\\s*'\\s*\\d{1,2}$` para permitir un decimal al final:

```{r}
pattern <- "^[4-7]\\s*'\\s*(\\d+\\.?\\d*)$"
```


Caso 4, metros usando comas, podemos tratarlo de manera similar a cómo convertimos el `x.y` a `x'y`. Una diferencia es que requerimos que el primer dígito sea 1 o 2:

```{r}
yes <- c("1,7", "1, 8", "2, " )
no <- c("5,8", "5,3,2", "1.7")
s <- c(yes, no)
str_replace(s, "^([12])\\s*,\\s*(\\d*)$", "\\1\\.\\2")
```

Luego verificaremos si las entradas son metros utilizando sus valores numéricos. Volveremos al estudio de caso después de introducir dos funciones ampliamente utilizadas en el procesamiento de cadenas que serán útiles al desarrollar nuestra solución final para las alturas autoreportadas.


## Podar

En general, los espacios al principio o al final de la cadena no son informativos.
Estos pueden ser particularmente engañosos porque a veces pueden ser difíciles de ver:

```{r}
s <- "Hi "
cat(s)
identical(s, "Hi")
```

Este es un problema lo suficientemente general como para que haya una función dedicada a eliminarlos: `str_trim`. El nombre viene de _trim_ o podar en inglés.

```{r}
str_trim("5 ' 9 ")
```


## Cambio de mayúsculas o minúsculas

Tengan en cuenta que _regex_ distingue entre mayúsculas y minúsculas.  A menudo queremos encontrar una equivalencia de palabra independientemente de si es mayúscula o minúscula. Un acercamiento para hacer esto es primero cambiar todo a minúsculas y luego continuar ignorando mayúsculas y minúsculas. Como ejemplo, noten que una de las entradas escribe números como palabras `Five foot eight inches`. Aunque no es eficiente, podríamos agregar 13 adicionales `str_replace` llamadas para convertir `zero` a `0`, `one` a `1`, y así. Para no tener que escribir dos operaciones separadas para `Zero` y `zero`, `One` y `one`, etc., podemos usar la función `str_to_lower` para hacer que todas las letras sean minúsculas:

```{r}
s <- c("Five feet eight inches")
str_to_lower(s)
```

Otras funciones relacionadas son `str_to_upper` y `str_to_title`. Ahora estamos listos para definir un procedimiento que convierta todos los casos problemáticos a pulgadas.

## Estudio de caso 2: alturas autoreportadas (continuación)

Ahora ponemos todo lo que hemos aprendido en una función que toma un vector de cadena e intenta convertir todas las cadenas posibles a un formato. Escribimos una función que reúne lo que hemos hecho anteriormente:

```{r}
convert_format <- function(s){
s %>%
str_replace("feet|foot|ft", "'") %>%
str_replace_all("inches|in|''|\"|cm|and", "") %>%
str_replace("^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$", "\\1'\\2") %>%
str_replace("^([56])'?$", "\\1'0") %>%
str_replace("^([12])\\s*,\\s*(\\d*)$", "\\1\\.\\2") %>%
str_trim()
}
```

También podemos escribir una función que convierta palabras en números:

```{r, warning=FALSE, message=FALSE}
library(english)
words_to_numbers <- function(s){
s <- str_to_lower(s)
for(i in 0:11)
s <- str_replace_all(s, words(i), as.character(i))
s
}
```

Tengan en cuenta que podemos realizar la operación anterior de manera más eficiente con la función `recode`, que estudiaremos en la Sección \@ref(recode).
Ahora podemos ver qué entradas problemáticas permanecen:

```{r}
converted <- problems %>% words_to_numbers() %>% convert_format()
remaining_problems <- converted[not_inches_or_cm(converted)]
pattern <- "^[4-7]\\s*'\\s*\\d+\\.?\\d*$"
index <- str_detect(remaining_problems, pattern)
remaining_problems[!index]
```

Además de los casos ingresados como metros, que solucionaremos a continuación, todos parecen ser casos imposibles de resolver.

### La función `extract` 

La función `extract` del __tidyverse__  es util para el procesamiento de cadenas que usaremos en nuestra solución final y, por ende, la presentamos aquí. En una sección anterior, construimos una expresión regular que nos permite identificar qué elementos de un vector de caracteres corresponden con el patrón de pies y pulgadas. Sin embargo, queremos hacer más. Queremos extraer y guardar los pies y los valores numéricos para poder convertirlos en pulgadas cuando sea apropiado.

Consideremos este ejemplo sencillo:
```{r}
s <- c("5'10", "6'1")
tab <- data.frame(x = s)
```

En la sección \@ref(separate) aprendimos sobre la función `separate`, que se puede utilizar para lograr nuestro objetivo actual:

```{r}
tab %>% separate(x, c("feet", "inches"), sep = "'")
```

La función `extract` del paquete __tidyr__ nos permite usar grupos _regex_ para extraer los valores deseados. Aquí está el equivalente al código anterior usando `separate`, pero ahora usando `extract`:

```{r}
library(tidyr)
tab %>% extract(x, c("feet", "inches"), regex = "(\\d)'(\\d{1,2})")
```

Entonces, ¿por qué necesitamos la nueva función `extract`? Hemos visto cómo pequeños cambios pueden conducir a no tener equivalencias exactas. Los grupos en _regex_ nos dan más flexibilidad. Por ejemplo, si definimos:

```{r}
s <- c("5'10", "6'1\"","5'8inches")
tab <- data.frame(x = s)
```

y solo queremos los números, `separate` falla:

```{r}
tab %>% separate(x, c("feet","inches"), sep = "'", fill = "right")
```

Sin embargo, podemos usar `extract`. La _regex_ aquí es un poco más complicada ya que tenemos que permitir `'` con espacios y `feet`. Tampoco queremos el `"` incluido en el valor, por lo que no lo incluimos en el grupo:

```{r}
tab %>% extract(x, c("feet", "inches"), regex = "(\\d)'(\\d{1,2})")
```


### Juntando todas la piezas

Ahora estamos listos para juntar todas las piezas y discutir nuestros datos de alturas reportados para tratar de recuperar todas las alturas posibles. El código es complejo, pero lo dividiremos en partes.

Comenzamos limpiando la columna `height` para que las alturas estén más cerca de un formato de pulgadas y pies. Agregamos una columna con las alturas originales para luego poder comparar.

Ahora estamos listos para _wrangle_ nuestro set de datos de alturas reportadas:

```{r, warning=FALSE, message=FALSE}
pattern <- "^([4-7])\\s*'\\s*(\\d+\\.?\\d*)$"

smallest <- 50
tallest <- 84
new_heights <- reported_heights %>%
mutate(original = height,
height = words_to_numbers(height) %>% convert_format()) %>%
extract(height, c("feet", "inches"), regex = pattern, remove = FALSE) %>%
mutate_at(c("height", "feet", "inches"), as.numeric) %>%
mutate(guess = 12 * feet + inches) %>%
mutate(height = case_when(
is.na(height) ~ as.numeric(NA),
between(height, smallest, tallest) ~ height, #inches
between(height/2.54, smallest, tallest) ~ height/2.54, #cm
between(height*100/2.54, smallest, tallest) ~ height*100/2.54, #meters
TRUE ~ as.numeric(NA))) %>%
mutate(height = ifelse(is.na(height) &
inches < 12 & between(guess, smallest, tallest),
guess, height)) %>%
select(-guess)
```

Podemos verificar todas las entradas que convertimos al escribir:

```{r, eval=FALSE}
new_heights %>%
filter(not_inches(original)) %>%
select(original, height) %>%
arrange(height) %>%
View()
```


Una observación final es que si miramos a los estudiantes más bajos de nuestro curso:

```{r}
new_heights %>% arrange(height) %>% head(n=7)
```

Vemos alturas de 53, 54 y 55. En los originales, también tenemos 51 y 52. Estas alturas tan bajas son raras y es probable que los estudiantes realmente querían decir `5'1`, `5'2`, `5'3`, `5'4` y `5'5`. Debido a que no estamos completamente seguros, los dejaremos según lo reportado. El objeto `new_heights` contiene nuestra solución final para este caso de estudio.

## División de cadenas

Otra operación de _wrangling_ de datos muy común es la división de cadenas. Para ilustrar cómo surge esto, comenzamos con un ejemplo ilustrativo. Supongamos que no tenemos la función `read_csv` o `read.csv` disponible. En cambio, tenemos que leer un archivo csv usando la función de base R `readLines` así:

```{r}
filename <- system.file("extdata/murders.csv", package = "dslabs")
lines <- readLines(filename)
```

Esta función lee los datos línea por línea para crear un vector de cadenas. En este caso, una cadena para cada fila en la hoja de cálculo. Las primeras seis líneas son:

```{r}
lines %>% head()
```

Queremos extraer los valores que están separados por una coma para cada cadena en el vector. El comando `str_split` hace exactamente esto:

```{r}
x <- str_split(lines, ",")
x %>% head(2)
```

Tengan en cuenta que la primera entrada representa el nombre de las columnas, por lo que podemos separarlas:

```{r}
col_names <- x[[1]]
x <- x[-1]
```

Para convertir nuestra lista en un _data frame_, podemos usar un acceso directo ofrecido por la función `map` en el paquete __purrr__. La función `map` aplica la misma función a cada elemento en una lista. Entonces, si queremos extraer la primera entrada de cada elemento en `x`, podemos escribir:

```{r}
library(purrr)
map(x, function(y) y[1]) %>% head(2)
```

Sin embargo, debido a que esta es una tarea tan común, __purrr__ provee un acceso directo. Si el segundo argumento recibe un número entero en lugar de una función, supondrá que queremos esa entrada. Entonces, el código anterior se puede escribir de manera más eficiente de esta manera:

```{r, eval=FALSE}
map(x, 1)
```

Para forzar `map` a devolver un vector de caracteres en lugar de una lista, podemos usar `map_chr`. Similar, `map_int` devuelve enteros. Entonces, para crear nuestro _data frame_, podemos usar:

```{r}
dat <- tibble(map_chr(x, 1),
map_chr(x, 2),
map_chr(x, 3),
map_chr(x, 4),
map_chr(x, 5)) %>%
mutate_all(parse_guess) %>%
setNames(col_names)
dat %>% head
```

Si exploran más el paquete __purrr__, aprenderán que es posible realizar lo anterior con el siguiente código, que es más eficiente:

```{r}
dat <- x %>%
transpose() %>%
map( ~ parse_guess(unlist(.))) %>%
setNames(col_names) %>%
as_tibble()
```


Resulta que podemos evitar todo el trabajo que se muestra arriba después de la llamada a `str_split`. Específicamente, si sabemos que los datos que estamos extrayendo se pueden representar como una tabla, podemos usar el argumento `simplify=TRUE` y `str_split` devuelve una matriz en lugar de una lista:

```{r}
x <- str_split(lines, ",", simplify = TRUE)
col_names <- x[1,]
x <- x[-1,]
colnames(x) <- col_names
x %>% as_tibble() %>%
mutate_all(parse_guess) %>%
head(5)
```

## Estudio de caso 3: extracción de tablas de un PDF

Uno de los  sets de datos proporcionados en __dslabs__ muestra las tasas de financiación científica por género en los Países Bajos:

```{r}
library(dslabs)
data("research_funding_rates")
research_funding_rates %>%
select("discipline", "success_rates_men", "success_rates_women")
```


Los datos provienen de un artículo publicado en las Actas de la Academia Nacional de Ciencias (PNAS)^[http://www.pnas.org/content/112/40/12349.abstract], una revista científica ampliamente leída. Sin embargo, los datos no se proporcionan en una hoja de cálculo; Está en una tabla en un documento PDF. Aquí hay una captura de pantalla de la tabla:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(file.path(img_path, "pnas-table-s1.png"))
```

(Fuente: Romy van der Lee y Naomi Ellemers, PNAS 2015 112 (40) 12349-12353^[http://www.pnas.org/content/112/40/12349].)

Podríamos extraer los números a mano, pero esto podría conducir a un error humano. En su lugar, podemos intentar cambiar los datos con R. Comenzamos descargando el documento pdf y luego importándolo a R:

```{r, eval=FALSE}
library("pdftools")
temp_file <- tempfile()
url <- paste0("http://www.pnas.org/content/suppl/2015/09/16/",
"1510159112.DCSupplemental/pnas.201510159SI.pdf")
download.file(url, temp_file)
txt <- pdf_text(temp_file)
file.remove(temp_file)
```

Si examinamos el texto del objeto, notamos que es un vector de caracteres con una entrada para cada página. Entonces mantenemos la página que queremos:

```{r, eval=FALSE}
raw_data_research_funding_rates <- txt[2]
```

Los pasos anteriores se pueden omitir porque también incluimos estos datos sin procesar en el paquete __dslabs__:

```{r}
data("raw_data_research_funding_rates")
```

Examinando el objeto `raw_data_research_funding_rates`
vemos que es una cadena larga y cada línea de la página, incluidas las filas de la tabla, están separadas por el símbolo de nueva línea: `\n`. Por lo tanto, podemos crear una lista con las líneas del texto como elementos de la siguiente manera:

```{r}
tab <- str_split(raw_data_research_funding_rates, "\n")
```

Debido a que comenzamos con solo un elemento en la cadena, terminamos con una lista con solo una entrada.

```{r}
tab <- tab[[1]]
```

Mediante el examen `tab` vemos que la información para los nombres de columna es la tercera y cuarta entrada:

```{r}
the_names_1 <- tab[3]
the_names_2 <- tab[4]
```

La primera de estas filas se ve así:

```{r, echo=FALSE}
cat(substr(the_names_1, 1, options()$width))
cat(substr(the_names_1, options()$width, nchar(the_names_1)))
```

Queremos crear un vector con un nombre para cada columna. Usando algunas de las funciones que acabamos de aprender, hacemos esto. Empecemos con `the_names_1`, mostrado anteriormente. Queremos eliminar el espacio inicial y todo lo que sigue a la coma. Utilizamos _regex_ para este último. Entonces podemos obtener los elementos dividiendo cadenas separadas por espacio. Queremos dividir solo cuando hay 2 o más espacios para evitar dividir `Success rates`. Entonces usamos la expresión regular `\\s{2,}`

```{r}
the_names_1 <- the_names_1 %>%
str_trim() %>%
str_replace_all(",\\s.", "") %>%
str_split("\\s{2,}", simplify = TRUE)
the_names_1
```


Ahora veremos `the_names_2`:

```{r, echo=FALSE}
cat(substr(the_names_2, 1, options()$width))
cat(substr(the_names_2, options()$width, nchar(the_names_2)))
```

Aquí queremos recortar el espacio inicial y luego dividirlo por espacio como lo hicimos para la primera línea:

```{r}
the_names_2 <- the_names_2 %>%
str_trim() %>%
str_split("\\s+", simplify = TRUE)
the_names_2
```

Luego podemos unirlos para generar un nombre para cada columna:


```{r}
tmp_names <- str_c(rep(the_names_1, each = 3), the_names_2[-1], sep = "_")
the_names <- c(the_names_2[1], tmp_names) %>%
str_to_lower() %>%
str_replace_all("\\s", "_")
the_names
```

Ahora estamos listos para obtener los datos reales. Al examinar el `tab` objeto, notamos que la información está en las líneas 6 a 14. Podemos usar `str_split` de nuevo para lograr nuestro objetivo:

```{r}
new_research_funding_rates <- tab[6:14] %>%
str_trim %>%
str_split("\\s{2,}", simplify = TRUE) %>%
data.frame(stringsAsFactors = FALSE) %>%
setNames(the_names) %>%
mutate_at(-1, parse_number)
new_research_funding_rates %>% as_tibble()
```

Podemos ver que los objetos son idénticos:

```{r}
identical(research_funding_rates, new_research_funding_rates)
```

## Recodificación {#recode}

Otra operación común que involucra cadenas es recodificar los nombres de variables categóricas. Supongamos que tienen nombres largos para sus niveles y los mostrarán en diagramas, es posible que deseen utilizar versiones más cortas de estos nombres. Por ejemplo, en los vectores de caracteres con nombres de países, es posible que deseen cambiar "Estados Unidos de América" a "Estados Unidos" y "Reino Unido" a "RU", y así sucesivamente. Podemos hacer esto con `case_when`, aunque __tidyverse__ ofrece una opción específicamente diseñada para esta tarea: la función `recode`.

Aquí hay un ejemplo que muestra cómo cambiar el nombre de los países con nombres largos:


```{r}
library(dslabs)
data("gapminder")
```

Supongamos que queremos mostrar series temporales de esperanza de vida por país para el Caribe:

```{r caribbean}
gapminder %>%
filter(region == "Caribbean") %>%
ggplot(aes(year, life_expectancy, color = country)) +
geom_line()
```

La gráfica es lo que queremos, pero gran parte del espacio se desperdicia para acomodar algunos de los nombres largos de los países.
<!--
```{r}
gapminder %>%
filter(region == "Caribbean") %>%
filter(str_length(country) >= 12) %>%
distinct(country)
```
-->
Tenemos cuatro países con nombres de más de 12 caracteres. Estos nombres aparecen una vez por año en el set de datos Gapminder. Una vez que elegimos los apodos, debemos cambiarlos todos de manera consistente. La función `recode` se puede utilizar para hacer esto:


```{r caribbean-with-nicknames}
gapminder %>% filter(region=="Caribbean") %>%
mutate(country = recode(country,
`Antigua and Barbuda` = "Barbuda",
`Dominican Republic` = "DR",
`St. Vincent and the Grenadines` = "St. Vincent",
`Trinidad and Tobago` = "Trinidad")) %>%
ggplot(aes(year, life_expectancy, color = country)) +
geom_line()
```

Hay otras funciones similares en otros paquetes de R, como `recode_factor` y `fct_recoder` en el paquete __forcats__.


## Ejercicios



1\. Complete todas las lecciones y ejercicios en el tutorial interactivo en línea [https://regexone.com/font](https://regexone.com/).

2\. En el directorio `extdata` del paquete __dslabs__, encontrará un archivo PDF que contiene datos de mortalidad diaria para Puerto Rico del 1 de enero de 2015 al 31 de mayo de 2018. Puede encontrar el archivo de esta manera:

```{r, eval=FALSE}
fn <- system.file("extdata", "RD-Mortality-Report_2015-18-180531.pdf",
package="dslabs")
```


```{r, eval = FALSE}
system2("open", args = fn)
```

y en Windows, puede escribir:

```{r, eval = FALSE}
system("cmd.exe", input = paste("start", fn))
```

¿Cuál de las siguientes opciones describe mejor este archivo?

a. Es una tabla. Extraer los datos será fácil.
b. Es un informe escrito en prosa. Extraer los datos será imposible.
c. Es un informe que combina gráficas y tablas. Extraer los datos parece posible.
d. Muestra gráficas de los datos. Extraer los datos será difícil.


3\. Vamos a crear un set de datos ordenado con cada fila que representa una observación. Las variables en este set de datos serán año, mes, día y muertes.
Comience instalando y cargando el paquete __pdftools__:


```{r, eval= FALSE}
install.packages("pdftools")
library(pdftools)
```

Ahora lea `fn` utilizando la función `pdf_text`y almacene los resultados en un objeto llamado `txt`. ¿Cuál de las siguientes opciones describe mejor lo que ve en `txt`?

a. Una tabla con los datos de mortalidad.
b. Una cadena de caracteres de longitud 12. Cada entrada representa el texto en cada página. Los datos de mortalidad están ahí en alguna parte.
c. Una cadena de caracteres con una entrada que contiene toda la información en el archivo PDF.
d. Un documento html.


4\. Extraiga la novena página del archivo PDF del objeto `txt`, luego use el `str_split` del paquete __stringr__ para que tenga cada línea en una entrada diferente. Llame a este vector de cadena `s`. Luego mire el resultado y eliga el que mejor describa lo que ve.

a. Es una cadena vacía.
b. Puedo ver la figura que se muestra en la página 1.
c. Es una mesa ordenada.
re. ¡Puedo ver la mesa! Pero hay muchas otras cosas de las que debemos deshacernos.



5\. Qué tipo de objeto es `s` y cuantas entradas tiene?


6\. Vemos que la salida es una lista con un componente. Redefinir `s` ser la primera entrada de la lista. Qué tipo de objeto es `s` y cuantas entradas tiene?


7\. Al inspeccionar la cadena que obtuvimos anteriormente, vemos un problema común: espacios en blanco antes y después de los otros caracteres. Recortar es un primer paso común en el procesamiento de cadenas. Estos espacios adicionales eventualmente complicarán dividir las cadenas, por lo que comenzamos por eliminarlos. Aprendimos sobre el comando `str_trim` que elimina espacios al principio o al final de las cadenas. Use esta función para recortar `s`.


8\. Queremos extraer los números de las cadenas almacenadas en `s`. Sin embargo, hay muchos caracteres no numéricos que se interpondrán en el camino. Podemos eliminarlos, pero antes de hacerlo queremos preservar la cadena con el encabezado de la columna, que incluye la abreviatura del mes.
Utilice la función `str_which` para encontrar las filas con un encabezado. Guarde estos resultados en `header_index`. Sugerencia: encuentre la primera cadena que corresponda con el patrón `2015` utilizando la función `str_which`.


9\. Ahora vamos a definir dos objetos: `month` almacenará el mes y `header` almacenará los nombres de columna. Identifique qué fila contiene el encabezado de la tabla. Guarde el contenido de la fila en un objeto llamado `header`, luego use `str_split` para ayudar a definir los dos objetos que necesitamos. Sugerencias: el separador aquí es uno o más espacios. Además, considere usar el argumento `simplify`.


10\. Observe que hacia el final de la página verá una fila _totals_ seguida de filas con otras estadísticas de resumen. Cree un objeto llamado `tail_index` con el índice de la entrada _totals_.


11\. Debido a que nuestra página PDF incluye gráficos con números, algunas de nuestras filas tienen solo un número (desde el eje y de la gráfica). Utilice la función `str_count` para crear un objeto `n` con el número de números en cada fila. Sugerencia: puede escribir una expresión regular para un número como este `\\d+`.


12\. Ahora estamos listos para eliminar entradas de filas que sabemos que no necesitamos. La entrada `header_index` y todo antes de que se elimine. Entradas para las cuales `n` es 1 también debe eliminarse, y la entrada `tail_index` y todo lo que viene después debe ser eliminado también.


13\. Ahora estamos listos para eliminar todas las entradas no numéricas. Haga esto usando _regex_ y la función `str_remove_all`. Sugerencia: recuerde que en _regex_, usar la versión en mayúscula de un carácter especial generalmente significa lo contrario. Entonces `\\D` significa "no un dígito". Recuerde que también quiere mantener espacios.



14\. Para convertir las cadenas en una tabla, use la función `str_split_fixed`. Convierta `s` en una matriz de datos con solo los datos de recuento de días y muertes. Sugerencias: tengan en cuenta que el separador es uno o más espacios. Haga el argumento `n` un valor que limita el número de columnas a los valores en las 4 columnas y la última columna captura todas las cosas adicionales. Luego mantenga solo las primeras cuatro columnas.



15\. Ahora ya casi está listo para terminar. Agregue nombres de columna a la matriz, incluyendo uno llamado `day`. Además, agregue una columna con el mes. Llame al objeto resultante `dat`. Finalmente, asegúrese de que el día es un número entero, no un carácter. Sugerencia: use solo las primeras cinco columnas.

16\. Ahora termine ordenando `tab` con la función `gather`.


17\. Haga un diagrama de muertes versus día con color para indicar el año. Excluya 2018 ya que no tenemos datos para todo el año.


18\. Ahora que hemos _wrangled_ estos datos paso a paso, póngalos todos juntos en un fragmento R, usando el _pipe_ tanto como sea posible. Sugerencia: primero defina los índices, luego escriba una línea de código que realice todo el procesamiento de la cadena.


19\. Avanzado: volvamos al ejemplo de Nómina MLB de la sección de extracción de la web. Use lo que aprendió en los capítulos de extracción de la web y procesamiento de cadenas para extraer la nómina de los Yankees de Nueva York, los Medias Rojas de Boston y los Atléticos de Oakland y graficarlos como una función del tiempo.


